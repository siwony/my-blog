[
  {
    "title": "Prism.js Syntax Highlighting 테스트",
    "url": "/programming/2024/10/07/prism-syntax-highlighting-test/",
    "category": "programming",
    "date": "2024-10-07",
    "excerpt": "이 포스트는 새로 적용된 Prism.js syntax highlighting을 테스트하기 위한 글입니다.",
    "content": "이 포스트는 새로 적용된 Prism.js syntax highlighting을 테스트하기 위한 글입니다.\n\n JavaScript 예제\n\njavascript\n// 피보나치 수열 생성 함수\nfunction fibonaccin {\n    if n <= 1 {\n        return n;\n    }\n    return fibonaccin - 1 + fibonaccin - 2;\n}\n\n// 배열 메서드 활용\nconst numbers = 1, 2, 3, 4, 5;\nconst doubled = numbers.mapnum => num  2;\nconsole.logOriginal: ${numbers};\nconsole.logDoubled: ${doubled};\n\n\n Python 예제\n\npython\n 클래스 정의\nclass Calculator:\n    def __init__self:\n        self.history = \n    \n    def addself, a, b:\n        result = a + b\n        self.history.appendf\"{a} + {b} = {result}\"\n        return result\n    \n    def get_historyself:\n        return self.history\n\n 사용 예제\ncalc = Calculator\nresult = calc.add10, 20\nprintf\"결과: {result}\"\n\n 리스트 컴프리헨션\nsquares = x2 for x in range10 if x % 2 == 0\nprintf\"짝수의 제곱: {squares}\"\n\n\n CSS 예제\n\ncss\n/ 반응형 그리드 레이아웃 /\n.grid-container {\n    display: grid;\n    grid-template-columns: repeatauto-fit, minmax300px, 1fr;\n    gap: 2rem;\n    padding: 2rem;\n}\n\n.card {\n    background: ffffff;\n    border-radius: 8px;\n    box-shadow: 0 4px 6px rgba0, 0, 0, 0.1;\n    padding: 1.5rem;\n    transition: transform 0.3s ease;\n}\n\n.card:hover {\n    transform: translateY-4px;\n    box-shadow: 0 8px 15px rgba0, 0, 0, 0.2;\n}\n\n\n HTML 예제\n\nhtml\n<!DOCTYPE html>\n<html lang=\"ko\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>샘플 페이지</title>\n</head>\n<body>\n    <header class=\"header\">\n        <nav class=\"nav\">\n            <ul class=\"nav-list\">\n                <li><a href=\"home\">홈</a></li>\n                <li><a href=\"about\">소개</a></li>\n                <li><a href=\"contact\">연락처</a></li>\n            </ul>\n        </nav>\n    </header>\n    \n    <main class=\"main-content\">\n        <section id=\"hero\">\n            <h1>환영합니다!</h1>\n            <p>이것은 샘플 HTML 코드입니다.</p>\n        </section>\n    </main>\n</body>\n</html>\n\n\n Java 예제\n\njava\n// 제네릭 클래스\npublic class Stack<T> {\n    private ArrayList<T> items;\n    \n    public Stack {\n        this.items = new ArrayList<>;\n    }\n    \n    public void pushT item {\n        items.additem;\n    }\n    \n    public T pop {\n        if isEmpty {\n            throw new EmptyStackException;\n        }\n        return items.removeitems.size - 1;\n    }\n    \n    public boolean isEmpty {\n        return items.isEmpty;\n    }\n    \n    public int size {\n        return items.size;\n    }\n}\n\n// 사용 예제\nStack<String> stringStack = new Stack<>;\nstringStack.push\"Hello\";\nstringStack.push\"World\";\nSystem.out.printlnstringStack.pop; // \"World\"\n\n\n Inline 코드 테스트\n\n여기서 console.log는 JavaScript의 출력 함수이고, print는 Python의 출력 함수입니다. \nCSS에서는 display: flex;를 사용하여 플렉스 레이아웃을 만들 수 있습니다.\n\n 기능 테스트\n\nPrism.js의 주요 기능들:\n- ✅ 자동 언어 감지\n- ✅ 라인 번호 표시\n- ✅ 코드 복사 기능\n- ✅ 언어 표시\n- ✅ 문법 하이라이팅\n\n코드 블록 위에 마우스를 올려보시면 복사 버튼이 나타납니다!",
    "tags": [
      "javascript",
      "python",
      "java",
      "prism",
      "syntax-highlighting"
    ]
  },
  {
    "title": "VO 사실과 오해",
    "url": "/programming/2024/02/18/vo-사실과-오해/",
    "category": "programming",
    "date": "2024-02-18",
    "excerpt": "> 2022.10.19수 사내에서 발표한 내용",
    "content": "VO 사실과 오해\n> 2022.10.19수 사내에서 발표한 내용\n\n!/assets/images/posts/programming/VO사실과_오해_img_1.pnghttps://woogienote.tistory.com/m/88\n\n\n\n!/assets/images/posts/programming/VO사실과_오해_img_2.pnghttps://kkminseok.github.io/posts/Spring_semina/\n \n\n위 2개의 사진에 나와있는 블로그는 VO는 객체의 속성과 getter, setter를 가지고 있다고하고, 다른 하나는 불변이라 readOnly의 특징을 가진다고 나와있습니다.\n\n둘 다 계층간 데이터 교환을 위한 객체라고 설명하고 있습니다. \n\n근데 위 한국 블로그 2개랑 마틴 파울러의 VO가 다르네?!\n\n 마틴 파울러의 VO\n\nMartin Fowler의 글에 의하면 \n\n> I find it useful to think of two classes of object: value objects and reference objects, depending on how I tell them apart\n>\n> 나는 구별하는 방법에 따라 값 객체와 참조 객체,두 가지 클래스의 객체를 고려하는 것이 유용하다는 것을 알게되었다.\n\n> When programming, I often find it’s useful to represent things as a compound.A 2D coordinate consists of an x value and y value.An amount of money consists of a number and a currency.A date range consists of start and end dates,which themselves can be compounds of year, month, and day.\n>\n>프로그래밍을 할 때, 사물을 복합물로 표현하는 것이 유용할 경우가 종종 있다.예를 들어, 2차원 좌표는 x, y로 이루어져 있고,돈이나 통화 같은 경우 숫자로 이루어져 있다.날짜의 범위는 시작 날짜와 종료날짜로 구성될 수 있고,연도와 월, 일의 복합물일 수 도 있다.\n\n예시. Pointx = 1, y = 2, Datemonth = 1, day = 4 \n\n즉 VO란, 한개 이상의 속성들을 묶어 특정 값을 나타내는 객체를 말하고, \n\nVO는 도메인 객체의 일종이며, 보통 기본키로 식별 값을 갖는 Entity와 구별해서 사용된다.\n\n 마틴 파울러의 VO를 다음과 같이 구분해서 설명하고 있다.\n\n1. equals & hash code 메서드 재정의\n\n기본적으로 객체를 === 비교동일성비교를 하면 객체의 참조 주소를 비교하고 == 동등성비교를 하면 객체의 값프로퍼티를 기반으로 비교를 하게 된다.\n\nRGB0,0,0 == RGB0,0,0 // false? 하얀색과 하얀색이 다르다?\n\nequals & hash code 메서드를 재정의 한다면 속성값이 같은 객체를 보장할 수 있다.\n\n2. 수정자Setter가 없는 불변Immutable 객체\n\nEntity와 같은 경우 별도의 식별 값을 가지고 있기 때문에내부 속성 값이 변경된다고 하더라도 같은 객체로 계속 인식하고 추적할 수 있습니다.  \n하지만 속성 값 자체가 식별 값인 VO는 속성 값이 바뀌게 되면 식별 값도 바뀌게 되어 추적이 불가능하고,복사 될 때는 의도치 않은 객체들이 함께 변경되는 문제를 유발합니다.\n\n따라서 VO는 값을 변경할 수 없는 불변 객체로 만들어야합니다.\n\nkotlin\nclass RGBvar r : Int, var g : Int, var b : Int{\n  overried fun toString : String\n}\n\nval color = RGB0,0,0\nval blackFont = FontStylecolor\n\ncolor.r = 180\ncolor.g = 85\ncolor.b = 162\n\nval purpleFont = FontStylecolor\n\nprintblackFont.color // Color180, 85, 162 출력\nprintpurpleFont.color // Color180, 85, 162 출력\n\n\n근데 왜 데이터 이동을 위한 객체도 VO라고 부르는걸까?\n\n이는 해당 글의 Further Reading 부분에서 확인할 수 있다.\n\n> One source of terminological confusion is that around the turn of the century some J2EE literature used \"value object\" for Data Transfer Object. That usage has mostly disappeared by now, but you might run into it.\n>\n> 용어 혼란의 한 가지 원인은 세기가 바뀔 무렵 일부 J2EE 문헌에서 Data Transfer Object 에 \"Value Object\"를 사용했다는 것 입니다. 그 사용법은 지금은 대부분 사라졌지만, 아마 이것을 우연히 만날 수 있다.\n\n즉 J2EE문헌에서 데이터 전달에 사용하는 객체를 VO라고 했었던 것이다.\n\n J2EE에서의 VO\n\n\n\nCore J2EE Patterns에서 VO는 데이터를 전송하기 위한 객체에 대한 패턴을 의미한다.\n\n내부적으로 Java Beans spec을 따라야 한다.\n\n자바빈즈 JavaBeans 클래스 규약\n\n1. private 접근제한자로 필드를 선언한다. 필수\n\n2. getter 메소드와 setter 메소드를 갖는다. 필수\n\n3. 기본 생성자가 반드시 존재해야 된다. 필수\n\n4. implements Serializable 선택\n\n하지만 이는 혼동의 여지가 있어 Core J2EE Patterns 2판에서 VO를 TOTransfer Object라고 변경했다.\n\nTO에 대해 자세히 알고싶다면 oracle 참조. https://www.oracle.com/java/technologies/transfer-object.html \n\n!/assets/images/posts/programming/VO사실과_오해_img_3.png\n\n 그럼 VO는 어떻게 써야할까?\n\nVO 정확히 말하면 VO Pattern에서의 VO객체는 TOTransfer Object로 변경되었다.\n\n데이터 전달을 위한 VO를 사용하고 싶다면 확실하게 Value Object 패턴 이라고 말해줄 필요가 있다.\n\n하지만 J2EE pattern에 나와있듯이 VO는 오해에 소지가 있어 TO로 변경되었으니 TO를 사용하는게 좋지 않을까?\n\n마지막으로 KSUG에서의 Toby님의 대화를 첨부한다.\n!/assets/images/posts/programming/VO사실과_오해_img_4.png\n\n 결론\n\n내가 생각하기에 저 2개의 블로그가 VO를 다르게 설명하게 된 원인은 VO Pattern과 DDD에서의 Value Object를 구분하지 못하여 생기는 문제가 아닐까 라고 생각이 든다.\n\n만약 VO Pattern에 대해 말하고 싶다면 Pattern을 명확하게 알려줘야 하고 애초에 VO를 J2EE core patterns에서는 TO라고 부르고 있다.\n\n데이터 전달을 위한 객체는 VO보다 DTO로 부르는게 더 적절하므로 DTO를 사용하자\n\n References\n- https://github.com/benelog/blog/issues/27\n- https://groups.google.com/g/ksug/c/M3l6ZqKpaQ4/m/4rcCbgS_CXUJ\n- https://martinfowler.com/bliki/ValueObject.html\n- https://d2.naver.com/news/3435170",
    "tags": [
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Test Post 1",
    "url": "/test/2024/01/01/test-post-1/",
    "category": "test",
    "date": "2024-01-01",
    "excerpt": "This is autogenerated test post 1.",
    "content": "This is autogenerated test post 1.\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam.\n\n Example Code\n\nruby\n Sample code block for Test Post 1\nputs \"Hello from Test Post 1\"\n\n\nMore sample content...",
    "tags": [
      "test",
      "sample"
    ]
  },
  {
    "title": "Welcome to My Tech Blog",
    "url": "/general/2024/01/01/welcome-to-my-blog/",
    "category": "general",
    "date": "2024-01-01",
    "excerpt": "안녕하세요! 제 기술 블로그에 오신 것을 환영합니다.",
    "content": "안녕하세요! 제 기술 블로그에 오신 것을 환영합니다.\n\n이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:\n\n- 프로그래밍 튜토리얼\n- 기술 트렌드 분석\n- 개발 경험 공유\n\n앞으로 유용한 콘텐츠로 찾아뵙겠습니다!",
    "tags": [
      "welcome",
      "introduction",
      "blog"
    ]
  },
  {
    "title": "Plan Archive",
    "url": "/back-end/2023/07/26/plan-archive/",
    "category": "back-end",
    "date": "2023-07-26",
    "excerpt": "-  이 붙은 jar 파일이며\n- 에플리케이션 실행에 필요한 모든 의존성이 포함되지 않는 파일이며\n- 소스코드와 리소스 파일만 포함된다.\n- 이런 jar 파일을 thin.jar, standard.jar로 불리기도 한다.",
    "content": "Plan Archive\n\n- -plan 이 붙은 jar 파일이며\n- 에플리케이션 실행에 필요한 모든 의존성이 포함되지 않는 파일이며\n- 소스코드와 리소스 파일만 포함된다.\n- 이런 jar 파일을 thin.jar, standard.jar로 불리기도 한다.\n\n SpringBoot 애플리케이션에서 생성하지 않는 방법 \n\n- reference: https://docs.spring.io/spring-boot/docs/2.5.1/gradle-plugin/reference/htmlsingle/packaging-executable.and-plain-archives\n\nSpring Boot 2.5.x 버전부터 build시 자동으로 생성된다 만약 생성을 원하지 않을 경우 classifier를 사용하거나\n\nkotlin\ntasks.getByName<BootJar>\"bootJar\" {\n\tclassifier = \"boot\"\n}\n\ntasks.getByName<Jar>\"jar\" {\n\tclassifier = \"\"\n}\n\n\nplan archive를 완전히 build하고 싶지 않을경우 아래와 같이 build.gradle.kts에 추가하면 된다.\n\nkotlin\ntasks.getByName<Jar>\"jar\" {\n\tenabled = false\n}\n\n\n\n Executable-Jar\n\n반대로 Excutable Jar는 그 즉시 실행할 수 있는 jar 파일을 의미한다,\n\n- 애플리케이션 실행에 필요한 모든 의존성이 포함된다.\n\n 해당 글을 작성하는 이유\n\n토이프로젝트 진행 중 간단하게 AWS ec2환경에서 Github Action + code deploy 를 활용해서 ci/cd를 진행해야 하는 일이 있었다.  \n그 중 deploy하는 bash script를 작성하는데 빌드 디렉토리 하위에 .jar 표현식을 가진 파일을 실행하라는 스크립트를 작성했었다.  \n그랬더니 plan jar 파일을 실행시켜 cd과정에서 실패했고 이 과정에서 궁금해서 쓰개 됨",
    "tags": [
      "TIL",
      "gradle",
      "build-tool"
    ]
  },
  {
    "title": "4. 컴포넌트 원칙",
    "url": "/book/2023/04/30/4-컴포넌트-원칙/",
    "category": "book",
    "date": "2023-04-30",
    "excerpt": "컴포는트는 배포 단위이며 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.",
    "content": "4. 컴포넌트 원칙\n 컴포넌트란\n컴포는트는 배포 단위이며 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.\n\n예시\n1. Java의 jar, war\n2. 루비의 gem\n3. .Net에서 DLL\n\n잘 설계된 컴포넌트라면 반드시 독립적으로 배포개발 가능한 능력을 갖춰야 한다.\n\n 컴포넌트의 역사\n 1. 소프트웨어 개발 초창기에 메모리에서 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.\n- 이 떄 당시 라이브러리는 바이너리가 아닌 소스코드 형태로 존재했다.\n- 하지만 이 방식은 컴파일 시 매우 느린 단점이 있다.\n 2. 컴파일 시간을 단축시키기 위해 함수 라이브러리 소스코드를 애플리케이션 코드로부터 분리했다.\n- 하지만 라이브러리가 점점 커졌고 할당된 메모리 주소를 넘거가게 되는데\n 3. 재배치가 가능한 바이너리relocatable bineary\n- 지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일을 수정하자는 개념\n- 로더는 재배치 코드가 자리할 위치 정보를 전달받음 -> 재배치 코드에는 로드한 데이터의 변경 부분을 주소에 로드할 수 있는지 알려주는 플래그 삽입\n- 이제 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었음\n- 실제로 로더는 바이너리를 입력받은 후 단순히 하나씩 차례로 메모리로 로드하며 재배치하는 작업을 처리\n  - 이를 통해 프로그래머는 오직 필요한 함수만 로드 할 수 있게 됨\n- 또한 컴파일러는 재배치 가능한 바이너리 안에 함수 이름을 메타데이터 형태로 생성하도록 수정\n  - 만약 프로그램이 라이브러리 함수를 호출한다면 라이브러리 함수 이름을 외부 참조external reference로 생성\n  - 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의external definition로 생성\n  - 이렇게 하여 외부 정의 에 링크시킬 수 있게 됨\n  - 이렇게 링킹 로더linking loader가 탄생\n\n 4. 링커\n- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.\n- 하지만, 프로그램은 훨씬 커지게 되며 링킹 로더가 너무 느려졌다.\n> 링킹 로더가 프로그램 하나를 로드하는 데만 한 시간 이상 걸리게 되었다. 자기테이프 사용\n- 마침내 로드와 링크가 두 단계로 분리\n  - 프로그래머가 느린 부분 즉, 링크 과정을 맡음\n  - 링커 라는 별도의 애플리케이션으로 해당 작업을 처리하도록 만듦\n  - 링커는 링크가 완료된 재배치 코드를 만들어 주어 로더의 로딩 과정이 아주 빨라짐 \n  - 한번 만들어둔 실행 파일은 언제라도 빠르게 로드 할 수 있게 되었다.\n\n 5. 무어의 법칙\n1. 1980년대 소스 모듈은 .c파일에서 .o파일로 컴파일 후 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐\n2. 각 모듈을 컴파일 하는 시간은 상대적으로 빠르지만 전체 모듈을 컴파일하는 일은 꽤 시간이 걸림\n3. 1980년대 후반에 들어서자 디스크는 작아졌으며 RAM의 용량은 커졌다. 컴퓨터 메모리는 저렴해짐 \n4. 1990년대 후반이 되자, 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는게 더 빨라지기 시작함.\n5. 이렇게 Active X와 공유 라이브러리 시대가 열리고 .jar파일 등장\n\n 결론: 이 책에서의 컴포넌트\n런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일\n\n 컴포넌트 응집성\n> 이 클래스를 어느 컴포넌트에 포함시켜야 할까? \n\n해당 장에서는 컴포넌트 응집성과 관련된 세 가지 원칙을 논의한다.\n\n- REPReuse/Release Equivalence Principle: 재사용/릴리스 등가 원칙\n- CCPCommon Closure Principle: 공통 폐쇄 원칙\n- CRPCommon Reuse Principle: 공통 재사용 원칙\n\n 1. REP: 재사용/릴리즈 등가 원칙\n> 재사용 단위는 릴리즈 단위와 같다.\n<!-- TODO -->\n\n\n 2. CCP: 공통 폐쇄 원칙\n> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. \n> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라\n<!-- TODO -->\n\n 3. CRP: 공통 재사용 원칙\n> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라\n<!-- TODO -->\n 컴포넌트 결합\n<!-- TODO -->",
    "tags": [
      "클린아키텍처",
      "TIL"
    ]
  },
  {
    "title": "8. 통합 테스트를 하는 이유",
    "url": "/book/2023/03/19/8-통합-테스트를-하는-이유/",
    "category": "book",
    "date": "2023-03-19",
    "excerpt": "통합 테스트란 시스템이 프로세스 외부 의존성과 어떻게 통합하는지 검증한다.",
    "content": "8. 통합 테스트를 하는 이유\n\n 통합 테스트는 무엇인가\n통합 테스트란 시스템이 프로세스 외부 의존성과 어떻게 통합하는지 검증한다.\n\n\n단위 테스트의 세 가지 사항을 하나라도 충족하지 못하는 테스트는 통합테스트의 범주에 속한다.\n\n> - 단일 동작 단위를 검증\n> - 빠르게 수행\n> - 다른 테스트와 별도로 처리\n\n통합 테스트는 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증한다.\n\n- 단위 테스트는 도메인 모델을 다룬다.\n- 통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다.\n\n<img src=\"/assets/images/posts/book/통합테스트_단위테스트_사사분면.jpeg\">\n\n통합 테스트는 주요 흐름happy path,과 단위 테스트가 다루지 못한 기타 예외 상황edge case 를 다룬다.\n\n>  주요 흐름happy apth \n> 시나리오의 성공적인 실행이다.\n>  예외 상황edge case\n> 비즈니스 시나리오 수행 중 오류가 발생하는 경우\n\n하지만 통합 테스트는 유지비가 많이 든다.\n- 프로세스 외부 의존성 운영이 필요한\n- 관련된 협력자가 많아 테스트가 비대해진다.\n\n대부분의 통합테스트를 단위테스트로 변환하면 유지비를 절감할 수 있지만, 중요한 통합 테스트가 비즈니스 시나리오당 하나 또는 두 개 있으면 시스템 전체의 정확도를 보장할 수 있다.\n\n<img src=\"/assets/images/posts/book/테스트%20피라미드.jpeg\">\n\n 통합 테스트와 빠른 실패\n어떠한 예외 상황에 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 테스트할 필요 없다.\n\nkotlin\n// User\nfun changeEmailnewEmail: String, company: Company {\n    requirecanChangeEmail\n    \n    ...나머지\n}\n\n// UserController\nfun changeEmailuserId: Int, newEmail: String{\n    val user = userRepository.findByIdOrNulluserId!!\n\n    val error = user.canChageEmail\n    iferror != null\n        return error\n\n    ...나머지\n}\n\n컨트롤러는 canChangeEmail를 호출하고 해당 메서드가 오류를 반환하면 연산을 중단한다.\n\n컨트롤러가 canChangeEmail를 참조하지 않고 이메일을 변경하려고 하면 \n- 예외가 던져질 것이고 \n- changeEmail매서드의 실행만으로 버그가 들어나므로 쉽게 알아차리고 고칠 수 있다.\n- 데이터의 손상으로 이어지지 않는다.\n\n이러한 테스트는 단위 테스트로 하는 것이 더 낫고 통합 테스트를 통해 검증할 필요가 없는 케이스다.\n\n버그를 빨리 나타나게 하는 것을 빠른 실패 원칙Fast Fail principle이라 하며 통합테스트에서 할 수 이 있는 대안이다.\n\n 빠른 실패 원칙\n예기칙 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미한다.\n\n이 원칙은 다음을 통해 애플리케이션의 안정성을 높인다.\n- 피드백 루프 단축: 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다.\n  -> 이미 운영 환경으로 넘어온 버그는 개발 중에 발견된 버그보다 수정 비용이 훨씬 더 크다.\n- 지속성 상태 보호: 버그는 애플리케이션 상태를 손상시킨다. -> 손상된 상태가 DB로 침투하면, 고치기가 훨씬 어려워진다. 빨리 실패하면 손상이 확산되는 것을 막을 수 있다.\n\n 어떤 프로레스 외부 의존성을 직접 테스트해야 하는가?\n 프로세스 외부 의존성의 두 가지 유형\n 관리 의존성\n- 애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과 상호 작용은 외부 환경에서 볼 수 없다.\n- 관리 의존성과 통신은 구현 세부 사항이다.  \n  - 외부 클라이언트는 DB의 구성을 신경 쓰지 않는다.\n  - 중요한 것은 시스템의 최종 상태이다.\n- ex. DB\n\n 비관리 의존성\n- 해당 의존성과의 상호작용을 외부에서 볼 수 있다.\n- 비관리 의존성의 통신은 식별할 수 있는 동작이다.  \n- ex. SMTP, Message Bus\n\n 관리 의존성이며 비관리 의존성인 프로세스\n관리 의존성과 비 관리 의존성 모두의 속성을 나타내는 프로세스 외부 의존성이 있을 수 있다.\n<img src=\"/assets/images/posts/book/관리의존성이며_외부의존성인경우_유.jpeg\">\n\n- 다른 애플리케이션에서 볼 수 있는 테이블을 비관리 의존성으로 취급한다.\n\n> 시스템 간 통합을 구현하는 데 DB보다는 동기식/비동기식 통신을 사용하는 것이 낫다.\n\n 통합 테스트에서 실제 DB를 사용할 수 없는경우\nDB를 그대로 테스트할 수 없다면 통합테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하자\n\n가치가 충분하지 않은 테스트는 테스트 스위트에 있어서는 안된다.\n\n 잘못된 내/외부 의존성을 위한 인터페이스 사용\nkotlin\ninterface UserRepository\nclass UserRepositoryImpl: UserRepository\n\n이렇게 인터페이스를 사용하는 일반적인 이유는 인터페이스가\n- 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,\n- 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP를 지키기 떄문이다.\n\n이 두 가지 이유 모두 오해이다.\n\n 1.프로세스 외부 의존성을 추상화해 느슨한 결합을 달성한다.\n단일 구현을 위한 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 클래스보다 결합도가 낮지 않다.\n\n> 진정한 추상화는 발견하는 것이지. 발명하는 것이 아니다.\n\n 2. 인터페이스는 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP을 준수한다.\nYANGI는 현재 필요하지않은 기능에 시간을 들여서는 안되는 원칙을 말하며, 이는 기회 비용을 낭비하거나 프로젝트 코드의 경량화를 방해한다.\n\n 통합 테스트 모범 사례\n통합 테스트를 최대한 활용하는 데 도움이 되는 지침\n1. 도메인 모델 경계 명시\n2. 애플리케이션 내 계층 줄이기\n3. 순환 의존성 제거\n\n 1. 도메인 모델 경계 명시\n항상 도메인 모델을 코드베이스에 명시적이고 잘 알려진 위치에 두도록 하라.\n\n- 도메인 클래스와 컨트롤러 사이의 명확한 경계로 단위테스트와 통합 테스트의 차리점을 쉽게 구별할 수 있다.\n\n 2. 계층 수 줄이기\n> 컴퓨터 과학의 모든 문제는 또 다른 간접 계층으로 해결할 수 있다. 간접 계층이 너무 많아서 문제가 생기지 않는다면 말이다.\n추상화가 지나치게 많으면 단위 테스트와 통합 테스트에도 도움이 되지 않는다.\n- 간접 계층이 많은 코드 베이스는 컨트롤러와 도메인 모델 사이에 명확한 경계가 없는 편이다.\n- 각 계층을 따로 검증하는 경향이 훨씬 강하다.\n- 이러한 경향으로 통합테스트는 가치가 떨어지며\n- 특정 계층의 코드만 실행하고 하위 계층은 목으로 처리한다.\n- 최종 결과는 항상 똑같이 낮은 리팩터링 내성과 불충분한 회귀 방지다.\n\n 3. 순환 의존성 제거하기\n순환 의존성의 대표적인 예는 call back이다.\nkotlin\nclass CheckOutService {\n    fun checkOutorderId: Int {\n        val service = ReportGenerationService;\n        service.generateReportorderId, this\n        ... 생략\n    }\n}\n\nclass ReportGenerationService {\n    fun generationServiceorderId: Int, checkOutService: CheckOutService {\n        ...생략\n    }\n}\n\n\n- 순환 의존성은 테스트를 방해한다.\n  - 클래스 그래프를 나눠서 동작 단위를 하나 분리하려면 목으로 처리해야 하는 경우가 많음\n- 인터페이스를 사용해 해결?\n  - ReportGenerationService를 구체 클래스 대신 인터페이스에 의존하는 경우 컴파일 타임의 순환 참조를 해결할 수 있으나\n  - 여전히 런타임에 순환이 있다.\n  - 추가로 코드를 알아야 하는데 부담이 늘어난다.\n\nkotlin\nclass CheckOutService {\n    fun checkOutorderId: Int {\n        val service = ReportGenerationService;\n        val report: Report = service.generateReportorderId\n        ... 생략\n    }\n}\n\nclass ReportGenerationService {\n    fun generationService\n        orderId: Int, \n        checkOutService: CheckOutService\n    : Report {\n        ...생략\n    }\n}\n\nReportGenerationService가 CheckOutService를 호출하는 대신 작업 결과를 리턴하게 하자.\n\n 테스트에서 다중 실행 구절 사용\n테스트 내에서 두개 이상의 준비/실행/검증 구절을 두는 것은 권장되지않는다.\n\n이는 테스트가 여러 가지 동작 단위를 확인한다는 신호로 유지보수성을 저해한다는 신호이기 때문이다.\n\n예를 들어 사용자의 등록과 삭제를 하나의 통합 테스트에서 확인하려고 하는 경우 아래와 같은 구조를 가질 수 있다.\n\n- 준비 : 사용자 등록에 필요한 데이터 준비\n- 실행 : UserController.RegisterUser 호출\n- 검증 : 등록 동작의 성공 여부를 확인하기 위해 데이터베이스 조회\n- 실행 : UserController.DeleteUser 호출\n- 검증 : 삭제 동작의 성공 여부를 확인하기 위해 데이터 베이스 조회\n이러한 방식은 사용자의 상태가 자연스럽게 흐르기 때문에 어느정도 설득력이 있어보인다.\n\n문제는 이러한 테스트 구조는 어떤 것을 검증하려는 것인지 모호해지면서 규모가 순식간에 커질 수 있다는 점이다.\n\n따라서 각 실행을 고유의 테스트로 추출해 각각 테스트하는 것이 좋다.\n\n다만 예외적으로 원하는 상태로 만들기가 까다로운 프로세스 외부 의존성인 경우 여러 동작을 하나루 묶어서 처리해야 한다.\n\n이 방법은 프로세스 외부 의존성과의 상호 작용 횟수를 줄이는 효과가 있으므로 어느 정도 타당하다고 볼 수 있다.",
    "tags": [
      "유닛테스트",
      "TIL"
    ]
  },
  {
    "title": "단위테스트 스타일",
    "url": "/book/2023/03/11/단위테스트-스타일/",
    "category": "book",
    "date": "2023-03-11",
    "excerpt": "단위테스트의 스타일은 3가지로 나뉜다.\n1. 상태 기반\n2. 출력 기반\n3. 통신 기반",
    "content": "단위테스트 스타일\n 요약\n단위테스트의 스타일은 3가지로 나뉜다.\n1. 상태 기반\n2. 출력 기반\n3. 통신 기반\n\n여기서 출력 기반 스타일의 테스트는 가장 품질이 좋지만 모든 코드에 적용할 수 없고 순수 함수 방식으로만 작성된 코드에 사용할 수 있다.\n\n통신 기반 테스트는 간혈적으로 사용해야 한다.\n\n\n 단위 테스트의 세 가지 스타일\n 1. 출력 기반 테스트\n<img src=\"/assets/images/posts/book/출력_기반_테스트.jpeg\">\n\nSUT에 입력을 넣고 생성되는 출력을 검증하는 방식이다.\n- 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용된다.\n- 함수형functional이라고 한다.\n  - 함수형 프로그래밍 에 뿌리를 두고 있다.\n\n 2. 상태 기반 스타일 정의\n<img src=\"/assets/images/posts/book/상태_기반_테스트.jpeg\">\n\n작업이 완료된 후 시스템 상태를 확인하는 것이다.\n\n상태 기반 스타일에서 상태란 SUT나 협력자 중 하나, 또는 DB나 파일시스템과 같은 프로세스 외부 의존성의 상태를 의미할 수 있다.\n\n 예제\nkotlin\nclass Order{\n    private val _products: MutableList<Product> = mutableListOf\n    private val products: List<Product>\n        get = _products\n\n    fun addProductproduct: Product{\n        _products.addproduct\n    }\n}\n\n@Test\nfun Adding a product to an order{\n    val product = Product\"Hand wash\"\n    val sut = Order;\n\n    sut.addProductproduct;\n\n    Assertions.assertEquals1, sut.products.count\n    Assertions.assertEqualsproduct, sut.products0\n}\n\naddProduct를 검증하는게 아닌 Order의 상태값인 products를 검증했다.\n\n 3. 통신 기반 스타일 정의\n목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.\n\nkotlin\n@Test\nfun Sending a greetings eamil{\n    val emailGatewayMock: EmailGateWay = mockk\n    val sut = new ControlleremailGatewayMock\n    val email = \"user@email.com\"\n    every{\n        emailGatewayMock.sendGreetingsEmailemail\n    } just run\n\n    sut.greetUseremail\n\n    verifyexactly = 1{\n        emailGatewayMock.sendGreetingsEmailemail\n    }\n}\n\n\n 단위테스트 스타일 비교\n|                             | 출력 기반 | 상태 기반 |통신 기반|\n|-----------------------------|---------|---------|------|\n|리펙터링 내성을 지키기 위해 필요한 노력|   낮음   |   중간   |  중간 |\n|유지비                         |   낮음   |   중간   |  높음 | \n\n 결론\n출력 기반 테스트를 선호하자. \n- 코드를 순수함수로 바꾸면 출력 기반 테스트로 변경할 수 있다.\n  - 하지만 모든 코드를 순수 함수로 바꿀 수 없다.\n\n 함수형 아키텍처\n<img src=\"/assets/images/posts/book/함수형_아키텍처.png\">\n\n함수형 프로그래밍은 수학적 함수mathematial function혹은 순수 함수pure function이라고 불리우는 함수를 사용하는 프로그래밍이다.\n\n- 하나의 입력과 하나의 출력이 있으며 둘 다 메서드 시그니처에 명시되어 있다.\n- 숨은 입출력이 없는 메서드이다.\n\nkotlin\nfun decimal calculatorDiscountproducts: Array<Product>{\n    val discount: BigDecimal = products.length  0.01\n    return Math.mindiscount, 0.2\n}\n\n\n 비즈니스 로직과 부수효과를 분리하는 방법\n두 가지 코드 유형을 구분하여 분리할 수 있다,.\n- 결정을 내리는 코드: 해당 코드는 부작용이 없기 때문에 수학적 함수를 사용해 작성할 수 있다.\n  - 함수형 코어\n- 해당 결정에 따라 작용하는 코드: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.\n  - 가변 셸",
    "tags": [
      "유닛테스트",
      "TIL"
    ]
  },
  {
    "title": "4. 좋은 단위 테스트의 4대요소",
    "url": "/book/2023/03/05/4-좋은-단위-테스트의-4대요소/",
    "category": "book",
    "date": "2023-03-05",
    "excerpt": "좋은 단위테스트의 네 가지 특성은 다음과 같다.\n1. 회귀 방지\n2. 리팩터링 내성\n3. 빠른 피드백\n4. 유지 보수성",
    "content": "4. 좋은 단위 테스트의 4대요소\n 요약\n좋은 단위테스트의 네 가지 특성은 다음과 같다.\n1. 회귀 방지\n2. 리팩터링 내성\n3. 빠른 피드백\n4. 유지 보수성\n\n이상적인 테스트는 4가지를 모두 만족하는 것이지만 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이므로 달성할 수 없다.\n\n하지만 특정 특성에 집중하고 다른 특성을 버릴 수 없다. 이러한 테스트는 가치가 없다.\n\n 1. 회귀 방지\n코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우를 의미한다.\n\n코드베이스가 커질수록 잠재적인 버그에 더 많이 노출되므로 회귀에 대해 효과적인 보호를 개발하는게 중요하다.\n\n 회귀 방지 지표에 대한 평가 사항\n- 테스트 중 실행되는 코드의 양 \n  - 일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.\n- 코드 복잡도 및 코드의 도메인 유의성 \n  - 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드boilerplate code보다 훨씬 더 중요하다\n  - 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입힌다.\n\n ETC\n- 단순한 코드를 테스트 하는 것은 가치가 거의없다.\n  - ex. getter, setter\n- 코드 외에 작성하지 않는 코드라이브러리, 프레임워크, 외부 시스템를 테스트 하는것도 중요하다.\n\n> 회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.\n\n 2. 리팩터링 내성\n테스트를 실패로 바꾸지 않고 기본 애플리케이션 코드를 피개터링할 수 있는지에 대한 척도이다.\n\n 리팩터링 내성에 대한 평가 사항\n- 거짓 양성의 빈도수적을수록 좋다.\n\n테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가하는 것 인데 여기에 대한 장점은 2가지가 있다.\n- 기존 기능이 고장났을 때 테스트가 조기 경고를 제공한다.\n  - 조기 경고로 결함이 있는 코드가 운영 환경에 배포되기 전에 문제를 해결할 수 있다.\n- 코드 변경이 회귀로 이어지지 않을 것 이라고 확신하게 된다.\n  - 확신이 없다면 리팩터링을 주저하게 되고 코드베이스가 나빠질 가능성이 훨씬 높아진다.\n\n하지만 거짓 양성은 이 두 가지 이점을 모두 방해한다.\n- 테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희적된다.\n  - 실패에 익숙 -> 신경 X -> 타당한 실패도 무시\n- 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 떨어져 더 이상 믿을 만한 안정망으로 인식하지 않는다.\n  - 신뢰가 줄어듦 -> 리팩토링이 줄어듦 -> 회귀를 피하려 코드 변경을 최소화\n\n 거짓 양성의 원인\n- 테스트와 SUT의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.\n- 거짓 양성을 줄이는 방법 : 테스트와 구현 세부 상황을 분리한다.\n\n 리팩터링 내성를 높이는 방법\n- 코드의 내부 작업과 테스트 사이를 가능 한 멀리 떨어뜨리고 최종 결과를 목표로 한다.",
    "tags": [
      "유닛테스트",
      "TIL"
    ]
  },
  {
    "title": "3 단위테스트 구조",
    "url": "/book/2023/03/02/3-단위테스트-구조/",
    "category": "book",
    "date": "2023-03-02",
    "excerpt": "해당 장에서는\n- 단위테스트 구조AAA패턴\n- 좋은 단위테스트 명명법\n- 매개변수화된 테스트Parameterized Test",
    "content": "3 단위테스트 구조\n\n 요약\n해당 장에서는\n- 단위테스트 구조AAA패턴\n- 좋은 단위테스트 명명법\n- 매개변수화된 테스트Parameterized Test\n\n과 같은 내용을 배운다.\n\n단위테스트 구조 AAA패턴은 우리가 일반적으로 테스트를 작성하는 Given-When-Then 구조인 BDD와 굉장히 유사하다.\n\n좋은 단위테스트 명명법은 기초적인 문법을 준수해야 하며 개발자가 아닌 다른 사람이 읽어도 이해할 수 있게 짓어야 한다.\n\n그리고 매개변수화된 테스트를 통해 유사하게 작성된 테스트를 여러 개로 묶을 수 있는 기능을 제공한다.\n\n 1. 단위테스트를 구성하는 방법\n AAAArrange, Act, Assert 패턴 사용\nAAA 패턴은 각 테스트를 준비, 실행, 검증이라는 부분으로 나눈다.\n1. 준비 구절에서 SUT과 해당 의존성을 원하는 상태로 만든다.\n2. 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며\n   출력이 있다면 출력값을 캡처한다.\n3. 검증 구절에서는 결과를 검증한다.  \n   결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.\n\n\nkotlin\nclass Calculator{\n    fun sumfirst: Double, second: Double: Double \n        = second + second\n}\n\ninternal class CalculatorTests{\n\n    @Test\n    fun void Sum of two numbers{\n        // 준비Arrange\n        val first = 10\n        val second = 20\n        val calculator = Calculator\n\n        // 실행Act\n        val result = calculator.sumfirst, second\n\n        // 검증Assert\n        Assertions.assertEquals30, result\n    }\n}\n\n\nAAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다. ->결국 전체 테스트 스위트의 유지 보수 비용이 줄어든다.\n\n 피해야 할 것\n 1. 여러 개의 준비, 실행, 검증 구절 피하기\n여러 개의 동작 단위를 검증하는 테스트를 의미하게 되고 이러한 테스트는 더 이상 단위 테스트가 아니라 통합테스트이다.\n\n실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고 간단하고, 빠르며, 이해하기 쉽다.\n\n 2. 테스트 내 if 문 피하기\nif 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 즉, 테스트를 여러 개로 나눌 수 있다.\n\n통합테스트에도 분기가 늘어나 얻는 이점이 없다.\n\n AAA패턴의 각 구절의 크기\n- 일반적으로 준비 구절이 가장 크다.\n  - 훨씬 크면 테스트 내 비공개 메서드 or 별도의 팩토리 클래스로 도출하는 게 좋다.\n    - Object Mother, Test Data Builder\n- 실행 구절은 보통 코드 한줄이다.\n  - 실행 구절이 두 줄 이상이라면 SUT의 공개 API에 문제가 있을 수 있다.\n- 단일 동작 단위는 여러 결과를 낼 수 있어 하나의 테스트로 그 모든 결과를 평가해도 좋다\n  - 하지만, 검증 구절이 너무 커지는 것은 제품 코드에서 추상화가 누락될 수 있다는 의미다.\n\n SUT 구별하기\nSUT는 애플리케이션에서 호출하고 하는 동작에 대한 진입점을 제공한다.\n\n그러나 진입점은 오직 하나만 존재할 수 있다.\n\n그러므로 SUT를 의존성과 구분하는 것이 중요하다.\n\nkotlin\ninternal class CalculatorTests{\n\n    @Test\n    fun void Sum of two numbers{\n        // 준비Arrange\n        val first = 10\n        val second = 20\n        val sut = Calculator\n\n        // 실행Act\n        val result = sut.sumfirst, second\n\n        // 검증Assert\n        Assertions.assertEquals30, resultsut\n    }\n}\n\n이처럼 테스트 내 SUT 변수명을 sut로 구분하면 자연스럽게 구분이 된다.\n\n 추가로\n- 테스트 시 준비 구절부터 시작하는게 아닌 검증 구절부터 시작하는 방법도 있다. TDD를 실천할 때\n- AAA패턴은 Given-When-Then패턴과 차이는 없지만, 프로그래머가 아닌 사람에게 더 읽기 쉬운 구조이다.\n\n\n 2. 테스트 간 테스트 픽스처 재사용\n테스트 픽스처는 테스트 실행 대상 객체다.\n- DB나 하드 디스크의 파일일 수 있다.\n- 이러한 객체는 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다.\n\n 올바르지 않은 테스트 간 테스트 픽스처 재사용\n 테스트 간 높은 결합도는 안티패턴\n준비 구절을 테스트 간 공유하게 된다면 모든 테스트가 서로 결합되고 만약 테스트의 준비 로직을 수정하면 클래스 속 모든 테스트에 영향을 미친다. \n\n 테스트 가독성을 떨어뜨리는 생성자 사용\n준비 코드를 생성자로 추출할 때 단점은 테스트 가독성을 떨어뜨리는 것이다. \n- 테스트가 무엇을 하는지 이해하려면 클래스의 다른 부분을 봐야한다.\n\n 더 나은 테스트 픽스처 재사용법\n- 비공개 팩토리 메서드\n\n 3. 단위 테스트 명명법\n- 엄격한 명명 정책을 따르지 않는다.\n- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자\n- 단어를 밑줄_ 표시로 구분한다.\n  - Kotlin에서는 백틱으로 함수 이름을 감싸면 띄어쓰기를 사용할 수 있다.\n\n> 테스트 클래스 이름을 지을 때 클래스명Tests 패턴을 사용하지만 테스트가 해당 클래스만 검증하는 것으로 제한하는게 아니다.\n> 단위 테스트에서 단위는 동작의 단위지 클래스의 단위가 아니다.\n\n 테스트 이름 명명시 피해야 하는 사항\n- 테스트 이름에 SUT의 매서드 이름을 포함하지 않는다.\n- 사실을 서술할 때 소망이나 욕구가 들어가지 않는다. ex. should be 문구\n  \n 4. 매개변수화된 테스트\n보통 테스트 하나로는 동작 단위를 완전하게 설명하기 충분하지 않다.\n\n동작이 충분히 복잡하면 이를 설명하는 데 테스트 수가 급격히 증가할 수 있으며 관리하기 어려워질 수 있다.\n\n대부분의 단위 테스트 프레임워크는 유사한 테스트를 묶을 수 있는 매개변수화된 테스트 기능을 제공한다.\n\n\n 예시\n아래와 같이 가장 빠른 배송일이 오늘로부터 이틀 후가 되도록 작동하는 배송기능이 있다면\nkotlin\nfun Deliverty for today is invalid\nfun Deliverty for tomorrow is invalid\nfun The soonest delivery date is two days from now\n\n\nkotlin\n@ParameterizedTest\n@CsvSource\n    \"HECTO_FINANCIAL,CARD,1000\",\n    \"NONE,MAINTENANCE_FEE,2000\",\n    \"NONE,ZERO,0\",\n\nfun Can detect an invalid delivery date\n    daysFromNow: Int,\n    expected: Boolean",
    "tags": [
      "유닛테스트",
      "TIL"
    ]
  },
  {
    "title": "1장 단위테스트의 목표",
    "url": "/book/2023/02/19/1장-단위테스트의-목표/",
    "category": "book",
    "date": "2023-02-19",
    "excerpt": "해당 장에서는 단위테스트의 목표와 현재 상황, 우리가 주로 사용하는 코드 커버리지 지표코드 커버리지, 분기 커버리지에 대해 알려주고 성공적인 테스트-스위트test-suite에 대한 특성을 알려준다.",
    "content": "1장 단위테스트의 목표\n 요약\n해당 장에서는 단위테스트의 목표와 현재 상황, 우리가 주로 사용하는 코드 커버리지 지표코드 커버리지, 분기 커버리지에 대해 알려주고 성공적인 테스트-스위트test-suite에 대한 특성을 알려준다.\n\n>  테스트 스위트\n> 테스트 실행 목적으로 그룹화된 테스트 케이스의 컬렉션이다.\n\n이 책에서 가장 흥미롭다고 느낀 내용은 테스트 코드도 관리해야 할 소프트웨이고, 주기적으로 관리리펙토링 등...를 해야 한다는 점이였다.\n\n 1. 단위테스트의 목표\n단위테스트의 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것 이다.\n\n> 소프트웨어가 더 나은 설계로 이어지는 것은 단위테스트의 부수효과 중 하나에 불과하다.\n\n<img width=350 src=\"/assets/images/posts/book/테스트_유무.png\">\n\n테스트가 없는 테스트는 빨리 시작할 수 있지만 시간이 지나면서 점점 더 많은 시간을 들여야 처음에 보여준 것 과 같은 정도의 진척을 낼 수 있다.\n\n개발 속도가 빠르게 감소하는 현상을 소프트웨어 엔트로피software entropy라고 한다.\n- 코드베이스에서 무언가를 변경할 때마다 무질서도엔트로피는 증가한다.\n- 지속적인 정리와 리팩터링 과 같은 적절한 관리를 하지 않으면 시스템은 점점 더 복잡해지고 무질서한다.\n\n테스트는\n- 안정망 혁할\n- 회귀에 대한 보험을 제공하는 도구\n- 하지만, 초반에 노력이 필요하다.\n\n 좋지 않는 테스트\n좋지 않는 테스트도 초반에는 코드가 나빠지는 것을 늦출 수 있지만, 거시적인 관점에서는 테스트를 작성하지 않았을 때와 같다.\n\n<img width=350 src=\"/assets/images/posts/book/잘못된_테스트_포함.png\">\n\n단위 테스트 목표를 달성하려면 테스트의 가치와 유지 비용을모두 고려해야 한다. 비용요소는 다음과 같은 다양한 활동에 필요한 시간에 따라 결정된다.\n- 기반 코드를 리팩터링 할 때 테스트도 리팩터링하라.\n- 각 코드 변경 시 테스트를 실행해라\n- 테스트가 잘못된 경고를 발생시킬 경우 처리하라.\n- 기반 코드가 어떻게 동작하는지 이해하려고 할 떄는 테스트를 읽는 데 시간을 투자하라.\n\n지속 가능한 프로젝트 성장을 위해 고품질 테스트에만 집중해야 한다.\n\n> 테스트 코드는 자산이 아니라 책임이다. 코드가 많아질수록 소프트웨어 내 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다.  \n> 테스트 코드도 결국 코드이다.  \n> 제품코드 뿐만 아니라 테스트 코드도 유지보수가 필요하다.\n\n 3. 테스트 스위트 품질 츨정을 위한 커버리지 지표\n단순 커버리지 지표만으로 테스트 스위트 품질을 효과적으로 측정하는데 사용될 수 없다.\n\n\n 코드 커버리지\n$$코드 커버리지테스트 커버리지 = \\frac{실행 코드 라인 수}{전체 라인 수}$$\n\n코드 커버리지가 낮으면 테스트가 충분치 않다는 증거이나, 100%라고 해도 반드시 양질의 테스트 스위트임을 보장하지 않는다.\n\nkotlin\nfun isStringLonginput: String: Boolean{\n    ifinput.length > 5\n        return true\n    return false\n}\n\nfun test{\n    val result = isStringLong\"abc\"\n    isEqualfalse, result\n}\n\n여기서 중괄호를 포함한 메서드 전체 라인 수는 5이고 true를 반환하는 구문을 제외하면 4줄이 실행된다.\n$4/5 = 0.8$ 이다.\n\n이를 다음과 같이 리팩토링하면 어떻게 될까?\nkotlin\nfun isStringLonginput: String: Boolean{\n    return input.length > 5\n}\n\n코드 커버리지가 100%로 증가했다.\n\n단지 메서드 내 코드를 바꿨을 뿐인데 해당 테스트가 검증하는 결과 개수는 여전히 같다.\n\n단지 테스트 코드에서 테스트 할 코드를 실행하고 검증을 아예 하지 않을 수 있다.\n\n 분기 커버리지\n분기 커버리지는 제어 구조에 중점을 둔다.\n$$분기 커버리지 = \\frac{통과 분기}{전체 분기 수}$$\n\n위에 작성했던 테스트 코드를 분기 커버리지를 적용하면 50%이다.\n\n분기 커버리지는 분기 개수만 다루지만, 해당 분기를 구현하는 데 얼마나 코드가 필요한지 고려하지 않는다.\n\n 커버리지 지표의 문제점\n- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.\n- 외무 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.\n\n> 병원에 있는 환자가 열이 높으면 열이 난다는 것을 의미할 수 있다.\n> 하지만 병원은 환자의 적절한 체온을 목표로 해서는 안된다.\n> 단순히 목표가 되면 환자 옆에 에어컨을 설치해서 '효율적으로' 빨리 끝낼 수 있다.\n\n시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋지만 이 높은 수준을 요구사항으로 삼는 것은 좋지 않다.\n\n 4. 무엇이 성공적인 테스트 스위트를 만드는가?\n 1. 개발 주기에 통합돼 있음\n모든 테스트는 개발 주기에 통합돼야 한다. \n이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다.\n\n 2. '코드베이스'에서 가장 중요한 부분만을 대상으로 함\n대부분의 애플리케이션에서 가장 중요한 부분은 비즈니스 로직도메인 모델이 있는 부분이다.\n비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.\n> 레버리지가 높다.\n\n인프라 코드에 복잡하고 중요한 알고리즘이 있을 수 있으므로 많이 테스트하는게 좋지만, 초첨은 도메인 모델에 머물러야 한다.\n\n이게 가능하려면 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 한다.\n\n 3. 최소 유지비로 최대 가치를 끌어냄\n이게 핵심이다.\n\n테스트를 빌드 시스템에 통합하는 것만으로 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다. 또한 가치가 유지비를 상회하는 테스트 스위트에 유지하는 것이 중요하다.\n\n이 마지막 속성은 두 가지로 나눌 수 있다.\n- 가치 있는 테스트 식별하기\n  - 더 나아가 가치가 낮은 테스트 식별하기\n- 가치 있는 테스트 작성하기\n\n 가치 있는 테스트 식별하기\n가치가 높은 테스트를 식별하려면 기준틀frame of reference이 필요하다.\n\n 가치 있는 테스트 작성하기\n가치 있는 테스트를 작성하려면 코드 설계 기술도 알아야 한다.\n\n단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력이 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.\n\n> 좋은 곡을 식별하는 것과 작곡하는 것은 다르다.\n\n References\n- 테스트 스위트\n  - https://en.wikipedia.org/wiki/Test_suite\n  - https://www.ibm.com/docs/ko/elm/6.0.5?topic=testing-test-case-test-suite-overview",
    "tags": [
      "유닛테스트",
      "TIL"
    ]
  },
  {
    "title": "equals",
    "url": "/programming/2022/09/25/equals/",
    "category": "programming",
    "date": "2022-09-25",
    "excerpt": "> equals는 재정의 하지 않는 것이 최선이다.\n- 각 인스턴스가 본질적으로 고유하다.\n  > ex. singleton 객체, enum\n- 인스턴스의 '논리적 동치성'을 검사할 필요가 없다.\n- 상위 클래스에서 재정의한 equals가 하위 클래스에도 적절하다.\n  > List, Set등...\n- 클래스가 private이거나 package-privete이...",
    "content": "equals\n\n equals를 재정의 하지 않아도 되는 상황\n> equals는 재정의 하지 않는 것이 최선이다.\n- 각 인스턴스가 본질적으로 고유하다.\n  > ex. singleton 객체, enum\n- 인스턴스의 '논리적 동치성'을 검사할 필요가 없다.\n- 상위 클래스에서 재정의한 equals가 하위 클래스에도 적절하다.\n  > List, Set등...\n- 클래스가 private이거나 package-privete이고 equals 메서드를 호출할 일이 없다.\n\n equals 규약 \n 요약\n- 반사성: A.equalsA == true\n- 대칭성: A.equalsB == B.equalsA\n- 추이성: A.equalsB && B.equalsC == A.equalsC\n- 일관성: A.equalsB == A.equalsB",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "식(expression)과 문(statement)",
    "url": "/programming/2022/09/24/식expression과-문statement/",
    "category": "programming",
    "date": "2022-09-24",
    "excerpt": "> Java에서 볼 수 없던 특징이라 정리하게 됨",
    "content": "식expression과 문statement\n> Java에서 볼 수 없던 특징이라 정리하게 됨\n\n 정의\n- 식expression : 값을 만들며, 다른 식의 하위 요소로 계산에 참여\n \n- 문statement : 자신을 둘러싼 가장 안쪽 블록의 최상위 요소이며, 아무런 값을 만들어내지 않는다.\n\n 예시\n if-else\n> 사실 조건식을 리턴하면 한줄로 코딩이 가능하지만 예를 들기 위해 일부로 풀어씀\n\nJava의 if-else는 '문'으로 분류된다.\njava\nboolean isOddint num{\n  ifnum % 2 != 0\n    return true;\n  else\n    return false;\n}\n\n\n하지만 Kotlin에서의 if-else '식'으로 사용할 수 있기 때문에 return 문에 if-else를 사용할 수 있다.\nkotlin\nfun isOddnum: Int: Boolean{\n  return ifnum % 2 != 0 true\n        else false\n}\n\n\nif-else문 이외에 when도 값을 리턴하는 '식'으로 사용된다.\n\n Kotlin의 함수표현\nKotlin은 2가지 방법으로 함수를 표현할 수 있다.\n\n 1. 블록문이 본문인 함수\n본문이 중괄호{}블록로 둘러싸인 함수\n\n 특징\n- 타입추론이 불가능하다.\n- 그러므로 반환 타입을 생략할 수 없다.\n\n 예시\nkotlin\nfun argsToArrayvararg nums: Int: Array<Int> {\n  return arrayOfnums\n}\n\n\n 2. 식이 본문인 함수\n등호와 식으로 이루어진 함수\n\n 특징\n- 컴파일러가 식을 분석할 수 있어 타입 추론이 가능\n- 추론이 가능 하므로 타입생략 가능\n- 별도의 키워드 명시 없이 마지막에 나온 값이 return값이 됨\n\n 예시\nkotlin\nfun argsToArrayvararg nums: Int = arrayOfnums",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "AWS EC2 + Amazon linux2 환경에 redis설치하기",
    "url": "/database/2022/08/01/aws-ec2-amazon-linux2-환경에-redis설치하기/",
    "category": "database",
    "date": "2022-08-01",
    "excerpt": "yum을 update하고 gcc와 make를 설치해야 한다.\n> gcc와 make를 설치하는 이유는 redis를 다운받고 컴파일 하는 과정이 필요하기 때문이다.",
    "content": "AWS EC2 + Amazon linux2 환경에 redis설치하기\n 1. 사전과정\nyum을 update하고 gcc와 make를 설치해야 한다.\n> gcc와 make를 설치하는 이유는 redis를 다운받고 컴파일 하는 과정이 필요하기 때문이다.\nbash\nsudo yum install update\nsudo yum intsall gcc make\n\n\n그 이후 관리하기 편하게 redis라는 디렉터리를 생성해주었다. 이 과정은 생략해도 상관 없다.\nbash\nmkdir redis && cd redis\n\n\n 2. Stable된 redis 다운로드\n 2-1. stable된 redis를 다운받고 압축을 해제한다.\nbash\nsudo wget http://download.redis.io/redis-stable.tar.gz\nsudo tar xvzf redis-stable.tar.g\n\n\n 2-2. 압축을 해제한 redis-stable 디렉토리에 이동한다.\nbash\ncd redis-stable\n\n\n 2-3. redis-stable 디렉토리 에서 make명령어를 통해 redis install\nbash\nsudo make\n\nmake 명령어를 입력하게 되면 redis-stable 디렉토리 속 Makefile를 기반으로 redis를 설치할 것이다.\n> 해당 글은 redis설치를 중점적으로 다루므로 make에 대해서 다루지 않을 것 이다.\n\n그 후 src 디렉토리로 이동하면 여러 파일들이 생성되는데 대표적인 파일들을 설명하자면\n- redis-server: Redis 그 자체이다.\n- redis-sentinel: Redis Sentinel 실행 파일모니터링 및 페일 오버 이다.\n- redis-cli: Redis와 대화하기 위한 CLI이다.\n- redis-benchmark: 성능을 확인하는데 사용된다.\n- redis-check-aof, redis-check-rdb: 드물게 손상된 데이터 파일에 유용하다.\n\n만약 \"Error jemalloc/jemalloc.h: No such file or directory when making Redis\"가 발생한다면 다음 명령어를 입력하면 해결된다.\nbash\nmake MALLOC=libc\n\n자세한 정보는 stackoverflowhttps://stackoverflow.com/a/43929348/18397196에 올라온 답변을 참고\n\n 3. 설치된 redis-server와 redis-cli를 적절한 위치로 복사\n> Redis 서버와 명령 행 인터페이스를 모두 적절한 위치에 복사하는 것이 좋다.  \n> 이 글에서 리눅스 디렉토리 구조에 대해 다루지 않겠다.\nbash\nsudo mkdir /etc/redis\nsudo mkdir /var/lib/redis\nsudo cp src/redis-server src/redis-cli /usr/local/bin/\nsudo cp redis.conf /etc/redis\n\n\n 4. Redis 설정\nvim 으로 redis.conf파일을 열어 설정을 변경할 수 있디.\nbash\nsudo vim /etc/redis/redis.conf\n\n\n이건 작성자가 메모 하고 싶어 남겨놨다. 단순 테스트 용으로 사용했다.\nconf\n...\nbind 0.0.0.0\n...\nprotected-mode no\n...\ndaemonize yes\n...\nlogfile /var/log/redis.log\n...\ndir /var/lib/redis \n\n- bind: 외부에서 접속할 수 있는 IP를 등록한다. 0.0.0.0으로 설정하면 모두 접근할 수 있다.\n- protected-mode: redis 보안에 관련된 설정이다. 참고http://redisgate.kr/redis/server/protected-mode.php\n- daemonize: redis실행시 foreground혹은 background로 실행할 것인지에 대한 설정이다. yes로 설정시 background로 실행된다.\n- logfile: 로그 파일의 위치및 파일명을 나타낸다.\n- dir: dbfilename로 설정해준 rdb 파일이 저장되는 dir 경로를 나타낸다.\n\n 5. init script 설정\n자동 실행을 위한 스크립트를 다운로드 한다.\n\n해당 스크립트를 /etc/init.d에 설치하면 이후 service redis-server start와 같이 간편하게 실행할 수 있다.\n\nbash\nsudo wget https://raw.githubusercontent.com/saxenap/install-redis-amazon-linux-centos/master/redis-server\n\nsudo mv redis-server /etc/init.d  /etc/init.d wget으로 다운받은 파일을 /etc/init.d 디렉토리로 옮긴다.\n\nsudo chmod 755 /etc/init.d/redis-server\n\n이후 wget으로 다운받은 redis-server를 vim으로 열어 redis=\"/usr/local/bin/redis-server\"가 있는지 확인하자\n\nvim /etc/init.d/redis-server \n\n\n 6. redis 실행\n실행 방법에는 총 2가지 방법이 있다.\nbash\nsudo /usr/local/bin/redis-server\n\n혹은\nbash\nsudo service redis-server start\n\n\n 7. redis 종료\nsudo /usr/local/bin/redis-server를 통해 실행했으면 control + c를 통해 나가면 된다.\n\nservice redis-server stop을 통해 redis를 종료할 수 있어야 하지만... 안된다. 나중에 쉘스크립트를 배우면 init script를 내가 직접 작성해야겠다.",
    "tags": [
      "redis",
      "TIL"
    ]
  },
  {
    "title": "CAP Theorem",
    "url": "/cs/2022/07/19/cap-theorem/",
    "category": "cs",
    "date": "2022-07-19",
    "excerpt": "CAP 이론에서 CAP는 다음과 같이 분산 데이터베이스 시스템의 세 가지 속성인 일관성Consistency, 가용성Availability, 파티션 허용성Partition tolerance를 나타낸다,",
    "content": "CAP Theorem\nCAP 이론에서 CAP는 다음과 같이 분산 데이터베이스 시스템의 세 가지 속성인 일관성Consistency, 가용성Availability, 파티션 허용성Partition tolerance를 나타낸다,\n\n|       속성       |                              설명                            |\n|------------------|--------------------------------------------------------------|\n|일관성            |모든 요청은 최신 데이터 또는 에러를 응답받는다.               |\n|가용성            |모든 요청은 정상 응답을 받는다.                               |\n|파티션 허용성     |노드간 통신이 실패하는 경우라도 시스템은 정상 동작 한다.      |\n\n주의 여기서 말하는 일관성은 ACID의 일관성과 다르다.\n\n CAP 의 핵심\nCAP 이론에 따르면 분산 데이터베이스 시스템은 네트워크 파티션이 발생하였을 때 세 가지 속성 중 두 가지만 만족할 수 있다.\n\n 세 가지 속성 중 두가지를 만족하는 시스템\n- CAConsistency-Availablility\n- CPConsistency-Partition tolerance\n- APAvailability-Partition tolerance\n\nCAP 이론은 위와 같이 세 종류의 시스템으로 나뉘지만 CAP이론은 네트워크 파티션 상황을 가정하므로 CA 시스템은 있을 수 없다. CA 시스템이 가능하려면 네트워크 파티션이 없어야 한다. 하지만, 네트워크 파티션이 없으면 CAP이론 자체가 쓸모가 없고, 네트워크 파티션은 어떤 이유에서든지 발생할 수 있다.\n\n분산 시스템에서 노드끼리 데이터를 주고 받을 때 타임아웃이 발생하는 모든 경우를 네트워크 파티션으로 볼 수 있다.  \n여기서 타임아웃은 하드웨어 문제 뿐만 아니라 Java의 GC등 다양한 이유로 발생할 수 있따.\n\n\n \n CAP 이론 논란\n- DB를 CP나 AP라고 불리는 것 멈춰! 둘다 아니니깐https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html\n- CAP 이론의 예외로 가장 잘 알려진 것은?https://www.quora.com/Distributed-Databases-What-are-the-best-known-exceptions-for-CAP-theorem\n\n Reference\n- http://happinessoncode.com/2017/07/29/cap-theorem-and-pacelc-theorem/\n- https://okky.kr/article/324449",
    "tags": [
      "distributed-systems",
      "TIL"
    ]
  },
  {
    "title": "Spring Transaction Propagation - 스프링 트랜잭션 전파속성",
    "url": "/back-end/2022/07/12/spring-transaction-propagation---스프링-트랜잭션-전파속성/",
    "category": "back-end",
    "date": "2022-07-12",
    "excerpt": "트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.",
    "content": "Spring Transaction Propagation - 스프링 트랜잭션 전파속성\n트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.\n\n 스프링이 지원하는 전파속성\n스프링이 지원하는 전파 속성은 다음과 같다.\n1. Required 기본값\n2. Supports\n3. Mandatory\n4. Requires new\n5. Not supported\n6. Never\n7. Nested\n\n 1. Required\n미리 시작 된 트랜잭션이 있으면 참여하고, 없으면 새로 시작한다.\n- 기본 속성\n- 모든 트랜잭션 매니저가 지원\n- 트랜잭션이 시작 된 후 다른 트랜잭션 경계가 설정된 메소드를 호출하면 같은 트랜잭션으로 묶인다.\n\n 2. Supports\n이미 시작된 트랜잭션이 있다면 참여하고, 없다면 트랜잭션 없이 진행한다.\n\n 3. Mandatory\n이미 시작된 트랜잭션이 있으면 참여한다. 시작된 트랜잭션이 없으면 예외가 발생한다.\n- 독립적으로 트랜잭션을 진행하면 안되는 경우 사용한다.\n\n 4. Requires new\n항상 새로운 트랜잭션을 시작한다.\n- 이미 진행중인 트랜잭션은 잠시 보류하고 새로운 트랜잭션을 시작한다.\n- 이전 트랜잭션과 별도로 동작한다.\n\n 5. Not supported\n트랜잭션을 사용하지 않는다.\n- 이미 진행중인 트랜잭션이 있으면 보류시킨다.\n\n 6. Never\n트랜잭션을 사용하지 않도록 강제한다. 이미 트랜잭션이 진행중이면, 예외를 발생한다.\n\n 7. Nested\n이미 실행중인 트랜잭션이 있으면, 중첩 트랜잭션을 시작한다.\n- 상위 트랜잭션은 하위 트랜잭션에 영향을 주지만, 하위 트랜잭션의 결과에 영향을 끼치지 않는다.\n\n Reference\n- https://mangkyu.tistory.com/169\n- https://www.youtube.com/watch?v=SUQxXg229Xg",
    "tags": [
      "spring",
      "transaction",
      "TIL"
    ]
  },
  {
    "title": "CORS해결기 근데 이제 Spring Security를 곁들인",
    "url": "/back-end/2022/07/04/cors해결기-근데-이제-spring-security를-곁들인/",
    "category": "back-end",
    "date": "2022-07-04",
    "excerpt": "Web Application 처음 프론트엔드 백앤드로 나눠서 협업을 진행하다보면 한번쯤 CORS에러를 겪는다. ",
    "content": "CORS해결기 근데 이제 Spring Security를 곁들인\nWeb Application 처음 프론트엔드 백앤드로 나눠서 협업을 진행하다보면 한번쯤 CORS에러를 겪는다. \n\nCORS는 브라우저의 보안 정책중 하나지만, 서버에서 요청을 응답할 떄 CORS관련 Header를 작성하여 보내줘야 한다.  \nMDN문서에 CORS관련해서 자바 코드로 된 예제가 있으니 참고하길 바란다.https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Access-Control-Allow-Origin  \n\n SpringMVC의 CORS설정\n일반적으로 Spring Boot를 통해 WAS를 만들게 된다면, Spring MVC를 사용하게 된다. WebMvcConfigurer를 상속받은 후 addCorsMappings 매서드를 통해 CORS를 설정할 수 있다.\n\n대부분 아래 예제 코드에 나와있는 방식으로 CORS문제를 해결할 것이다.\n> 이렇게 코드를 통해 설정하면 Spring MVC가 내부적으로 Filter를 통해 CORS관련 Header를 만들어준다.\nkotlin\n@Configuration\nclass WebMvcCorsConfig: WebMvcConfigurer{\n\n    override fun addCorsMappingsregistry: CorsRegistry {\n        registry\n            .addMapping\"/\"\n            .allowedOrigins\"https://www.hirecruit.site\"\n            .allowedMethodsallowedHttpMethod\n            .allowCredentialstrue\n            .maxAge3000;\n    }\n\n    private fun allowedHttpMethod: Array<String> =\n        arrayOf\n            HttpMethod.GET.name,\n            HttpMethod.POST.name,\n            HttpMethod.PATCH.name,\n            HttpMethod.PUT.name,\n            HttpMethod.DELETE.name,\n            HttpMethod.HEAD.name,\n            HttpMethod.OPTIONS.name,\n        \n}\n\n\n 하지만 Spring Security를 사용하게 된다면?\nSpring Security는 Spring기반의 애플리케이션의 보안인증/인가/취약점 방어 등을 담당하는 Spring하위의 프레임워크이다.\n기본적으로 Spring Security도 필터 기반으로 동작하고 있다. 아까 CORS설정도 filter를 통한다는 사실도 꼭 기억하자\n\nSpring Security를 사용해서 사용자의 역할Role별로 endpoint의 접근을 관리할 수 있다. 아래는 hirecruit프로젝트에 사용되었던 설정 클래스의 일부이다.\nkotlin\n@Configuration\nclass SecurityConfig: WebSecurityConfigurerAdapter{\n    ...\n    override fun configurehttp: HttpSecurity {\n        ...\n        http.authorizeRequests{\n                it.antMatchers\n                    \"/worker/me/\"\n                .hasAnyRoleRole.WORKER.name, Role.MENTOR.name\n        }\n        ...\n    }\n}\n\n/worker/me/표현식에 해당하는 endpoint에 대해 WORKER와 MENTOR의 역할을 가지고 있는 사용자만 접근할 수 있다.  \n그렇지 않은 사용자가 해당 endpoint에 접근하면 401혹은 개발자가 작성한 handler에 따라 동작이 달라지겠지만 일반적인 API서버를 만든다면 401를 리턴하게 될 것이다.\n\n 401 error와 함께 발생한 CORS\npreflight요청은 서버에 어떤 method, header, content type을 지원하는지 사전에 확인하는 요청이다.  \npreflight요청은 주로 브라우저의 스크립트로 보내는 Fetch, Axios요청에 사용된다.\n\npreflight 요청은 OPTIONS method를 사용하여 요청한다.  \nOPTIONS method는 요청시 header, cookie, body를 포함하지 않아 client에서 사용자 인증정보를 보낼 수 없다. \n\n그러므로 클라이언트에서는 preflight요청이 실패하였으므로 cors에러가 반환되었고, preflight요청 후 본 요청에 대해 실패하였으므로 error.response.status객체를 통해서 status code를 불러올 수 없었고 이로인해 예외처리를 하지 못하는 상황이 되었다.\n\n그래서 모든 OPTIONS 메서드의 요청을 모두 접근할 수 있게 변경하였다.\nkotlin\n@Configuration\nclass SecurityConfig: WebSecurityConfigurerAdapter{\n    ...\n    override fun configurehttp: HttpSecurity {\n        ...\n        http.authorizeRequests{\n                it.antMatchersHttpMethod.OPTIONS, \"/\".permitAll // CORS를 위해 OPTION method는 모든 요청에 대해 권한없이 접근할 수 있다.\n                it.antMatchers\n                    \"/worker/me/\"\n                .hasAnyRoleRole.WORKER.name, Role.MENTOR.name\n        }\n        ...\n    }\n}\n\n\n하지만 여기서 끝난 것이 아니다. security에 cors설정을 적용시키려면 configure매서드에서 HttpSecurity.cors를 통해 cors설정을 적용시킨다는 것을 spring security에 알려줘야 한다.\nkotlin\n@Configuration\nclass SecurityConfig: WebSecurityConfigurerAdapter{\n    ...\n    override fun configurehttp: HttpSecurity {\n        ...\n        http.cors // 여기\n        http.authorizeRequests{\n                it.antMatchersHttpMethod.OPTIONS, \"/\".permitAll // CORS를 위해 OPTION method는 모든 요청에 대해 권한없이 접근할 수 있다.\n                it.antMatchers\n                    \"/worker/me/\"\n                .hasAnyRoleRole.WORKER.name, Role.MENTOR.name\n        }\n        ...\n    }\n}\n\nhttp.cors를 통해 WebMvcConfigurer를 통해 설정한 cors설정을 적용하였다. Security에서 cors설정을 하는 방법이 있지만 귀찮으므로 여기에 적진 않겠다.",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "Java Reference와 GC",
    "url": "/programming/2022/06/28/java-reference와-gc/",
    "category": "programming",
    "date": "2022-06-28",
    "excerpt": "최초의 Java에서는 GC작업에 애플리케이션의 사용자 코드가 관여하지 않도록 구현되어 있었지만 GC작업에서 좀 더 다양한 방법으로 객체를 처리하기 위해 JDK1.2부터  패키지를 추가하여 제한적으로 사용자 코드와 GC가 상호작용할 수 있게 되었다.",
    "content": "Java Reference와 GC\n최초의 Java에서는 GC작업에 애플리케이션의 사용자 코드가 관여하지 않도록 구현되어 있었지만 GC작업에서 좀 더 다양한 방법으로 객체를 처리하기 위해 JDK1.2부터 java.lang.ref 패키지를 추가하여 제한적으로 사용자 코드와 GC가 상호작용할 수 있게 되었다.\n\n java.lang.ref\njava.lang.ref 패키지는 strong reference 이외에 soft, weak, phantom 3가지의 새로운 참조 방식을 각각 Reference 클래스로 제공한다.\n\n>  strong reference 란?\n> A a = new A코드에서 변수a가 생성된 A객체를 참조하는 것 과 같이 전형적으로 객체를 참조하는 방식을 의미한다.  \n> 강한 참조를 통해 참조되고 있는 객체는 가비지 컬렉션의 대상에서 제외된다.\n\n java.lang.ref.Reference는 어떻게 활용할 수 있나요?\n- GC에 일정 부분 관여할 수 있다.\n- LRU - Least Recently Used 캐시 와 같이 특별한 작업을 하는 애플리케이션 작성\n\n 1. 가비지 판단 기준\nJava GC는 객체가 가비지인지 판별하기 위해 reachability라는 개념을 사용한다.\n- 어떤 객체에 유효한 참조가 있으면 reachable\n- 어떤 객체에 유효한 참조가 없다면 unreachable\n\n가비지 판단 기준은 2가지로 나뉘고, unreachable객체를 가비지로 간주해 GC를 수행한다.\n\n한 객체는 여러 다른 객체를 참조하고, 참조된 다른 객체들도 또 다른 객체들을 참조할 수 있으므로 객체들은 참조 사슬을 이룬다. 이 상황에서 유효한 참조 여부를 파악하려면 유효한 최초의 참조가 있어야 하는데 이를 객체 참조의 root set 이라고 한다.\n\n root set의 종류 \n힙에 있는 객체들에 대한 참조는 4가지 종류가 있는데\n1. 힙 내의 다른 객체에 의한 참조\n2. Java 스택, 즉 Java 메서드 실행 시 사용하는 지역 변수와 파라미터들에 의한 참조\n3. 네이티브 스택, 즉 JNI에 의해 생성된 객체에 대한 참조\n4. 메서드 여역에 정적 변수에 의한 참조\n\n이들 중 1. 힙 내의 다른 객체에 의한 참조를 제외한 나머지 3개2, 3, 4가 root set으로 reachability를 나누는 기준이 된다.\n\n 2. Soft, Weak, Phantom Reference와 Reachability\njava.lang.ref는 soft/weak/phantom reference를 클래스 형태로 제공한다. java.lang.ref 공식 문서https://docs.oracle.com/javase/7/docs/api/java/lang/ref/package-summary.html\n\nSoft/Weak/Pantom Reference 객체는 다른 객체와 달리 Java GC가 특별하게 취급한다.\n\n WeakReference 클래스 예제\n다음은 WeakReference의 생성 예제이다.\njava\nWeakReference<Sample> wr = new WeakReference<>new Sample;\nSample wrGet = wr.get;\n\n\njava.lang.ref.WeakReference 클래스는 참조 대상인 객체를 캡슐화 한 WeakReference객체를 생성한다.\n이렇게 생성된 WeakReference객체는 다른 객체와 달리 Java GC가 특별하게 취급된다.\n\n캡슐화된 내부 객체는 weak reference에 의해 참조된다.\n\n위의 코드를 그림으로 나타내면 다음과 같다.  \n<img src=\"/assets/images/posts/programming/weak-ref-ex1.png\">\n\nRoot set에서 변수wr는 Simple객체를 캡슐화한 WeakReference를 참조하고 있고, 변수wrGet는 Simple객체를 직접 참조하고 있다.\n\nroot set에 있는 변수wrGet가 Simple객체를 직접 참조를 하고 있으므로 Simple은 strongly reachable object이다.\n\n만약 여기서 변수wrGet에 null를 대입하면 어떻게 될까?\n\njava\nWeakReference<Sample> wr = new WeakReference<>new Sample;\nSample wrGet = wr.get;\n...\nwrGet = null\n\n그림으로 나타내면 다음과 같다.  \n<img src=\"/assets/images/posts/programming/weak-ref-ex2.png\">\n\n이제 root set에서 Simple를 직접 참조하고 있는 객체가 없고 WeakReference를 통해 변수wr가 WeakReference로 간접적으로 참조하고 있으므로, Simple객체는 Weakly reachable object이다.\n\n만약 WeakReference대신 SoftReference를 사용한다면 Simple객체는 Softly reachable object가 되고, Phantom reachable object가 된다.\n\n 2-1. Java 스펙에서의 reference object\nJava 스펙에서는 SoftReference, WeakReference, PhantomReference 3가지 클래스에 의해 생성된 객체를 reference object라고 부른다.\n\n- reference object는 Reference 클래스의 객체에 대해서만 사용하는 용어다.\n- reference object에 의해 참조된 객체는 referent라고 부른다.\n- 위 코드에서\n  - reference object는 new WeakReference 생성자를 의미하고\n  - referent는 new Sample생성자로 생성된 객체를 의미한다.\n\n 3. Strengths of Reachability\n앞에서 언급한 것 처럼 reachability는 총 5종류가 있고 이는 GC가 처리하는 기준이 된다.\n\nJava스펙에서 이들 5종류의 reachability를 Strengths of Reachability라고 불린다.\n\n하나의 객체는 여러 strong reference, soft reference, weak reference, phantom reference의 다양한 조합으로 참조될 수 있다.\n\nJava GC는 root set으로부터 시작해서 객체에 대한 모든 경로를 탐색하고 그 경로에 있는 reference object들을 조사하여 그 객체에 대한 reachability를 결정한다. 다양한 참조 관계의 결과, 하나의 객체는 다음 5가지 reachability 중 하나가 될 수 있다.\n\n 5가지 Reachability\n- strongly reachable: root set으로 시작하여 어떤 reference object가 없는 사슬이 하나라도 있는 객체\n- softly reachable: strongly reachable 객체가 아닌 객체 중에 soft reference만 통과하는 참조 사슬이 하나라도 있는 객체\n- weakly reachable: strongly reachable 객체가 아닌 객체 중에 weak reference만 통과하는 참조 사슬이 하나라도 있는 객체\n- phantomly reachable: strongly reachable 객체, softly reachable 객체, weakly reachable 객체 모두 해당되지 않는 객체. 이 객체는 파이널라이즈finalize되었지만 아직 메모리가 회수되지 않은 상태이다.\n- unreachable: root set으로 부터 시작되는 참조 사슬로 참조되지 않는 객체\n\nReachability에 대해 더 적고 싶지만 길어져 다음 md로 넘기려고 한다.\n\n\n Reference\n- https://d2.naver.com/helloworld/329631\n- https://madplay.github.io/post/java-garbage-collection-and-java-reference\n- https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/ref/package-summary.html\n- https://luckydavekim.github.io/development/back-end/java/weak-reference-in-java",
    "tags": [
      "TIL",
      "coding",
      "memory",
      "development",
      "java"
    ]
  },
  {
    "title": "WeakHashMap",
    "url": "/programming/2022/06/28/weakhashmap/",
    "category": "programming",
    "date": "2022-06-28",
    "excerpt": "> 더 이상 사용하지 않는 객체를 GC할 때 자동으로 삭제해주는 Map\n- Key가 더 이상 강하게 레퍼런스strong reference되는 곳이 없다면 해당 엔트리를 제거한다.\n- Map의 엔트리를 Key에 의존하는 경우 사용할 수 있다.\n- 캐시를 구현하는데 사용할 수 있지만, 직접 구현을 권장하지 않는다.",
    "content": "WeakHashMap\n> 더 이상 사용하지 않는 객체를 GC할 때 자동으로 삭제해주는 Map\n- Key가 더 이상 강하게 레퍼런스strong reference되는 곳이 없다면 해당 엔트리를 제거한다.\n- Map의 엔트리를 Key에 의존하는 경우 사용할 수 있다.\n- 캐시를 구현하는데 사용할 수 있지만, 직접 구현을 권장하지 않는다.\n\n공식문서https://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html",
    "tags": [
      "TIL",
      "coding",
      "memory",
      "development",
      "java"
    ]
  },
  {
    "title": "ECS에 배포한 단일 노드 Redis의 Read only replica 에러 해결기",
    "url": "/database/2022/06/26/ecs에-배포한-단일-노드-redis의-read-only-replica-에러-해결기/",
    "category": "database",
    "date": "2022-06-26",
    "excerpt": "HiRecruit서비스에서는 Redis를 Session storage로 사용한다.  ",
    "content": "ECS에 배포한 단일 노드 Redis의 Read only replica 에러 해결기\nHiRecruit서비스에서는 Redis를 Session storage로 사용한다.  \n\n 왜 Hirecruit에서는 Amazon ElastiCache for Redis를 두고 ECS에 redis를 배포헀나요?\n일단 Amazon ElastiCache 서비스의 비용은 학생들이 부담하기에는 돈이 너무 많이 든다. 그리고 Redis를 단일 노드로 사용할 것 이므로 Amazon ElasticCache는 오버스펙이라는 생각이 들어 Docker 컨테이너 형태로  쉽게 배포할 수 있는 ECS를 선택했다.\n\n 1. 배포방식\nredis 공식 docker imagehttps://hub.docker.com/_/redis를 pull받아서 별도의 설정없이 그대로 배포했다.\n\n이미 local환경에서 어느정도 테스트를 해봐서 상관 없겠지 하며 배포를 했지만... 어느순간 갑자기 Read only replica에러가 발생했다.\n\n 2. 수많은 에러의 향연\n운영 환경에서 SpringBoot Application Server가 잘 동작하고 있었는데 어느순간 1분단위로 계속 에러가 발생하였다.\n\n<img src=\"/assets/images/posts/database/readonly-error.png\">\n\n> Clould Watch logging...\n\n로그를 살펴보면 RedisReadOnlyException이 발생하는 것을 확인할 수 있다.\nlog\n20220613T162700 pool-1-thread-1 ERROR o.s.s.s.TaskUtils$LoggingErrorHandler Unexpected error occurred in scheduled task\norg.springframework.data.redis.RedisSystemException: Error in execution; nested exception is io.lettuce.core.RedisReadOnlyException: READONLY You can't write against a read only replica.\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convertLettuceExceptionConverter.java:54 ~spring-data-redis-2.6.4.jar!/:2.6.4\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convertLettuceExceptionConverter.java:52 ~spring-data-redis-2.6.4.jar!/:2.6.4\n\tat org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convertLettuceExceptionConverter.java:41 ~spring-data-redis-2.6.4.jar!/:2.6.4\n\tat org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translatePassThroughExceptionTranslationStrategy.java:44 ~spring-data-redis-2.6.4.jar!/:2.6.4\n\tat org.springframework.data.redis.FallbackExceptionTranslationStrategy.translateFallbackExceptionTranslationStrategy.java:42 ~spring-data-redis-2.6.4.jar!/:2.6.4\n\tat org.springframework.data.redis.connection.lettuce.LettuceConnection.convertLettuceAccessExceptionLettuceConnection.java:272 ~spring-data-redis-2.6.4.jar!/:2.6.4\n    이하 생략...\n\n갑자기 잘 작동하던 Redis가 ReadOnly로 변했다는게 이상하여 원인을 찾기 위해 redis-cli를 통해 Redis에 접속한 후 레디스 서버 정보를 보여주는 info 명령어를 치고 로그를 확인하는 중 Replication 섹션에서 role이 slave로 변경된 것을 확인했다.\nconf\n Replication\nrole:slave\nmaster_host:xxx.xxx.xxx.xxx\nmaster_port:xxxx\nmaster_link_status:down\nmaster_last_io_seconds_ago:-1\nmaster_sync_in_progress:0\nmaster_link_down_since_seconds:1341313174\n\n\n그 후 임시 방편으로 redis-cli에서 SLAVEOF NO ONE을 입력하여 redis node를 slave에서 master로 변경하고, application 에서는 더이상 RedisReadOnlyException이 발생하지 않은 것을 확인했다.\n\n 3. 해치웠나?\n정상작동을 확인하고 하루가 지난 후 똑같은 에러가 발생하였다.\n\n그래서 에러가 발생하지 않도록 Redis Replication에 대해 알고자 구글링을 하는 도중 redis.conf에 cluster-enabled 설정을 발견했다.\n\n 3-1. Redis Cluster?\nRedis Cluster는 데이터를 자동으로 여러 개의 Redis 노드에 나누어 저장할 수 있는 방법을 제공한다. 또한 일부 노드가 죽거나 통신이 되지 않을 때에도 작업을 계속할 수 있는 가용성을 제공한다. \n\n하지만 cluster-enabled 속성의 기본값은 no다 즉, 원래 아무 설정도 하지 않으면 단일 노드로 동작해야 한다는 것 이다. 하지만 해당 이슈가 발생하였으므로 ECS환경에서는 다르게 작동한다고 생각이 들었다.\n\n 4. 해결\nredis.conf에 cluster-enabled속성에 no를 설정한 후 image를 만들고 배포하였다. 6월 15일부터 지금까지 정상작동 하고 있다.\n\n redis.conf\nconf\ncluster-enabled no\n\n\n 5. 문제 원인이 뭐였을까?\n아직 redis에 대한 depth가 낮아 원인을 정확하게 모르겠지만, 취업한 친구의 사수님 피셜로 같은 ECS서비스를 사용하면 Redis컨테이너끼리 묶이는 경향이 있다고 한다. 정확한건 나중에 깊게 공부하다 보면 알 수 있겠지...?",
    "tags": [
      "redis",
      "TIL"
    ]
  },
  {
    "title": "POJO(Plain Old JAVA Object)",
    "url": "/programming/2022/06/26/pojoplain-old-java-object/",
    "category": "programming",
    "date": "2022-06-26",
    "excerpt": ": 오래된 방식의 간단한 자바 오브젝트  \n\"특정 <U>'기술'</U>에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말한다.\"\n- 자바 오브젝트 모델, 컨벤션 혹은 프레임워크를 따르지 않는 Java오브젝트를 나타낸다.",
    "content": "POJOPlain Old JAVA Object\n: 오래된 방식의 간단한 자바 오브젝트  \n\"특정 <U>'기술'</U>에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말한다.\"\n- 자바 오브젝트 모델, 컨벤션 혹은 프레임워크를 따르지 않는 Java오브젝트를 나타낸다.\n\n 등장 배경  \n- 특정 기술EJB 등..과 외부 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생긴다.\n- 특정 기술의 클래스를 상속받거나, 특정 기술을 직접 의존하게 되어 확장성이 매우 떨어지는 단점이 있다.\n- 대표적인 객체지향 프로그래밍 언어의 자바가 객체지향 설계의 점들을 잃어버리게 되버린다 \n\n&rarr; 이러한 것들을 보완하기 위해 POJO라는 개념이 나오게 되었다.\n\n 특징\n- 특정 규약에 종속되지 않는다.\n    >객채지향 설계를 할 수 있게된다.\n- 특정 환경에 종속되지 않는다\n    > test코드를 작성하기 좋다.\n\n 정의\nPOJO는 Java 언어 규약에 의해 강제된 것 이외의 제한에 구속되지 않는 Java 오브젝트 이므로   \n\n다음과 같은 클래스는 POJO에 위배된다.\n1. 미리 지정된 클래스를 extends 하는 것\n   java\n   public class Foo extends javax.servlet.http.HttpServlet { ... }\n   \n2. 미리 정의된 인터페이스를 implements 하는 것.\n   java\n   public class Bar implements javax.ejb.EntityBean { ... }\n   \n3. 미리 정의된 Annotation을 포함하는 것.\n   java\n   @javax.persistence.Entity\n   public class Baz { ... }\n   \n\n하지만 기술적인 어려움 및 다른 이유로 인해 여러 프레임워크는 POJO에 규정된 Annotation을 사용하고,  \n그것을 POJO Compliant - POJO를 준수하는 객체 라고 한다.\n\n이는 Annotation을 추가하기 전에 POJO이고 Annotation을 제거했을 때, POJO 상태로 되돌아간다면 POJO라고 할 수 있다.\n> 예시로 Hibernate의 Entity 객체를 들 수 있다.\n\n 대표적인 POJO Framework\nSpring, Hibernate  \n- 위 프레임워크는 객체지향적인 설계를 하고있다. 또한 POJO를 지향한다.\n- 개발자가 서비스 로직에 집중하고 POJO로 쉽게 개발하는것을 지원하고 있다.\n\n POJO를 지키기 위해 개발 하기전 다시한번 생각해보자\n- 자신의 코드에 if/else, switch가 난무하지 않는가?\n- 책임과 역활이 다른 코드가 하나의 클래스에 다 들어가 있지 않은가?\n- 절차지향적으로 한 개 파일에 모든 코드를 넣고 있지 않는가\n- 내가 만든 객체를 재사용 가능한가?\n\n Java Beansjava-beans.md\n- POJO의 변형이라 볼 수 있다.\n- POJO보다 더 세부적인 규약이 정해져 있고 이를 지켜야 한다.\n- Serializable 마커 인터페이스실제 구현이 없고 단순히 확인을 할 수 있는를 implement한다.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Aspect Oriented Programming(관점 지향 프로그래밍)",
    "url": "/back-end/2022/06/05/aspect-oriented-programming관점-지향-프로그래밍/",
    "category": "back-end",
    "date": "2022-06-05",
    "excerpt": ": 애플리케이션에서의 관심사의 분리기능의 분리, 핵심적인 기능에서 부가적인 기능을 분리한다.  \n분리한 부가기능을 라는 독특한 모듈형태로 만들어서 설계하고 개발하는 방법",
    "content": "Aspect Oriented Programming관점 지향 프로그래밍\n 1. 관점 지향 프로그래밍?\n: 애플리케이션에서의 관심사의 분리기능의 분리, 핵심적인 기능에서 부가적인 기능을 분리한다.  \n분리한 부가기능을 Aspect라는 독특한 모듈형태로 만들어서 설계하고 개발하는 방법\n\n 1-1. AOP는 OOP를 보완하는 수단\nAOP는 OOP를 대체하기 위함이 아니라 OOP를 보완하는 수단이다.  \n여러 곳에서 쓰이는 공통 기능을 모듈화하고, 쓰이는 곳에 연결함으로써 유지보수 혹은 재사용에 용의하도록 도와준다.\n\n AOP의 장점\nAOP의 장점은 아래와 같다.\n- 중복되는 코드 제거\n- 효율적인 유지보수\n- 높은 생산성\n- 재활용성 극대화\n- 변화 수용이 용이\n\n\n 2. Spring에서의 AOP\nSpring AOP의 핵심 기능은 Spring Poject가 추구하는 방향인 비 침투적이며 그러므로 핵심기능을 수정하지 않고 공통 기능의 구현을 추가할 수 있다.\n\n핵심 기능에 공통 기능을 추가하는 방법에는 아래와 같이 3가지 방법이 존재한다.\n 공통 기능을 추가하는 방법\n- 컴파일 : 자바 파일을 클래스 파일로 만들 때 바이트코드를 조작하여 적용된 바이트코드를 생성한다.\n- 로드 타임 : 클래스를 로딩하는 시점에 끼워 넣는다.\n- 런타임 : A라는 클래스를 빈으로 만들 때 A라는 타입의 프록시 빈을 감싸서 만든 후에, 프록시 빈이 클래스 중간에 코드를 추가해서 넣는다.\n\n\n 2-1 AOP 주요 개념\n<img src=\"/assets/images/posts/back-end/aop-ex.png\">\n\n- Aspect : 여러 객체에 공통으로 적용되는 기능\n- Target : Aspect에 적용이 되는 대상\n- Advice : 타겟에 제공할 부가기능을 담고 있는 모듈로직\n- Join Point : Advice를 적용가능한 지점 \n- Pointcut : Advice를 적용할 타겟의 메서드를 선별하는 정규표현식이다.\n- Weaving : Advice를 핵심 코드에 적용하는 것을 말합니다.",
    "tags": [
      "spring",
      "spring-triangle",
      "TIL"
    ]
  },
  {
    "title": "PSA - Portable Service Abstraction",
    "url": "/back-end/2022/06/05/psa---portable-service-abstraction/",
    "category": "back-end",
    "date": "2022-06-05",
    "excerpt": "PSA는 에서 적용되는 설계원칙인 에 휴대용 이라는 뜻을 가진 Portable이 붙어진 용어이다. ",
    "content": "PSA - Portable Service Abstraction\nPSA는 서비스 지향 아키텍처 - SOA에서 적용되는 설계원칙인 서비스 추상화 - Service Abstraction에 휴대용 이라는 뜻을 가진 Portable이 붙어진 용어이다. \n\n 1. Service Abstraction - 서비스 추상화\n서비스 추상화를 간략하게 설명하자면, 특정 서비스가 추상화 되었다는 의미는 서비스의 내부 구현내용을 모르더라도 해당 서비스를 이용할 수 있다. \n\n예를 들어 JDBC Driver를 통해 DB에 접근하지만 개발자는 JDBC Driver가 어떻게 구현되어 있는지 알지 않아도 해당 서비스를 사용할 수 있다.\n\n즉 위의 말을 요약하여 정리하면 추상화 계층을 사용하여 어떤 기술을 내부에 숨기고 개발자에게 편의성을 제공해주는 것이라고 할 수 있다.\n\n 2. Portable Service Abstraction\nPortable Service Abstraction은 Service Abstraction에서 한발짝 더 나아가 특정 서비스를 사용하는 비즈니스 로직은 그 특정 서비스의 변경을 수정 없이 할 수 있다.\n\nJDBC를 예로 들면 JDBC는 DB벤더마다 여러개의 Driver를 가질 수 있다. 이런 Driver를 변경하고 싶다면 Driver만 병경하면 되고 JDBC를 사용하는 비즈니스 로직은 수정되지 않는다.\n\n즉, 하나의 추상화로 여러 서비스ex. JDBC Driver를 묶어둔 것을 PSA이다.\n\n스프링에서의 추상화된 트랜잭션 관리를 제공한다. 이는 PSA가 활용된 것이다.\n\n 1. PSA 예시\n- Spring Transactional\n- Spring Cache\n- Spring MVC\n\n Reference\n1. 백기선 - 스프링 제대로 공부했는지 5분안에 확인하는 방법https://www.youtube.com/watch?v=bJfbPWEMj_c&t=308s\n2. 백기선 - 예제로 배우는 스프링 입문, 12 스프링 PSAhttps://www.youtube.com/watch?v=P3vzrqADl8I\n3. https://en.wikipedia.org/wiki/Service_abstraction",
    "tags": [
      "spring",
      "spring-triangle",
      "TIL"
    ]
  },
  {
    "title": "IoC(Inversion Of Control) - 제어의 역전",
    "url": "/back-end/2022/06/05/iocinversion-of-control---제어의-역전/",
    "category": "back-end",
    "date": "2022-06-05",
    "excerpt": ": 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다.\n- 컴포넌트 의존관계 결정 Component dependency resolution, 설정configuration 및 생명주기lifecycle를 해결하기 위한 디자인 패턴Design Pattern\n>어떤 객체가 사용할 객체의존관계인 객체를 직접 선언하여 사용하는 것이...",
    "content": "IoCInversion Of Control - 제어의 역전\n: 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다.\n- 컴포넌트 의존관계 결정 Component dependency resolution, 설정configuration 및 생명주기lifecycle를 해결하기 위한 디자인 패턴Design Pattern\n>어떤 객체가 사용할 객체의존관계인 객체를 직접 선언하여 사용하는 것이 아니라,  \n>어떤 방법을 사용하여ex.생성자 등..사용하여 주입 받아 사용것 을 IoC의 일부라고 표현 할 수 있다.\n\n일번적인 제어권: 자기가 사용할 의존성은 자기가 만들어서 사용\njava\n@Service\npublic class CarService {\n\tprivate CarRepository carRepository = new CarRepository;\n}\n\n\n IoC 분류\n DL - Dependency Lookup\n: 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lookup하는 것 이다.\n\n DI - Dependency Injection\n: 각 클래스간의 의존관계를 빈 설정Bean Definition정보를 바탕으로 컨테이너가 자동으로 연결해 주는 것 이다.\n\nDI의 분류\n- Setter Injection\n- Constructor Injection\n- Method Injection  \n\n<img width=500px src=./img/DI-DL.png>\n\n Dependency Injection를 통한 IoC\njava\n@Service\npublic class CarService {\n\t\n    // CarRepository를 사용은 하지만 만들지는 않는다.\n\tprivate CarRepository carRepository;\n    /\n    생성자를 통해서 받아온다.\n    따라서 의존성을 관리하는 일은 CarService가 하는 일이아니다. 누군가 밖에서 해주는 것이다.\n    /\n    //생성자를 통한 의존성 주입 \n    public CarServiceCarRepository carRepository{\n    \tthis.carRepository = carRepository;\n    }\n}\n\n \"DI는 IoC를 구현하는 방법의 한 종류\"\n게임을 예시로 들어보자\n1. 플레이어가 게임 캐릭터를 조종한다.\n2. 게임 캐릭터가 해야 할 일퀘스트 등..을 플레이어가 직접적으로 관여해 조종한다.\n3. 게임 캐릭터의 제어권은 플레이어외부에게 넘어감 -> 제어권이 위임되었다 -> 제어의 역전IoC\n\n IoC Container\n: Spring Framework는 객체에 대한 생성 및 생명주기를 관리 할 수 있는 기능을 제공한다.\n- 객체의 생성을 책임지고, 의존성을 관리\n- POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다\n- 객체 생성에 대한 제어권을 IoC Container에 넘긴다.\n\n 구성요소\n\n 1. BeanFactory\n- Bean 등록, 생성, 조회, 반환 관리\n- IoC Container의 최상단에 interface로 존재한다.\n- 보통 BeanFactory를 바로 사용하지 않고, 이를 확장한 ApplicationContext를 사용한다.\n\n 2. ApplicationContext\n- BeanFactory와 Bean을 등록, 생성, 조회, 반환 을 관리하는 기능은 같다.\n- BeanFactory의 서브 인터페이스인 ListableBeanFactory, HierachicalBeanFactory라는 인터페이스를 상속하여 BeanFactory를 상속하고 있다.\n- Spring의 각종 부가 서비스를 추가로 제공한다.  \n    - ResourceLoaderAware의 ResourceLoader 편리한 리소스 조회\n        > 로컬, 개발, 운영등을 구분해서 \n    - ApplicationEventPublisherAware의 ApllicationEventPublicher 이벤트발행/구독 모델 지원\n    - MessageSourceAware의 MessageSource 메시지소스를 활용한 국제화i18n 기능\n    - ApllicatonContextAware의 ApllicationContext\n    - EnviornmentCapable 환경변수\n        > 로컬 개발, 운영등을 구분해서 처리 Profile\n- Spring이 제공하는 ApplicationContext 구현 클래스가 여러 종류가 있다.\n\n IoC의 핵심은?\n개발자가 Bean을 직접 만들지 않고 xml, annotation과 같은 메타데이터를 제공하면 프로그램Spring framework이 해당 메타데이터를 사용해 Bean객체를 제어한다.  \n\n즉, IoC Container는 Spring Framework이라고 할 수 있고, 이는 Spring Framwork를 사용하는 이유이자 핵심 \\기능이다.",
    "tags": [
      "spring",
      "spring-triangle",
      "TIL"
    ]
  },
  {
    "title": "Bean Validator에서 검증에 실패한 필드를 클라이언트에게 알려주자!",
    "url": "/back-end/2022/06/04/bean-validator에서-검증에-실패한-필드를-클라이언트에게-알려주자/",
    "category": "back-end",
    "date": "2022-06-04",
    "excerpt": "Spring boot에서 Bean Validator는 가 달린 인수에 대해 검증이 실패하게 된다면 를 던지게 된다.  \n이를 이용해 클라이언트가 보낸 잘못된 데이터를 다음과 같이 예쁜? Json 메세지로 반환해보자",
    "content": "Bean Validator에서 검증에 실패한 필드를 클라이언트에게 알려주자!\nSpring boot에서 Bean Validator는 @Valid가 달린 인수에 대해 검증이 실패하게 된다면 MethodArgumentNotValidException를 던지게 된다.  \n이를 이용해 클라이언트가 보낸 잘못된 데이터를 다음과 같이 예쁜? Json 메세지로 반환해보자\njson\n{\n    \"message\": \"'name':'공백일 수 없습니다.', 'homepageUri':'올바른 URL이어야 합니다.'\"\n}\n\n\n\n 1. MethodArgumentNotValidException\nMethodArgumentNotValidException공식문서https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/MethodArgumentNotValidException.html는 내부적으로 BindException를 상속받고 있고 BindException는 BindingResult객체를 맴버 변수로 가지고 있다.  \nBindingResult는 에러가 발생한 필드에 대한 정보를 담고있는 FelidError를 List형태로 여러개 가지고 있고,  \nFelidError속에는 검증이 실패한 필드이름FelidError.field과, 이에 대한 기본메세지FelidError.defaultMessage 정보가 담겨있다. 이를 이용해 간단하게 ExceptionHandler를 만들어보자.\n\n 2. @RestControllerAdvice를 통한 예외처리\n나는 다음과 같이 로직을 작성했다.\nkotlin\n@RestControllerAdvice\nclass GlobalExceptionHandler{\n\n    @ExceptionHandlerMethodArgumentNotValidException::class\n    private fun validationExceptionex: MethodArgumentNotValidException: ResponseEntity<ExceptionResponseEntity>{\n        val bindingResult: BindingResult = ex.bindingResult\n\n        val errorResult = StringBuilder\n        for fieldError in bindingResult.fieldErrors {\n            /\n              유효성검사에 통과하지 못한 field name\n             /\n            val fieldErrorName = fieldError.field\n\n            /\n              유효성 검사에 통과하지 못한 field에 대한 기본 메세지\n             /\n            val errorMessage = fieldError.defaultMessage\n\n            errorResult.append\"'$fieldErrorName'\".append\":\"\n            errorResult.append\"'${errorMessage}.'\"\n            errorResult.append\", \"\n        }\n        errorResult.deleteerrorResult.lastIndexOf\", \", errorResult.lastIndex + 1 // 마지막 리스트일 경우  \", \" 문자열을 제거한다.\n\n        return ResponseEntity.statusHttpStatus.BAD_REQUEST.value\n            .bodyExceptionResponseEntityerrorResult.toString\n    }\n}\n\nbindingResult.fieldErrors를 순회한다. for문을 통해 클라이언트에 반환할 메세지를 만들것이기 떄문에 errorResult변수에 StringBuilder객체를 생성했다.\n\n검증에 실패한 필드의 이름과 에러 메시지를 가져오고 이를 맨 처음에 보여줬던 json파일의 message값처럼 문자열을 생성한다. ExceptionResponseEntity는 String필드 1개만 가지고 있는 객체이다.",
    "tags": [
      "spring-mvc",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Gradle에서 jar file의 이름을 변경하는 방법",
    "url": "/back-end/2022/06/04/gradle에서-jar-file의-이름을-변경하는-방법/",
    "category": "back-end",
    "date": "2022-06-04",
    "excerpt": "일반적으로 gradle에서 jar파일을 얻으려면 명령어를 사용하게 된다. 그러면 프로젝트 루트를 기준으로  하위에 jar파일이 생성된다.  ",
    "content": "Gradle에서 jar file의 이름을 변경하는 방법\n일반적으로 gradle에서 jar파일을 얻으려면 gradle build명령어를 사용하게 된다. 그러면 프로젝트 루트를 기준으로 /build/lib 하위에 jar파일이 생성된다.  \n\n그러면 jar 파일은 {artifactId}-{version}.jar형식으로 생성되는데 이 점을 이용하여 build된 jar 파일의 이름을 변경할 수 있다.\n\n build.gradle\n만약 jar file를 siwony-1.0.jar로 생성하고 싶다면 다음과 같이 build.gradle를 수정하면 된다.\nkotlin\nversion = '1.0'\nbase.archivesName.set\"siwony\"\n\n그러면 build 후 siwony-1.0.jar파일이 생성되는 것을 확인할 수 있다.\n\nbase.archivesName.set\"siwony\"는 base.archivesBaseName = \"siwony\"로 사용할 수 있지만 해당 방법은 gradle 8에서 Deprecate될 예정이라 권장하지 않는다.",
    "tags": [
      "TIL",
      "gradle",
      "build-tool"
    ]
  },
  {
    "title": "try-with-resource 구문과 use함수",
    "url": "/programming/2022/05/16/try-with-resource-구문과-use함수/",
    "category": "programming",
    "date": "2022-05-16",
    "excerpt": "Java에서는 자원을 close를 해야 할 떄 ../java/grammar/try-with-resources.md문으로 자원이 일을 한 후 자동으로 를 호출해주는 구문이 있다.",
    "content": "try-with-resource 구문과 use함수\nJava에서는 자원을 close를 해야 할 떄 try-with-resources../java/grammar/try-with-resources.md문으로 자원이 일을 한 후 자동으로 close를 호출해주는 구문이 있다.\n\njava\n... 생략\nprivate boolean isRunningProcess process throw Exception {\n    String line;\n    StringBuilder pidInfo = new StringBuilder;\n\n    try BufferedReader input = new BufferedReadernew InputStreamReaderprocess.getInputStream {\n        while line = input.readLine != null {\n            pidInfo.appendline;\n        }\n    } \n    return !StringUtils.isEmptypidInfo.toString;\n}\n\n\n그렇다면 이를 어떻게 kotlin으로 사용할 수 있을까? 바로 표준 함수인 use함수를 이용해 가능하다.\nkotlin\nprivate fun isRunningprocess: Process: Boolean {\n    var line: String?\n    val pidInfo = StringBuilder\n    BufferedReaderInputStreamReaderprocess.inputStream.use { input ->\n        while input.readLine.also { line = it } != null {\n            pidInfo.appendline\n            return pidInfo.isNotEmpty // 여기서도 가능하다!\n        }\n        // return pidInfo.isNotEmpty \n    }\n}\n\n여기서 주의해야 하는점은 \"람다 본문에서 사용한 return은 비지역 반환\"이다. 즉, return문은 람다가 아닌 isRunning함수를 끝내며 값을 반환한다.\n\n 좀 더 자세히\nuse함수는 kotlin.io패키지에서 확인할 수 있다.\nkotlin\ninline fun <T : Closeable?, R> T.useblock: T -> R: R\n\nuse함수의 body를 보면  Closeable를 상속한 클레스에서만 사용할 수 있고, 함수 시그니처의 block은 24 ~ 30줄에 작성한 람다를 의미한다.\n\n> 코드: https://github.com/JetBrains/kotlin/blob/6a670dc5f38fc73eb01d754d8f7c158ae0176ceb/libraries/stdlib/jvm/src/kotlin/io/Closeable.ktL22\n\n Reference\nhttps://shinjekim.github.io/kotlin/2019/11/01/Kotlin-%EC%9E%90%EB%B0%94%EC%9D%98-try-with-resource-%EA%B5%AC%EB%AC%B8%EA%B3%BC-%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-use-%ED%95%A8%EC%88%98/",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "엘비스 연산자 - Elvis Operation",
    "url": "/programming/2022/05/13/엘비스-연산자---elvis-operation/",
    "category": "programming",
    "date": "2022-05-13",
    "excerpt": "- 엘비스 연산자는 로 표현된다.\n- 왼쪽 객체가 non-null이면 그 객체의 값으 리턴되고, null이면 ?:의 오른쪽 값을 리턴한다.",
    "content": "엘비스 연산자 - Elvis Operation\n- 엘비스 연산자는 ?:로 표현된다.\n- 왼쪽 객체가 non-null이면 그 객체의 값으 리턴되고, null이면 ?:의 오른쪽 값을 리턴한다.\n\n if-else 예제\nif-else를 사용하여 문자열의 길이를 구하는 메서드를 구현하는 예제이다.\nkotlin\nfun mainargs: Array<String>{\n    val str: String? = \"1234\"\n    val nullStr: String? = null\n\n    printlngetStrLengthstr // 4출력\n    printlngetStrLengthnullStr // -1 출력\n    \n}\nfun getStrLengthstr: String?: Int{\n    return ifstr != null str.length else -1\n}\n\n\n이 코드를 엘비스 연산자를 이용하여 구현한다면 다음과 같다.\nkotlin\nfun mainargs: Array<String>{\n    val str: String? = \"1234\"\n    val nullStr: String? = null\n\n    printlngetStrLengthstr // 4출력\n    printlngetStrLengthnullStr // -1 출력\n    \n}\nfun getStrLengthstr: String?: Int{\n    return str?.length ?: -1\n}\n\n\n Throw Exception 예제\nException이 발생되도록 할 수 있다.\nkotlin\nfun findMemberByIdxmemberIdx: Long : MemberEntity{\n    return memberRepository.findByIdOrNullmemberIdx ?: throw IllegalStateException\"존재하지 않는 회원입니다.\"\n}\n\n\n\n Reference\nhttps://codechacha.com/ko/kotlin-elvis-operation/",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "가변인수 - varages",
    "url": "/programming/2022/05/02/가변인수---varages/",
    "category": "programming",
    "date": "2022-05-02",
    "excerpt": "// todo heap pollution",
    "content": "가변인수 - varages\n// todo heap pollution\n\n- Java5에서 추가되었다.\n- 한 매서드에 하나만 사용할 수 있고 인수들의 맨 마지막에 위치해야 한다.\n  > 가변 인수가 여러개 필요하다면 빌더를 통해 가변인수를 사용한다.\n\njava\npublic class A{\n    \n    public int addAllNumsint... numbers{\n        return Arrays.streamnumbers.sum;\n    }\n}",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "인스턴스화를 막는 방법",
    "url": "/programming/2022/05/02/인스턴스화를-막는-방법/",
    "category": "programming",
    "date": "2022-05-02",
    "excerpt": "객체지향에서 객체를 만드는 인스턴스화를 막는다니 이게 뭔소리인가 싶지만, 주로 유틸리티성 클래스같이 정적 메소드로만 이루어져 있는 클래스들은 객체를 생성할 필요가 없다.  ",
    "content": "인스턴스화를 막는 방법\n객체지향에서 객체를 만드는 인스턴스화를 막는다니 이게 뭔소리인가 싶지만, 주로 유틸리티성 클래스같이 정적 메소드로만 이루어져 있는 클래스들은 객체를 생성할 필요가 없다.  \n\n객체를 생성할 필요가 없으므로 불필요한 인스턴스화를 막기위한 방법에 대해 적어보려고 한다.\n\n private생성자를 활용하자\njava\npublic class HelloUtil{\n    private HelloUtil{\n\n    }\n\n    public static String hello{\n        return \"hello\";\n    }\n}\n\n\n이렇게 기본 생성자의 접근지정자를 private으로 막아두면 외부에서 객체를 생성하지 못한다. 하지만, 여전히 내부에서는 생성할 수 있다.  \n\n구지 이것을 막고싶다면, AssertionError를 던지자 \njava\npublic class HelloUtil{\n\n    /\n      이 클래스는 인스턴스를 만들 수 없다.\n    /\n    private HelloUtil{\n        throw new AssertionError;\n    }\n\n    public static String hello{\n        return \"hello\";\n    }\n}\n\n이런식으로 내부에서 객체를 생성하려 시도하면 Error가 발생하여 객체가 생성되지 않는다.\n\n AssertionError\n해당 객체는 error이기 때문에 try~catch로 막지 말자.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Keyword",
    "url": "/programming/2022/04/29/keyword/",
    "category": "programming",
    "date": "2022-04-29",
    "excerpt": "식별자로 사용할 수 없는 키워드를 의미한다.",
    "content": "Keyword\n 1. Hard Keywords\n식별자로 사용할 수 없는 키워드를 의미한다.\n\n 1-1. as\nas키워드는 타입 캐스팅과 별칭 기능의 두 가지 역할을 한다.\n\n 타입 캐스팅\nkotlin\nval x: String = y as String\n\n위 코드는 y를 String으로 캐스팅하여 x에 대입하는 코드이다.  \n컴파일 오류는 발생하지 않지만, 런타임 시 캐스팅이 불가능한 타입일 경우 Exception이 발생한다.\n&rarr; 이를 Unsafe 캐스팅이라고 한다.\n\nkotlin\nval x: String? = y as String?\n\nNullable 한 값을 캐스팅 해야 하는 경우 ?연산자를 이용하여 y가 null일 경우 캐스팅을 하지 않고 x에 null를 대입하게 된다.\n\nas를 통한 타입 캐스팅은 런타임시에 캐스팅이 실패 할 경우 Exception이 발생하는데 Exception이 발생하지 않고, null를 대압하고 싶다면 as?키워드를 사용할 수 있다.\nkotlin\nval x: String? = y as? String\n\n물론 null를 허용해야 하므로 타입뒤에 ?를 사용해야 한다.\n\n alias\nas는 import 구문에서 alias의 역할을 맡고있다.\n\n예시로 Animal.Info와 Human.Info 클래스를 import 한다고 하면, 둘다 동일한 Info라는 이름을 가지기 때문에 충돌이 일어난다.\n자바는 이럴 경우 해당 클래스를 접근 할 때 한쪽클래스는 패키지명까지 모두 작성해야 한다.\n\n하지만 코틀린에서는 as키워드를 사용해 alias를 지정할 수 있다.\nkotlin\nimport Animal.Info\nimport Human.Info as humnInfo\n\n\n 1-2. fun\n함수임을 나타내는 키워드다.\n\nkotlin\nfun 함수명args...: 반환타입{\n    ...\n}\n\n//예시\nfun adda:Int, b:Int: Int{\n    return a + b;\n}\n\n\n 1-3. in\nfor loop, range expressions, when expressions, generic 등에 쓰일 수 있다.\n\n for loop\nkotlin\nval items: Array<Int> = arrayOf1, 2, 3\nfor i: Int in items\n    println\"i = \" + i  \n\nJava의 for eachenhanced for loop와 동일하게 동작하며 1, 2, 3를 출력한다.\n\n range expressions\nin 키워드는 다음과 같이 조건식으로도 사용이 가능하다. \nkotlin\nval items: Array<Int> = arrayOf1, 2, 3\nval hasOne: Boolean = 1 in items\nprintlnhsaOne\n\n> true 출력\n\nJava에서 Collection에 있는 원소를 찾으려면 items.contains1와 같이 contains연산을 해야 한다.\n\n when expressions\nJava의 switch처럼 동작한다.\n\nkotlin\nwhena {\n    a in 1..10 -> println\"a is in 1 ~ 10\"\n}\n\n\n generic\n제네릭에서 in연산을 통해 반공변성을 사용할 수 있지만 길어지므로 다른 글에 적도록 하겠다.\n\n !in\nin 앞에 부정연산자를 붙은 키워드이고 in의 반대를 나타낸다.  \nrange expressions, when expressions와 같은 조건식에서만 사용할 수 있다.\n\n 1-4. is\n타입캐스팅과 관련된 키워드이다.\n\nJava에서는 타입캐스팅과 관련된 코드를 작성하려면 아래와 같이 Boilerplate한 code를 작성할 수 밖에 없다.\njava\nObject hello = \"hello\";\nifhello instanceof String\n    System.out.printlnStringhello.length;\n\n\n하지만 Kotlin은 컴파일러가 is로 체크하는 부분을 추적하여 자동으로 캐스팅해준다.\n> 이를 Smart Cast라고 한다.\nkotlin\nAny hello = \"hello\";\nifhello is String\n    System.out.printlnhello.length;\n\n\n when expression\nis 키워드는 when expression에서 사용할 때 가장 강력한 기능인 거 같다.\nkotlin\nwhen a {\n    is Int -> printa\n    is String -> printa.length\n    is IntArray -> printx.size\n}\n\n\n !is\n- is에 부정연산자 !가 붙은 연산자이다.\n- in, !in과 같이 반대의 관계이다.\n- is연산자가 사용되는 모든 곳에 사용할 수 있다.\n\n 1-5. this\n// TODO implicit label에 대해 공부하기 및 extendsion function에 대해 공부하기  \n공식홈페이지의 코드가 너무 어렵다 공부하고 적어야겠다.\n\n 1-6. throw\njava와 같이 Exception을 발생시키는 키워드이다.\n\n추가적으로 Kotlin은 Java와 다르게 CheckedException의 예외 처리를 강제하지 않는다.\n\n 1-7. type aliases\n말 그대로 타입에 별칭을 줄 수 있다.\n\n- generic, function, class 등 여러곳에 사용할 수 있다.\n- class, method 블럭 외부에 선언해야 한다.\n\nkotlin\ntypealias FileTable<K> = MutableMap<K, MutableList<File>>\ntypealias NodeSet = Set<Network.Node>\n\nfun main {\n    var fileTable: FileTable<Int> = HashMap\n    var nodeSet: NodeSet = HashSet\n}\n\n이와 같이 generic선언이 긴 경우 커스텀한 타입으로 선언 할 수 있고\n\n함수도 Java의 functional interface와 비슷하게 커스텀한 타입으로 선언할 수 있다.\nkotlin\ntypealias MyHandler = Int, String, Any -> Unit\ntypealias Predicate<T> = T -> Boolean\n\nfun functionhandler: MyHandler, predicate: Predicate<Int> {\n    handler.invoke10, \"20\", 30\n    ifpredicate.invoke10\n        println\"predicate is true\";\n}\n\nfun main {\n    function\n        {a, b, c -> println\"$a $b $c\"},\n        {a -> a == 10}\n    \n}\n\n출력결과\n\n10 20 30\npredicate is true\n\n\n클래스도 커스텀한 별명을 만들어낼 수 있다.\nkotlin\nclass A {\n    class Inner\n}\n\ntypealias AInner =  A.Inner\ntypealias Password = String\ntypealias Username = String\n\nfun main {\n    val node: AInner = AInner\n    val userPassword : Password = \"password\"\n    val username: Username = \"siwony\"\n}\n\n\n 1-8. val, var\n- val은 immutable한 값을 갖는다. java에서 final 키워드와 같다.\n- var은 mutable한 값을 갖는다. 즉 값이 변할 수 있다.\n\n 1-9. when expression\nwhen expression은 Java의 switch와 비슷하다.\n\n\njava\nswitch x {\n    case 1 : \n        System.out.println\"1\";\n        break;\n    \n    case 2 : \n        System.out.println\"2\";\n        break;\n    \n    default : \n        System.out.println\"not found\";\n        System.out.println\"go back!\";\n}\n\n이 코드는 충분히 볼만하지만 만약 개발중에 break를 빼먹게 된다면 프로그램의 정합성을 해치게 된다.\n그리고 여러 사람들이 느끼기에는 default가 의미적으로 안맞다고 하는 사람도 있다.\n\n반면 코틀린 코드를 보면\nkotlin\nwhen x {\n  1 -> println\"1\"\n  2 -> println\"2\"\n  else -> {\n        println\"not found\"\n        println\"go back!\"\n    }\n}\n\nbreak를 신경쓰지 않아도 되고 if else조건식을 사용하는 느낌을 준다.\n\n그럼 만약 여러 케이스에 대해 동일하게 처리해야 하면 어떻게 해야 할까?\nkotlin\nwhen x {\n  1, 2, 3, 4 -> println\"1 or 2 or 3 or 4\"\n  5 -> println\"2\"\n  else -> {\n        println\"not found\"\n        println\"go back!\"\n    }\n}\n\n그냥 한줄에 콤마,로 구분하여 적을 수 있다!\n\n Reference\n- https://medium.com/@joongwon/kotlin-kotlin-키워드-및-연산자-해부-1-hard-keywords-3062f5fe2d11",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Kotlin",
    "url": "/programming/2022/04/29/kotlin/",
    "category": "programming",
    "date": "2022-04-29",
    "excerpt": "- JetBrains에서 2011년에 공개한 오픈 소스 프로그래밍 언어\n- Java에 비해 상당히 간결한 문법을 가지고 있다.\n  > 근데 뭔가 많이 간결해서 Java 쓰다가 Kotlin 쓰면 헷깔린다.\n- Java와의 상호 운용이 100% 지원된다.\n  > 하지만 Runtime 시점에 사용되지 않는 Lombok 의 경우 100% 호환이 안된다.Kotlin...",
    "content": "Kotlin\n- JetBrains에서 2011년에 공개한 오픈 소스 프로그래밍 언어\n- Java에 비해 상당히 간결한 문법을 가지고 있다.\n  > 근데 뭔가 많이 간결해서 Java 쓰다가 Kotlin 쓰면 헷깔린다.\n- Java와의 상호 운용이 100% 지원된다.\n  > 하지만 Runtime 시점에 사용되지 않는 Lombok 의 경우 100% 호환이 안된다.Kotlin 1.5.20 에 실험적으로 지원한다.\n\n\n Hello World출력\nkotlin\nfun mainargs: Array<String> {\n    println\"Hello World!\" // 출력: Hello World\n}\n\n1. Java와 다르게 class선언을 하지 않고 main 메서드로 바로 코드를 실행할 수 있다.\n    java\n    public class Main{\n        public static void mainString argv{\n            System.out.println\"Hello World!\";\n        }\n    }\n    \n2. kotlin은 세미클론;을 붙이지 않아도 된다.\n   > ex println\"Hello, World!\"\n\n kotlin 문법 정리\n1. 변수variable.md\n2. class",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Kotlin의 변수",
    "url": "/programming/2022/04/29/kotlin의-변수/",
    "category": "programming",
    "date": "2022-04-29",
    "excerpt": "- 와 이라는 키워드로 변수를 만든다.\n- 과 이 존재한다.\n  >  키워드로 null을 허용할 것인지 말 것인지 결정한다.\n- 변수의 타입을 명시하지 않고도 타입추론이 가능하다.",
    "content": "Kotlin의 변수\n 이글의 예제 코드는 Main 함수에서 진행되었으며, Main함수를 생략했습니다.\n 특징\n- var와 val이라는 키워드로 변수를 만든다.\n- Non-null과 Nullable이 존재한다.\n  > ? 키워드로 null을 허용할 것인지 말 것인지 결정한다.\n- 변수의 타입을 명시하지 않고도 타입추론이 가능하다.\n\n 변수의 선언\nKotlin의 변수 선언은 다음과 같다.\nKotlin\nvar 변수명: 변수타입 = 초기화값\nex var siwony: String = \"siwony\"\n\nval 변수명: 변수타입 = 초기화값\nex val siwony: String = \"siwony\"\n\n여기서 var과 val를 제외하고는 Java와 별반차이가 없다.\n\n Java의 경우 예시\njava\nString siwony = \"siwony\";\n\n\n도대체 val과 var의 차이가 무엇일까?\n\n val과 var의 차이\n val\n- val은 valuable이다.\n- 읽기만 가능하다. &rarr; 불변 변수이다.\n- Java로 따지만 final 키워드를 붙인 변수라고 생각하면 된다.\n\n예시\nkotlin\nval siwony: String = \"siwony\"\nsiwony = \"si_wony\" // val은 불변변수 이므로 컴파일 에러가 발생한다.\nprintlnsiwony //print변수 콘솔의 특정 값을 출력할 수 있는 함수\n\n- 위 코드는 콘솔의 \"si_sowny\"를 출력하기 전에 Val cannot be reassigned 에러를 발생시킨다.\n\n var\n- var는 variable이다.\n- 읽기/쓰기 쓰기가 가능한 변수다.\n\n예시\nkotlin\nval siwony: String = \"siwony\"\nsiwony = \"si_wony\"\nprintlnsiwony // siwony가 아닌 si_wony가 출력된다.\n\n- 정상적으로 siwony 변수의 값이 \"si_wony\"로 변경 되어 출력된다.\n\n Non-null 과 Nullable\n> Kotlin은 Non-null타입과 Nullable타입을 가지고 있다.\n\n Non-null\n: 변수가 null을 가질 수 없는 타입이다.\n\n예제\nkotlin\nvar siwony : String = null // 컴파일 에러가 발생한다.\n\n- siwony 변수는 null을 허용하지 않아 Null can not be a value of a non-null type String 에러를 발생시킨다.\n\n Nullable\n: 변수가 null을 가질 수 있는 타입이다.\nkotlin\nvar siwony : String? = null\n// \nprintlnsiwony // 출력: null\n\n- 성공적으로 siwony 변수에 null이 들어갔다.\n- null을 출력했다.\n\n 변수의 타입 추론\n코틀린은 컴파일 시점에 타입을 결정하는 정적 타입 언어이다. 즉, 컴파일과 동시에 타입이 결정된다.\n\n 타입 추론의 예시\nkotlin\nvar siwony = \"siwony\" // String 타입으로 추론이 됌\nprintlnsiwony // 출력: siwony\n\nvar age = 12 // Int 타입으로 추론이 됌\nprintlnage // 출력: 12\n\nvar height = 174.3 // Double 타입으로 추론이 됌\nprintlnheight 출력: 174.3\n\n\n 타입 추론의 잘못된 예시\nkotlin\nvar siwony = \"siwony\"\nsiwony = 17 // String 타입에 Int타입의 값을 대입했으므로 컴파일 에러\n\n- The integer literal does not conform to the expected type String 에러가 나왔다.\n 결론은 컴파일 시점에 타입을 결정하는 정적 타입 언어이므로 타입을 자유자재로 변경할 수 없다.",
    "tags": [
      "kotlin",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "직렬화 - Serializable",
    "url": "/programming/2022/04/26/직렬화---serializable/",
    "category": "programming",
    "date": "2022-04-26",
    "excerpt": "> Java Object Serialization Spechttps://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html",
    "content": "직렬화 - Serializable\n> Java Object Serialization Spechttps://docs.oracle.com/javase/8/docs/platform/serialization/spec/serialTOC.html\n\n직렬화의 정의는 여기../../cs/data-serialization.md를 참고해주길 바란다.\n\n자바에서의 직렬화는 다음과 같이 Serializablehttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/Serializable.html 인터페이스를 구현하게 된다. \n\njava\npublic class Animal implements Serializable{\n    ...\n}\n\n\n 대표적인 Serializable 구현체\n- Vector\n- HashMap\n- ArrayList\n- JPA 표준 스펙의 Entity\n\n 1. 직렬화가 가능한 객체의 조건\n1. 기본형 타입 - Primitive Type\n2. Serializable 인터페이스를 구현한 객체\n3. 직렬화를 진행할 객체의 맴버중에 Serializable 인터페이스가 구현되지 않으면 안된다.\n4. serialVersionUID가 같은 객체만 가능하다.\n   > 클래스가 변경되어도 역직렬화를 하고 싶다면 serialVersionUID를 임의로 지정해줘야 한다.\n\n추가적으로 transient 키워드가 사용된 맴버는 직렬화 되지 않고 null로 표현된다.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "향상된 for 루프 - Enhanced for loop",
    "url": "/programming/2022/04/20/향상된-for-루프---enhanced-for-loop/",
    "category": "programming",
    "date": "2022-04-20",
    "excerpt": "- 주로 for each한다.\n- JDK5부터 추가되었다.\n- 배열 뿐만 아니라 를 구현한 클래스에 사용할 수 있다.",
    "content": "향상된 for 루프 - Enhanced for loop\n- 주로 for each한다.\n- JDK5부터 추가되었다.\n- 배열 뿐만 아니라 Iterable를 구현한 클래스에 사용할 수 있다.",
    "tags": [
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "리스트 순회중 만난 ConcurrentModificationException",
    "url": "/programming/2022/04/20/리스트-순회중-만난-concurrentmodificationexception/",
    "category": "programming",
    "date": "2022-04-20",
    "excerpt": "알고리즘을 풀다가 리스트를 를 통해 순회하며  연산을 해야 하는 상황이 있었다. 필자는 아무렇지 않게 순회중  연산을 하게 되었는데 가 발생하였다.",
    "content": "리스트 순회중 만난 ConcurrentModificationException\n 1. 문제의 발생과 배경\n알고리즘을 풀다가 리스트를 enhanced for loopfor each를 통해 순회하며  List.remove연산을 해야 하는 상황이 있었다. 필자는 아무렇지 않게 순회중 List.remove 연산을 하게 되었는데 ConcurrentModificationException가 발생하였다.\n\n처음에는 ConcurrentModificationException라는 이름을 보고 동시성 관련 예외라고 잠깐 생각했지만 싱글스레드 환경에서 발생했으므로 다른 원인이 있다는 것을 짐작하여 구글링을 하게 되었다.\n그리고 나중에 이러한 일을 겪지 않으려 이 글을 작성한다.\n\nConcurrentModificationException이 발생한 코드의 예시는 다음과 같다.\njava\nprivate static boolean solutionString phone_book {\n    final LinkedList<String> phone_books = Arrays.streamphone_book\n            .collectLinkedList::new, LinkedList::add, LinkedList::addAll;\n    ...\n\n    for String s : phone_books {  // 이 부분!\n        ...\n        phone_books.removes;\n        ...\n    }\n}\n\n\n ConcurrentModificationException란?\nConcurrentModificationException의 공식문서https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ConcurrentModificationException.html를 살펴보면 첫번째 문단에 다음과 같이 나와있다.\n\n> This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.\n\n이 문장을 번역해보면  \n\"이 예외는 객체의 동시 수정이 허용되지 않는경우 동시 수정을 감지한 메서드에서 thorw될 수 있다.\" 즉, 동시성 관련하여 예외가 발생할 수 있다. 하지만, 3번째 문단은 다음과 같이 나와있다.\n\n> Note that this exception does not always indicate that an object has been concurrently modified by a different thread. If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception. For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception.\n\n대충 번역을 해보면 \"이 예외는 항상 다른 스레드에 의해 동시에 수정됨을 나타내는 것이 아니고, 단일 스레드가 객체의 계약을 위반하는 메서드 호출 시퀀스를 실행하는 경우 발생할 수 있다. 예를 들어 fail-fast iterator로 컬렉션을 반복하는 동안 컬렉션을 수정하는 경우 iterator는 이 예외를 thorw한다.\"\n\n위에서 1. 문제의 발생과 배경1-문제의-발생과-배경부분에 첨부한 코드를 다시한번 살펴보면 Linked List가 enhanced for loop를 통해 순회하며 List.remove를 한 부분에서 ConcurrentModificationException이 발생했다. \n\n이정도까지 왔으면 짐작이 될 것이다. LinkedList는 fail-fast Iterator를 사용한다.\n\nLinkedList의 공식 문서https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html를 살펴보면 4문단에 다음과 같이 나와있다.\n> The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.\n\n볼드 처리한 부분만 해석하면 해당 문제 \"이 클래스의 iterator와 listIterator 메서드는 fail-fast이고, 구조적으로 수정되는 경우 반복자의 자체 제거 또는 추가 메서드를 통하지 않는 경우를 제외하고 반복자는 ConcurrentModificationException을 throw합니다.\"\n\n 해결방법\n\n 1. List.remove가 아닌 Iterator.remove를 사용한다.\nList.remove가 아닌 Iterator를 삭제하는 방법인 iterator.remove를 사용하면 된다.\n\njava\nprivate static boolean solutionString phone_book {\n    final LinkedList<String> phone_books = Arrays.streamphone_book\n            .collectLinkedList::new, LinkedList::add, LinkedList::addAll;\n    ...\n\n    Iterator<String> iterator = phone_books.iterator\n    whileiterator.hasNext{\n        ...\n        iterator.remove;\n        ...\n    }\n}\n\n이 방법은 스레드 환경에 안전하지 않다.  \n하지만 필자는 싱글스레드 환경인 알고리즘 풀이에서 발생한 예외라 이렇게 해결했다.\n\n 2. java.util.concurrent 패키지의 CopyOnWirteArrayList를 활용하자",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "java-collection-framework"
    ]
  },
  {
    "title": "벌크 연산 - Bulk Opertation",
    "url": "/back-end/2022/04/20/벌크-연산---bulk-opertation/",
    "category": "back-end",
    "date": "2022-04-20",
    "excerpt": "> \n- 여러 건을 하나의 쿼리로 수정하거나 삭제하는 방법",
    "content": "벌크 연산 - Bulk Opertation\n> executeUpdate\n- 여러 건을 하나의 쿼리로 수정하거나 삭제하는 방법\n\n\n 주의사항\n벌크 연산은 영속성 컨텍스르를 무시하고 DB에 직접 쿼리하므로 벌크 연산을 먼저 실행 후 영속성 컨텍스트를 초기화 하는 방법을 추천한다. 그렇지 않으면 영속성 컨텍스트에 저장된 값과 DB에 저장되어 있는 값에 대한 데이터 정합성이 발생한다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "SpringMVC는 어떻게 데이터를 반환할까?",
    "url": "/back-end/2022/04/20/springmvc는-어떻게-데이터를-반환할까/",
    "category": "back-end",
    "date": "2022-04-20",
    "excerpt": "> 부제: 와 ",
    "content": "SpringMVC는 어떻게 데이터를 반환할까? \n> 부제: ViewResolver와 MessageConverter\n\n 해당 글을 적게 된 동기\nSpring은 MVC2를 따르기 위해 모든 요청에 대한 응답을 DispacherServlet에서 모두 담당하는 것이 아닌 JSP, HTML과 같이 view만을 반환하는 ViewResolver를 통해 view를 반환한다. 그렇다면, \"JSON혹은 XML과 같은 데이터를 받고 비즈니스 로직을 처리 후 다시 JSON이나 XML과 같은 데이터는 어떻게 데이터를 반환하여 클라이언트에 전달하는지\" 의문을 가지게 되었는데...\n\nSpringMVC 요청 흐름을 검색하면 다음과 같이 간략한 다이어그램을 볼 수 있다.\n<img width=\"750\" src=\"/assets/images/posts/back-end/spring-mvc-request-stream.png\">\n\nView는 ViewResolver를 통해 View를 전달받는데, XML이나 JSON같은 데이터는 어떤식으로 반환하는지에 대한 정보를 찾기도 힘들고 제대로 된 다이어그램도 찾을 수 없어 직접 디버깅과 구글링을 통해 탐구할 것이다.\n\n부분적으로 생략된 부분이 있기 때문에 디버깅을 같이 따라해보면 좋겠다.\n\n @ResponseBody\n@ResponseBody 어노테이션을 사용한 Controller는 ViewResolver가 아닌 MessageConverter를 통해 사용자에게 데이터를 반환한다.\n> +@RestController속에 @ResponseBody 어노테이션이 있다.\n\n 1. 요청/응답 과정을 핥아보자\n앞으로 살펴볼 클래스들의 UML이다.\n> 누락된 부분 있을 수 있으므로 제보 부탁드려요 :\n\n<img src=\"/assets/images/posts/back-end/DispatcherServlet-UML.png\">\n\n 1-1. 사전작업\n1. DispatcherServlect클래스 내부에 들어간다.\n2. DispatcherServlectdoService를 찾는다.\n3. 메서드의 첫번 째 줄인 this.logRequestrequest;에 breaking point를 건다.\n\n<img src=\"/assets/images/posts/back-end/dispatherServlet-pre-ready.png\">\n\n이후 아무 @RestController를 만들어서 해당 컨트롤러를 실행할 예정이다.\n\n필자는 다음과 같은 컨트롤러를 만들었다.\n\njava\n@RestController\npublic class HelloController {\n\n    @GetMapping\"/hello\"\n    private String hello{\n        return \"hello\";\n    }\n}\n\n\n 1-2. 디버깅을 해보자\n\n 1. 컨트롤러헨들러를 가져와 실행할 수 있는 상태를 만드는 과정\ndoService 메서드에서 계속 Step Over를 하다보면 doDispatchrequest, response를 찾을 수 있다.\n\n<img width=\"800\" src=\"/assets/images/posts/back-end/find-doDispatch.png\">\n\ndoDispathcrequest, response 내부로 들어가기 위해 디버거의 Step Into를 사용하면 doDispatch메서드로 들어가진다 그 후,\nmappedHandler = this.getHandlerprocessedRequest;구분이 나올때까지 Step Over를 한다.\n\n<img width=\"800\" src=\"/assets/images/posts/back-end/find-handler-mapping.png\">\n\n그 후 계속 Step Over를 하다보면 HandlerMapping부분을 찾을 수 있는데 getHandlerprocessedRequest부분에서 다시 한번 Step Into를 하면  \n\n<img width=\"800\" src=\"/assets/images/posts/back-end/getHandler.png\">\n\n1. handlerMappings변수에 5개의 HandlerMapping이 존재하는 것을 확인할 수 있고\n2. 핸들러들을 순회하면서\n3. RequestMappingHandler를 찾은 다음\n4. RequestMappingHandler가 사전작업 파트1-1-사전작업에서 필자가 만든 HelloControllerhello를 hander가 가지고 있는것을 볼 수 있다. \n\n이렇게 HandlerMapping을 통해 controllerhandler Bean객체를 DispatcherServlet에게 전달한 후,\ngetHandler를 통해 얻은 HandlerAdapter를 얻어오는 것을 볼 수 있다.  \n> HandlerAdapter로 handler를 실행할 수 있다.\n\n<img width=\"800\" src=\"/assets/images/posts/back-end/find-handlerAdapter.png\">\n\ngetHandlerAdapter내부로 들어가면 이번에는 for문을 통해 사용할 HandlerAdapter를 찾는 과정이 진행된다.  \nHandlerAdapter는 사진과 같이 4개가 존재한다.\n<img width=\"800\" src=\"/assets/images/posts/back-end/get-handler-adapter-inside.png\">\n\n디버깅을 계속 진행하다보면 RequestMappingHandlerAdapter가 선택되는 것을 확인할 수 있다. 이제 hendler를 실행할 수 있는 HandlerAdapter를 찾았고 handler를 실행할 단계만 남아있다.\n\n 2. Handler 실행하기\ngetHandlerAdapter에서 빠져나온 후 Step Over를 통해 이동하다보면 mv = ha.handleprocessedRequest, response, mappedHandler.getHandler;를 볼 수 있는데 이 코드는 \nhandlerAdapter를 통해 handler를 실행한다. handle매서드를 속을 살펴보면  \n<img width=\"800\" src=\"/assets/images/posts/back-end/invoke-handler.png\">\n\n아래와 같이 handleInternal 매서드가 있는 것을 볼 수 있는데   \n<img width=\"800\" src=\"/assets/images/posts/back-end/exec-handle-method.png\">\n\n한번 더 내부코드에 들어가면\n\n<img width=\"800\" src=\"/assets/images/posts/back-end/handleInternal.png\">\n\n1. handlerMethod를 인수로 가지고 있고,\n2. invokeHandlerMethod 메서드에서 리플렉션으로 handlerMethod를 실행한다.\n   > 필자 기준 HelloControllerhello가 실행된다.\n\n더 자세히 알기 위해 invokeHandlerMethod를 살펴보면\n\n<img src=\"/assets/images/posts/back-end/invoke-handler1.png\">\n\n거의 끝나간다. invokeHandlerMethod속 invocableMethod.invokeAndHandlewebRequest, mavContainer를 통해 handler가 실행되고 그에 대한 반환결과를 얻을 수 있다!\n\n해당 사진에 나와있는 코드이외에 여러 코드가 많지만 invocableMethod.invokeAndHandlewebRequest, mavContainer부분만 알면된다 그 이외의 코드는 view관련 코드인듯 하다. \n\ninvokeAndHandlewebRequest, mavContainer의 내부를 들어가보자\n\n<img src=\"/assets/images/posts/back-end/invoke-handler2.png\">\n\n1. handler를 리플렉션으로 실행한다.\n2. returnValue 에 hello값이 저장되있는 것을 확인 할 수 있다.\n\n그 이후 Step Over를 계속 하다 보면, StringHttpMessageConverter를 확인할 수 있다!\n<img src=\"/assets/images/posts/back-end/StringHttpMessageConverter.png\">\n\n드디어 찾았다. HelloController는 단순하게 \"hello\"를 반환하므로 StringHttpMessageConverter를 통해 메시지를 반환하지만 객체를 반환하게 된다면 Jackson라이브러리에서 제공하는 appingJackson2HttpMessageConverter를 사용하게 된다.\n\n 결론\n결과적으로 XML, JSON과 같은 view를 제외한 데이터는 ViewResolver를 거치지 않고, MessageConverter를 거쳐 데이터를 반환한다.\n\n Reference\n- https://devlog-wjdrbs96.tistory.com/409\n- https://velog.io/@prayme/Spring은-Http-Message-Body를-어떻게-Java의-객체로-역직렬화할까",
    "tags": [
      "spring-mvc",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Fetch Join",
    "url": "/back-end/2022/04/19/fetch-join/",
    "category": "back-end",
    "date": "2022-04-19",
    "excerpt": "Fetch Join은 일반적인 SQL JOIN이 아닌 JPQL에서 성능 최적화를 위해 제공하는 기능이다.  \nFetch Join은 연관된 엔터티 혹은 컬렉션을 한번에 조회하는 기능이다. 한방쿼리",
    "content": "Fetch Join\nFetch Join은 일반적인 SQL JOIN이 아닌 JPQL에서 성능 최적화를 위해 제공하는 기능이다.  \nFetch Join은 연관된 엔터티 혹은 컬렉션을 한번에 조회하는 기능이다. 한방쿼리\n\n Fetch Join 예\nJPQL\nsql\nselect m from Member m join fetch m.team\n\nselect projection에 Member의 m만 적었지만 m에 연관된 team도 같이 SQL문에 조회되는 쿼리가 나간다.\n\nsql\nSELECT M., T. FROM MEMBER m \nINNER JOIN TEAM T ON M.TEAM_ID=T.ID\n\n> '' 은 필드를 생략했습니다.\n\n즉, 쿼리로 어떠한 객체 그래프를 한번에 조회 하는지 명시하는 방법이 Fetch Join이다.\n\n Fetch Join의 특징\n- JPQL은 결과를 반환할 때 연관관계를 고려하지 않는다.\n- 일반JOIN은 SELECT절에 지정한 엔티티만 조회하고,  \n  select절에 지정된 엔터티와 연관관계가 맻어진 엔터티 혹은 컬렉션을 한번에 조회한다.\n\n Fetch Join 요약\n- N + 1문제를 해결할 수 있다.\n- 1 대 N 조회 시 카테시안 곱이 발생한다.\n  > distinct를 사용하여 중복을 제거할 수 있다.\n- 컬렉션을 Fetch Join하면 페이징 API를 사용할 수 없다.\n  > Batch Size를 통해 해결할 수 있다.\n- 둘 이상의 컬렉션을 Fetch Join 할 수 없다,\n  > Hibernate에서는 경고를 남기고 DB가 아닌 메모리에서 페이징 처리를한다.\n- Fetch Join 대상에는 별칭을 줄 수 없다.\n  > 하이버네이트의 경우 가능하지만 가급적 사용하지 말자",
    "tags": [
      "spring",
      "jpa",
      "JPQL",
      "TIL"
    ]
  },
  {
    "title": "생성자 대신 정적 매소드 사용을 고려해라",
    "url": "/programming/2022/04/19/생성자-대신-정적-매소드-사용을-고려해라/",
    "category": "programming",
    "date": "2022-04-19",
    "excerpt": "> 동일한 시그니처의 생성자를 여러개 가질 수 없다.",
    "content": "생성자 대신 정적 매소드 사용을 고려해라\n\n 장점\n 객체 생성에 대해 이름을 가질 수 있다.\n> 동일한 시그니처의 생성자를 여러개 가질 수 없다.\n\n 호환 가능한 다른 인스턴스를 리턴할 수 있다.\n- 클라이언트에게 구현체를 숨길 수 있다.\n- 구현체가 없어도 된다.\n\n> ServiceLoader, 찾아보기\n\n 단점\n-",
    "tags": [
      "TIL",
      "coding",
      "effective-java",
      "development",
      "java"
    ]
  },
  {
    "title": "Junit5",
    "url": "/programming/2022/04/16/junit5/",
    "category": "programming",
    "date": "2022-04-16",
    "excerpt": "Java의 대표적인 단위 테스트 코두\n- Java8+\n- 대체제: TestNG, Spock\n- Junit5부터 class, method에 public를 붙여주지 않아도 된다.",
    "content": "Junit5\nJava의 대표적인 단위 테스트 코두\n- Java8+\n- 대체제: TestNG, Spock\n- Junit5부터 class, method에 public를 붙여주지 않아도 된다.\n\n Junit 모듈\n- Platform: 테스트를 실행해주는 런처 제공, TestEngine API 제공\n- Jupiter: TestEngine API 구현체로 JUnit5 제공\n- Vintage: Junit4, 3를 지원하는 TestEngine 구현체",
    "tags": [
      "junit",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "비관적 락, 낙관적 락",
    "url": "/back-end/2022/04/13/비관적-락-낙관적-락/",
    "category": "back-end",
    "date": "2022-04-13",
    "excerpt": "데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 가정하는 방법이다.",
    "content": "비관적 락, 낙관적 락\n\n 1. 낙관적 락 - Optimistic Lock\n데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 가정하는 방법이다.\n\n- JPA 제공하는 버전 관리 기능을 사용한다.\n- 커밋하기 전까지 트랜잭션 충돌을 알 수 없다.\n\n 1-1. JPA에서의 비관적 락 - @Version\n@Version 어노테이션은 JPA에서 버전 관리를 위해 제공하는 어노테이션이다.  \njava\n@Entity\npublic class Member{\n    @Id @GeneratedValuestrategy = GenerationType.IDENTITY\n    private Long id;\n\n    private String name;\n\n    @Version\n    private int version;\n}\n\n위와 같이 @Version어노테이션을 붙이면 version필드가 1씩 자동으로 증가한다.  \n그리고 엔터티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외를 발생시킨다.\n\n@Version를 사용하면 최초 커밋만 인정하기 때문에 예외가 발생한다.\n\n이게 가능한 이유는 JPA의 영속상태의 엔터티에 있는 버전과 DB 버전를 비교하고 같으면 버전을 1증가하여 수정한다.\nsql\nUPDATE BOARD\nSET\n    name=?,\n    VERSION=? 버전 + 1 증가\nWHERE\n    ID=?\n    AND VERSION=? 버전 비교\n\n그렇지 않으면 where문에서 조건이 달라지므로 수정할 대상이 없어진다. 이 경우 아래와 같은 예외가 발생한다.\n\n\n> 낙관적 락 예외\n> - javax.persistence.OptimisticLockException - JPA 예외\n> - org.hibernate.StaleObjectStateException - 하이버네이트 예외\n> - org.springframework.orm.ObjectOptimisticLockingFailureException - 스프링 예외 추상화\n\n\n 주의사항\n- 당연하게도 @Version이 달린 필드는 JPA가 관리하므로 특수한 상황 외에는 임의로 수정하면 안된다.\n    > 벌크 연산 시 버전을 무시한다.\n- 버전은 엔터티의 값을 변경하면서 증가한다.\n  - 연관관계 필드의 경우, 주인 필드를 수정할 때만 버전이 증가한다.\n\n\n 2. 비관적 락 - Pessimistic Lock\n> 트랜잭션 충돌이 발생한다고 가정하고 락을 건다.\n\n- DB가 제공하는 락 기능을 사용한다.\n  > ex. select for update\n\n 특징\n- 엔터티가 아닌 스칼라 타입을 조회할 때 사용될 수 있다.\n- 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다.\n\n 2-1. JPA 비관적 락 LockModeType\nDB 트랜잭션 락 메커니즘에 의존하는 방법이다.\n\n 1. PESSIMISTIC_READ\ndirty read가 발생하지 않을 떄 Shared Lock을 획득하고 데이터가 UPDATE, DELETE를 방지할 수 있다.\n> PESSIMISTIC_READ를 지원하지 않으면 PESSIMISTIC_WRITE로 대체된다.\n\n 2. PESSIMISTIC_WRITE\n배타적 잠금 - Exclusive Lock을 획득하고 데이터를 다른 트랜잭션에서 READ, UPDATE, DELETE하는 것을 방지할 수 있다.\n\n 3. PESSIMISTIC_FORCE_INCREMENT\n버전 정보를 강제로 증가시킨다.\n- 유일하게 버전 정보를 사용한다.\n- PESSIMISTIC_WRITE와 유사하게 작동하지만 @Version이 지정된 Entity와 협력하기 위해 도입되었다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Package",
    "url": "/programming/2022/04/05/package/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "- 서로 연관됨 클래스 또는 인터페이스들을 묶어 놓은 묶음\n- 클래스들이 필요할 때만 사용될 수 있도록 함\n- 클래스를 패키지 이름 과 함께 계층적인 형태로사용\n- 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간 충돌 막아줌",
    "content": "Package\n- 서로 연관됨 클래스 또는 인터페이스들을 묶어 놓은 묶음\n- 클래스들이 필요할 때만 사용될 수 있도록 함\n- 클래스를 패키지 이름 과 함께 계층적인 형태로사용\n- 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간 충돌 막아줌\n\n 패키지 정의 방법\n- 보통 도메인 이름을 거꾸로 적은 후, 그 뒤에 프로젝트 이름을 붙여서 만듬\n- 프로젝트 이름뒤에 다른 이름이 나올 수 있다.\n- 각각의 폴더명은 숫자로 시작할 수 없다.\n- 도메인 이름이 8cruz.com 이고 프로젝트 이름이 javastudy 라면 com.eightcruz.javastudy 로 패키지를 지정 할 수 있다.\n 사용방법\n- improt {도매인} 처럼 사용\n- 클래스 이름대신에  를 적어도 된다. import com.eightcruz.javastudy.;\n- improt를 하지않고 다음과 같이 사용할 수 있다.  \n    com.eightcruz.javastudy.Hello hello = new com.eightcruz.javastudy.Hello;",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "JAVA",
    "url": "/programming/2022/04/05/java/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "JAVA는 상속, 캡슐화은닉성, 다형성, 추상화를 제공한다. OOP참고../OOP.md",
    "content": "JAVA\n 특징\n 1. 객체 지향 프로그래밍OOP\nJAVA는 상속, 캡슐화은닉성, 다형성, 추상화를 제공한다. OOP참고../OOP.md\n\n 2. 운영체체의 독립적플랫폼에 독립적\n> WORAWrite Once Run Anywhere\n\nJAVA는 자바 가상머신Java Virtual Machine == JVM에서 실행된다.  \n\n2 - 1. 간단한 JVM 동작원리\n1. JVM에서 별도의 Java Compiler를 통해 개발자가 작성한 코드.java 파일를 byte code로 변환합니다.\n2. 변환한 byte code를 JVM를 통해 실행한다.\n\n>  byte code와 binary code의 차이\n> - Byte code는 JVM같은 가상 머신이 이해할 수 있는 코드.class\n> - Binary code는 CPU가 이해할 수 있는 코드\n\n 3. 자동 메모리 관리Garbage Collector\nJAVA는 JVM이 지속적으로 메모리를 감시하여 더이상 사용되지 않는 메모리를 해제시켜 준다.\n- 즉, 포인터라는 개념이 없다.\n- 메모리관리는 JVM이 처리하므로 개발자가 따로 관리할 필요가 없다.\n\n 4. 멀티쓰레드 지원\nJAVA는 하나의 프로그램에서 여러 개의 쓰레드가 동시에 실행할 수 있는 환경을 제공한다.\n- C/C++과 다르게 운영체제의 지원이 없이 멀티스레드 프로그래밍이 가능하다.\n- 구형방식은 Threed class방식과, Runnable 인터페이스 방식이 있다.\n\n 5. 동적 로딩 지원\nJAVA는 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 객체기 필요한 시점에 클래스를 동적 로딩하여 생성한다.\n- 클래스를 일부 변경시 다시 컴파일 하지 않아도 되는 이점이 있다.\n- 비교적 적은 작업으로 처리할 수 있는 유연성을 제공한다.\n- 반면에 필요할때 메모리에서 불러오기 떄문에 실행 속도가 정적로딩에 비해 느리다.",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Try-with-resources",
    "url": "/programming/2022/04/05/try-with-resources/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "해당 문법은 에서 선언된 객체들에 대해 try가 종료될 떄 자동으로 자원을 해제해주는 기능히다.\n- try에서 선언된 객체가 AutoCloseable을 구현하면 Java는 try구문이 종료될 때 객체의  메소드를 호출한다.\n- Java7 버전에 추가되었다.",
    "content": "Try-with-resources\n해당 문법은 try...에서 선언된 객체들에 대해 try가 종료될 떄 자동으로 자원을 해제해주는 기능히다.\n- try에서 선언된 객체가 AutoCloseable을 구현하면 Java는 try구문이 종료될 때 객체의 close 메소드를 호출한다.\n- Java7 버전에 추가되었다.\n\n 1. Java7 이전의 자원 해제 방법\ninput.txt를 읽는 코드입니다. \njava\npublic class ResourceClose {\n    public static void mainString args {\n        Scanner scanner = null;\n        try {\n            // scanner 생성\n            scanner = new Scannernew File\"input.txt\";\n            System.out.printlnscanner.nextLine;\n        } catch FileNotFoundException e {\n            e.printStackTrace;\n        } finally {\n            // scanner 리소스 반납\n            if scanner != null \n                scanner.close;\n        }\n    }\n}\n\n여기에서는 try에서 Scanner객체를 생성한 후 finally에서 close를 해줬다.\n\n이경우에는 finally를 통해 무조건 자원을 해제 해줘야 하고 혹시 모를 NPE를 대비해 null체크를 했다. 이런 코드를 Java7부터 다음과 같이 사용할 수 있다.\n\n 2. Java7 이후의 자원 해제 방법\njava\npublic class ResourceClose {\n    public static void mainString args {\n        try Scanner scanner = new Scannernew File\"input.txt\"{\n            System.out.printlnscanner.nextLine;\n        } catch FileNotFoundException e {\n            e.printStackTrace;\n        }\n    }\n}\n\n이 코드는 어느 곳에도 생성된 리소스를 반납하지 않아도 try옆 괄호 안에 있는 리소스에 대해 자동으로 close가 호출된다.\n\ntry with resources구분에 사용되는 리소스는 java.lang.AutoCloseable 인터페이스를 구현해야 한다.\n\nScanner의 공식 API 문서https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html를 보면 java.lang.AutoCloseable를 구현한 것을 볼 수 있다.\n\n 3. Java9에서 나온 개선사항\nJava7에서는 자원을 해제해야 하는 리소스를 반드시 try옆 괄호 안에 생성을 해야 한다.\n\n하지만 Java9부터 변수를 통해 이를 해제할 수 있다.\n\njava\npublic class ResourceClose {\n    public static void mainString args {\n        Scanner scanner = new Scannernew File\"input.txt\";\n        try scanner{\n            System.out.printlnscanner.nextLine;\n        } catch FileNotFoundException e {\n            e.printStackTrace;\n        }\n    }\n}\n\n 주의사항\n- 사용할 변수가 final이거나\n- effectively final사실상 final인 변수를 사용해야 한다.",
    "tags": [
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "enum(열거형)",
    "url": "/programming/2022/04/05/enum열거형/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "- 열거타입을 이용하면 변수를 선언할 때 변수타입으로 사용가능\n- 특정 값만 가져야 한다면 열거형 사용\n- 상수를 열거형 대신해서 사용했던것",
    "content": "enum열거형\n- 열거타입을 이용하면 변수를 선언할 때 변수타입으로 사용가능\n- 특정 값만 가져야 한다면 열거형 사용\n- 상수를 열거형 대신해서 사용했던것\n\n 상수를 이용하는 방법\njava\n    public class EnumExam {\n        public static final String MALE = \"MALE\";\n        public static final String FEMALE = \"FEMALE\";\n\n        public static void mainString args {\n            String gender1;\n\n            gender1 = EnumExam.MALE;\n            gender1 = EnumExam.FEMALE;                  \n        }\n    }\n\n 상수를 이용했을때 문제점\n- String으로 선언된 gender1에는 MALE,FEMALE 둘중 한가지 값을 가지기 원함\n- 개발자가 임의로 값을 넣어 줄수 있다.  \n    gender1 = 소년;\n\n 해결 방법\n- 열거형 사용\njava\nenum Gender{\n    MALE, FEMALE;\n}\n\n- 열거형 사용\njava\nGender gender2;\n\n    \ngender2 = Gender.FEMALE;\n\n//Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능.다른 값은 대입할 수가 없다.",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "변수의 scope, static",
    "url": "/programming/2022/04/05/변수의-scope-static/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "프로그램상에서 사용되는 변수의 사용가능한 범위",
    "content": "변수의 scope, static\n scope\n프로그램상에서 사용되는 변수의 사용가능한 범위\njava\n    public class ValableScopeExam{\n\n        int globalScope = 10;   // 인스턴스 변수 \n\n        public void scopeTestint value{   \n            int localScope = 10;\n            System.out.printlnglobalScope;\n            System.out.printlnlocalScpe;\n            System.out.printlnvalue;\n        }\n    }\n\n- 클래스의 속성으로 선언된 변수 globalScope의 사용범위는 클래스 전체\n- 매개변수로 선언된 int value 는 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭내이다.\n- 메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭내이다.\n static\n- main은 static 한 method\n- static한 메서드는 static 하지 않은 필드를 사용 할 수 없다.\njava\n    public class VariableScopeExam {\n        int globalScope = 10; \n\n        public void scopeTestint value{\n            int localScope = 20;            \n            System.out.printlnglobalScope;\n            System.out.printlnlocalScope;\n            System.out.printlnvalue;\n        }   \n        public static void mainString args {\n            System.out.printlnglobalScope;  //오류\n            System.out.printlnlocalScope;   //오류\n            System.out.printlnvalue;        //오류  \n        }   \n    }\n\n- static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다.  \n- 인스턴스가 여러개 생성되도 static한 변수는 하나다.\n- 클래스명.변수명 으로 사용하는것이 더 바람직하다고 하다.  \n    VariableScopeExam.staticVal\njava\n  ValableScopeExam v1 = new ValableScopeExam;\n    ValableScopeExam v2 = new ValableScopeExam;\n    v1.golbalScope = 20;\n    v2.golbalScope = 30; \n\n    System.out.printlnv1.golbalScope;  //20 이 출력된다. \n    System.out.printlnv2.golbalScope;  //30이 출력된다. \n\n    v1.staticVal = 10;\n    v2.staticVal = 20; \n\n    System.out.printlnv1.statVal;  //20 이 출력된다. \n    System.out.printlnv2.statVal;  //20 이 출력된다.",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Array",
    "url": "/programming/2022/04/05/array/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "array.length\n> 배열 크기 반환",
    "content": "Array\n 배열 선언\njava\n///////////1차원///////////\nint arr1 = new int100;\nint arr2 = new int{1, 2, 3, 4};\nint arr3 = {1,2,3,4};\n///////////2차원///////////\nint arr4 = new int34;\n\nint arr5 = new int3;\narr50 = new int1\n\n\n 배열 사용\narray.length\n> 배열 크기 반환\n\nfor each  \nfor타입 값을 받아줄 변수명 : 출력하고 싶은 자료구조\njava\nint arr = {1, 2, 3}\nforint i : arr\n    System.out.printlni\n//출력: \n//1 2 3",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "JAVA Data Type",
    "url": "/programming/2022/04/05/java-data-type/",
    "category": "programming",
    "date": "2022-04-05",
    "excerpt": "- 총 8가지의 기본형 타입Primitive data type을 미리 정의하여 제공\n- 기본값이 있기 떄문에 Null  \n    if null 넣고 싶으면 WrapperClass 활용\n- 실제 갑을 저장하는 공간 스택Stack메모리에 저장",
    "content": "JAVA Data Type\n\n 종류\n 기본형 타입primitive data type\n- 총 8가지의 기본형 타입Primitive data type을 미리 정의하여 제공\n- 기본값이 있기 떄문에 Null  \n    if null 넣고 싶으면 WrapperClass 활용\n- 실제 갑을 저장하는 공간 스택Stack메모리에 저장\n 참조형 타입Reference type\n- 기본형 타입을 제외한 타입\n- 비어있는 객체를 의미하는 Null 존재\n- 값이 저장되어 있는곳의 주소값을 저장하는 공간으로 Heap힙 메모리에 저장\n- 객체나 배열을 Null 값으로 받으면 NullPointException발생\n\nbyte\n- 자바의 기본 데이터 전송 단위  \n- default = 0\n- Wrapper class Byte\n\nshort  \n- default = 0\n- Wrapper class Shrot\n\nint  \n- default = 0\n- Wrapper class Integer\n\nlong  \n- default = 0L 명시적표현 L사용\n- Wrapper class Long\n\nfloat\n- default = 0f 명시적표현 f사용\n- Wrapper class Float\n\ndouble  \n- default = 0.0d 명시적표현 d사용\n- Wrapper class Double\n\nboolean  \n- default = false\n- Wrapper class Boolean\n\nchar  \n- default = ‘\\u0000’\n- Wrapper class Character\n\nString  \n- new 연산 없이도 인스턴스를 생성할수 있는 reference data type  \n \n 형변환\n묵시적 형변환\njava\nint x = 400;\nlong y = x;\n\n강제 형변환\njava\nlong x = 5;\nint y = intx;",
    "tags": [
      "legacy",
      "TIL",
      "grammar",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "HTTP 버전별 차이",
    "url": "/network/2022/03/30/http-버전별-차이/",
    "category": "network",
    "date": "2022-03-30",
    "excerpt": "- HTTP의 초기 버전은 버전 정보가 없었다.\n  > 차후 버전 구분을 위해 0.9라고 불리게 되었다.\n- 단순히 GET 통신만 가능하다.\n- HTTP 해더가 없기 떄문에 데이터 전송은 HTML문서만 가능하고\n- 오류 코드가 없었기 떄문에 문제 상황시 해당 파일 내부에 문자에 대한 설명을 포함하여 보내졌다고 한다.",
    "content": "HTTP 버전별 차이\n 1. HTTP 0.9\n- HTTP의 초기 버전은 버전 정보가 없었다.\n  > 차후 버전 구분을 위해 0.9라고 불리게 되었다.\n- 단순히 GET 통신만 가능하다.\n- HTTP 해더가 없기 떄문에 데이터 전송은 HTML문서만 가능하고\n- 오류 코드가 없었기 떄문에 문제 상황시 해당 파일 내부에 문자에 대한 설명을 포함하여 보내졌다고 한다.\n\n 2. HTTP 1.0\n- 상태코드가 응답값 시작 부분에 포함되어 요청에 대한 성공과 실패를 확인할 수 있다.\n- HTTP 헤더가 요청/응답 모두 추가되어 프로토콜의 확장이 가능하다.\n  > 해더의 Content-Type의 도움으로 HTML 파일 이외 다른 문서도 전송이 가능하다.\n- POST, HEAD가 추가되었다.\n- Connection 특성 : 응답 직후 종료\n\n 3. HTTP 1.1\nHTTP의 첫 번쨰 표준 버전이다.\n- PUT, DELETE, OPTIONS, TRACE 메서드가 추가되었다.\n- 추가적으로 여러 헤더값도 추가되었다.\n  > 예시.  \n  > http\n  > Via : 중계서버프록시, 게이트웨이 등의 지원 프로토이름.버전.호스트명 ex. via: 1.1 123abc. cloudfront.net CloudFront\n  > Accept : 클라이언트의 사용가능 미디어타입 ex. application/json, text/plain, /       \n  > \n\n 3-1. 커넥션 유지 - Persistent Connection Keep Alive와 Pipeline\n\n 1. Keep Alive\nHTTP는 TCP 연결 기반 위에서 동작하는 프로토콜이다. TCP는 신뢰성 확보를 위해 연결을 맺고 끊을 때 handshake가 이루어 진다. 3-way-handshake, 4-way-handshake   \nHTTP는 비 연결성 프로토콜이기 떄문에 한번 연결로 한번의 요청 후 응답을 하고나면 연결을 끊어버린다. 이러면 오버헤드가 커질 수 있어 HTTP/1.1에서 Kepp-alive기능이 추가되었다.\n\n 1-1. Keep-alive란?\n이미 연결되어 있는 TCP 연결을 재사용하여\n한 번 맺어졌던 연결을 끊지 않고 지속적으로 유지하여 불필요한 핸드 셰이크를 줄여 성능을 개선할 수 있다.\nkeep-alive 응답의 예제\nhttp\nHTTP/1.1 200 OK\nConnection: Keep-Alive\nKeep-Alive: timeout=5, max=1000\n\n\n\n 1-2. 주의사항\n하나의 커넥션으로 여러 요청과 응답을 처리할 수 있지만...\n모든 TCP 세션을 무한정 유지할 수는 없으므로 timeout과 max설정을 잘 설정해야 한다.\n\n추가적으로 Nginx와 같이 Event-driven 구조여서 non-blocking을 사용하는 웹서버는\nKeep Alive를 하면서도 Thread를 점유하지 않기 때문에 동시 처리에 유리하다.\n\n\nKeep Alive는 https://goodgid.github.io/HTTP-Keep-Alive/http10 여기에서 잘 알려주는 거 같아 첨부한다.\n\n 커넥션 유지의 장점\n응답 속도 개선, TCP 세션 처리 부하 감소\n\n 2. 파이프라이닝 - Pipelining\n<img src=\"/assets/images/posts/network/pipelining.png\">\n\nHTTP 요청은 순차적으로 이루어 진다.\n\n파이프라이닝은 응답을 받지 않아도 순차적으로 요청을 보내고 이에 대한 각각의 응답을 받아 응답 속도를 높힌다.\n\n 3-2. 호스트 헤더 - Host Header\nHTTP 1.1에서 Host Header의 추가로 버츄얼 호스팅이 가능해졌다.\n\n> 버추얼 호스팅 - virtual hosting이란?  \n> 하나의 서버에 여러개의 도메인 이름을 호스팅하는 방식을 말한다.\n\n이로 인해 하나의 IP에 여러개의 도메인을 운영할 수 있게 되었다.\n\n 3-3. 강화된 인증 절차\n실제 서버에서 클라이언트 인증을 요구하는 www-authentication 헤더는 서버 사이에 프록시가 위치하는 경우 프록시가 사용자의 인증을 요구할 수 있는 방법이 없었다.\n\nHTTP/1.1에서 다음 2개 해더가 추가되어 프록시가 클라이언트에게 인증/인가 요청을 할 수 있다.\n- proxy-authentication\n- proxy-authorization\n\n 3-4. HTTP 1.1의 단점\n\n 1. HOL - Head Of Line Blocking - 특정 응답의 지연\nConnection을 통해서 다수개의 파일을 요청/응답 받을 수 있는 기법인 pipelining 기법을 통해 성능을 향상할 수 있지만. 한가지 문제가 있다.\n\n하나의 TCP연결에서 3개의 이미지를 얻으려고 하는 경우 HTTP 요청 순서는 다음과 같다.\n\n| --- a.png --- |\n\n                | --- b.png --- |\n\n                                | --- c.png --- |\n\n순서대로 첫번째 이미지를 요청하고 응답받고 다음 이미지를 요청하게 되는데 만약 첫번째 이미지를 요청하고 응답이 지연되면,  \n아래 그림과 같이 두,세번째 이미지는 당연히 첫번째 이미지의 응답처리가 완료되기 전까지 대기하게 되며 이와 같은 현상을 HTTP의 Head of Line Blocking이라고 한다.\n\n| ------------------------- a.png --------------------- |\n\n                                                        | -b.png- |\n\n                                                                  | --c.png-- |\n\n\n 2. RTT - Round Trip Time 증가\nHTTP 1.1은 일반적인 경우 하나의 connection에 하나의 요청을 한다. 이렇다 보니 매 요청마다 3-way-handshake가 반복적으로 일어나고 불필요한 RTT증가와 네트워크 지연을 초례한다.\n\n 3. 무거운 Header 구조\nhttp/1.1의 헤더에는 많은 메타정보들이 저장되어 있다.\n\n- 사용자가 방문한 웹페이지는 다수의 요청이 발생하는데, 이 경우 매 요청시 중복된 헤더값을 전송한다.\n- 요청을 통해서 전송하려는 페이로드보다 헤더 값이 더 큰 경우도 있다.\n\n\n 4. HTTP 2.0\n기존 HTTP 1.1에 비해 성능 향상에 초점을 둔 버전이다.\n\n다음은 HTTP2에 대한 소개글을 일부 가져왔다. https://http2.github.io/\n> HTTP/2 is a replacement for how HTTP is expressed “on the wire.” It is not a ground-up rewrite of the protocol; \n> HTTP methods, status codes and semantics are the same, and it should be possible to use the same APIs as HTTP/1.x possibly with some small additions to represent the protocol.\n\n> The focus of the protocol is on performance; \n> specifically, end-user perceived latency, network and server resource usage. \n> One major goal is to allow the use of a single connection from browsers to a Web site.\n\n<img src=\"/assets/images/posts/network/http2.png\">\n\nHTTP 2.0은 HTTP 1.1에 대한 높은 호환성을 보여주며, 성능향상을 가져왔다.\n- 기존 평문 - Plain Text을 사용하던 HTTP 1.x와 달리 HTTP 2.0은 바이너리 포멧으로 인코딩된 Message, Frame으로 구성된다.\n\n- Stream  : 구성된 연결 내에서 전달되는 바이트의 양방향 흐름\n  > 하나 이상의 메시지를 전달 할 수 있다.\n- Message : 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스다.\n- Frame   : Http/2.0에서의 통신의 최소 단위 \n  - 이 프라임 헤더는 최소한으로 프레임이 속하는 스트림을 식별한다.\n  - Headers Type Frame, Data Type Frame이 존재한다.\n\n 4-1. Multiplexed Streams\n- 한 Connection으로 동시에 여러 개 메시지를 주고 받을 수 있으며, \n- Response는 순서에 상관없이 stream으로 주고받는다.\n\n 4-2. Prioritization\n- 리소스간 우선순위를 설정한다.\n\n 4-3. Server Push\n- 서버는 클라이언트의 요청에 대해 요청하지 않은 리소스를 마음대로 보내줄 수 있다.\n    > 즉, 클라이언트가 요청하기 전에 필요하다고 예상되는 리소스를 Server에서 먼저 요청한다.\n\n 4-4. Header Compression\n<img width=600 src=\"/assets/images/posts/network/header-compression.png\">\n\n- 이전 Header의 내용과 중복되는 필드를 재전송하지 않아 데이터를 절약한다.\n- Header table과 Huffman Encoding 기법HPAC 압축방식을 이용해 헤더를 압축한다.\n\n HTTP 1.0 vs HTTP 1.1 vs HTTP 2.0\n<img width=600 src=\"/assets/images/posts/network/http1-vs-http1_1-vs-http2.png\">\n\n Reference\n- https://falsy.me/http의-버전-별-차이에-대해-알아보고-ubuntu-nginx에-http-2를-적용해/\n- https://withbundo.blogspot.com/2021/02/http-http-10-http-11.html\n- https://www.popit.kr/나만-모르고-있던-http2/",
    "tags": [
      "TIL",
      "http"
    ]
  },
  {
    "title": "클래스 기반의 프록시 생성 방법",
    "url": "/programming/2022/03/29/클래스-기반의-프록시-생성-방법/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "ByteBuddy와 CGlib로 class기반 생성을 할 수 있다.",
    "content": "클래스 기반의 프록시 생성 방법\nByteBuddy와 CGlib로 class기반 생성을 할 수 있다.\n\n 주의사항\n이 두가지 모두 상속을 이용한 Proxy객체를 만든다.  \n그러므로 final 클래스 혹은 기본 생성자가 private라면 proxy를 만들 수 없다. \n\n인터페이스가 있다면 인터페이스 기반 프록시를 만드는 것을 권장한다.\n> 위와같은 제약사항이 없고 편하다.\n\n이전 글 예제를 기반으로 작성 이전글dynamic-proxy.md\n CGlib\n공식 위키: https://github.com/cglib/cglib/wiki\n 의존성 추가\nhttps://mvnrepository.com/artifact/cglib/cglib\n\n 간단한 사용예제\njava\nMethodInterceptor handler = new MethodInterceptor {\n    @Override\n    public Object interceptObject o, Method method, Object args, MethodProxy methodProxy throws Throwable {\n        BookService bookService = new BookService;\n        ifmethod.getName.equals\"rent\" {\n            System.out.println\"AAAAAAA\";\n            Object returnResult = method.invokebookService, args;\n            System.out.println\"BBBBBBB\";\n            return returnResult;\n        }\n\n        return method.invokebookService, args;\n    }\n};\n\nBookService bookService = BookService Enhancer.create\n        BookService.class,\n        handler\n;\n\nBook book = new Book\"스프링\";\nbookService.rentbook;\nbookService.returnBookbook;\n\n출력결과\n\nAAAAAAA\nrent: 스프링\nBBBBBBB\nreturn book: 스프링\n\n- rent method만 다르게 출력되는 것을 볼 수 있다.\n\n\n ByteBuddy\n공식 사이트: https://bytebuddy.net\n 의존성 추가\nhttps://mvnrepository.com/artifact/net.bytebuddy/byte-buddy\n\n 간단한 사용예제\njava\nClass<? extends BookService> proxyBookService = new ByteBuddy.subclassBookService.class // BookService의 subclass 생성 선언\n        .methodElementMatchers.named\"rent\".interceptInvocationHandlerAdapter.ofnew InvocationHandler { // rent라는 이름을 가진 메서드에 대한 헨들링을 한다.\n            BookService bookService = new BookService;\n            @Override\n            public Object invokeObject proxy, Method method, Object args throws Throwable {\n                System.out.println\"AAAAAA\";\n                Object resultOfRentMethod = method.invokebookService, args;\n                System.out.println\"BBBBBB\";\n                return resultOfRentMethod;\n            }\n        }\n        .make\n        .loadBookService.class.getClassLoader.getLoaded;// BookService를 로드한 클래스 로더에서 로딩된 결과를 가지고 온다.\n\nBookService bookService = proxyBookService.getConstructornull.newInstance;\n\nBook book = new Book\"스프링\";\nbookService.rentbook;\nbookService.returnBookbook;\n\n\n 출력결과\n\nAAAAAA\nrent: 스프링\nBBBBBB\nreturn book: 스프링",
    "tags": [
      "TIL",
      "byte-code-controller-way",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Repository",
    "url": "/back-end/2022/03/29/repository/",
    "category": "back-end",
    "date": "2022-03-29",
    "excerpt": "Member",
    "content": "Repository\n Spring Data JPA 사용전\n 예제 코드\n 예제 모델\nMember\njava\n@Entity\n@Getter @Setter\n@NoArgsConstructoraccess = AccessLevel.PROTECTED\n@ToStringof = {\"id\", \"name\"}\npublic class Team {\n\n    @Id @GeneratedValue\n    @Columnname = \"team_id\"\n    private Long id;\n    private String name;\n\n    @OneToManymappedBy = \"team\"\n    private List<Member> members = new ArrayList<>;\n\n    public TeamString name {\n        this.name = name;\n    }\n}\n\nTeam\njava\n@Entity\n@Getter @Setter\n@NoArgsConstructoraccess = AccessLevel.PROTECTED\n@ToStringof = {\"id\", \"name\"}\npublic class Team {\n\n    @Id @GeneratedValue\n    @Columnname = \"team_id\"\n    private Long id;\n    private String name;\n\n    @OneToManymappedBy = \"team\"\n    private List<Member> members = new ArrayList<>;\n\n    public TeamString name {\n        this.name = name;\n    }\n}\n\n\n 예제 Repository\nMember Repository\njava\n@Repository\npublic class MemberJpaRepository {\n\n    @PersistenceContext // EntityManger 를 injection 해주는 annotation\n    private EntityManager em;\n\n    public Member saveMember member{\n        em.persistmember;\n        return member;\n    }\n\n    public long count{\n        return em.createQuery\"select countm from Member m\", Long.class.getSingleResult;\n    }\n\n    public Optional<Member> findByIdLong id{\n        Member member = em.findMember.class, id;\n        return Optional.ofNullablemember;\n    }\n\n    public Member findLong id{\n        return em.findMember.class, id;\n    }\n\n    public void deleteMember member{\n        em.removemember;\n    }\n\n    public List<Member> findAll{\n        return em.createQuery\"select m from Member m\".getResultList;\n    }\n}\n\nTeamRepository\njava\n@Repository\npublic class TeamJpaRepository {\n\n    @PersistenceContext \n    private EntityManager em;\n\n    public Team saveTeam team{\n        em.persistteam;\n        return team;\n    }\n\n    public void deleteTeam team{\n        em.removeteam;\n    }\n\n    public List<Team> findAll{\n        return em.createQuery\"select t from Team t\", Team.class.getResultList;\n    }\n\n    public Optional<Team> findByIdLong id{\n        Team team = em.findTeam.class, id;\n        return Optional.ofNullableteam;\n    }\n\n    public long count{\n        return em.createQuery\"select countt from Team t\", Long.class.getSingleResult;\n    }\n}\n\n 테스트 코드 작성\njava\n@SpringBootTest\n@Transactional\npublic class MemberJpaRepositoryTest {\n    @Autowired\n    MemberJpaRepository memberJpaRepository;\n\n    @Test\n    public void basicCRUD {\n        Member member1 = new Member\"member1\";\n        Member member2 = new Member\"member2\";\n        memberJpaRepository.savemember1;\n        memberJpaRepository.savemember2;\n\n        //단건 조회 검증\n        Member findMember1 = memberJpaRepository.findByIdmember1.getId.get;\n        Member findMember2 = memberJpaRepository.findByIdmember2.getId.get;\n        assertThatfindMember1.isEqualTomember1;\n        assertThatfindMember2.isEqualTomember2;\n\n        //리스트 조회 검증\n        List<Member> all = memberJpaRepository.findAll;\n        assertThatall.size.isEqualTo2;\n\n        //카운트 검증\n        long count = memberJpaRepository.count; assertThatcount.isEqualTo2;\n        //삭제 검증 \n\n        memberJpaRepository.deletemember1; memberJpaRepository.deletemember2;\n        long deletedCount = memberJpaRepository.count;\n        assertThatdeletedCount.isEqualTo0;\n    }\n}\n\n> 참고. UPDATE는 JPA의 변경 감지Dirty Checking을 사용하므로 필요 없다.\n 위 코드의 문제점\n- 위에 Member와 Team의 Repository는 서로 관리하는 Entity만 다르지 기능은 똑같다.\n- 개발자가 CRUD같은 기본 로직을 계속 짜줘야한다. &rarr; 매우번거롭다\n\n하지만 Spring Data JPA는 이 귀찮은 과정을 스킵할 수 있게한다.\n\n Spring Data JPA 적용후\n 공용 인터페이스 설정 \n JavaConfig 설정- 스프링 부트 사용시 생략 가능\njava\n@Configuration\n@EnableJpaRepositoriesbasePackages = \"jpabook.jpashop.repository\"\npublic class AppConfig {} \n\n- 스프링부트사용시@SpringBootApplication이 위치를지정해당 패키지와 하위 패키지 인식\n- 만약 패키지의 위치가 달라지면 @EnableJpaRepositories가 필요하다\n\n Spring Data JPA가 구현 클래스 대신 생성한다.\n<img width=450px src=\"/assets/images/posts/back-end/data-jpa-implements.png\">\n\n- org.springframework.data.repository.Repository를 구현한 클래스는 스캔 대상이다. \n  - 그리하여 실제로 MemberRepository 인터페이스를 가져와 출력하면  \n    memberRepo.getClass &rarr; class com.sun.proxy.$ProxyXXX 와 같이 프록시 객체가 만들어진다는것을 알 수 있다.\n- @Repository 생략 가능하다\n\n\n 공용 인터페이스 적용\nMember Repository\njava\n@Repository\npublic interface MemberRepository extends JpaRepository<Member, Long> {}\n\nTeam Repository\njava\n@Repository\npublic interface TeamRepository extends JpaRepository<Team, Long> {}\n\n 테스트 코드 작성\n> 기존 순수 JPA 기반 테스트에서 사용했던 코드를 그대로 스프링 데이터 JPA 리포지토리 기반 테스트로 변경해도 동일한 방식으로 동작한다\njava\n@SpringBootTest\n@Transactional\n@Rollbackvalue = false\nclass MemberRepositoryTest {\n\n    @Autowired MemberRepository memberRepo;\n\n    @Test\n    public void basicCRUD {\n        Member member1 = new Member\"member1\";\n        Member member2 = new Member\"member2\";\n        memberRepository.savemember1;\n        memberRepository.savemember2;\n\n        //단건 조회 검증\n        Member findMember1 = memberRepository.findByIdmember1.getId.get; \n        Member findMember2 = memberRepository.findByIdmember2.getId.get; \n        assertThatfindMember1.isEqualTomember1; \n        assertThatfindMember2.isEqualTomember2;\n\n        //리스트 조회 검증\n        List<Member> all = memberRepository.findAll; assertThatall.size.isEqualTo2;\n\n        //카운트 검증\n        long count = memberRepository.count; assertThatcount.isEqualTo2;\n\n        //삭제 검증 \n        memberRepository.deletemember1; \n        memberRepository.deletemember2;\n        long deletedCount = memberRepository.count;\n        assertThatdeletedCount.isEqualTo0;\n      }\n\n\n}\n\n- 위와 같이 간단하게 만들 수 있다.\n- 우리는 그냥 간단한 CRUD를 저기 만들어 놓은 Repository를 이용하여 만들면 된다.\n- Spring Data JPA한테 구현해야 할 코드를 맡기자\n\n 공통 인터페이스 분석\n- JpaRespotiroy 인터페이스: 공통 CRUD 제공\n- 제네릭은 <Entity Type, 식별자 타입>으로 설정한다\n JpaRepository 공통 기능 인터페이스\njava\npublic interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, QueryByExampleExecutor<T>{\n    //etc....\n}\n\n JpaRepository를 사용하는 인터페이스\njava\npublic interface MemberRepository extends JpaRepository<Member, Long> {}\n\n\n 공통 인터페이스 구성\n<img width=500px src=\"/assets/images/posts/back-end/interface-config.png\">\n\n 제네릭 타입\n- T: 엔티티\n- ID : 엔티티의 식별자 타입\n- S : 엔티티와 그 자식 타입\n\n 주요 메서드\n- saveS : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.\n- deleteT : 엔티티 하나를 삭제한다.\n  > 내부에서 EntityManager.remove 호출\n- findByIdID : 엔티티 하나를 조회한다\n  > 내부에서 EntityManager.find 호출\n- getOneID : 엔티티를 프록시로 조회한다.\n  > 내부에서 EntityManager.getReference 호출\n- findAll... : 모든 엔티티를 조회한다.\n  > 정렬sort, 패이징Pageable조건을 파라미터로 제공할 수 있다. \n\n참고: JpaRepository 는 대부분의 공통 메서드를 제공한다.",
    "tags": [
      "spring",
      "jpa",
      "data-jpa",
      "TIL"
    ]
  },
  {
    "title": "Spring Data JPA",
    "url": "/back-end/2022/03/29/spring-data-jpa/",
    "category": "back-end",
    "date": "2022-03-29",
    "excerpt": "> 이 md는 김영한씨의 실전! 스프링 데이터 JPAhttps://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84/ 라는 강의를 보고 정리합니다.",
    "content": "Spring Data JPA\n> 이 md는 김영한씨의 실전! 스프링 데이터 JPAhttps://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84/ 라는 강의를 보고 정리합니다.\n\n 이것은 마법같은 기술이다\n>기존 Spring + JPA 만으로 생산능력이 높아졌지만 이 기술을 사용함으로써 더욱 생산성이 높아진다.\n- 구현체 없이 Repository 만으로 구현이 가능하다.\n- CRUD는 기본적으로 제공된다. &rarr; 개발자는 핵심 비즈니스 로직에만 집중하여 개발하자!\n- 선택이 아닌 필수다! 실무에 무조건 적용된다.\n\n 하지만\n- JPA를 너무 추상화 해버린다.\n- JPA를 몰라도 사용할 수 있다.\n- 문제는 문제가 생겨 해결할때 JPA의 기본 원리를 모르면 해결할 수가 없다.\n- 결론은 JPA부터 공부하자.\n\n 실습환경\nSpring initializer를 통해 실습 환경을 생성한다.  \n실습 환경 공유https://start.spring.io/!type=maven-project&language=java&platformVersion=2.4.5.RELEASE&packaging=jar&jvmVersion=11&groupId=com.study&artifactId=data-jpa&name=data-jpa&description=Demo%20project%20for%20Spring%20Boot&packageName=com.study.data-jpa&dependencies=web,data-jpa,h2,lombok &larr; 링크를 타고들어가면 똑같은 필자와 똑같은 환경제공\n\n Java11\n\n Build Tool\n- Gradle\n\n Dependencies\n- Spring Web \n- Spring Data JPA\n- H2 Database - 2mb의 메모리를 사용하는 가장 좋은 실습용 DB\n- Lombok - Getter, Setter와 같은것을 어노테이션으로 생성을 해주는 의존성\n\n./gradlew dependencies --configuration compileClasspath  \n프로젝트폴더에서 위와같은 명령어를 사용하면 자신이 사용한 dependencies를 확인할 수 있다.\n\n H2DB 설치 및 실행\n1. 현재 추가된 Dependency 버전에 맞는 H2DBhttps://www.h2database.com/html/main.html를 설치한다.  \n\n    window유저는 window를 사용하면 되고, mac이나 linux환경을 사용하면 All Platform 을 선택해서 다운로드한 후 압축을 풀면된다.   \n\n    h2DB의 Dependency는 intellij ultimate 기준 오른쪽에 다음과 같이 확인할 수 있다.  \n\n    > <img width=350px src=\"/assets/images/posts/back-end/data-jpa-gradle-depedency.png\">\n\n2. 압축 해제후 /src/bin/ 경로로 이동후 ./h2.sh를 실행한다.   \n   만약 permission denied로 실행을 못하면 chmod 755 ./h2.sh를 쉘에 입력한다.\n\n3. 실행후 H2 콘솔에 JDBC URL에 jdbc:h2:~/DBname 과 같이 입력한다.  \n   이는 DB파일을 생성하기 위해 최초 1번만 실행한다.\n   > DBname은 자신이 원하는 이름으로 입력해라 \n4. 그후 접속은 jdbc:h2:tcp://localhost/~/DBname\n\n application 설정파일\napplication.properties 파일의 이름을 application.yml 이와같이 변경한다. 그후 다음과 같이 입력한다.  \n\n설정파일은 프로젝트 상위 폴더기준 /src/main/resources에 있다.\n\nyml\nspring:\n  datasource:\n    url: jdbc:h2:tcp://localhost/~/DBname  위에서 생성한 접속 URL\n    username: sa\n    password:\n    driver-class-name: org.h2.Driver\n\n  jpa:\n    hibernate:\n      ddl-auto: create  애플리케이션 실행 시점에 테이블을 drop 하고, 다시 생성한다.\n    properties:\n      hibernate:\n        show_sql: true\n        format_sql: true  보여주는 쿼리를 예쁘게 포맷팅 해준다.\n\n  logging.level:\n    org.hibernate.SQL: debug\n    org.hibernate.type :trace   파라미터 바인딩된 부분까지 나온다.\n\n\n Spring Data JPA사용방법\n 1. Entity 생성\nMember\njava\n@Entity @Getter\n@NoArgsConstructoraccess = AccessLevel.PROTECTED\n@ToStringof = {\"id\", \"username\", \"age\"}\npublic class Member {\n\n    @Id @GeneratedValue\n    @Columnname = \"member_id\"\n    private Long id;\n    private String username;\n\n    public MemberString username{\n        this.username = username;\n    }\n}\n\n\n 2. Repository 생성\nMemberRepository\n- Repository는 interface로  JpaRepository<Entity, EntityIdType>를 상속 받는다.\njava\n@Repository\npublic interface MemberRepository extends JpaRepository<Member, Long>\n\n\n 3. Test 코드 작성\n- Intellij에서는 테스트 코드를 작성할때 작성하고싶은 클레스에서 cmd + n 누르면 메뉴가 나타나는데 여기에서 test를 만들수 있다.\n- 이렇게 만든 Test는 /src/test 에 있다.\njava\n@SpringBootTest\n@Transactional //JPA를 테스트하려면 트렌젝션 내에서 동작해야 된다. //import는 springframework trancational을 선택한다.\nclass MemberRepositoryTest {\n\n    @Autowired MemberRepository memberRepo;\n\n    @Test\n    public void testMember{\n        Member member = new Member\"memberA\";\n        Member savedMember = memberRepo.savemember;\n\n        Member findMember = memberRepo.findByIdsavedMember.getId.get;\n\n        assertThatfindMember.getId.isEqualTomember.getId;\n        assertThatfindMember.getUsername.isEqualTomember.getUsername;\n        assertThatfindMember.isEqualTomember;\n    }\n\n}\n\n\n 테스트가 느린이유\n기본적으로 Intllij에서는 gradle를 거쳐 Test밑 빌드를 하기 떄문에 속도가 느리다.  \n\n다음과 같이 설정한다\n1. Perference에 들어가서 build tool를 검색한다.\n2. 왼쪽 네비게이션 바에서 Build Tool 하위에 Gradle을 선택후\n3. Build and run 에서 Build and run using과 Run tests using 를 Intllij IDEA로 선택한다.\n\n<img width=500px src=\"/assets/images/posts/back-end/gradle-setting.png\">\n\n 쿼리를 더욱 이쁘게 날리자 - 이는 공부용으로 좋다.\ndependency를 build.gradle에 dependencies안에 다음과 같이 추가한다.  \n\nbuild.gradle\ngradle\ndependencies {\n implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.5.7'\n}",
    "tags": [
      "spring",
      "jpa",
      "data-jpa",
      "TIL"
    ]
  },
  {
    "title": "스레드 로컬 - Thread Local",
    "url": "/programming/2022/03/29/스레드-로컬---thread-local/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 김영한 인프런 핵심 원리 - 고급편https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8",
    "content": "스레드 로컬 - Thread Local\n Reference\n- 김영한 인프런 핵심 원리 - 고급편https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8\n\n\n 스레드 로컬\n: 스레드 단위로 로컬 변수를 할당하는 기능을 제공하는 클래스이다\n- JDK1.2 부터 지원하고 java.lang패키지에 있다.\n\n Thread Local의 동작 원리\n 값 저장\n스레드 로컬를 사용하면 각 스레드마다 별도의 내부 저장소를 생성한다. \n> 같은 인스턴스 스레드 로컬 필드에 접근해도 동시성 이슈가 발생하지 않는다.\n\n\nThread-A             |  Thread-B\n:-------------------------:|:-------------------------:\n!/assets/images/posts/programming/thread-local-save1.png  |  !/assets/images/posts/programming/thread-local-save2.png\n\n 값 조회\n스레드 로컬을 통해 데이터를 조회해도 해당 Thread가 저장한 값을 알맞게 반환해준다.\n<img width=650 src=\"/assets/images/posts/programming/thread-local-lock-up.png\">\n\n 사용 예시\n ThreadLocal의 method\n- ThreadLocal.set: 스레드 로컬에 값 설정\n- ThreadLocal.get: 스레드 로컬에 값 얻기\n- ThreadLocal.remove: 스레드 로컬에 값 제거\n\n 예시\n값을 저장하고 조회하는 간단한 서비스ThreadLocalService를 만들었다.\njava\n@Slf4j\npublic class ThreadLocalService {\n\n    private final ThreadLocal<String> nameStore = new ThreadLocal<>;\n\n    public String logicString name  {\n        log.info\"저장 name={} -> nameStore={}\", name, nameStore.get;\n        nameStore.setname;\n        sleep1000; // 대충 저장을 하면 1초가 걸림\n        log.info\"조회 nameStore={}\", nameStore.get;\n        return nameStore.get;\n    }\n\n    public void removeValueInThreadLocal{\n        this.nameStore.remove;\n    }\n\n    public String lockUpValue{\n        return nameStore.get;\n    }\n\n    private void sleeplong time{\n        try {\n            Thread.sleeptime;\n        } catch InterruptedException e {\n            e.printStackTrace;\n        }\n    }\n}\n\n- 일부로 동시성 이슈를 만들어 내려고 logic매서드 속에 해당 Thread를 1초동안 sleep하게 만들었다.\n- 하지만 ThreadLocal를 통해 값을 nameStore값을 받으므로 동시성 이슈가 발생하지 않는다.\n\n이제 태스트 코드로 확인해보자\njava\n@Slf4j\npublic class FieldServiceTest {\n\n    private ThreadLocalService service = new ThreadLocalService;\n\n    @Test\n    void field{\n        log.info\"main start\";\n        Runnable userA =  -> {\n            service.logic\"userA\";\n            service.removeValueInThreadLocal;\n            log.info\"ThreadLocal 값 제거 후 조회 -> {}\", service.lockUpValue;\n        };\n\n        Runnable userB =  -> {\n            service.logic\"userB\";\n            service.removeValueInThreadLocal;\n            log.info\"ThreadLocal 값 제거 후 조회 -> {}\", service.lockUpValue;\n        };\n\n        Thread threadA = new ThreaduserA;\n        threadA.setName\"thread-A\";\n\n        Thread threadB = new ThreaduserB;\n        threadB.setName\"thread-B\";\n\n        threadA.start;\n        threadB.start;\n\n        sleep3000; // Main Thread가 바로 종료되지 않도록한다.\n        log.info\"main exit\";\n    }\n\n    private void sleeplong time {\n        try {\n            Thread.sleeptime;\n        } catch InterruptedException e {\n            e.printStackTrace;\n        }\n    }\n}\n\n출력 예시\n> 상황에 따라 스레드가 실행되는 시점이 다를 수 있다.\nsh\n14:55:05.535 main INFO com.siwony.ifl_spring_advanced.trace.FieldServiceTest - main start\n14:55:05.539 thread-B INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 저장 name=userB -> nameStore=null\n14:55:05.538 thread-A INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 저장 name=userA -> nameStore=null\n14:55:06.546 thread-A INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=userA\n14:55:06.546 thread-B INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=userB\n14:55:06.546 thread-A INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=null\n14:55:06.546 thread-B INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=null\n14:55:08.541 main INFO com.siwony.ifl_spring_advanced.trace.FieldServiceTest - main exit\n\n- ThreadLocal를 사용해서 Thread가 ThreadLocalService의 똑같은 객체를 접근해 같은 ThreadLocal를 사용했지만 동시성 이슈가 발생하지 않았다.\n- A-Thread는 A-Thread가 저장한 값인 userA를 제대로 저장 후 값을 가져왔다.\n- B-Thread는 B-Thread가 저장한 값인 userB를 제대로 저장 후 값을 가져왔다.\n- A-Thread, B-Thread는 ThreadLocalService.remove를 통해 ThreadLocalService속 ThreadLocal의 값을 remove해서 삭제 후 lockUpValue매서드로 조회 했더니 null이 출력되었다.\n\n\n ThreadLocal의 주의사항\n여기서 한 가지 의문이 드는 점이 있는데,  \n\"어차피 Thread가 종료되면 Thread에 따라 ThreadLocal도 제거될 텐데 왜 ThreadLocal.remove를 통해 스레드 저장소의 저장된 값을 지우는 거지?\"라는 의문이 들 수 있다.\n\n하지만 이는 나중에 얘기치 못한 상황을 불러 올 수 있는데 특히 Thread Pool를 사용하는 Tomcat과 같은 시스템에서 문제가 발생할 수 있다.\n\n사용자 A의 요청                |  사용자 A의 요청에 대한 응답\n:-------------------------:|:-------------------------:\n!/assets/images/posts/programming/thread-local-issue-ex1.png  |  !/assets/images/posts/programming/thread-local-issue-ex2.png\n- 사용자A는 WAS에 요청하여 Thread-A를 사용해 사용자 A를 저장후 사용자A에게 HTTP응답을 했다.\n- 사용자A는 요청이 끝나 사용자A가 요청한 로직을 처리한 Thread-A는 Thread Pool에 반환되었다.\n- Thread-A가 파괴되지 않았으므로 Thread-A는 스레드 로컬에는 사용자A의 데이터가 남아있다.\n\n여기서 사용자B가 사용자B 즉, 자신의 정보를 조회하는 로직을 요청했는데, 하필 Thread-A를 사용하면 어떻게 될까?\n\n<img src=\"/assets/images/posts/programming/thread-local-issue-ex3.png\">\n\n1. 사용자B는 조회를 위한 HTTP요청을 한다.\n2. WAS는 스레드 풀에서 스레드를 하나 조회한다.\n3. 근데 하필 thread-A 가 할당되었다.\n4. Thread-A는 스레드 로컬에서 데이터를 조회한다.\n5. 스레드 로컬은 thread-A 전용 보관소에 있는 사용자A 값을 반환한다.\n6. 결과적으로 사용자A 값이 반환된다.\n7. 사용자B는 사용자A의 정보를 조회하게 된다.\n\n이렇게 사용자B가 사용자A를 조회하는 치명적인 문제가 발생할 수 있다.\n\n이러한 문제가 발생할 수 있으므로 스레드 로컬의 값을 ThreadLocal.remove 를 통해서 꼭 제거해야 한다.",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Synchronized 키워드 - 경쟁상태를 해결하는 방법",
    "url": "/programming/2022/03/29/synchronized-키워드---경쟁상태를-해결하는-방법/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "키워드는 Multi-Thread 환경에서 여러개의 쓰래드가 하나의 공유 변수에 동시에 접근할 때 이 발생하지 않도록 한다.",
    "content": "Synchronized 키워드 - 경쟁상태를 해결하는 방법\nsynchronized 키워드는 Multi-Thread 환경에서 여러개의 쓰래드가 하나의 공유 변수에 동시에 접근할 때 경쟁상태 - Race Condition이 발생하지 않도록 한다.\n\n그러면 어떻게 Synchronized 키워드는 경쟁상태를 해결할까?  \n그것은 바로 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 즉, blocking을 사용해 경쟁상태를 해결하고 있다.\n\n하지만 이를 너무 남발하면 성능 이슈가 발생하는데, 프로그래밍 내부적으로 block, unblock작업은 어느정도 공수가 들어가는 작업이다. 꼭 필요할 떄 사용하자.\n\n Synchronized 키워드 사용방법\n일반적으로 3가지 동기화 방법이 있다.\n1. 인스턴스 메소드 동기화\n2. 스태틱 메소드 동기화\n3. 메소드 속 동기화\n\n\n 1. 인스턴스 메서드에 사용하는 방법\njava\nclass A {\n    private int a = 0;\n\n    public synchronized void increaseA{\n        a++;\n        System.out.printlna;\n    }\n}\n\n위에 예시와 같이 메서드 시그니처에 추가하는 방식으로 사용할 수 있다.\n\n 주의할 점\n여기서 메서드에 synchronized가 붙으니까 메소드 단위로 동기화될 수 있다고 오해할 수 있는데, 해당 방법은 객체 단위로 동기화 된다. 위 예제를 이용해 설명을 하면, 위에 두 메서드는 동시에 수행될 수 없다.\n\n 2. 스태틱 메소드 동기화\njava\nclass A {\n    private int a = 0;\n\n    public static synchronized void increaseA{\n        a++;\n        System.out.printlna;\n    }\n}\n\n클래스 내의 static 메소드는 오직 하나만 존재한다 그러므로 여러 객체가 하나의 static메소드를 공유하므로, 모든 생성된 객체를 동기화 한다.  \n여러 객체들이 동시에 increase를 호출하면 1개의 쓰레드만 이 메서드에 진입할 수 있다.\n\n\n 3. 메소드 속 synchronized 블록\n메소드 단위로 synchronized를 적용하는 것은 비 효율적일 수 있다. 경쟁 상태 - Race condition가 발생하는 부분만 synchronized블럭을 사용해 동기화 할 수 있다.\n\n사용법은 synchronizedlock_object로 사용할 수 있는데 lock_object는 동기화 할 범위 즉, 인스턴스를 의미한다.\n\njava\npublic class A {\n    private long a = 0;\n\n    public void increase {\n        long temp = 0;\n\n        synchronized this {\n            a++;\n            temp = number;\n        }\n\n        System.out.printlntemp;\n    }\n}\n\n위 예제는 자신의 인스턴스를 동기화 하는 예제이다.",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Facade Pattern",
    "url": "/programming/2022/03/29/facade-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다.\n<img width=550px src=./img/facade-diagram.png>",
    "content": "Facade Pattern\n: 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다.\n<img width=550px src=./img/facade-diagram.png>\n\n- Facade는 건물의 앞쪽 정면 이라는 뜻을 가진다.\n- Facade는 자신이 가지고 있는 각 클래스의 기능을 정확히 알아야 한다.\n- Facade 패턴은 어떤 서브시스템에 대한 간단한 인터페이스로 제공하는 것이다. &rarr; FTP를 사용할때 그 안에 있는 로직을 직접 사용한다고 생각해보자 끔찍하다.\n- 전자레인지를 생각해보자. 우리는 전자레인지의 기능만 알고 사용하지 그안에 동작원리까지 알고 사용하는가?  \n  &rarr; 우리는 전자레인지의 버튼이 어떤 역활인지만 알면된다.\n\n Facade Pattern의 예시\n간단한 FTP client 형식적으로 만들어보자\n- FTP는 연결할 수 있고 디렉토리를 연결할 수 있고 연결을 끊을 수 있다.\n- Reader는 연결할 수 있고, 파일의 내용을 읽을 수 있고, 연결을 끊을 수 있다.\n- Reader는 연결할 수 있고, 파일의 내용을 쓸 수 있고, 연결을 끊을 수 있다.\n 퍼사트 패턴의 적용 전\n<img width=350px src=./img/before-facade.png>\n\nFTP class\njava\npublic class Ftp{\n\n    private String host;\n    private int port;\n    private String path;\n\n    public FtpString host, int port, String path{\n        this.host = hose;\n        this.prot = prot;\n        this.path = path;\n    }\n\n    public void connect{\n        System.out.println\"FTP host: \"+ host + \"Prot: \" + prot  + \"로 연결합니다.\"\n    }\n\n    public void moveDir{\n        System.out.printlnpath + \"로 연결을 종료합니다.\";\n    }\n\n    public void disconnect{\n        System.out.println\"연결을 종료합니다.\";\n    }\n}\n\nfile을 읽어오는 Reader class\njava\npublic class Reader{\n\n    private String fileName;\n\n    public ReaderString fileName{\n        this.fileName = fileName;\n    }\n\n    public void fileConnect{\n        System.out.println\"Reader: \"+ fileName +\" 로 연결합니다.\";\n\n    }\n\n    public void fileRead{\n        System.out.println\"Reader: \"+ fileName +\" 의 내용을 읽어옵니다..\";\n\n    }\n\n    public void fileDisconnect{\n            System.out.println\"Reader: \"+ fileName +\" 로 연결을 종료합니다.\";\n    \n    }\n\n}\n\nfile을 삽입하는 Writer class\njava\npublic class Writer{\n\n    private String fileName;\n\n    public WriterString fileName{this.fileName=fileName}\n\n    public void fileConnect{\n        System.out.println\"Writer: \"+ fileName +\" 로 연결합니다.\";\n\n    }\n\n    public void write{\n        System.out.println\"Writer: \"+ fileName +\" 로 파일쓰기를 합니다..\";\n\n    }\n\n    public void fileDisconnect{\n            System.out.println\"Writer: \"+ fileName +\" 로 연결을 종료합니다.\";\n    \n    }\n\n}\n\n결과 main method\njava\npublic class main{\n    public static void mainString args{\n        Ftp ftp = new Ftp\"www.foo.com\", 22, \"/home/etc\";\n        ftp.connect;\n        ftp.moveDir;\n\n        Writer writer = new Writer\"text.tmp\";\n        writer.fileConnect;\n        writer.write;\n\n        Reader reader = new Reader\"text.tmp\";\n        reader.connect;\n        reader.fileRead\n\n        reader.disConnect;\n        writer.disConnect;\n        ftp.disConnect;\n\n    }\n}\n\n- 클라이언트개발자가 Ftp기능을 사용하려면 Ftp, Writer, Reader의 객체가 어떻게 동작하는지 알아야 한다.\n- 퍼사드 객체를 통해 이 문제를 해결 할 수있다.\n\n 퍼사트 패턴의 적용 후\n<img width=300px src=./img/after-fasade.png>\n\nftp의 퍼사드인 sftpClient Class\n\njava\npublic class SftpClient{\n\n    private Ftp ftp;\n    private Writer writer;\n    private Reader reader;\n\n    public SftpClientFtp ftp, Reader reader, Writer writer{\n        this.ftp = ftp;\n        this.reader = reader;\n        this.writer = writer;\n    }\n\n    public SftpClientString host, int prot, String path, String fileName{\n        this.ftp = new Ftphost, prot, path;\n        this.reader = new ReaderfileName;\n        this.writer = new WriterfileName;\n    }\n\n    public void connect{\n        ftp.connect;\n        ftp.moveDir;\n        reader.connect;\n        writer.connect;\n    }\n    \n    public void disconnect{\n        reader.FileDisconnect;\n        writer.FIleDisconnect;\n        ftp.disconnect;\n    }\n\n    public void read{\n        reader.fileRead;\n    }\n\n    public void writer{\n        writer.write;\n    }\n}\n\n\n결과\njava\npublic class Main{\n    public static void mainString args{\n        SftpClient sftpClient = new SftpClient\"www.foo.com\", 22, \"/home/etc\", \"text.tmp\";\n        sftpClient.connect;\n\n        sftpClient.write;\n        sftpClient.read;\n        sftpClient.disconnect\n    }\n}\n\n- 클라이언트는 굉장히 간단하게 FTP기능을 간단하게 사용할 수 있다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "다이나믹 프록시 - Dynamic Proxy",
    "url": "/programming/2022/03/29/다이나믹-프록시---dynamic-proxy/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "런타임에 특정 인터페이스들을 구현하는 클래스 또는 인스턴스를 만드는 기술\n- 공식문서https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html",
    "content": "다이나믹 프록시 - Dynamic Proxy\n런타임에 특정 인터페이스들을 구현하는 클래스 또는 인스턴스를 만드는 기술\n- 공식문서https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html\n\n Proxy 패턴을 정적으로 개발자가 직접 구현 시 단점\n- 부가적인 기능을 추가할 때 마다 별도의 Proxy를 만들어야 한다.\n- 위임하는 코드가 중복해서 발생할 수 있다.\n\n\n 다이나믹 프록시 사용처\n- Spring Data JPA\n- Spring AOP\n- Mockito\n- Hibernate lazy initialization\n\n 단점\n- Class기반 Proxy를 만들 수 없다.\n- 코드의 유연성이 떨어진다.\n\n 사용 예제\n 클래스 구조\n- Book, BookService와 이를 구현하고 있는 DefaultBookService 가 있다.\njava\npublic class Book {\n\n    private String title;\n    public Book {}\n\n    public BookString title {\n        this.title = title;\n    }\n\n    public String getTitle {\n        return title;\n    }\n\n    public void setTitleString title {\n        this.title = title;\n    }\n}\n\npublic interface BookService {\n\n    void rentBook book;\n    void returnBookBook book;\n}\n\npublic class DefaultBookService implements BookService{\n    \n    @Override\n    public void rentBook book {\n        System.out.println\"rent: \" + book.getTitle;\n    }\n\n        @Override\n    public void returnBookBook book {\n        System.out.println\"return: \" + book.getTitle;\n    }\n}\n\n 동적으로 Proxy를 생성\n> Proxy.newProxyInstanceClassLoader, Class<?>, InvocationHandler\n1. 첫 번째 인자로 해당 Class를 불러온 ClassLoader를 넘겨준다.\n2. 두 번째 인자로 Proxy를 만들 객체의 interface를 Class 배열로 넘겨준다.\n3. 세 번째 인자로 이 Proxy의 메서드가 호출이 될 때 어떻게 처리해야 할지에 대한 설명을 넘겨준다.\n\n\njava\n    BookService bookService = BookService Proxy.newProxyInstance\n            BookService.class.getClassLoader, // BookService를 불러온 class loader\n            new Class{BookService.class}, // 어떤 interface의 Proxy 타입\n            new InvocationHandler { // method 타입을 어떻게 처리할 것 인지 정의\n                BookService bookService = new DefaultBookService;\n\n                @Override\n                public Object invokeObject proxy, Method method, Object args throws Throwable {\n                    System.out.println\"AAAA\";\n                    Object invokeValue = method.invokebookService, args;\n                    System.out.println\"BBBB\";\n                    return invokeValue;\n                }\n            }\n    ;\n\n\n Java의 다이나믹 프록시의 단점\n첫 번째로 자바에서 제공하는 동적 프록시는 유연하지 않다.\n> 메서드별로 다르게 적용하려고 하면 코드가 엄청 커진다.\n    \n만약 DefaultBookService의 rent메서드만 따로 다르게 출력하고 싶다면 다음과 같은 방식으로 해야 한다.\njava\n    BookService bookService = BookService Proxy.newPoxyInstance\n    BookService.class.getClassLoader, // BookService를 불러온 class loader\n    new Class{BookService.class}, // 어떤 interface의 Proxy 타입\n    new InvocationHandler { // method 타입을 어떻게 처리할 것 인지 정의\n        BookService bookService = new DefaultBookService;\n\n        @Override\n        public Object invokeObject proxy, Method method, Object args throws Throwable {\n            ifmethod.getName.equals\"rent\";{\n                System.out.println\"AAAA\";\n                Object invokeValue = method.invokebookService, args;\n                System.out.println\"BBBB\";\n                return invokeValuer\n            }\n\n\n            return method.invokebookService, args;\n        }\n    }\n;\n\n결국 proxy 클래스를 만들지 않는 수고를 덜 수 있지만 유연하지 않아 확장성이 떨어져 코드가 복잡하고 커지게 된다.\n\n두 번째는 class기반의 프록시를 만들 수 없다.  \n> class기반의 프록시를 만드는 방법은 ByteBuddy와 CGlib로 만들 수 있다\n\n다음글 class기반의 프록시 생성방법class-base-proxy",
    "tags": [
      "TIL",
      "byte-code-controller-way",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Java version 변경",
    "url": "/programming/2022/03/29/java-version-변경/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "현재 작성자 기준 17로 동작하고 있다.",
    "content": "Java version 변경\n\n 1. 현재 동작하는 java의 버전을 확인한다.\nbash\n$ java -version\njava version \"17.0.1\" 2021-10-19 LTS\nJavaTM SE Runtime Environment build 17.0.1+12-LTS-39\nJava HotSpotTM 64-Bit Server VM build 17.0.1+12-LTS-39, mixed mode, sharing\n\n현재 작성자 기준 17로 동작하고 있다.\n\n 2. 설치되어 있는 JVM 목록 확인\nbash\n$ /usr/libexec/java_home -V\nMatching Java Virtual Machines 3:\n    17.0.1 x86_64 \"Oracle Corporation\" - \"Java SE 17.0.1\" /Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home\n    11.0.11 x86_64 \"AdoptOpenJDK\" - \"AdoptOpenJDK 11\" /Library/Java/JavaVirtualMachines/adoptopenjdk-11.jdk/Contents/Home\n    1.8.0_292 x86_64 \"AdoptOpenJDK\" - \"AdoptOpenJDK 8\" /Library/Java/JavaVirtualMachines/adoptopenjdk-8.jdk/Contents/Home\n/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home\n\n현재 작성자는 다음 버전이 설치 되어 있다.\n- JDK1.8\n- JDK11\n- JDK17\n\n\n 3. JAVA_HOME 경로를 자신이 원하는 버전으로 설정한다.\n작성자는 JDK11로 변경할 것 이다.\nbash\n$ export JAVA_HOME=$/usr/libexec/java_home -v 11 \n$ source ~/.bash_profile",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Thread Pool",
    "url": "/programming/2022/03/29/thread-pool/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐Queue에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것",
    "content": "Thread Pool\n: 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐Queue에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것\n\n Java의 스레드의 특성\n- Java의 스레드는 CPU를 최대한 사용해서 많은 업무를 동시에 처리할 수 있게 도와준다.\n- 스레드를 생성하려면 약간의 시간과 메모리가 필요하다.\n- JVM은 스레드의 생성 개수에 대한 제약이 없다.\n  > &rarr; 지속적으로 생성한다면 성능저하 및 메모리 고갈의 문제가 생길 수 있다.\n\n Thread Pool의 필요성\n- JVM의 옵션등으로 스레드의 생성을 제어를 할 수 없다.\n- 무제한적인 스레드의 생성을 막기위한 스레드 관리 방식이 필요하다.\n- Thread Pool은 어플리케이션이 선택적으로 사용할 수 있는 스레드 관리 방식이다.\n\n Thread Pool방식을 사용하는 소프트웨어\n대표적으로 Tomcat과 같은 웹서버가 있다.  \n- 웹서버는 엄청 많은 요청이 들어올 수 있는데 요청마다 스레드를 생성하는 것은 JVM의 메모리를 급격하게 소비시키며 성능에도 저하가 발생할 수 있다. \n- 이럴 때 최대 스레드 개수를 지정해 놓으면 지정한 스레드 개수 이상의 HTTP 요청에 대해서 처리하지 않고 기다리다가 \n- 유휴상태의 스레드가 생기면 그 때 사용하지 않는 스레드를 재사용하여 HTTP요청을 처리한다.\n\n Thread Pool의 구조\n<img src=\"/assets/images/posts/programming/thread-pool.png\">\n\n1. Thread Pool은 작업처리에 사용되는 스레드를 제한된 개수만큼 정한다.\n2. 작업큐 - Queue에 들어오는 작업 - Task들을 하나씩 스레드가 맡아 처리한다.\n3. 그 후 스레드에서 Task가 끝나면 Application에 반환한다.",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Custom Repository",
    "url": "/back-end/2022/03/29/custom-repository/",
    "category": "back-end",
    "date": "2022-03-29",
    "excerpt": "개발을 하다 보면 Spring Data Jpa제공하는 Query Method만으로 부족한 경우가 있다.  \n이를 위해 Custom한 Repository를 Data JPA와 함께 사용하고 싶을 경우 사용한다.  \n> 대표적으로 Querydsl과 DataJpa와 같이 사용하는 경우가 있다.",
    "content": "Custom Repository\n 왜 필요할까?  \n개발을 하다 보면 Spring Data Jpa제공하는 Query Method만으로 부족한 경우가 있다.  \n이를 위해 Custom한 Repository를 Data JPA와 함께 사용하고 싶을 경우 사용한다.  \n> 대표적으로 Querydsl과 DataJpa와 같이 사용하는 경우가 있다.\n\n 대략적인 워크플로우\n보통 Spring Data Jpa를 사용할 경우 JpaRepository를 상속받아서 사용한다.  \nCustomRepository를 생성하기 전에 xxRepository가 JpaRepository를 상속받는 구조이다\n\n<img width=550 src=\"/assets/images/posts/back-end/custom-repo-structure.png\">\n\n1. 사용할 DomainRepository에 JpaRepository와 xxCustomRepository를 extends받는다.\n2. xxCustomRepository를 구현한다. 구현체 xxCustomRepositoryImpl\n3. xxRepository 에서 DomainRepository와 xxCustomRepository를 사용할 수 있다.\n\n CustomRepository의 규칙\n- Custom Repository Interface 형식 : xxCustomRepository\n- Custom Repository Implements 형식 : xxCustomRepositoryImpl",
    "tags": [
      "spring",
      "jpa",
      "data-jpa",
      "TIL"
    ]
  },
  {
    "title": "Adepter Pattern",
    "url": "/programming/2022/03/29/adepter-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 서로 다른 인터페이스를 가진 두 클래스를 어댑터 클래스로 인터페이스를 통일 시켜 사용하는 방법이다.\n- 관계가 없는 인터페이스를 같이 사용이 가능하다.  \n    > 재사용성이 증가한다.\n- 기존 클라이언트 단의 코드 수정을 최소화 할 수 있다.\n- 어댑터 클래스에서 통일 시켜주는 부분을 하나씩 구현해야 한다.",
    "content": "Adepter Pattern\n: 서로 다른 인터페이스를 가진 두 클래스를 어댑터 클래스로 인터페이스를 통일 시켜 사용하는 방법이다.\n- 관계가 없는 인터페이스를 같이 사용이 가능하다.  \n    > 재사용성이 증가한다.\n- 기존 클라이언트 단의 코드 수정을 최소화 할 수 있다.\n- 어댑터 클래스에서 통일 시켜주는 부분을 하나씩 구현해야 한다.\n\n 기본설계\n<img width=550px src=./img/adepter-pattern-diagram.png>\n\nAdaptee 클래스를 Adapter를 통해 Adaptee에 있는기능을 Adapter로 맞게 변환하여 client가 사용할 수 있게 한다.\n\n Adepter Pattern의 사용예시\nReference: https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/dashboard  \n요구사항\n- 수에 2배 연산, 1/2 연산을 float로 반환하여 수행하는 객체를 만들어라\n- 구현객체의 이름은 Adepter\n- Math클래스에는 위와같은 기능을 double로 반환하는 매서드가 정의되어있다.\n\nMath class\njava\npublic class Math{\n    public static double towTimedouble num{return num  2;}\n    public static double halfdouble num{return num / 2;}\n}\n\n\nAdepter Pattern으로 요구사항에 맞게 float로 값을 반환\njava\n//선언과 구현을 분리하기위해 인터페이스 Adepter선언\npublic interface Adepter{\n    public float towTimeToFloatfloat num;\n    public float halfTOfFloatfloat num;\n}\n\npublic class AdepterImpl implements Adepter{\n    @Override\n    public float towTimeToFloatfloat num{\n        return float Math.towTimedoublenum;\n    }\n\n    @Override\n    public float halfTOfloatfloat num{\n        return float Math.halfdoublenum;\n    }\n}\n\n\n결과\njava\npublic class Main {\n    public static void mainString args {\n        Adapter adapter = new AdapterImpl;\n\n        //200반환\n        System.out.printlnadapter.towTimeToFloat100f;\n        //50반환\n        System.out.printlnadapter.halfTOfFloat100f;\n    }\n}",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "디자인 패턴",
    "url": "/programming/2022/03/29/디자인-패턴/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 자주 사용하는 설계 패턴을 정형화하여 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계\n> 알고리즘과 유사하지만 명확하게 정답이 있는것은 아니며 프로젝트 상황에 맞게 적용가능하다.",
    "content": "디자인 패턴\n: 자주 사용하는 설계 패턴을 정형화하여 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계\n> 알고리즘과 유사하지만 명확하게 정답이 있는것은 아니며 프로젝트 상황에 맞게 적용가능하다.\n\n 장점\n- 개발자설계자 간의 원활한 소통\n- 소프트웨어 구조 파악 용이\n- 재사용을 통한\u001c개발 시간 단축\n- 설계 변경 요청에 대한 유연한 대처\n\n GOFGang Of Four디자인 패턴\n: 객체지향 개념에 따른 설계중 재사용할 경우 유용한 설계를 디자인 패턴으로 정리해 놓은것\n> 소프트웨어를 설계 할 때는 기존에 경험이 중요하다. 그러나 모든 사람이 다양한 경험을 가질 수 없다.\n- 총 23개의 디자인패턴\n- 이를 이해하여 잘 활용한다면 경험이 부족하더라도 좋은 소프트웨어 설계가 가능하다.\n\n 생성 패턴\n: 객체를 생성하는 것과 관련된 패턴이다.\n- 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화한다.\n- 코드의 유연성을 높여준다.\n\n 생성패턴의 종류\n- Singleton./Singleton-Pattern.md\n- Prototype\n- Builder\n- Abstract Factory\n- Chaining\n\n 구조 패턴\n: 프로그램 내 자료구조, 인터페이스 구조 등 프로그램을 설계하는데 활용 될 수 있는 패턴\n- 클래스 객체들의 구성을 통해 더 큰 구조를 만들 수 있게 해준다.\n- 복잡한 구조를 개발/유지보수 를을 쉽게 만들어준다.\n\n 구조패턴의 종류\n- Adapter./Adepter-Pattern.md\n- Composite\n- Bridge\n- Decorator./Decorator-Pattern.md\n- Facade\n- FlyWeight\n- Proxy./Proxy-Pattern.md\n\n 행위 패턴\n: 반복적으로 사용되는 객체들의 상호작용을 패턴화한 패턴\n- 클래스나 객체들이 상호작용 및 책임을 분산 하는 방법을 제공한다.\n- 독립적으로 일을 처리하고자 할 때 사용한다.\n\n 행위패턴의 종류\n- Template Method\n- Interpreter\n- Iterator\n- Observer./Observer-Pattern.md\n- Strategy./Strategy-Pattern.md\n- Visitor\n- Chain of Responsibility\n- Command\n- Mediator\n- State\n- Memento",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "페이징 & 정렬",
    "url": "/back-end/2022/03/29/페이징-정렬/",
    "category": "back-end",
    "date": "2022-03-29",
    "excerpt": "",
    "content": "페이징 & 정렬\n 순수 JPA",
    "tags": [
      "spring",
      "jpa",
      "data-jpa",
      "TIL"
    ]
  },
  {
    "title": "바이트 코드 조작",
    "url": "/programming/2022/03/29/바이트-코드-조작/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 코드에서 버그 찾는 툴\n- 시간 복잡도 계산",
    "content": "바이트 코드 조작\n\n 바이트코드 조작 활용 예시\n 1. 프로그램 분석\n- 코드에서 버그 찾는 툴\n- 시간 복잡도 계산\n\n 2. 클래스 파일 생성\n- 프록시\n  > JPA Entity, Spring AOP\n- 특정 API호출 접근 제한\n- 스칼라 같은 함수형 언어의 컴파일러\n\n 3. 그 밖에...\n- 프로파일러 - newrelic\n- 최적화\n- logging",
    "tags": [
      "TIL",
      "coding",
      "JVM",
      "development",
      "java"
    ]
  },
  {
    "title": "Concurrent 프로그래밍",
    "url": "/programming/2022/03/29/concurrent-프로그래밍/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 동시에 여러 작업을 진행할 수 있는 프로그래밍\n- ex. 유튜브 보면서 코딩",
    "content": "Concurrent 프로그래밍\n- 동시에 여러 작업을 진행할 수 있는 프로그래밍\n- ex. 유튜브 보면서 코딩\n 자바에서 지원하는 Concurrent 프로그래밍\n- 멀티 프로세싱 ProcessBuilder\n- 멀티 스레드\n  > Thread, Runnable 등...\n\n 기본적인 Threed\n 구현 방법\n Thread상속\njava\npublic static void mainString args {\n    HelloThread helloThread = new HelloThread;\n    helloThread.start;\n    System.out.println\"hello : \" + Thread.currentThread.getName;\n}\nstatic class HelloThread extends Thread {\n    @Override\n    public void run {\n        System.out.println\"world : \" + Thread.currentThread.getName;\n    } \n}\n\n Runnable 구현, 람다\njava\nThread thread = new Thread -> System.out.println\"world : \" + Thread.currentThread.getName;\nthread.start;\nSystem.out.println\"hello : \" + Thread.currentThread.getName;\n\n 주요기능\n sleep\n: 해당 스레드를 일정 시간동안 멈춘다.\n- 락을 주지않는다.\n  > 데드락의 위험성\n- interrupt 메소드가 호출되면 InterruptedException가 발생한다.\n사용방법\njava\nString importantInfo = {\n    \"Mares eat oats\",\n    \"Does eat oats\",\n    \"Little lambs eat ivy\",\n    \"A kid will eat ivy too\"\n    };\n\nfor int i = 0; i < importantInfo.length; i++ {\n    // 4초 간 중지한다\n    Thread.sleep4000;\n    // 메세지를 출력한다\n    System.out.printlnimportantInfoi;\n}\n\n\n interrupts\n: 해당 스레드를 꺠워서 InterruptedExeption를 발생 시킨다.\n- InterruptedExeption를 예외처리 하는 것은 해당 스레드가 결정한다.\njava\nThread thread = new Thread\n         -> {\n            try {\n                Thread.sleep4000L;\n            } catch InterruptedException e {\n                e.printStackTrace;\n            }\n            System.out.printlnThread.currentThread;\n        }\n;\n\nthread.start;\nthread.interrupt;\n\n\n join\n: 다른 스레드가 끝날 때까지 기다린다.\n- join를 사용하는곳 에서 InterruptedException이 발생한다.\njava\nThread thread = new Thread\n         -> {\n            try {\n                Thread.sleep2000;\n            } catch InterruptedException e {\n                e.printStackTrace;\n            }\n            System.out.println\"thread is done\"; // 먼저 출력\n        }\n;\nthread.start;\nthread.join;\nSystem.out.println\"main thread is done\";",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "메소드 레퍼런스 - Method Reference",
    "url": "/programming/2022/03/29/메소드-레퍼런스---method-reference/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": Lambda 표현식을 더 간단하게 표현하는 방법입니다.\n- 메소드 레퍼런스를 이해 하려면 Lambda를 먼저 이해해야 한다.\n- 람다식이 구현되어있는 경우 사용할 수 있는 메서드 참조용 특수 문법이다.",
    "content": "메소드 레퍼런스 - Method Reference\n: Lambda 표현식을 더 간단하게 표현하는 방법입니다.\n- 메소드 레퍼런스를 이해 하려면 Lambda를 먼저 이해해야 한다.\n- 람다식이 구현되어있는 경우 사용할 수 있는 메서드 참조용 특수 문법이다.\n\n Method Reference를 만드는 유형\n<img width =500 src=\"/assets/images/posts/programming/method-reference.jpeg\">\n\n> 참고자료 - 모던 자바 인 엑션 3장\n\n 1. 정적 메서드 참조\n: 파라미터로 전달받은 변수의 메서드를 사용하는게 아닌, 정적 메서드의 인자로 사용된다.\n\n예제\n|                   Lambda                    |      Method Reference     | \n|---------------------------------------------|---------------------------|\n|String x -> Integer.parseIntx          |Integer::parseInt        |\n|SimpleMemberVO x -> SimpleMemberVO.ofx |SimpleMemberVO::of       |\n\n- Integer의 parseInt 메서드는 Integer::parseInt로 표현할 수 있다.\n- String x -> Integer.parseIntx의 경우 파라미터 x를 parseInt의 인자로 사용된다.\n\n 2. 다양한 형식의 인스턴스 메서드 참조\n: 파라미터로 전달받은 변수의 메서드를 사용한다.\n예시\n|                       Lambda                     |       Method Reference       | \n|------------------------------------------------- |------------------------------|\n|Instant x -> x.toEpochMilli                 |Instant::toEpochMilli       |\n|Optional<T> x -> x.isPresent                |Optional::isPresent         |\n|List<T> x -> x.stream                       |Collection::stream          |\n|String x, String y -> x.compareTolgnoreCasey|String::compareToIgnoreCase |\n> T는 제네릭 타입 즉, 아무타입이나 올 수 있다.\n- String의 length메서드를 String::length로 사용 가능\n- Instant x -> x.toEpochMilli의 경우 파라미터 x를 받아서 x자신의 메서드toEpochMilli를 수행한다.\n  \nString x, String y -> x.compareToIgnoreCasey를 표현한 String::compareToIgnoreCase는 무엇인가.\n1. 첫번째 파라미터가 메소드의 수신자가 된다.\n2. 나머지 파라미터는 해당 메소드로 전달 된다.\n\n 3. 기존 객체의 인스턴스 메서드 참조\n: 기존에 이미 생성된 인스턴스의 인자로 사용 된다.\n- 정적 메서드의 인자와는 다르다.\n\n예시\n|                   Lambda                    |      Method Reference      | \n|---------------------------------------------|----------------------------|\n|Long x -> memberRepository.findByIdx   |memberRepository::findById|\n|String x -> member.updateUsernamex     |member::updateUsername    |\n\n 생성자 참조\n- Method Reference와 비슷하다.\n- x -> new UserDtox를 UserDto::new와 같은 형태로 사용할 수 있다.",
    "tags": [
      "TIL",
      "grammar",
      "coding",
      "development",
      "java",
      "java8"
    ]
  },
  {
    "title": "Callable과 Future",
    "url": "/programming/2022/03/29/callable과-future/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "은 과 다르게 작업task의 결과를 받을 수 있다.  \n그리고 를 이용해 의 작업물을 객체로 감싸서 받을 수 있다.",
    "content": "Callable과 Future\nCallable은 Runnable과 다르게 작업task의 결과를 받을 수 있다.  \n그리고 ExecutorService를 이용해 Callable의 작업물을 Future객체로 감싸서 받을 수 있다.\n\n Callable\n- 인자가 없고 리턴 타입의 객체를 리턴한다.\n- ExecutorService의 submit매서드를 사용하여 Task를 실행할 수 있다.\n\n Future\n- 비동기적인 작업의 현재 상태를 조회하거나 결과를 가저 올 수 있다.\n- 블로킹 콜을 이용해 최종 결과를 얻는다.\n  > 작업이 완료될 때 까지 기다린다.\n- 지연 완료 - pending Completion 객체라고도 한다\n\n get - 결과를 가져온다.\n오버로딩된 두가지 메서드를 제공한다.\n- 계산이 완료될 때까지 기다린 다음에 결과를 검색한다.\n  java\n  V get throws InterruptedException, ExecutionException;\n  \n- 최대 지정된 시간까지 기다렸다가 사용 가능한 경우 객체를 검색한다.\n  java\n  V getlong timeout, TimeUnit unit throws InterruptedException, ExecutionException,TimeoutException;\n  \n\n예시\njava\nExecutorService executorService = Executors.newFixedThreadPool10;\n\nCallable<String> callable =  -> {\n    Thread.sleep2000L;\n    return \"Callable done\";\n};\n\nFuture<String> future = executorService.submitcallable;\nSystem.out.println\"Get result\"; // blocking call - 약 2초 후 결과를 가져온다.\nString result = future.get;\nSystem.out.printlnresult;\n\nexecutorService.shutdown;\n\n- \"Get result\"가 출력된 후 약 2초후 Future에서 반환한 \"Callable done\"가 출력된다.\n\n isDone, isCancelled - 작업 상태 확인하기\n- isDone은 작업이 안료되면 true를 반환 그렇지 않으면 false\n  java\n  boolean isDone;\n  \n- isCancelled 착업이 완료된 경우 true를 반환하고, 작업이 정상적으로 종료되거나 예외 또는 취소된 경우도 true를 반환한다.\n  java\n  boolean isCancelled;\n  \n\n cancelboolean mayInterruptIfRunning - 작업취소하기\n: 해당 작업을 취소하려 할 떄 사용한다.\njava\nboolean cancelboolean mayInterruptIfRunning;\n\n- 작업이 완료되었거나, 취소할 수 없는 경우에 false를 반환한다.\n- 성공적으로 취소했으면, true 아니면 false을 반환한다.\n- 작업이 이미 완료되었거나, 취소되었거나, 다른 이유로 취소할 수 없는 경우에는 false를 반환한다.\n\n ExecuterService의 invokeAll과 invokeAny\n> 여러개의 동시 Callable작업에 대한 처리를 담당하지만 어떤 차이점이 있을까?\n invokeAll - 모든 Future목록을 반환한다.\n: 태스크를 실행하고 모두 완료되거나 시간 초과가 만료될 때, 상태 및 결과를 저장하고 있는 Future목록을 반환한다.\njava\n<T> List<Future<T>> invokeAllCollection<? extends Callable<T>> tasks throws InterruptedException;\n\n<T> List<Future<T>> invokeAllCollection<? extends Callable<T>> tasks, long timeout, TimeUnit unit\nthrows InterruptedException;\n\n- 이 작업이 진행되는 동안 현재 컬렉션이 수정되면 메서드의 결과가 정의되지 않는다.\n- 동시에 실행한 작업중에 가장 오래걸리는 작업만큼 시간이 소요된다.\n\n예시\njava\nExecutorService executorService = Executors.newFixedThreadPool10;\n\nCallable<String> callable1 =  -> {\n    Thread.sleep1000L;\n    return \"Java\";\n};\nCallable<String> callable2 =  -> {\n    Thread.sleep2000L;\n    return \"Spring\";\n};\nCallable<String> callable3 =  -> {\n    Thread.sleep1500L;\n    return \"JPA\";\n};\nList<Future<String>> futures = executorService.invokeAllArrays.asListcallable1, callable2, callable3;\n\nforFuture<String> f : futures{\n    System.out.printlnf.get;\n}\n\nexecutorService.shutdown;\n\n- 약 2초를 기다린 후 가장 작업이 빨리 끝난 순서대로 \"Java\", \"JPA\", \"Spring\"이 출력 되었다.\n\n invokeAny\n: 가장 먼저 완료된 작업의 결과를 바로 반환한다.\njava\n<T> T invokeAnyCollection<? extends Callable<T>> tasksthrows InterruptedException, ExecutionException;\n\n<T> T invokeAnyCollection<? extends Callable<T>> tasks, long timeout, TimeUnit unit \nthrows InterruptedException, ExecutionException, TimeoutException;\n\n- 이 작업이 진행되는 동안 지정된 컬렉션이 수정되면 이 메서드의 결과가 정의되지 않는다.\n- 동시에 실행한 작업중에 제일 짧게 걸리는 작업만큼 시간이 걸린다.\n- 이 또한 블록킹 콜\n\n에시\njava\nExecutorService executorService = Executors.newFixedThreadPool10;\n\nCallable<String> callable1 =  -> {\n    Thread.sleep1000L;\n    return \"Java\";\n};\n\nCallable<String> callable2 =  -> {\n    Thread.sleep2000L;\n    return \"Spring\";\n};\n\nCallable<String> callable3 =  -> {\n    Thread.sleep1500L;\n    return \"JPA\";\n};\n\nString future = executorService.invokeAnyArrays.asListcallable1, callable2, callable3;\nSystem.out.printlnfuture;\n\nexecutorService.shutdown;\n\n- 대략 1초를 기다리고 가장 먼저 완료된 작업의 결과\"Java\"가 바로 반환된다.",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "JVM",
    "url": "/programming/2022/03/29/jvm/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> 이 md는 Java7버전 기준으로 작성되었어요... Permanent Generation이 삭제가 되어버리네...?? 그와중에 블로그들 왜 다 java7버전 기준으로 정리함 어이없음 ㅋㅋㅋㅋㅋ 역시 전자정부표준프레임워크의 나라...?",
    "content": "JVM\n> 이 md는 Java7버전 기준으로 작성되었어요... Permanent Generation이 삭제가 되어버리네...?? 그와중에 블로그들 왜 다 java7버전 기준으로 정리함 어이없음 ㅋㅋㅋㅋㅋ 역시 전자정부표준프레임워크의 나라...?\n\n: JVM이란 Java Virtual Machine의 약자로 자바 가상 머신이다.\n\n> 가상머신?  \n> : 프로그램을 실행하기 위해 물리적 머신즉, 컴퓨터과 유사한 머신을 소프트웨어로 구현한 것\n\n 왜 JVM을 알아야 할까? + 동기부여\n- 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해 &rarr; 성능튜닝시 필요하다.\n- 코드만 찍어내는 무능한 프로그래머가 아니라 엔지니어로서 내부 동작 원리를 알고 근본적인 문제를 해결하기 위해\n- 내가 사용하는 기술 스텍에 대해 자세히 알고 싶어서.\n\n Java의 목표\n WORAWrite Once Run Anywhere\n- WORA를 구현하기 위해 물리적인 머신과 별개의 가상 머신을 기반으로 동작하도록 설계되었다.\n- 이를 구현한 구현체가 JVM이다.\n- Java Byte code를 실행하고자 하는 모든 하드웨어에 JVM을 동작시킴으로 Java 실행 코드를 변경하지 않고 모든 종류의 하드웨어에서 동작할 수 있다.\n  > 특정 OS에 대한 JVM만 있으면 플랫폼에 상관없이 Java를 실행할 수 있다!\n\n JVM의 특징\n- 스택 기반의 가상 머신 &harr; 레지스터 기반 가상 머신\n  > 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.\n- symbolic references심볼릭 레퍼런스\n  > primitive data type를 제외한 모든 타입클래스와 인터페이스을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.\n- 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장  \n  > C/C++ 등의 전통적인 언어는 플랫폼에 따라 int형의 크기가 변한다.  \n  JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.\n- 네트워크 바이트 오더network byte order - 뭔말인지 모르겠다.\n  > 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다.\n\n>  symbolic references심볼릭 레퍼런스\n> : 참고하는 클래스의 특정 메모리 주소를 참조 관계로 구성한 것이 아닌 참조하는 대상의 이름만을 지칭한 것이다.  \n> Class 파일이 JVM에 올라가게 되면 Symbolic Reference는 그 이름에 맞는 객체의 주소를 찾아서 연결하는 작업을 수행한다.  \n> 그러므로, 실제 메모리 주소가 아니라 이름만을 가진다.\n\n\n JVM의 역할\n- Java 애플리케이션을 Class Loader를 통해 읽어 들여 자바 API와 함께 실행한다.\n- JVM은 자바와 OS사이에서 중개자 역할을 수행하여 OS에 독립적인 플랫폼을 갖게 해준다.\n  > OS의 메모리에 직접접근하는 것이 아닌 JVM이라는 가상 머신을 통해 간접적으로 접근한다.\n- GCGarbage Collector  \n  : JVM이 GC를 통해 자동으로 메모리를 관리 해준다.\n\n Java프로그램 실행과정\n> JVM 구성을 알기전에 Java프로그램의 실행과정을 알아보자\n\n<img width=600px src=\"/assets/images/posts/programming/jvm-execute-level.png\">\n\n1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다.\n   > JVM은 이 메모리를 용도에 따라 여러 영역으로 관리한다.\n2. 자바 컴파일러javac가 Java 소스 코드.java를 읽어 Java 바이트 코드.class로 변환한다.\n3. JVM의 Class Loader를 통해 .class 파일들을 JVM으로 로딩한다.\n4. 로딩된 .class파일들을 Excution engine을 통해 해석된다.\n5. 해석된 byte code는 Runtime Data Area 에 배치되어 실질적인 수행이 이루어진다.\n   > 이러한 과정속에서 JVM은 필요에 따라 GC같은 관리 작업을 수행한다.\n\n JVM의 구성\n<img width=600 src=\"/assets/images/posts/programming/jvm-component.png\">\n\n> 클래스 로더Class Loader가 컴파일된 Java byte code를 런타임 데이터 영역Runtime Data Areas에 로드하고, 실행 엔진Execution Engine이 Java byte code를 실행한다.\n\n 1. Class Loader클래스 로더\n: JVM내로 클래스.class를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.\n 1 - 1. 특징\n- 동적 로드  \n  : 컴파일 타임이 아닌 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크한다.\n- 계층 구조 - Hierarchical  \n  : 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다.\n    > 최상위 클래스 로더는 부트스트랩 클래스 로더Bootstrap Class Loader이다.\n- 로딩 요청 위임 - Delegate Load Request  \n  : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다.\n    > 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하여 상위 클래스 로더에 있다면 해당 클래스를 사용하고,  \n    > 없다면 로드를 요청받은 클래스 로더가 클래스를 로드한다.\n- 가시성 제약 조건 - Have Visibility Constraint  \n  : 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없다.\n- 언로드 불가 - Cannot unload classes  \n  : 클래스 로더에 의해 로딩된 클래스들은 다시 JVM상에서 없앨 수 없다.\n  > 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.\n\n 1 - 2. 클래스 로드 과정\n자바의 동적 로딩 기능은 클래스로더 서브 시스템에 의해 처리된다.\n컴파일 시점이 아닌 클래스를 처음 참조하는 런타임 시점에 Loading, Linking, Initialization 작업이 이루어진다.\n\n 1 Loading - 로딩\nBootstrap, Extension, Application 컴포넌트들에 의해 클래스들이 로드되며,  \n이 세가지 클래스 로더들은 모두 상속관계로 정의되어 있으며 delegate위임 방식으로 작업을 진행한다.\n\n- Bootstrap ClassLoader\n  - JVM을 가동할 떄 생성되며, 자바가 아닌 네이티브 코드로 구현되어 있다.\n  - jre의 lib폴더에 있는 rt.jar 파일을 찾아 자바 API들을 로드하여 이 로더가 우선 순위가 가장 높다.\n- Extension ClassLoader\n  - 기본 자바 API를 제외한 확장 클래스를 로드한다.\n    > 다양한 보안 확장 기능 등을 여기에서 로드하게 된다.\n  - jre의 lib폴더에 있는 모든 확장 코어 클래스 파일들을 로드한다.\n- Application ClassLoader\n  - Extension ClassLoader의 자식이며 시스템 클래스로더 - System ClassLoader라고 불린다.\n    > Application 레벨에 있는 클래스를 로드한다. 즉, 사용자가 지정한 $CLASSPATH내의 클래스를 로드한다.\n\n 2 Linking - 연결\n- verify - 검증 : 바이트코드 검증기는 생성된 자바 바이트코드가 적절한지 대해 검증한다.\n  - 검증이 실패할 경우 검증오류를 발생시킨다.\n- prepare - 준비 : 모든 정적변수의 메모리가 할당되며 기본 default 값으로 할당한다.\n- resolve - 해석 : 모든 심볼릭한 메모리 참조를 메서드 영역에 있는 타입으로 직접 참조한다.\n\n 3 Initialize - 초기화\n모든 정적 변수가 자바 코드에 명시된 값으로 초기화되며 정적 블록이 실행 된다.\n\n 2. Execution Engine실행 엔진\n런타임 데이터 영역에 할당된 바이트 코드는 실행엔진에 의해서 실행된다.\n- 그래서 실행 엔진은 byte code를 JVM내부에서 기계가 실행할 수 있는 형태로 변경한다.\n- 이 때 두가지 방법을 사용한다. Interpreter, JIT\n- 실행 엔진이 어떻게 동작하는지는 JVM 명세에 규정되지 않았다.\n  > 표준이 없어 여러 JVM 벤더들은 다양한 기법으로 실행 엔진을 향상시키고 다양한 방식의 JIT컴파일러를 도입하고 있다.\n\n 2-1. Interpreter인터프리터\n: Java byte code를 명령어 단위로 읽어 실행하는 방식\n- 한줄씩 실행하기 때문에 느리다는 단점을 가지고 있다.\n\n 2-2. JITJust In TIme\n: 인터프리터 방식으로 실행하다 적절한 시점에 byte code를 컴파일하여 native code로 변경한 후 더는 인터프리팅하지 않고 native code를 직접 실행하는 방식 \n- 네이티브 코드는 캐시에 저장되어, 한번 컴파일된 코드는 빠르게 실행된다.\n- 하지만, JIT컴파일러가 컴파일하는 과정은 byte code를 인터프리팅 하는 것보다 느리다.\n  > 한 번만 실행될 코드는 인터프리팅하는게 이득이다.\n- JIT컴파일러를 사용하는 JVM은 내부적으로 해당 메서드의 수행을 체크하고, 일정 정도를 넘을 때 컴파일을 수행한다.\n\n 2-3 GCGabage collector\n아무 참조가 없는 인스턴스를 모아 제거하는 역할.\n\n 3. Runtime Data Area - Java 7기준\n> 시간이 된다면 Java8버전 이후 JVM의 메모리 구조를 정리해야겠다.\n\n: JVM이 Java ByteCode를 실행하기 위해 사용되는 메모리 공간이다.\n- 크게 5가지 영역으로 구분할 수 있다.\n  > Method Area, Heap Area, Stack Area, PC Registers, Native Method Stacks\n\n<img width=\"385\" src=\"/assets/images/posts/programming/runtime-data-area1.png\">\n\n 3 - 1. Method Area - 메서드 영역\n- 모든 클래스 수준클래스명, 부모클래스명, 메소드, 변수의 데이터가 저장된다.\n- 공유자원 + JVM당 한개의 영역을 가지고 있다.\n\n 3 - 2. Heap힙 영역\n- 모든 인스턴스 오브젝트클래스, 배열 등가 저장되는 공간이다.\n- GC의 관리 대상이다.\n- 물론 class 영역에 올라온 클래스들만 객체로 생성할 수 있다.\n- 당 하나의 영역밖에 존재하지 않으며 또한 공유자원이다.\n\nJava7 버전까지의 Heap은 크게 3가지부분으로 나눌 수 있다.\n  > Permanent Generation제거 됨, New/Young Generation, Tenured Generation  \n\n<img src=\"/assets/images/posts/programming/heap-component.png\">\n\nJava8 이후 메모리 구조  \n<img src=\"/assets/images/posts/programming/java-8-jvm-metaspace.jpg\">\n\n 1 Permanent Generation - Java8부터 제거됨\n> Permanent Generation가 제거되고, OS 레벨에서 관리되는 Native 메모리 영역에 Metaspace 가 추가되었다.\n\n: 생성된 객체들의 정보의 주소값이 저장된 공간이다.\n- Class loader에 의해 로드되는 class나 method 등에 대한 Meta 정보가 저장되며 JVM에 의해 사용된다.\n- 내부적으로 Reflection 기능을 사용하는 Spring Framework를 이용할 경우, 이 영역에 대한 고려가 필요하다.\n- Permanent Generation영역은 Java8부터 제거되고 native영역 중 Metaspace가 생겼다.\n\n 3 - 3. Stack Area - 스택 영역\n- 여러형태의 변수/임시 데이터, threed/method 정보, 지역변수, 매개변수, 리턴 값, 연산시 일어나는 값들을 저장한다.\n- 각각의 thread마다 개별의 스택영역이 존재한다.\n- 메서드 호출시 각각의 스텍 프레임해당 메서드만을 위한 공간이 생성된다.\n- 메서드 수행이 끝나면 스텍 프레임 별로 삭제한다.\n\n 1 스택 프레임의 세가지 서브 엔티티\n- 지역변수 배열 - Local Variable Array: 메서드의 지역변수의 개수와 해당하는 값에 대한 정보를 담고있다.\n- 피연산자 스택 - Operand Stack: 중간연산이 필요로 할 때, 연산작업을 수행하기 위한 작업공간이다.\n- 프레임 데이터 - Frame Data: 메서드에 해당하는 심볼이 저장된다.\n\n 3 - 4. PC Register\n: Threed가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 부분을 기록하는 부분이다.\n- Threed가 시작될때 생성되며, Threed마다 하나씩 존재한다.\n- 현재 수행중인 JVM 명령어의 주소를 갖는다.\n\n 3 - 5. Native Method stack\n실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역\n> Java 프로그램이 컴파일되어 생성하는 바이트코드가 아니다. 즉, Java가 아닌 다른언어로 작성된 코드를 위한 공간이다.\n- Java Native Interface를 통해 바이트 코드로 전환하여 저장한다.\n- 일반프로그램처럼 커널이 스텍을 잡아 독자적으로 프로그램을 실행시키는 영역이다.\n  > C언어의 code를 실행시켜 커널에 접근이 가능하다!\n\n New/Young Generation\n1. Eden 영역에서 minor GC가 일어날 때\n2. Eden 영역에 있는 값들을 Survivor 0 혹은 1 영역에 복사하고\n3. 이 영역을 제외한 나머지 영역의 객체를 삭제한다.\n\nEden : 객체들이 최초로 생성되는 공간.  \n-  여기에 객체가 가득차게 되면 첫 번째 GCminor GC가 발생한다.\n\nSurvivor 0/1 : Eden에서 참조되는 객체들이 저장되는 공간\n\n Tenured Generation\n: New Generation에서 일정 시간 참조되며 살아있는 객체들이 저장되는 공간이다.\n- 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다.\n- 이 영역에서 객체가 사라질 때 Major GC가 발생한다고 말한다.\n\n 객체의 소멸과정\n 1. Eden영역에 객체가 가득차게 되면 첫번째 GC가 발생한다.\n 2. Eden영역에 있는 값들을 Survivor0 혹은 1영역에 복사한다.\n 3. 나머지 영역의 객체를 삭제한다.\n\n 3-5 Method Area== Class area == Static area\n: 클래스 정보를 처음 메모리공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간\n- 올라가게 되는 메서드의 byte code는 프로그램의 흐름을 구상하는 byte code이다.\n    > Java 프로그램은 main 메서드의 호출로 흐름을 이어가기 때문이다!\n- 사실상 컴파일 된 byte code 대부분이 메서드 byte code이므로 거의 모든 byte code가 올라간다.\n- Runtime Constant Pool이라는 별도의 관리영역도 존재한다.\n  > 참조 자료형을 저장하요 참조하고 중복을 막아준다.\n\n올라가는 정보의 종류\n- Field Information  \n  > 맴버변수의 이름, 데이터 타입, 접근 제어자의 대한 정보\n- Method Information\n  > 메서드의 이름, 데이터 타입, 접근 제어자의 대한 정보\n- Type Information\n  > class혹은 interface여부, type의 속성, 전체 이름, super class의 전체이름interface, Object 제외",
    "tags": [
      "TIL",
      "coding",
      "JVM",
      "development",
      "java"
    ]
  },
  {
    "title": "Exception (예외)",
    "url": "/programming/2022/03/29/exception-예외/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 시스템에 비정상적인 상황이 생겼을 때 발생한다.\n- 시스템 수준에서 발생한다. &rarr; 심각한 수준의 오류\n- 개발자가 미리 예측하여 처리할 수 없다. &rarr; 오류에 대한 처리를 신경 쓰지 않아도 된다.",
    "content": "Exception 예외\n 오류Error와 예외Exception\n 오류Error\n: 시스템에 비정상적인 상황이 생겼을 때 발생한다.\n- 시스템 수준에서 발생한다. &rarr; 심각한 수준의 오류\n- 개발자가 미리 예측하여 처리할 수 없다. &rarr; 오류에 대한 처리를 신경 쓰지 않아도 된다.\n\n 예외Exception\n: 개발자가 구현한 로직에서 발생하는 에러이다.\n- 예외가 발생할 상황을 미리 예측하여 개발자가 처리 가능하다.\n- 예외를 구분하고 그에 따른 처리 방법을 정확이 알고 적용하는것이 중요하다.\n\n JAVA의 예외 클래스\n<img width=550px src=\"/assets/images/posts/programming/exception-class-structure.png\">\n\n- 모든 예외 class는 Throwable class를 상속받고 있다.\n- Error는 시스템 레벨에 심각한 수준의 에러이기 때문에 시스템에 변화를 주어 문제를 처리하는게 일반적이다.\n- Exception은 개발자가 로직을 추가하여 처리할 수 있다.\n\n 예외 클래스의 종류\n|      |Checked Exception |   Unchecked Exception   |\n|------|------------------|-------------------------|\n|처리여부| 예외 처리를 강제한다. | 명시적인 처리를 강제하지 않는다. |\n|확인시점| 컴파일 단계         | 실행단계                   |\n|대표 예외|Exception의 상속받은 하위 클래스 중 <br>RuntimeException을 제외한 모든 예외 <br> - IOException <br> - SQLException | RuntimeException 하위 예외 <br> - NullPointerException <br> - IllegalArgumentException\n\nChecked Exception과 Unchecked Exception의 명확한 구분기준은 필수적으로 예외 처리를 해야 하는지에 따라 구분된다.\n\n 일반적인 예외 처리의 방법\n> 일반적으로 예외 복구, 예외처리 회피, 예외 전환 이 있다.\n 1. 예외 복구\njava\nint maxretry = MAX_RETRY;\nwhilemaxretry -- > 0 {\n    try {\n        // 예외가 발생할 가능성이 있는 시도\n        return; // 작업성공시 리턴\n    }\n    catch SomeException e {\n        // 로그 출력. 정해진 시간만큼 대기\n    } \n    finally {\n        // 리소스 반납 및 정리 작업\n    }\n}\nthrow new RetryFailedException; // 최대 재시도 횟수를 넘기면 직접 예외 발생\n\n> 제시도를 통해 예외를 복구한다.\n\n예외 복구의 핵심은 예외가 발생하여도 에플리케이션은 정상적인 흐름으로 진행한다.\n\n 2. 예외처리 회피\njava\npublic void add throws SQLException {\n    ... // 구현 로직\n}\n\n예외가 발생하면 throws를 통해 호출한쪽으로 예외를 던지고 그 처리를 회피한다.\n- 무책임하게 예외를 던지는것은 위험하다.\n- 호출한 쪽에서 다시 예외를 받아 처리하도록 하거나,\n- 해당 매서드에서 처리하는것이 최선의 방법이다.\n\n 3. 예외전환\njava\ncatchSQLException e {\n   ...\n   throw DuplicateUserIdException;\n}\n\n예외를 잡아서 다른 예외를 던지는 것이다.\n- 호출한 쪽에서 예외를 받아서 처리할떄 좀더 명확하게 인지 할 수 있도록 돕기 위한 방법이다.  &rarr; 예외를 분명히 알아야지 처리하기 좋다.\n- 예를들어 Checked Exception 중 복구가 불가능한 예외가 잡혔다면 이를 Unchecked Exception으로 전환하여 다른 계층에서 일일이 예외를 선언할 필요가 없도록 할 수도 있다.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Volatile - 메모리 가시성을 해결하는 방법",
    "url": "/programming/2022/03/29/volatile---메모리-가시성을-해결하는-방법/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "키워드는 Java 라는 것을 명시하는 것이다.",
    "content": "Volatile - 메모리 가시성을 해결하는 방법\nvolatile 키워드는 Java \"변수를 Main Memory에 저장하겠다\"라는 것을 명시하는 것이다.\n\n모든 volatile 변수는 컴퓨터의 메인 메모리로 부터 읽히고, volatile 변수에 대한 쓰기 작업은 메인 메모리로 직접 이루어진다. 즉, CPU cache를 사용하지 않는다.\n\n 키워드 선언 방식\njava\nprivate volatile int counter;\n\n\n 가시성이란?\n<img width=\"450\" src=\"/assets/images/posts/programming/hardware-archiecture.png\">\n\n보통 CPU가 메인 메모리에 접근이 필요할 때, RAM &rarr; Cache &rarr; CPU Register 순으로 읽은 후 명령을 수행한다 그리고 데이터를 메인 메모리에 저장하기 위해 이 과정을 역순으로 한다.\n\nvolatile 변수를 사용하고 있지 않는 MultiThread 어플리케이션에서는 Task를 수행하는 동안 성능 향상을 위해 Main Memory에서 읽은 변수 값을 CPU Cache에 저장하게 된다.\n\n만약 Multi Thread환경에서 Thread가 공유되는 변수 값을 읽어올 때 각각의 Cache Memory에 저장된 값이 다르므로 인해 변수 값 불일치가 발생하게 된다.\n\n에제는 제이온님의 블로그가 더 잘 나와있는 거 같아 첨부하겠다. https://steady-coding.tistory.com/555\n\n volatile 키워드의 특징\n- 특정 변수에 대해서 최신 값을 제공한다.\n  > 하지만 원자성을 보장하지 않는다. 즉, race condition를 해결해 주지 않는다.\n- CPU의 cache를 활용하지 못하고 그 이외에 성능 이슈가 존재한다.\n  - 대표적으로 JVM 성능 향상을 위한 코드 재정리를 막는다.\n- 32 bit 변수에서만 기능을 보장한다.\n\n요약. 변수의 가시성 보장이 반드시 필요한 경우에만 사용하자",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Java의 날짜/시간을 나타내는 API",
    "url": "/programming/2022/03/29/java의-날짜시간을-나타내는-api/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> , , 등...",
    "content": "Java의 날짜/시간을 나타내는 API\n Java8 이전\n> Date, Calendar, SimpleDateFormet등...\n 문제점\n 1. 객체명이 직관적이지 않다.\n> Data객체가 날짜와 시간을 제공한다. &rarr; 객체명이 일관적이지 않다.\njava\nDate date = new Date;\nlong time = date.getTime;\nSystem.out.printlndate; //날짜 출력 ex. Sun Jun 21  15:32:35 PDT 2020\nSystem.out.printlntime; // 1970년도를 지군으로 지금까지의 초를 나타낸다 ex. 1938472839485\n\n\n 2. mutable하다.\n> 서로 다른 여러 Threed에서 해당 Date객체를 모두 수정하게 된다면 예상치 못한 부수 효과가 일어날 것이다.\njava\nDate date = new Date;\nlong time = date.getTime;\nSystem.out.printlndate; //출력 예시 - Sun Jun 21  15:32:32 PDT 2020\n\nThread.sleep1000  3 //3초동안 해당 threed는 대기한다.\nDate after3Sec = new Date;\nSystem.out.printlnafter3Sec // 출력 예시 Sun Jun 21  15:35:35 PDT 2020 // 3초증가\n\nafter3Sec.setTimetime // 3초 전 시간을 set함\nSystem.out.printlnafter3Sec // 출력 예시 Sun Jun 21  15:35:35 PDT 2020 // date변수와 시간이 똑같아 졌다.\n\n\n 3. Type safety하지 않다.\njava\nCalendar calendar = new GregorianCalendar1802, -9, -15; // 무려 날짜에 음수가 들어갈 수 있다.모든 수를 정수형 - int로 받음\nDate dateCalender = calendar.getTime; // Date타입을 반환한다.\nSystem.out.printlndateCalender; // 출력: Mon Mar 16 00:00:00 KST 1801\n\nCalendar calendar = new GregorianCalendar1802, 9, 15; \nSystem.out.printlncalendar.getTime; // 출력: Fri Oct 15 00:00:00 KST 1802 // 9월을 입력했지만 8월로 출력되었다.\n\n\n Java8 이후\u001d\n> Instence, LocalData, LocalDateTime\n 지금 시간을 기계 시간으로 표현하는 방법\n- Instant.now\n  >현재 UTC GMT를 리턴한다. Universal Time Coordinated == Greenwich Mean Time\n\n예시\njava\nInstant now = Instant.now;\nSystem.out.printlnnow; // 예시. 2021-08-31T14:26:51.212729Z\nSystem.out.printlnnow.atZoneZoneId.of\"UTC\"; //예시. 2021-08-31T14:26:51.212729ZUTC \n\nZonedDateTime zonedDateTime = now.atZoneZoneId.systemDefault;\nSystem.out.printlnzonedDateTime; // 예시. 2021-08-31T23:26:51.212729+09:00Asia/Seoul\n\n\n 인류용 시간을 표현하는 방법\n- LocalDateTime.now\n  > 현재 시스템 Zone에 해당하는로컬 일시를 리턴한다.\n- LocalDateTime.ofint, Month, int, int, int, int\n  > 로컬의 특정 일시를 리턴한다.\n- ZonedDateTime.ofint, Month, int, int, int, int, ZoneId\n  > 특정 Zone의 특정 일시를 리턴한다.\n\n 기간을 표현하는 방법\n> Period / Duration.between\njava\nLocalDate today = LocalDate.now;\nLocalDate nextYearBirthDay = LocalDate.of2022, Month.APRIL, 22;\nPeriod between = Period.betweentoday, nextYearBirthDay;\nSystem.out.println\"month: \" + between.getMonths + \" day: \"+between.getDays; // 예시. month: 7 day: 22 2021, 8, 31기준\n\n\n 날짜 포멧팅\n- DataTimeFormatter\n- 미리 정의한 포멧팅 참고https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.htmlpredefined\njava\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern\"MM/d/yyyy\";\nLocalDate date = LocalDate.parse\"07/15/1982\", formatter;\n//  LocalDate date = LocalDate.ISO_DATE_TIME; // 포메싱 예시\nSystem.out.printlndate; // 예시. 1982-07-15\nSystem.out.printlntoday.formatformatter; // 예시. 09/2/2021\n\n\n 레거시 API 지원\n- GregorianCalendar와 Date 타입의 인스턴스를 Instant나 ZonedDateTime으로 변환 가능. \n- java.util.TimeZone에서 java.time.ZoneId로 상호 변환 가능.\njava\nZoneId newZoneAPI = TimeZone.getTimeZone\"PST\".toZoneId;\nTimeZone legacyZoneAPI = TimeZone.getTimeZonenewZoneAPI;\nInstant newInstant = new Date.toInstant;\nDate legacyInstant = Date.fromnewInstant;",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "api",
      "java8"
    ]
  },
  {
    "title": "어노테이션 프로세서 - Annotation Processor",
    "url": "/programming/2022/03/29/어노테이션-프로세서---annotation-processor/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "Oracle 공식문서https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html",
    "content": "어노테이션 프로세서 - Annotation Processor\nOracle 공식문서https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html\n\nLombok의 @Getter @Setter annotation으로 getter/setter를 생성해준다. 어노테이션 프로세서라는 기술은 Lombok 같이 코드를 자동으로 생성해 줄 수 있을 뿐만 아니라 모든 파일을 만들어 낼 수 있다.\n\n Lombok의 동작원리\n컴파일 시점에 어노테이션 프로세서를 사용하여 소스코드의 ASTabstract syntax tree 를\n조작한다.\n\n 어노테이션 프로세서란?\n자바 컴파일러 플러그인의 일종으로, 어노테이션에 대한 코드베이스를 검사, 수정, 생성 및 문서와 같은 파일을 생성할 수 있는 기술이다.\n- 컴파일 단계에서 작동한다.\n- ASTabstract syntax tree를 조작할 수 없다.\n  > Annotation이 붙어있는 클래스를 참조할 수 있지만 수정할 수 없다.\n\n 하지만 어떻게 lombok은 수정할 수 있나요?\n<img src=\"/assets/images/posts/programming/annotation-processer-process-api.png\">\n\n공개된 API가 아닌 컴파일러의 내부 클래스를 이용해 기존 소스 코드를 조작한다. &rarr; 이를 해킹이라고 주장하는 의견이 있다.\n- 공식 API가 아니므로 호환성의 문제가 생길 수 있다.\n\nAST를 수정하지 않고 정석적인 방법을 사용한 라이브러리\n- AutoValuehttps://github.com/google/auto/blob/master/value/userguide/index.md\n- Immutableshttps://immutables.github.io\n\n하지만 다들 lombok처럼 편리성을 제공해주지 못한다.\n\n 어노테이션 프로세서의 동작원리\n- Round에 의해서 동작한다.\n  > round  \n  > : 각 round마다 Processor에게 특정한 어노테이션들이 가지고 있는 앨리먼트를 가지고 있다면 프로세서가 해당 결과를 처리한다.\n\n 장점\n- 런타임 비용이 없다.\n  > 컴파일 할 때 조작되어 사용되기 때문에 비용이 드는게 아니다.\n\n 단점\n- 기존의 코드를 고치는 공식적인 방법이 없다.\n  > lombok은 해킹을 통해 하고있다.",
    "tags": [
      "TIL",
      "byte-code-controller-way",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Wrapper class",
    "url": "/programming/2022/03/29/wrapper-class/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 객체지향 프로그래밍에서 모든 것은 객체로 다루어져야 한다.\n- 그렇지만, Java는 성능상의 이유로 8개의 을 객체로 다루지 않는다.",
    "content": "Wrapper class\n\n 왜 사용할까?\n- 객체지향 프로그래밍에서 모든 것은 객체로 다루어져야 한다.\n- 그렇지만, Java는 성능상의 이유로 8개의 기본형Primitive Type을 객체로 다루지 않는다.\n\n하지만 매개변수로 객체가 필요하거나, 기본형 값 대신 객체로 저장해야 하거나, 객체 간 비교가 필요하는 등...  \n&rarr; 이럴 때 Wrapper class를 사용한다.\n- 대표적으로 Java의 Collection Framework에서는 Wrapper class를 사용한다.\n\n Wrapper class란?\n: 기본형primitive type 변수를 감싸거나wrap, 포함하는contain class이다.\n- 기본형 값들을 객체로 다루는 일을 가능하게 해준다.\n- Wrapper class로 감싸고 있는 기본 타입 값은 외부에서 변경 할 수 없다.\n  > 만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 한다. &rarr; 불변성을 가진다.\n- String형의 경우 기본 타입을 감싸거나 포함하는 class가 아니므로 wrapper class가 아니다.\n\n Wrapper class의 종류\n|Primitive Type|Wrapper Class|\n|----|---------|\n|char|Character|\n|byte|Byte|\n|short|Short|\n|int|Integer|\n|long|Long|\n|float|Float|\n|double|Double|\n|boolean|Boolean|  \n\n Wrapper Class의 구조\n<img src=\"/assets/images/posts/programming/wrapper-class-structure.png\">\n\n- wrapper class들은 모두 java.lang패키지에 포함되어 제공된다.\n- Number: 내부적으로 숫자를 다루는 wrapper class들의 부모 클래스\n\n\n Boxing 과 UnBoxing\n<img src=\"/assets/images/posts/programming/boxing-unboxing.png\">\n\n Boxing\n: 기본 타입의 데이터를 wrapper class의 인스턴스로 변환하는 과정\n  > Primitive type &rarr; Wrapper class instance\n\n예제 코드\njava\nint intA = 1;\nInteger integerA = new IntegerintA; // int형인 intA변수를 boxing했다. \n\n Unboxing\n: wrapper class의 인스턴스에 저장된 값을 -> 기본 타입의 데이터로 꺼내는 과정\n> Wrapper class instance &rarr; Primitive type\n\n예제 코드\njava\nInteger integerA = new Integer1;\nint intA = integerA.intValue;\n\n\n AutoBoxing & AutoUnBoxing\n> JDK 1.5버전부터 boxing,unboxing이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해준다.\n\n 예시 코드\njava\nInteger inteagerA = 1;\nint intA = 1;",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Annotation",
    "url": "/programming/2022/03/29/annotation/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "Annotation은 그자체로 주석이라는 의미를 가진다. 하지만 일반 주석이랑 다르다!\n- JDK5 버전부터 사용할 수 있다.\n- 를 붙여서 사용한다.\n- Reflection을 이용해 Class의 Annotation을 조회할 수 있다.\n- Annotatino은 interface에 해당된다.",
    "content": "Annotation\nAnnotation은 그자체로 주석이라는 의미를 가진다. 하지만 일반 주석이랑 다르다!\n- JDK5 버전부터 사용할 수 있다.\n- @를 붙여서 사용한다.\n- Reflection을 이용해 Class의 Annotation을 조회할 수 있다.\n- Annotatino은 interface에 해당된다.\n\n\n Annotation의 용도\n> 대부분 사용되는 용도는 다음과 같다.\n 1. 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공\n대표적으로 Java에서 제공하는 @Override가 있다.\n\n다음은 equals를 Override하는 예시이다.\njava\n@Override\npublic boolean equalsObject o {\n    if this == o return true;\n    if !o instanceof Book return false;\n    Book book = Book o;\n    return a == book.a && Objects.equalsb, book.b;\n}\n\n다음과 같이 파라미터가 다르면 @Override에서 에러가 발생하는 것을 볼 수 있다\n<img width=450 src=\"/assets/images/posts/programming/annotation-override-error.png\">\n\n에러 메시지\nsh\n파일경로/Book.java:10:5\njava: method does not override or implement a method from a supertype\n\n\n 2. 소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공\n대표적인 예시로 Querydsl의 Q타입 Entity를 생성하는 것이 있다. 이를 가능하게 하는 기능을 annotation processor라고 한다.\n\n 3. 실행시런타임시특정 기능을 실행하도록 정보를 제공\nannotation은 클래스, 메서드, 필드등에 대한 메타데이터를 가질 수 있다. 대표적인 예로 SpringBoot의 @Component가 있는데 이 annotation이 붙여진 class는 Spring의 관리대상에 포함된다.\n\n.  \n.  \n. ETC...\n\n Use Case\n- 컴파일러를 위한 정보제공 :  @FunctionalInterface , @supresswarnings\n- 자동 문서 작성 : Jenkins, Jira, Teamcity 등...\n- 코드 자동 생성 : Querydsl, lombok, JAXB 등...\n  > annotation processor\n- 런타임 프로세싱 : Junit, DISpring, loggingLog4J, DAHibernate 등...\n\n\n Annotation의 구성\n다음은 Annotation의 예시이다.\njava\n@Target{ElementType.FIELD}\n@RetentionRetentionPolicy.RUNTIME\npublic @interface Annotation {\n}\n\n @TargetElementType\n: Annotation이 적용할 위치를 나타낸다.\n|위치|Element Type|\n|---|------------|\n|패키지| ElementType.PACKAGE|\n|클래스, 인터페이스, enum, record|ElementType.TYPE|\n|Annotation 타입| ElementType.ANNOTATION_TYPE|\n|생성자|ElementType.CONSTRUCTOR|\n|맴버 변수|ElementType.FIELD|\n|지역 변수|ElementType.LOCAL_VARIABLE|\n|메서드| ElementType.METHOD|\n|Record component | ElementType.RECORD_COMPONENT |\n|매개변수|ElementType.PARAMETER|\n|파라미터 타입|ElementType.TYPE_PARAMETER|\n|타입|ElementType.TYPE_USE|\n\n @RetentionRetentionPolicy\n: Annotation 의 Scope를 제한한다.\n- SOURCE  \n  어노테이션 정보가 컴파일시 사라진다. 즉, 바이트코드에 존재하지 않는다.\n  > ex. @Override, @SuppressWarnings, lombok의 getter/setter\n- CLASS\n  클래스 파일에 존재하고 컴파일러에 의해 사용가능, 가상머신런타임에서는 사라진다.\n- RUNTIME\n  실행시 어노테이션 정보가 가상 머신에 의해서 참조 가능. reflection에 의해 사용될 수 있다.\n\n CLASS는 왜 사용될까?\n> 참고: https://stackoverflow.com/questions/38975073/retention-of-java-type-checker-annotations\n\nCLASS 정책은 Maven과 Gradle로 다운받은 라이브러리와  jar파일은 소스코드.java가 아닌 바이트코드.class만 남겨진다.  \n\n.class 파일만 존재하는 라이브러리 같은 경우에도 타입체커, IDE 부가기능 등을 사용할수 있으려면 CLASS 정책이 필요하다.  \nSOURCE 정책으로 사용한다면 컴파일된 라이브러리의 jar 파일에는 어노테이션 정보가 남아있지 않기 때문에 위와 같은 기능을 사용할 수 없다.  \n\n 추가적인 구성요소\n @Inherited\n슈퍼클래스를 상속한 서브 클래스에서도 해당 Annotation을 갖도록 한다.\n\njava\n@Target{ElementType.TYPE}\n@RetentionRetentionPolicy.RUNTIME\npublic @interface Annotation {}\n\n@Annotation\npublic class SuperClass{}\n\npublic class DownClass extends SuperClass{}\n\n리플렉션을 이용해 DownClass의 Annotation가져오기\njava\npublic static void mainString args {\n    Class<DownClass> downClassClass = DownClass.class;\n    Arrays.streamdownClassClass.getAnnotations.forEachSystem.out::println;\n}\n\n출력 결과 예시\nsh\n@패키지_이름.Annotation\n\n\n @Documented\n@Documented 어노테이션이 지정된 대상의 JavaDoc 에 이 어노테이션의 존재를 표기하도록 지정한다.\n\n 변수\nannotation은 변수를 사용할 수 있다. 변수의 형식은 다음과 같다.\njava\npublic 타입 변수명;\npublic 타입 변수명 default 기본값;\n\n\n- final과 abstract, private 를 사용할 수 없다.\n- public은 기본적으로 생략이 된다.\n- 기본값에 null이 들어갈 수 없다.\n- 변수의 타입은 기본형 혹은 java.lang.String형만 올 수 있다.\n\n만약 annotation의 변수명이 value면 annotation를 다음과 같이 사용할 수 있다.\njava\n@Target{ElementType.TYPE}\n@RetentionRetentionPolicy.RUNTIME\npublic @interface Annotation {\n    String value;\n\n    String a default \"\";\n}\n\n@Annotation\"hello\"\npublic class ExClass1 { }\n\n@Annotationvalue = \"hello\", a = \"a\"\npublic class ExClass2 { }",
    "tags": [
      "TIL",
      "byte-code-controller-way",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Strategy Pattern(전략 패턴)",
    "url": "/programming/2022/03/29/strategy-pattern전략-패턴/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "이전글: 템플릿 메서드 패턴template-method-pattern.md",
    "content": "Strategy Pattern전략 패턴\n이전글: 템플릿 메서드 패턴template-method-pattern.md\n\n 참고자료\n- 김영한 인프런 핵심 원리 - 고급편https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8\n- 예제 코드https://github.com/siwony/spring-core-principle-advanced/tree/main/src/test/java/com/siwony/ifl_spring_advanced/trace/strategy\n\n<p align=center><img width=450 src=\"/assets/images/posts/programming/strategy-pattern.png\"></p>\n\n전략 패턴은 변하지 않는 부분을 Context 라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를 만들어 해당 인터페이스를 구현하도록 한다.\n\n> 템플릿 메서드 패턴은 상속을 활용해 특정 부분만 변경하도록 한다. 전략패턴은 위임을 통해 특정 부분만 변경할 수 있다.\n\nGOF의 디자인 패턴에서는 전략 패턴의 의도는 다음과 같다.\n> 알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자.   \n> 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.\n\n 예제 - 비즈니스 로직의 수행 속도를 측정하여 로깅하기\n> 실습환경: SpringBoot + lombok + junit5\n V1 - 필드에 전략을 저장하는 방식\n> 객체의 생성과 동시에 Strategy 조립하기 - 선 조립, 후 실행\njava\n@Slf4j\n@AllArgsConstructor\npublic class ContextV1 {\n\n    private Strategy strategy;\n\n    public void execute{\n        long startTime = System.currentTimeMillis;\n        // 비즈니스 로직 실행\n        strategy.call;\n        // 비즈니스 로직 종료\n        long endTime = System.currentTimeMillis;\n        long resultTime = endTime - startTime;\n        log.info\"resultTime={}\", resultTime;\n    }\n}\n\npublic interface Strategy {\n    void call;\n}\n\n- ContextV1은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다.\n  > 이것을 컨텍스트 - context라고 한다.\n- Context는 내부에 Strategy strategy필드를 가지고 있다. 이 필드에 변하는 부분인 Strategy의 구현체를 주입하면 된다.\n- execute에서 strategy.call;를 통해 비즈니스 로직 실행을 Strategy에 위임했다.\n\n 전략패턴 사용\njava\n@Test\nvoid strategy{\n    ContextV1 context1 = new ContextV1 -> log.info\"비즈니스 로직1 실행\";\n    context1.execute;\n\n    ContextV1 context2 = new ContextV1 -> log.info\"비즈니스 로직2 실행\";\n    context2.execute;\n}\n\n출력 예시\nlog\n17:20:12.049 main INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV1Test - 비즈니스 로직1 실행\n17:20:12.051 main INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV1 - resultTime=3\n17:20:12.052 main INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV1Test - 비즈니스 로직2 실행\n17:20:12.052 main INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV1 - resultTime=0\n\n- 람다를 이용해 ContextV1에 Strategy.call를 구현했다.\n- 상속을 사용하지 않고 Strategy인터페이스를 의존하므로 좀 더 유연한 구조로 변경되었다.\n\n 전략 패턴 실행 \n<img width=500 src=\"/assets/images/posts/programming/strategy-exec.png\">\n\n 선 조립, 후 실행방식\nContext의 내부 필드에 Strategy 를 두고 사용하는 방식은 \n- Context와 Strategy를 한번 조립하고 나면 이후로는 Context를 실행하기만 하면 된다.\n- Spring에서 애플리케이션 로딩 시점에 DI를 통해 필요한 의존관계를 모두 맺어두고 난 다음에 실제 요청을 처리하는 것과 같은 원리이다.\n- 이 방식의 단점은 Context와 Strategy를 조립한 이후에는 전략을 변경하기 번거롭다.\n  > Getter/Setter를 사용해도 되지만 동시성 문제가 있을 수 있다.\n\n이처럼 전략을 변경하기 어려운 방식을 어떻게 해결할 수 있을까?\n\n V2 - 전략을 실행할 때 직접 파라미터로 전달하는 방식\n위의 방식에서 Strategy필드를 제거하고 파라미터로 Strategy를 넘겨주기만 하면된다.\njava\n@Slf4j\npublic class ContextV2 {\n\n    public void executeStrategy strategy{\n        long startTime = System.currentTimeMillis;\n        // 비즈니스 로직 실행\n        strategy.call;\n        // 비즈니스 로직 종료\n        long endTime = System.currentTimeMillis;\n        long resultTime = endTime - startTime;\n        log.info\"resultTime={}\", resultTime;\n    }\n}\n\n 테스트 코드\njava\n@Test\nvoid strategy{\n    ContextV2 context1 = new ContextV2;\n    context1.execute -> log.info\"비즈니스 로직1 실행\";\n\n    ContextV2 context2 = new ContextV2;\n    context2.execute -> log.info\"비즈니스 로직2 실행\";\n}\n\n출력 예시\njava\n17:54:42.737 main INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV2Test - 비즈니스 로직1 실행\n17:54:42.740 main INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV2 - resultTime=5\n17:54:42.742 main INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV2Test - 비즈니스 로직2 실행\n17:54:42.742 main INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV2 - resultTime=0\n\n- Context를 실행할 때 마다 전략을 인수로 전달한다.\n  > 이는 장점이자 단점이다.\n- 클라이언트는 Context를 실행하는 시점에 원하는 Strategy를 전달할 수 있다. 따라서 이전 방식과 비교해서 원하는 전략을 더욱 유연하게 변경할 수 있다.\n\n 전략 패턴 실행 \n<img width=500 src=\"/assets/images/posts/programming/strategy-exec-param.png\">\n\n다음글: 템플릿 콜백 패턴template-callback-pettern",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "JVM, JDK, JRE",
    "url": "/programming/2022/03/29/jvm-jdk-jre/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> WORA - Write Once Run Anywhere\n- JVM으로 Java byte code파일를 OS 특화된 코드로 변환인터프리터, JIT컴파일러하여 실행한다.\n- byte code를 실행하는 표준이자 구현체 이다.\n  - JVM 스펙: https://docs.oracle.com/javase/specs/index.html\n  - JVM 밴더: 오라...",
    "content": "JVM, JDK, JRE\n JVM - Java Virtual Machine\n> WORA - Write Once Run Anywhere\n- JVM으로 Java byte code.class파일를 OS 특화된 코드로 변환인터프리터, JIT컴파일러하여 실행한다.\n- byte code를 실행하는 표준이자 구현체 이다.\n  - JVM 스펙: https://docs.oracle.com/javase/specs/index.html\n  - JVM 밴더: 오라클, 아마존, Azul 등...\n- 특정 플랫폼에 종속적이다.\n\n>  JVM 기반으로 동작하는 프로그래밍 언어\n> Kotlin, Scala, Groovy, JRuby 등...\n\n\n JRE - Java Runtime Environment\n> Java 10까지 JDK뿐만 아니라 JRE까지 배포했다.\n- JVM + 핵심 라이브러리\n- 개발 관련 x, 실행 관련 o\n- Java11부터 Java는 JRE로 따로 배포하지 않는다.\n\n JDK - Java Development Kit\n> Java 11부터는 JDK 단위로 배포된다.\n- JRE + 개발 툴java c\n- 소스코드를 작성할 떄 Java언어는 플랫폼 독립적이다.\n  > JVM만 구현되어 있으면 어느 플랫폼에서든지 컴파일 및 실행을 할 수 있다.\n\n Java의 유료화?\nJava는 여러개의 구현체가 존재한다. 그 중 Oracle에서 만든 Oracle JDK 11버전부터 상용으로 사용할 떄 유료이다.  \n\n즉, 어떤 JDK를 사용하냐에 따라 다르다 \n> ex. openJDK를 사용하면 무료다!",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "String class",
    "url": "/programming/2022/03/29/string-class/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "Java를 만든 사람들은 객체지향 언어를 설계할 때 모든 것을 객체로 만들지 않고 를 보유하여 성능을 개선했다.  \n> 원시형은 스택 영역에 저장되고, 객체는 힙 영역에 저장되므로 힙 영역은 메모리 관리가 복잡하고 공간을 스택 영역 보다 더 차지한다.",
    "content": "String class\nJava를 만든 사람들은 객체지향 언어를 설계할 때 모든 것을 객체로 만들지 않고 원시형 - Primitive Type를 보유하여 성능을 개선했다.  \n> 원시형은 스택 영역에 저장되고, 객체는 힙 영역에 저장되므로 힙 영역은 메모리 관리가 복잡하고 공간을 스택 영역 보다 더 차지한다.\n\n자바의 String은 원시형과 클래스 사이의 형태로 설계되었다.\n\n String의 특별한 기능\n 1. +연산자 오버로딩\nJava는 SW공학 관점에서 오버로딩을 지원하지 않는다.  \n하지만, Java에서는 오직 문자열 더하기 연산을 위해 +만 오버로딩 되어 있다. 참고자료http://egloos.zum.com/js7309/v/11155465\n\n내부 동작을 간단하게 설명하자면 String형의 + 연산은 내부적으로 StringBuilder.append를 사용해서 문자열을 연결한다.\n> C, C++은 연산자 오버로딩을 지원한다. +연산자를 -가 동작하도록 만들 수 있다!\n\n 2. 기본형처럼 문자열 리터럴로 초기화 할 수 있다.\nString의 초기화는 직접 문자열 리터럴로 초기화 하거나, new 연산자로 초기화할 수 있다.\n\n하지만 new 연산자로 초기화 하는 방법은 권장하지 않는다. 그 이유는 String리터럴로 생성된 String 값은 Heap 영역 내 String Constant Pool에 저장이 된다. \n\n String Constant Pool\n> 앞으로 String Pool이라고 부를 것이다.\njava\nString s1 = \"hello\";\nString s2 = \"hello\";\nSystem.out.printlns1 == s2; // true 출력\n\nString s3 = new String\"hello\";\nSystem.out.printlns2 == s3// false 출력\n\ns1과 s2는 String Constant Pool에 저장된 값을 공유하므로 동일비교==를 하면 true가 출력되지만,  \nnew 연산자를 사용한 s3같은 경우 s2와 ==비교를 하면 false가 출력된다.\n\n위의 코드를 그림으로 나타내면 아래와 같다.  \n<img width=500 src=\"/assets/images/posts/programming/string-constant-pool-ex.png\">\n\n String Constant Pool의 변천사\nJava6 이전에는 String Constant Pool은 Heap메모리에 존재하지 않고 Permenent Generation 메모리에 있었다.\n\nJava 7 버전에서는 PermGen이 아닌 Heap 메모리 영역으로 옮겼다.  \n그렇기 때문에 메모리가 한정적인 PemGen에서 Strirng Pool 메모리 사이즈 때문에 걱정하는 일이 사라졌다.\n\n String Table Size\nJava String Pool은 기본적으로 HashTable 구조를 가지고 있다.\n그래서 String Pool은 좋은 성능을 자랑한다.\n\n\n String class의 내부 \n> 본 글은 OpenJDK11 기준으로 작성되었습니다.\n\n<img src=\"/assets/images/posts/programming/in-string-class.png\">\n\nString class의 일부분을 가져왔다. String class는 final로 선언되어 상속해서 사용할 수 없다.  \n\n그리고 String class는\n- 직렬화를 위한 Serializable\n- 비교를 위한 Comparable\n- read-only를 위한 CharSequence\n  > length, charAt과 같은 문자열 조회 기능을 추상화한 인터페이스이다.\n\n위에 3가지 인터페이스를 구현한 클래스이고,  \n\n String은 불변이다.\n위 사진에서 private final byte value;로 선언된 배열이 있다. 이 상수배열은 String class에서 실질적인 값을 가지고 있는 상수이다.\n\njava\nString s = \"hello\";\ns = \"hello world\";\n\n위에 코드는 String 클래스의 내부적인 값이 바뀐 것처럼 오해할 수 있지만 사실은 새로운 String객체가 대입된 것이라고 할 수 있다.\ntoUpperCase, trim과 같은 메서드도 사실은 새로운 String 객체를 반환한다.\n\nJava Oracle String 공식문서https://docs.oracle.com/javase/7/docs/api/java/lang/String.html에 String이 불변이라는 것에 대한 글이 기술되어 있다.\n\n 비 효율적인 코드\nString이 불변이므로 비 효율적인 코드가 발생하는데\njava\nString str = \"Hello\";\nfor int i = 1; i < 1000; ++i {\n    str = str + i;\n}\n\n위 코드는 같은 경우 str변수에 문자가 이어 붙여지는 것이 아닌 새로운 String 객체가 1000번 생성되는 코드이다. \n\n이러한 문제를 해결하기 위해 StringBuilder와 StringBuffer를 사용해야 한다.\n\n다음글: StringBuilder와 StringBuffer",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "api"
    ]
  },
  {
    "title": "JVM 구조",
    "url": "/programming/2022/03/29/jvm-구조/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "<img width=\"600px\" src=\"/assets/images/posts/programming/jvm-structore.png\">",
    "content": "JVM 구조\n<img width=\"600px\" src=\"/assets/images/posts/programming/jvm-structore.png\">\n\n 클래스 로더 시스템 - Class Loader\n> 로딩 &rarr; 링크 &rarr; 초기화\n- .class파일 에서 bytecode를 읽고 메모리에 저장한다.\n- 로딩: 클래스를 읽어오는 과정\n- 링크: 레퍼런스를 연결하는 과정\n- 초기화: static 값을 초기화 및 변수에 할당\n\n 메모리 - Memory\n- 메서드 영역 - method  \n  : 클래스 수준의 정보이름, 부모 클래스 이름, 메소드, 변수저장하고, 해당 자원은 모든 영역에 공유된다.\n\n- 힙 영역 - heap  \n  : 객체를 저장하고, 해당 자원은 모든 영역에 공유된다.\n\n- 스텍 영역 - stack  \n  - Thread마다 런타임 stack을 만들고 스텍프레임을 블럭으로 쌓는다.\n  - Thread가 종료되면 런타임 스택도 사라진다.\n  > 스텍프레임  \n  > : 스택 영역에 저장되는 메소드의 호출 정보를 의미한다.  \n  > 메서드 하나당 하나의 스택 프레임이 존재한다.\n\n- PC - Program Counter  \n  : 스레드 속 현재 실행할 스택 프레임을 가리키는 포인터가 생성한다.\n  - thread를 호출할 때 생긴다.\n\n- 네이티브 메서드 스택 - Native Method Stack  \n  : native method를 호출할 때 사용한다.\n  - thread를 호출할 때 생긴다.\n\n\n//todo 여기 보고 좀 더 정리 https://javapapers.com/core-java/java-jvm-run-time-data-areas/Program_Counter_PC_\n\n 실행 엔진 - Execute Engin\n- 인터프리터 - Interpreter  \n  byte code를 한줄 씩 실행한다.\n\n- JIT 컴파일러 - Just In Time Compiler  \n  인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 바꿔둔다.   \n  &rarr; 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다\n\n- GCGarbage Collector  \n  더 이상 참조되지 않는 객체를 모아서 정리한다.\n\n JNI - Java Native Interface\nJava application에서 C, C++, 어셈블리 같은 언어로 작성된 함수를 사용할 수 있는 방법을 제공한다.\n- Native 키워드를 사용한 메소드 호출할 수 있다.",
    "tags": [
      "TIL",
      "coding",
      "JVM",
      "development",
      "java"
    ]
  },
  {
    "title": "리플렉션 - Reflection",
    "url": "/programming/2022/03/29/리플렉션---reflection/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "Spring은 Annotatino을 통해 , Hibarnate는 Entity클래스의 정보를 통한 Poxy를 이용해 지연 로딩을 하고, Jackson라이브러리는 를 활용해 직렬화를 구현한다.   \n이러한 것을 가능하게 하는 기술을 이라는 기술이다. 리플렉션을 이용해 필드의 값을 가져오거나, 객체를 동적으로 생성하는 등 클래스를 동적으로 다룬다. 이 글은 Ja...",
    "content": "리플렉션 - Reflection\n\n Spring, Hibernate 그리고 Jackson라이브러리는 어떻게 작동할까?\nSpring은 Annotatino을 통해 , Hibarnate는 Entity클래스의 정보를 통한 Poxy를 이용해 지연 로딩을 하고, Jackson라이브러리는 Getter/Setter를 활용해 직렬화를 구현한다.   \n이러한 것을 가능하게 하는 기술을 리플렉션 - Reflection이라는 기술이다. 리플렉션을 이용해 필드의 값을 가져오거나, 객체를 동적으로 생성하는 등 클래스를 동적으로 다룬다. 이 글은 Java진영에서 자주 사용하는 프레임워크, 라이브러리를 꿰뚫는 기술에 대한 TIL이다.\n\n 리플렉션\n: 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩Dynamic Loading하여 생성자Constructor, 멤버 필드Member Variables 그리고 멤버 메서드Member Method 등을 사용할 수 있도록 한다.\n- 구체적인 클래스 타입을 알지 못해도 그 클래스의 구성요소를 접근할 수 있다.\n\n 구체적인 클래스 타입을 알지 못할때가 언제일까?\n'내 코드인데 어떻게 클래스 타입을 모를수가 있지?' 라는 의문점을 품을 수 있다. 하지만 이는 관점을 프레임워크의 입장이 되어 생각해보면 이해가 쉽게 가능하다.\n\nSpring 프레임워크의 어노테이션 같은 기능들이 리플렉션을 통해 프로그램 실행중 동적으로 클래스 정보를 가져와 사용한다. 하지만 Spring 프레임워크 입장에서는 어느 객체를 다룰지 모르는데 클래스의 정보를 알 수 있을까?\n객체의 모든 타입은 Object를 상속받고 있다. A라는 객체는 Object타입으로 담을 수 있지만 A가 가지고 있는 메서드와 필드는 사용할 수 없다.\n\n하지만 리플렉션을 사용한다면 해당 객체의 타입을 몰라도 필드와 메서드를 사용할 수 있고 객체의 정보를 가져오는 등 런타임 시점에 동적으로 객체를 다룰 수 있다.\n\n\n 기초적인 사용방법\n리플렉션의 첫 시작은 Class<?>라는 API를 사용하게 될 것이다. 공식문서https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html  \n\n다음은 클래스와 이미 생성된 객체의 Class<?>객체를 가져오는 코드의 예시다.\njava\n// Book이라는 Type의 Class객체를 가져오는 방법\nClass<Book> bookClass = Book.class;\n\n// 이미 생성된 객체의 Class객체를 가져오는 방법\nBook book = new Book;\nClass<? extends Book> aClass = book.getClass;\n\n// 클래스 이름으로 가져오는 방법 Class.forName함수의 인수로 FQCN를 넘겨준다.\n\n\n다음과 같이 FQCN로 Class<?>를 생성할 수 있다.\njava\nClass<?> bookClass = Class.forName\"com.ex.Book\";\nSystem.out.println\"aClass1.getName = \" + aClass1.getName; // com.ex.Book 출력\n\n- 위와 같은 방식은 클래스를 찾지못하면 ClassNotFoundException를 발생시킨다.\n- 해당 방법을 사용하는 대표적인 에시는 JDBC\n\n 사전준비\n> 패키지 이름은 com.ex가 기준\n1. Book 클래스 생성\n   java\n\n    public class Book {\n\n        private static String a = \"author\";\n        private static final String b = \"isbn\";\n        private String c = \"title\";\n        public int d = 10000;\n        protected String e = \"a\";\n\n        public Book{}\n        public BookString c, int d, String e {\n            this.c = c;\n            this.d = d;\n            this.e = e;\n        }\n\n        private void methodA{\n            System.out.println\"methodA\";\n        }\n        public void methodB{\n            System.out.println\"methodB\";\n        }\n    }\n   \n2. MyInterface 생성\n   java\n   public interface MyInterface {}\n   \n3. MyBook 클래스 생성 &rarr; Book클래스 상속 &rarr; MyInterface구현\n   java\n   public class MyBook extends Book implements MyInterface {}\n   \n\n 클래스 정보 가져오기\n 필드 가져오기\ngetFields - public 필드만 가져온다.\njava\nClass<Book> bookClass = Book.class;\nField bookFields = bookClass.getFields;\n\nArrays.streambookFields.forEachSystem.out::println; // 필드를 출력하는 예시\n\n출력\nsh\npublic int com.ex.Book.d\n\n---\n\ngetFields - 모든 필드를 가져온다.\njava\n...\nField bookFields = bookClass.getFields;\nArrays.streambookFields.forEachSystem.out::println;\n\n출력\nsh\nprivate static java.lang.String com.ex.Book.a\nprivate static final java.lang.String com.ex.Book.b\nprivate java.lang.String com.ex.Book.c\npublic int com.ex.Book.d\nprotected java.lang.String com.ex.Book.e\n\n---\n\n필드의 값 가저오기\njava\nClass<Book> bookClass = Book.class;\nField bookFields = bookClass.getDeclaredFields;\nBook book = new Book;\n\nArrays.streambookFields.forEachfield -> {\n    try {\n        field.setAccessibletrue; // access level에 상관없이 field를 가저오는 방법 \n        Object value = field.getbook;\n        System.out.printlnfield + \" = \" + value + \"\\n\";\n    } catch IllegalAccessException e { \n        // 만약 field.setAccessiblefalse; 면 해당 예외가 발생한다.\n        e.printStackTrace;\n    }\n};\n\n출력\njava\nprivate static java.lang.String com.ex.Book.a = author\n\nprivate static final java.lang.String com.ex.Book.b = isbn\n\nprivate java.lang.String com.ex.Book.c = title\n\npublic int com.ex.Book.d = 10000\n\nprotected java.lang.String com.ex.Book.e = a\n\n\n위 예제들을 통해 알 수 있는 점은 \n\n 메서드 가져오기\njava\nClass<Book> bookClass = Book.class;\nArrays.streambookClass.getDeclaredMethods.forEachSystem.out::println;\n\n출력\nsh\npublic void com.ex.Book.methodB\npublic final native void java.lang.Object.waitlong throws java.lang.InterruptedException\npublic final void java.lang.Object.waitlong,int throws java.lang.InterruptedException\npublic final void java.lang.Object.wait throws java.lang.InterruptedException\npublic boolean java.lang.Object.equalsjava.lang.Object\npublic java.lang.String java.lang.Object.toString\npublic native int java.lang.Object.hashCode\npublic final native java.lang.Class java.lang.Object.getClass\npublic final native void java.lang.Object.notify\npublic final native void java.lang.Object.notifyAll\n\n- public인 methodB뿐만 아니라 Object에 있는 method도 함께 가져왔다.\n---\n\n해당 클래스에 있는 method만 가져오기\njava\nClass<Book> bookClass = Book.class;\nArrays.streambookClass.getDeclaredMethods.forEachSystem.out::println;\n\n출력\nsh\nprivate void com.ex.Book.methodA;\npublic void com.ex.Book.methodB;\n\n- 이번에는 Book클래스에만 있는 모든 클래스를 가져왔다.\n\ninvoke - 메서드 실행하기\njava\nClass<Book> bookClass = Book.class;\nBook book = new Book;\n\nArrays.streambookClass.getDeclaredMethods.forEach\n        method -> {\n            try {\n                method.setAccessibletrue; // private에도 접근할 수 있게함\n                method.invokebook, null;\n            } catch IllegalAccessException | InvocationTargetException e {\n                e.printStackTrace;\n            }\n        }\n;\n\n- invoke의 첫 인자로 해당 클래스의 인스턴스가 들어가고 두번째 인자부터 해당 매서드의 파라미터 값을 넣는다.\n\n 해당 클래스의 인터페이스와 super클래스를 가져오는 방법\njava\nClass<Book> bookClass = Book.class;\nClass<? super Book> superclass = bookClass.getSuperclass;\nSystem.out.println\"superclass = \" + superclass;\n\nClass<MyBook> myBook = MyBook.class;\nArrays.streammyBook.getInterfaces.forEachSystem.out::println;\n\n출력\nsh\nsuperclass = class java.lang.Object\ninterface com.ex.MyInterface\n\n\n\n그 밖에... 여러가지 기능들을 사용할 수 있다. API가 너무 많기때문에 여기서 생갹하겠다. 나중에 필요할 떄 더 정리할 예정\n\n Reflection의 주의사항\n- 지나친 사용은 성능 문제를 야기할 수 있다.\n- 컴파일 시점이 아닌 런타임 시점에 발생하는 문제를 만들 수 있다.\n- 접근 지시자를 무시할 수 있다.",
    "tags": [
      "TIL",
      "byte-code-controller-way",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Proxy Pattern",
    "url": "/programming/2022/03/29/proxy-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "<img width=650 src=\"/assets/images/posts/programming/proxy-simple.png\">",
    "content": "Proxy Pattern\n<img width=650 src=\"/assets/images/posts/programming/proxy-simple.png\">\n\n: Proxy Class를 통해 대신 전달 하는 형태로 설계되며, 실제 Client는 접근하려는 객체Real Subject를 바로 접근하는게 아닌 Proxy로 부터 결과를 받는다.\n> Proxy: 대리인 이라는 뜻, 뭔가를 대신하여 처리하는것  \n\n\n주로 logging, 혹은 부가적인 기능을 추가할 때 사용한다. DataJPA Repository, Hibernate Entity 등... 다양한 곳에서 사용한다.\n\n이런 부가적인 기능을 메서드에 직접 코드를 수정해서 추가하는게 어닌 원래 매서드의 코드를 수정하지 않고 부가적인 기능을 추가할 수 있게 하는 패턴이다.\n 특징\n 장점\n- 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.\n  > OCP - Open-Close Principle\n- 기존 코드가 해야 하는 일만 유지할 수 있다.\n  > SRP - Single Responsibility Principle\n- 기능 추가 및 초기화 지연 등으로 다양하게 활용할 수 있다.\n  > 자원이 큰 객체를 늦게 초기화 하던지 혹은 로깅, 캐싱등 여러가지로 활용할 수 있다. \n 단점\n- 코드의 복잡도가 증가한다.\n\n Proxy 패턴 구현 예제\n\n\n 1. 상속을 이용한 Proxy - 인터페이스가 없는 경우\n메서드 Overried를 이용해 프록시 패턴을 구현한다. - 상속성\n\n<img width=550 src=\"/assets/images/posts/programming/proxy-uml-extend.png\">\n\n- Proxy는 RealSubject를 상속받는다.\n- Proxy는 RealSubject의 메서드를 overried한다.\n\n 구현\n1. GameService와 GameService의 Proxy객체인 GameServiceProxy가 있다.\n2. GameService는 start라는 매서드를 가진다.\n3. 원래 메서드GameService.start의 코드를 수정하지 않고 해당 메서드의 수행속도를 측정하고 싶다.\n4. GameServiceProxy가 GameService를 상속받고 부모의 start의 수행속도를 측정한다.\n\njava\n// GameServiceReal Subject\npublic class GameService{\n  public void start throws InterrubtedException{\n    System.out.println\"Game Start!!\"\n  }\n}\n\n// GameServiceProxyProxy\npublic class GameServiceProxy extends GameService {\n\n  @Overried\n  public void start throws InterrubtedException{\n    long before = System.currentTimeMillis;\n    System.out.println\"이 자리에 오신 여러분을 진심으로 환영합니다.\";\n    Thread.sleep1000L;\n  }\n}\n\npublic class Client {\n  public static void mainString args{\n    GameService gameService = new GameServiceProxy;\n    gameService.start;\n  }\n}\n\n출력 결과 \nsh\nGame Start!!\n1000\n\n\n 사용하는 이유\n- Real Subjectex. GameService를 고칠 수 없는 경우 상속으로 해결한다.\n- 인터페이스를 이용한 Proxy구조보다 비교적 단순하다.\n\n하지만 가급적으로 인터페이스를 활용하는게 좋다.\n\n 2. 인터페이스를 이용한 Proxy\n인터페이스를 이용해 프록시 패턴을 구현한다. - 다형성\n\n<img width=550px src=\"/assets/images/posts/programming/proxy-uml-interface.png\">\n\n- Proxy와 RealSubject는 interface인 Subject를 구현한다.\n- Proxy는 RealSubject를 가지고 있는다.\n- Proxy객체는 RealSubject의 메서드를 대신 실행한다.\n\n 구현\n1. GameService 인터페이스와 그를 구현한 DefaultGameService, ProxyGameService가 있다.\n2. DefaultGameService의 proxy는 ProxyGameService이고 DefaultGameService를 필드로 가지고 있다.\n3. 원래 메서드DefaultGameService.start의 코드를 수정하지 않고 해당 메서드의 수행속도를 측정하고 싶다.\n4. GameServiceProxy는 DefaultGameService의 메서드를 대신 실행해 start의 수행속도를 측정한다.\n\njava\n// DefaultGameServiceRealSubject와  ProxyGameServiceProxy의 Subject 인터페이스\npublic interface GameService {\n    void start throws InterruptedException;\n}\n\n// DefaultGameServiceReal Subject\npublic class DefaultGameService implements GameService{\n\n    @Override\n    public void start throws InterruptedException {\n        System.out.println\"Game Start!!!\";\n        Thread.sleep1000L;\n    }\n}\n\n// GameServiceProxyProxy\npublic class GameServiceProxy implements GameService{\n\n    private final GameService gameService; // proxy를 적용할 RealSubject\n\n    public GameServiceProxyGameService gameService {\n        this.gameService = gameService;\n    }\n\n    @Override\n    public void start throws InterruptedException {\n        long before = System.currentTimeMillis;\n        gameService.start;\n        System.out.printlnSystem.currentTimeMillis - before;\n    }\n}\n\n// Client\npublic class Client {\n    public static void mainString args throws InterruptedException {\n        GameService gameService = new GameServiceProxynew DefaultGameService;\n        gameService.start;\n    }\n}\n\n출력 결과\nsh\nGame Start!!\n1000\n\n\n 사용하는 이유\n- 사용범위가 넓다. ex. 늦은초기화\n  java\n  public class GameServiceProxy implements GameService{\n\n    private final GameService gameService; // proxy를 적용할 RealSubject\n\n    @Override\n    public void start throws InterruptedException {\n        long before = System.currentTimeMillis;\n        ifgameService == null{\n          gameService = new DefaultGameService; // 야매지만 늦은 초기화를 수행했다.\n        }\n        gameService.start;\n        System.out.printlnSystem.currentTimeMillis - before;\n    }\n  }\n  \n- 상속을 이용한 방법보다 조금 더 복잡하다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "Java Beans",
    "url": "/programming/2022/03/29/java-beans/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> EJBEnterprise Java Beans와 전혀 다르다.",
    "content": "Java Beans\n> EJBEnterprise Java Beans와 전혀 다르다.\n\n자바빈즈Java Beans 는 자바Java로 작성된 소프트웨어 컴포넌트를 일컫는 말로 데이터 표현을 목적으로하는 자바 클래스다.\n- Java Beans클래스는 Java Beans Convention를 지켜야 한다.\n- 주로 GUI에서 사용한다.\n- 이 모든 규칙을 따를 필요는 없다.\n  > GUI툴을 사용할 거 아니라면\n \n오늘날 우리는 클래스들의 특정 프로퍼티에 접근하는 여러 프레임워크가 있다. ex. Spring, JPA, thymleaf  \n이러한 툴들이 이런 객체들의 프로퍼티에 접근하기 위해 어떠한 메서드에 접근해야 하는지 일관적인 방법이 필요하다.  \n이미 Java Bean규약에 정의되어 있으므로 이 규약을 일부 따르고 있다.\n\n Java Beans Convention\n- JavaBeans의 목적은 여러가지 객체를 하나의 객체Bean에 담기 위함이다.\n- JavaBeans의 규칙을 다른사람과 협업을 하기 위한 프로토콜이라고 이해하는게 편하다.\n  > JavaBeans의 규칙에 따르는 툴들이 규칙에 따라 객체에 접근 할 수 있다. ex. jackson 라이브러리\n\n\n 1. 모든 필드는 private이며, getter/setter메서드를 통해서만 접근이 가능하다.\n- 필드에 대한 완벽한 제어를 하기위함이다\n- 캡슐화 - Encapsulation를 지키기 위함이다.\n\n boolean값은 어떤 형식으로 getter와 setter를 만들어야 할까?\n만약 User라는 객체가 있고 이 User가 만료되어 있는지 확인하기 위해 expired라는 boolean형 값을 가진다고 해보자\njava\npublic class User{\n  ...\n  boolean expired = false;\n  ...\n}\n\n그러면 어떻게 getter를 만들어야 할까? 그냥 getExpired라고 하면 될까?\n\n하지만, JavaBeans spec에서는 boolean의 getter를 만들 떄 is를 사용한다.   \n그러면 expired의 getter는 isExpired가 된다.\n\n 2. Argument가 없는no-argument public 생성자가 존재한다.\n> 개인적으로 불변 객체를 만드는 방법과 반대인 거 같아서 부정적인 의견이다. \n- 생성자에 Argument가 없다면 필요한 데이터만 할당해주면 된다.\n- 기본 생성자로 객체를 생성하고, getter/setter를 호출해 할당하면 Argument에 관여받지 않고 할당이 가능하다.\n- 리플렉션을 통한 객체를 생성하기 쉽다.\n\n 3. java.io.Serializable인터페이스를 구현한다. \n- 우리는 메모리에 존재하는 객체를 영속화하여 사용할 수 있다.\n  > DB에 저장, file에 저장, 네트워크 정보 전송 등...\n- File I/O, 통신을 할 떄 사용하는 Stream으로 변환 해야 한다.\n  > 이 작업을 직렬화Serialization이라고 부른다,\n- 다른 Builder에서 편리하게 공통의 Convention을 지키면서 사용하기 위해서 java.io.Serializable인터페이스를 구현한다.\n\n 특징\n\n 장점\n- Bean의 속성, 이벤트, 메소드는 다른 애플리케이션에 노출이 가능하다.\n- Bean을 구성하는데 도움이 되는 보조 프로그램이 제공될 수 있다.\n- Bean의 설정정보는 영속성 저장소에 저장하고 복원할 수 있다.\n\n 단점\n- 기본 생성자가 있는 클래스는 유효하지 않은 상태에서 인스턴스화 될 수 있다.\n    - 수동으로 생성하는 경우 이러한 문제가 생길 수 있다.\n    - 컴파일러가 이러한 문제를 감지하지 못한다.\n- 불변 객체가 제공하는 이점이 없다.\n  > Bean은 기본적으로 변경가능하다.\n- 모든 속성 - property에 대해 getter를 만들고 대부분의 property에 대해 setter를 만들어야 하는 경우 많은 양의 코드가 생긴다.\n  > 그래서 Lombok를 사용한다.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "Class Loader System - 클래스 로더 시스템",
    "url": "/programming/2022/03/29/class-loader-system---클래스-로더-시스템/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> 로딩 &rarr; 링크 &rarr; 초기화",
    "content": "Class Loader System - 클래스 로더 시스템\n> 로딩 &rarr; 링크 &rarr; 초기화\n\n<img width=500 src=\"/assets/images/posts/programming/class-loader-system.png\">\n\n 1. 로딩\n클래스 로더가 .class파일을 읽은 후 그 내용에 따라 적절한 바이너리 데이터를 만들고 메서드 영역에 저장한다.\n- 기본적으로 계층형 구조로 되어있다.\n  > 기본적인 3가지 클래스 로더, Bootstrap. PlatformExtension, Application\n- 최상위 Bootstrap클래스 로더부터 하위 클래스 로더인 Application클래스 로더가 class를 찾다 존재하지 않으면 ClassNotFoundException을 던지고 해당 프로그램 혹은 스래드가 죽는다.\n    > Bootstrap &rarr; Platform &rarr; Application &rarr; throw ClassNotFoundException\n- Extension Class Loader는 JDK9부터 Platform Class Loader로 이름변경 되었다.\n- 로딩이 끝나면 해당 클래스 타입의 Class<?>객체를 생성하여 힙 - heap 영역에 저장된다.\n 저장되는 데이터\n 1. FQCN - Fully Qualified Class Name   \n모든 클래스에는 정의된 클래스 이름과 패키지 이름이 있는데, 완전한 클래스 이름은 클래스 이름 + 패키지 이름을 합쳐야된다.\n\njava\nString a = \"a\" // Class Name\njava.lang.String b = \"b\" // Fully Qualified Class Name\n\n2. Class, Interface, Enum  \n3. Method, Variable\n\n Class Loader의 실체를 확인해보자\njava\npublic class App {\n\n    public static void mainString args {\n        ClassLoader classLoader = App.class.getClassLoader;\n        System.out.println\"classLoader = \" + classLoader;\n        System.out.println\"classLoader.getParent = \" + classLoader.getParent;\n        System.out.println\"classLoader.getParent.getParent = \" + classLoader.getParent.getParent;\n    }\n}\n\nmain메서드가 있는 클래스에서 class loader를 불러와 부모와 자식들을 확인해 봤다.\n\n출력결과는 다음과 같다.\nsh\nclassLoader = jdk.internal.loader.ClassLoaders$AppClassLoader@2c13da15\nclassLoader.getParent = jdk.internal.loader.ClassLoaders$PlatformClassLoader@17c68925\nclassLoader.getParent.getParent = null\n\nAppClassLoaderApplicationClassLoader와 PlatformClassLoader가 출력된다. 하지만 BootstrpClassLoader는 나오지 않고 null이 출력된다.\n\n BootstrapClassLoader를 불러올 수 없는 이유\n결론은 native코드로 구현되어 Java에서 볼 수가 없다.\n- native코드로 되어있어서 JVM구현체마다 다르다.\n- Java code에서 참조를 할 수 없다.\n\n\n하지만 jdk.internal.loader.ClassLoaders에서 Bootstrap클래스 로더를 확인할 수 있다.\n\n<img width=500 src=\"/assets/images/posts/programming/check-class-loader.png\">\n\n 2. 링크\n- Verify, Prepare, Reolveoptional 세 단계로 나눠져 있다.\n\n Verify\n.class 파일이 형식이 유효한지 체크한다.\n- 혹시라도 byte code가 올바르지 않게 변경될 수 있으므로\n\n Prepare\n클래스 변수static 변수와 기본값에 필요한 메모리를 준비하는 과정이다.\n\n Resolve\n심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체한다.\n- 선택적으로 이루어 진다. Optinoal\n\n 3. 초기화\nstatic변수의 값을 할당한다.\n> static변수의 값을 할당한다.",
    "tags": [
      "TIL",
      "coding",
      "JVM",
      "development",
      "java"
    ]
  },
  {
    "title": "Decorator Pattern",
    "url": "/programming/2022/03/29/decorator-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴\n- 기본 뼈대클래스는 유지하되, 이후 필요한 형태로 꾸밀 때 사용한다.\n- 확장의 필요한 경우 상속의 대안으로 사용한다\n- SOLID에 OCP, DIP를 따른다.",
    "content": "Decorator Pattern\n: 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴\n- 기본 뼈대클래스는 유지하되, 이후 필요한 형태로 꾸밀 때 사용한다.\n- 확장의 필요한 경우 상속의 대안으로 사용한다\n- SOLID에 OCP, DIP를 따른다.\n\n Decorator Pattern 테이블\n<img width=450px src=./img/decorator-pattern-table.png>\n\n Decorator Pattern의 적용\n 요구사항\n- ICar interface를 상속받아 Audi차를 여러모댈로 나눠 만들어라\n- ICar에는 getPrice, showCost 가 선언되어있다.\n\n 1. Decorator Pattern의 적용 전\n 선언과 기능의 분리를 위해 ICar 인터페이스 생성\njava\npublic interface ICar {\n    int getPrice;\n    void showCost;\n}\n\n\n Audi 차를 만들기위한 기본 class 생성\njava\npublic class Audi implements ICar{\n\n    private int cost;\n\n    public Audiint cost{\n        this.cost = cost;\n    }\n\n    @Override\n    public int getPrice{\n        return this.cost;\n    }\n    @Override\n    public void showCost {\n        System.out.println\"Audi Base는 \"+cost+\" 원 입니다.\";\n    }\n}\n\n\n결과\njava\npublic class main{\n    public sstatic void mainString args{\n        ICar audi = new Audi1000;\n        audi.showPrice; // 출력: Audi Base는 1000 원 입니다.\n\n    }\n}\n\n- 우리는 여러 모델의 아우디 Car를 만들어야 된다.\n- 여러 모델 class에 바로 ICar를 상속받아 여러 모델의 클래스를 만들수 있지만 Decorator Pattern을 이용여 모델을 추가할 것이다.\n- 여러 모델a3, a4, a5는 모델값modelPrice이 기본값에서 추가된다.\n\n 1. Decorator Pattern의 적용 후\n Decorator Pattern을 사용하기 위한 AudiModelDecorator class 만들기\njava\npublic class AudiModelDecorator implements ICar{\n\n    protected ICar audi;\n    protected int modelPrice;\n\n    public AudiModelDecoratorICar audi{\n        this.audi = audi;\n    }\n\n    @Override\n    public int getPrice {\n        return audi.getPrice;\n    }\n\n    @Override\n    public void showCost {\n        System.out.println\"가격은 \"+audi.getPrice+modelPrice+\" 만원 입니다\";\n    }\n\n\n 여러 모델class 선언하기\njava\npublic class A3 implements AudiModelDecorator{\n\n    public A3ICar audi {\n        superaudi;\n        this.modelPrice = 1000;\n    }\n}\n\npublic class A4 extends AudiModelDecorator {\n    public A4ICar audi {\n        superaudi;\n        this.modelPrice = 2000;\n    }\n}\n\npublic class A5 extends AudiModelDecorator {\n\n    public A5ICar audi {\n        superaudi;\n        this.modelPrice = 3000;\n    }\n}\n\n\n 결과\njava\npublic class Main{\n    public static void main{\n\n        ICar audi = new Audi1000;\n        audi.showCost; // 출력: Audi Base는 1000 원 입니다.\n\n        ICar audi3 = new A3audi;\n        audi3.showCost; // 출력: A3의 가격은 2000 원 입니다.\n\n        ICar audi4 = new A4audi;\n        audi4.showCost; // 출력: A4의 가격은 3000 원 입니다.\n\n        ICar audi5 = new A5audi;\n        audi5.showCost; // 출력: A5의 가격은 4000 원 입니다.\n    }\n}",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "람다 표현식",
    "url": "/programming/2022/03/29/람다-표현식/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 간단히 메소드를 하나의 식으로 표현한 것이다.",
    "content": "람다 표현식\n: 간단히 메소드를 하나의 식으로 표현한 것이다.\n\n 표현방법\n 1. 람다\n인자 리스트 -> {바디}\n 2. 인자리스트\n- 인자가 없을 떄 : \n  java\n  Supplier<Integer> get10 =  -> 10;\n  //혹은\n  Supplier<Integer> get10 =  -> {\n      return 10\n  };\n  \n- 인자가 한개일 때: one, one\n\n- 인자가 여러개 일 때: one, two\n  java\n  BinaryOperator<Integer> sum = a, b -> a + b;\n  //혹은\n  BinaryOperator<Integer> sum = Integer a, Integer b -> a + b;\n  \n- 인자의 타입을 생략 가능하다.\n- 컴파일러가 추론infer하지만 명시할 수 있다.  \n   ex. Integer one, Integer two \n\n 변수 캡처Variable Capture\n effectiv final\n: final로 선언은 되지 않았지만 변수의 값이 사실상 변하지 않는 final한 변수\n- 만약 나중에 effective final로 선언된 변수의 값이 변경된다면 effective final이 아니다. \n- Java 8부터 지원하는 기능이다.\n- 익명 클래스 구현체, 람다에서 사용가능하다.\n  \n예시\njava\npublic void run{\n    int baseNumber = 10; // 사실상 baseNumber가 변하지 않는다.\n\n    IntConsumer printInt = i -> System.out.printlni + baseNumber;\n\n    // baseNumber++ 와 같이 변수의 값을 변경한다면 effectiv final이 아니다.\n}\n\n\n 로컬 변수 캡처\n: final 혹은 effective final사실상 final 인 경우에만 참조할 수 있다.\n- 그렇지 않을 경우 concurrency동시성 문제가 생길 수 있어서 컴파일러가 방지한다.\n\n예시\njava\npublic void run{\n    final int baseNumber = 10;\n\n    IntConsumer printInt = i -> System.out.printlni + baseNumber;\n}\n\n\n 변수의 쉐도잉Variable Shadowing\n> 익명 클래스는 새로 scop를 만들지만, 람다는 람다를 감싸고 있는 스콥과 같다.\njava\npublic void run{\n\tint num = 10; \n    num++; //num 을 증가하였으므로 effective Final이 아니다.\n\t\n\t//로컬 클래스\n\tclass local\n\t{\n\t\tvoid print\n\t\t{\n            // 여기서 num은 local class속 printf에 scope를 가져 run매서드의 num을 가린다.\n\t\t\tint num = 1; \n\t\t\tSystem.out.printlnnum; //1를 출력한다.\n\t\t}\n\t}\n\t\n\t//익명 클래스\n\tConsumer<Integer> anomy = new Consumer<Integer> {\n\t\t\n\t\t@Override\n\t\tpublic void acceptInteger t {\n            // 여기서 num은 Consumer class속 accept에 scope를 가져 run매서드의 num을 가린다.\n\t\t\tint num = 1 + t;\n\t\t\tSystem.out.printlnnum; //1 + 입력받은값t가 출력된다.\n\t\t}\n\t};\n\t\n\t//람다식\n    /\n    / 람다식은 run 메서드와 scope가 같으므로 run의 num을 참조하지만\n    / run의 num은 effective Final이 아니므로 컴파일 오류가 난다.\n    / \n\tConsumer<Integer> lamda = num -> // num에 오류\n\t{\n\t\tint num=11; // 오류\n\t\tSystem.out.println\"hi\";\n\t};\n}",
    "tags": [
      "TIL",
      "grammar",
      "coding",
      "development",
      "java",
      "java8"
    ]
  },
  {
    "title": "함수형 interface",
    "url": "/programming/2022/03/29/함수형-interface/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 추상 메서드가 1개만 있으면 모두 함수형 이다.\n- 정적 메서드, 디폴트 메서드가 있을 수 있다.\n- SAMSingle Abstract Method\n-  : Java compiler는 이렇게 명시된 함수형 에 두 개 이상의 메소드가 선언되면 오류를 발생시킨다.",
    "content": "함수형 interface\n- 추상 메서드가 1개만 있으면 모두 함수형 interface이다.\n- 정적static 메서드, 디폴트default 메서드가 있을 수 있다.\n- SAMSingle Abstract Method\n- @FunctionalInterface : Java compiler는 이렇게 명시된 함수형 interface에 두 개 이상의 메소드가 선언되면 오류를 발생시킨다.\n\n Java에서의 함수형 프로그래밍\n- 함수를 interface의 First class obejct로 사용할 수 있다.\n- 순수함수 Pure function : 상태가 없는 함수를 말한다. ex 객체\n   - 사이드 이팩트를 만들 수 없다. &rarr; 함수 밖에 있는 값을 변경하지 못한다.\n- 고차 함수 Higher-Order Function : 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수 있다.\n- 불변성 \n\n 함수형 interface의 선언\n 예시\njava\n@FunctionalInterface // 함수형 인터페이스가 아니라면 compile error가 생긴다.\npublic interface RunSomething{\n\n    void doIt; // 추상 메서드 1개\n\n    //정적 메서드\n    static void printName{\n        System.out.println\"siwon\";\n    }\n\n    // 디폴트 메서드\n    default void printAge{\n        System.out.println18;\n    }\n}\n\n 함수형 interface의 사용\n 1-1. 익명 클래스\njava\nRunSomething r = new RunSomething {\n    @Override\n    public void one {\n        System.out.println\"siwony\";\n    }\n};\n\nr.one;\n\n 1-2. lambda\njava\n// 한줄일때\nRunSomething r =  -> 실행문\nr.doIt;\n\n// 2줄이상일때\nRunSomething r =  -> {\n    실행문1;\n    실행문2;\n    ...\n}\nr.doIt;\n\n//매개변수를 받을 때\nRunSomething r = number -> 실행문;\nr.doIt;\n\n// 매개변수가 2개 이상일때\nRunSomething r = number, ... -> 실행문;\n\n// 리턴값이 있을때 ex 두 정수를 더하는 메서드\nRunSomething r = i, j -> return i + j;\nr.doIt10, 20;\n\n\n 자바에서 제공하는 함수형 인터페이스\n> Java에서는 1.8버전부터 기본적으로 자주 사용할만한 함수형 인터페이스를 제공한다.\n- java.lang.function 패키지https://url.kr/b295ks 에 정의 되어있다.\n\n Function<T, R> 를 통한 람다표현식의 사용\n- T 타입을 받아 R 타입을 리턴하는 함수 인터페이스 이다.\n- apply 함수만 구현하면 된다.\n- 다음과 같은 함수 조합용 메서드를 제공한다. \n  - compose\n  - andThen\n\n 람다 표현식을 사용하기 전\n정수 10에 입력받은 숫자를 더하고 싶다면\n\n1. Plus10이라는 클래스에 함수를 만든다. 혹은 그냥 익명함수를 사용할 수 있다.\njava\npublic class Plus10 implements Function<Integer, Integer>{\n    @Override\n    public Integer applyInteger i{\n        return 10 + i;\n    }\n}\n\n2. 객체를 생성해서 사용한다.\njava\npublic class main{\n    public static void mainString args{\n        Plus10 p10 = new Plus10;\n        System.out.printlnp10.apply1; // 11 출력\n    }\n}\n\n 람다 표현식의 사용\njava\npublic class main{\n    public static void mainString args{\n        Function<Integer, Integer> p10 = i -> i + 10;\n        System.out.printlnp10.apply1; // 11 출력\n    }\n}\n\n\n 자바에서 제공하는 다양한 함수형 인터페이스\n UnaryOperator<T>\n- Function<T, R>의 특수한 형태로, 입력값 하나를 받아 동일한 타입을 리턴한다.\n  \n Consumer<T>\n: T 타입을 받아 아무값도 리턴하지 않는 함수 인터페이스\n- 함수 조합용 메서드를 제공한다.\n    - andThen\n\n사용예시\njava\nConsumer<Integer> printT = i -> System.out.printlni;\nprintT.accept1; // 1출력\n\n//위 코드랑 똑같은 동작을 한다.\nConsumer<Integer> printT = System.out::println; \nprintT.accept1; // 1출력\n\n BiFunction<T, U, R>\n- 두 개의 값T, U를 받아 R 타입을 리턴하는 함수 인터페이스\n  - R applyT t, U u\n\n BinaryOperator<T>\n   Function<T, U, R>의 특수한 형태로, 동일한 타입의 일렬값 두개를 받아 리턴하는 함수 인터페이스\n\n Supplier<T>\n- T 타입의 값을 제공하는 함수 인터페이스\n  - T get;\n\n사용예시\njava\nSupplier<Integer> get10 =  -> 10;\nSystem.out.printlnget10.get; // 10 출력\n\n\n Predicate<T>\n- T 타입을 받아서 boolea를 반환하는 함수 인터페이스\n  - boolean testT t\n- 다음과같은 함수 조합용 메서드를 제공한다.\n  - And\n  - Or\n  - Negate\n\n사용예시\njava\nPredicate<Integer> isEven = i -> i % 2 == 0;\nisEven.test10 // true",
    "tags": [
      "TIL",
      "grammar",
      "coding",
      "development",
      "java",
      "java8"
    ]
  },
  {
    "title": "Enumeration 와 Iterator",
    "url": "/programming/2022/03/29/enumeration-와-iterator/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> Enumeration 와 Iterator는 서로 동작하는 것이 비슷하다.  \n> 먼저 이 두 개를 알기 전에  방식에 대해 알아야 한다.",
    "content": "Enumeration 와 Iterator\n> Enumeration 와 Iterator는 서로 동작하는 것이 비슷하다.  \n> 먼저 이 두 개를 알기 전에 Fila-Fast 방식에 대해 알아야 한다.\n\n Fila-Fast 방식\n: 순차적 접근이 모두 끝나기 전에 컬렉션 객체에 변경이 일어날 때 순차적 접근이 실패되면서 ConcurrentModificationException를 반환 하는 것\n\n>Enumeration은 순차적 접근 시 컬렉션 객체에 변경이 일어나도 이를 무시하고 끝까지 동작하는 반면   \n>Iterator는 Fila-Fast 방식으로 동작한다.\n\n Enumeration\n> 일반적으로 JDK 1.2 이후 버전에서는 Enumeration보다 Iterator를 사용하는 것을 권장하고 있다.\n- JDK 1.2 부터 지원한다.\n- 반복을 시작하기 전 원본 데이터에 대해 snap-shot 을 찍고 해당 snap-shot에 대한 반복을 시작한다.  \n  &rarr; 반복을 시작하기 전 원본과 snap-shot에 대한 불일치가 생길 수 있다.\n- Iterator와 다르게 삭제가 없다.\n\n Method\n- boolean hasMoreElements : Vector로 부터 생성된 Enumeration의 요소가 있으면 true, 아니면 false 반환\n- E nextElement : Enumeration 내의 다음 요소를 반환한다. \n\n\n Iterator\n- JDK 1.4 부터 지원한다.\n- Fila-Fast 방식을 지원한다.  \n- Enumeration와 다르게 삭제가 있다.\n\n Method\n- boolean hasNext : 읽어올 요소가 남아있는지 확인하는 메소드. 요소가 있다면 true, 없다면 false\n- E next : 다음 데이터를 반환한다.\n- void remove : next로 읽어온 요소를 삭제한다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "api"
    ]
  },
  {
    "title": "Observer Pattern",
    "url": "/programming/2022/03/29/observer-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 변화가 일어 났을때, 미리 등록된 다른 클래스에 통보해주는 패턴\n> 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만듭니다.",
    "content": "Observer Pattern\n: 변화가 일어 났을때, 미리 등록된 다른 클래스에 통보해주는 패턴\n> 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만듭니다.\n\n\n- event listener에서 해당 패턴을 사용 하고 있다.\n- 관찰자 패턴이라고 하기도 한다.\n\n Oberver Pattern 테이블\n<img width=450px src=./img/observer-pattern-table.png>\n\n Oberver Pattern 의 구현\n Butten에 대한 IButtonListener 인터페이스 만들기\njava\npublic class IButtonListener{\n\n    public void clickEventString event;\n}\n\n 버튼을 구현할 Button 클래스 만들기\njava\npublic class Button{\n\n    private String name;\n    private IButtonListener buttonListener;\n\n    public ButtonString name{\n        this.name = name;\n    }\n\n    public void clickString message{\n        buttonListener.clickEventmessage;\n    }\n\n    public void addListenerIButtonListener buttonListener{\n        this.buttonListener = buttonListener;\n    }\n}\n\n\n 결과\njava\npublic class Main{\n\n    public static void mainString args{\n\n        Button button = new Button\"버튼\";\n\n        button.addListenerevent -> {\n            System.out.printlnevent;\n        };\n\n        button.click\"메시지 전달 : click 1\"; // 출력: 메시지 전달 : click 1\n        button.click\"메시지 전달 : click 2\"; // 출력: 메시지 전달 : click 2\n        button.click\"메시지 전달 : click 3\"; // 출력: 메시지 전달 : click 3\n        button.click\"메시지 전달 : click 4\"; // 출력: 메시지 전달 : click 4\n\n    }\n}\n\n1. Button 객체를 button변수에 생성\n2. button에 addListener 메서드에 람다를 이용해 IButtonListener 구현\n3. button에 click 메서드가 동작하면 addListener를 통해 등록된 IButtonListener 구현체에 clickEvent 메서드가  동작한다.\n\n 특징\n- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 정보가 갱신되는 1:N 의 관계를 정의한다.\n- 연결은 인터페이스를 이용하여 느슨한 결함성을 유지한다.\n- JAVA에서 기본으로 Observable 클래스와 Observer 인터페이스를 제공한다. &rarr; 현제는 despatched 됐다.\n- Swing, Android 등에서 UI관련된 곳에서 이 옵저버 패턴이 많이 사용된다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "Interface",
    "url": "/programming/2022/03/29/interface/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": Java Programing 언어에서 들이 구현해야 하는 동작을 지정하는데 사용하는 추상 자료형이다.\n- 라는 키워드를 사용하여 선언한다.\n- 메소드 시그니처, 상수 선언\n  >  과 은 상수를 값을 할당해줘야 한다.",
    "content": "Interface\n: Java Programing 언어에서 class들이 구현해야 하는 동작을 지정하는데 사용하는 추상 자료형이다.\n- interface라는 키워드를 사용하여 선언한다.\n- 메소드 시그니처Method sigature, 상수 선언\n  > static 과 final은 상수를 값을 할당해줘야 한다.\n 역할\n interface의 특징\n- 인터페이스는 객체를 어떻게 구성해야 하는지 정리한 설계도이다.\n- 객체의 교환성다형성을 높여준다.\n- interface 변수에 interface가 구현된 서로 다른 구현 객체를 할당해서 사용이 가능하다.\n- 구현 객체를 직접 몰라도 interface만 알아도 객체 호출이 가능하게 한다.\n- 객체가 interface를 사용하면, interface 메서드를 반드시 구현해야 하는 제약을 건다.\n\n위 특징을 이용해서 얻고자 하는 인터페이스interface 역할은 다음과 같다.\n<img width=550px src=\"/assets/images/posts/programming/interface-responsibility.png\">\n\ninterface를 이용하여, 개발 코드를 직접 수정하지 않고도, 사용하고 있는 객체만 변경할 수 있도록 하기 위함이다.\n\n interface 사용\n 1. interface 선언 \njava\npublic interface 인터페이스명 { ... }\n\n// ex.1\npublic interface User{ ... }\n// ex.2\ninterface User{ ... }\n\n- 인터페이스명은 UpperCamelCase로 작성되어야 한다.\n- interface는 접근지정자 public만 사용할 수 있다.\n  > public을 생략가능하다.\n- interface는 객체로 생성할 수 없기 떄문에 생성자를 가질 수 없다.\n\n 2. interface의 구성요소\n1. 상수 필드Constant Field2-1-상수-필드constant-field\n2. 추상 메서드Abstract Method2-2-추상-메서드abstract-method\n3. 디폴트 메서드Default Method2-3-디폴트-메서드default-method\n4. 정적 메서드Static Method2-4-정적-메서드static-method\n> 대괄호는 생략 가능한 것을 나타냄\n 2-1. 상수 필드Constant Field\njava\npublic interface User{\n    \n    public static final 필드타입 상수명 = 값;\n\n    //ex\n    String FIRST_NAME = \"siwon\"; //또는\n    public static final String FIRST_NAME = \"siwon\"; // 는 같다.\n}\n\n- interface는 객체가 될 수 없기에 런타임에 필드 데이터를 저장할 수 없다.  \n  > 그래서 인스턴스 필드instance field  / 정적 필드static field 는 선언이 불가능 하다. \n- 상수 필드는 Compile Time에 선언되고 Run Time에 변경되지 않으므로 인터페이스에 선언이 가능하다.\n- public static final는 명시적으로 사용하지 않아도, Compile Time에 자동으로 선언되어 상수로 만든다.\n- 네이밍은 모두 대문자로 구성되고 구분자는 Under Bar\"_\" 로 표현한다.\n\n 2-2. 추상 메서드Abstract Method\njava\npublic interface User{\n    public abstract 리턴타입 메서드이름매개변수, ...\n\n    // 예시\n    String sendMoenyMoney money; // 와\n    public abstract String sendMoenyMoney money; // 는 같다\n}\n\n- interface 변수로 호출된 메서드는 최종적으로 구현 객체에서 실행된다.\n- 추상 메서드는 리턴 타입 / 매서드 시그니처Method sigature 가 기술되는 클래스 설계 메서드이다.\n- public abstract은 명시적으로 선언하지 않아도, Compile Time에 자동으로 선언된다.\n\n 2-3 디폴트 메서드Default Method\njava\npublic interface User{\n    //디폴트 메서드Default Method\n    /\n    / @implSpac\n    / 이 구현체는 어떤 행동을 합니다.\n    /\n     public  default 리턴타입 메서드_이름매개변수, ...{ ... }\n\n    // 예시\n    /\n    / @implSpac\n    / 이 매서드는 사용자의 상태를 변경합니다.\n    /\n    public default void setStatusStatus status{\n        ifstatuc == Status.ACTIVE{\n            System.out.println\"사용자가 활성화 되었습니다.\";\n            return;\n        }\n        System.out.println\"사용자가 비활성화 되었습니다\";\n    }\n}\n\n- 선언시 default 가 필요하다.\n- 클래스의 인스턴스 메서드와 동일하다.  &rarr; 인스턴스 메서드 \n- 디폴트 메서드는 나중에 인터페이스를 구현한 구현 클래스에 인스턴스 메서드로 추가된다.\n- 기본 메서드는 구현체가 모르게 추가된 기능으로 그만큼 리스크가 있다.\n  - 구현체에 따라 런타임 에러가 발생할 수 있다. ex. NPE 등...\n  - 반드시 문서화를 하는걸 권장한다. @ImplSpec\n- Object에서 제공하는 메서드는 사용할 수 없다.\n  > hashCode, equals\n\n Default Method Override\n> 재정의Override를 통해서 구현 클래스에서 default 메서드를 재구현할 수 있다.\njava\n// 예시코드\npublic class UserImpl implements User{\n\n    @Override\n    public default void setStatusStatus status{\n        ifstatus == Status.ACTIVE\n            System.out.println\"사용자가 활성화 되었습니다.\";\n        else ifstatus == Status.AFK\n            System.out.println\"사용자가 잠수상태가 되었습니다.\";\n        else\n            System.out.println\"사용자가 비활성화 되었습니다\";\n    }\n}\n\n\n 2-4 정적 메서드Static Method\njava\npublic interface User{\n    // 정적 메서드Static Method\n     public  static 리턴타입 메서드이름매개변수, ... { ... }\n    // 예시\n    public static void printFirstName{\n        System.out.println\"나의 이름은 \" + firstName + \"입니다.\";\n    }\n}\n\n- Java8 에서 추가된 interface의 맴버이다.\n- 키워드로 static을 붙이고 메소드 시그니처 + 메서드의 Body몸체 가 있어야 한다.\n-  public 은 명시적으로 사용하지 않아도, Compile Time에 자동으로 선언된다.\n\n 3. interface 구현\n- 객체는 interface에 있는 추상 메서드를 구현한 실체 메서드를 가지고 있어야한다.\n- interface를 구현한 객체를 구현 객체구현체 라고 한다.\n\n interface 구현 방식\n1. 단일 인터페이스 구현 클래스Single Interface Implement Class3-1-단일-인터페이스-구현-클래스implementclass\n2. 다중 인터페이스 구현 클래스Multiple interface Implement Class3-2-다중-인터페이스-구현-클래스multiple-interface-implement-class\n3. 익명 구현 객체Anonymous Implement Object\n\n 3-1. 단일 인터페이스 구현 클래스ImplementClass\njava\npublic class 구현클래스_이름 implements 인터페이스_이름{\n    // 인터페이스의 추상 메서드를 구현한 실체 메서드 선언 부분\n}\n\n예시\njava\npublic interface User{\n    public static final String FIRST_NAME = \"siwon\";\n    String sendMonyMoney money;\n    public default void setStatusStatus status{\n        ifstatus == Status.ACTIVE{\n            System.out.println\"사용자가 활성화 되었습니다\";\n            return;\n        }\n        System.out.println\"사용자가 비활성화 되었습니다\";\n    }\n    public static void printFirstName { \n        System.out.println\"나의 이름은 \" + firstName + \"입니다.\"; \n    }\n}\n\npublic class Recipient implements User {\n\n    // 추상 메서드는 다음처럼 실체 메서드를 정의해야한다.\n    public String sendMoneyMoney money {\n        thirdpartyApi.sendmoney.getType, money.getAmount;\n        return Status.SUCCESS.name;\n    }\n\n    // 디폴트 메서드는 재정의가 가능하다.\n    // 재정의 하지 않으면, 인터페이스에 정의된 내용 그대로 사용된다.\n    @Override\n    public default void setStatusStatus status {\n        ifstatus == Status.ACTIVE {\n            System.out.println\"수취인이 활성화 되었습니다\";\n            return;\n        }\n        System.out.println\"수취인이 비활성화 되었습니다\";\n    }\n}\n\n만약 추상 메서드를 구현 클래스에서 실체 메서드를 모두 작성하지 않으면 추상클래스로 선언해야된다.\njava\npublic abstract class Recipient implements User{ ... }\n\n\n 3-2 다중 인터페이스 구현 클래스Multiple Interface Implement Class\njava\npublic class 구현클래스_이름 implements 인터페이스_이름1, 인터페이스이름2{\n    // 인터페이스의 추상 메서드를 구현한 실체 메서드를 선언하는 부분\n}\n\n- interface를 구현한 구현 클래스는 다중 인터페이스를 구현 가능합니다.\n- 다중 interface를 구현한 구현 클래스는 반드시 모든 interface의 추상 메서드를 실체 메서드로 구현해야한다.\n- 하나라도 추상 메서드가 구현되지 않으면, 구현 클래스는 추상 클래스로 선언되어야 한다.\n\n다중 인터페이스의 사용\njava\n하위인터페이스 = new 구현클래스; \n상위인터페이스1 = new 구현클래스;\n상위인터페이스2 = new 구현클래스;\n\n- 하위인터페이스 변수는 하위인터페이스, 상위인터페이스1, 상위인터페이스2의 실체 메서드를 모두 사용할 수 있다.\n- 상위인터페이스1 변수는 상위인터페이스1의 실체 메서드만 사용할 수 있다.\n- 상위인터페이스2 변수는 상위인터페이스2의 실체 메서드만 사용할 수 있다.\n\n 3-3. 다중 인터페이스 구현 클래스Multiple Interface Implement Class\n- 구현 클래스를 만들어서 사용하는 것이 일반적이고, 재사용이 가능하기에 편리하다.  \n  하지만 일회성으로 사용하는 구현 클래스는 클래스로 만들어서 선언해서 쓰는 것이 비효율적이다.\n- 이러한 비효율을 개선하기 위해 만들어졌다. &rarr; 주로 임시 작업 스레드를 만들기 위해 많이 활용된다.\n- 익명 구현 객체의 경우에는 참조할 구현 클래스가 없기 때문에 User interface 이름을 그대로 사용한다.\n- 다만, 익명 구현 객체의 구현 부에는 interface의 추상 메서드가 아닌 실체 메서드를 선언해야 한다.\n\njava\nUser user = new User{\n    public String sendMoenyMoney money{\n        thirdpartyApi.sendmoney.getType, money.getAmount;\n        return Status.SUCCESS.name;\n    }\n\n    @Override\n    public default void setStatusStatus status {\n        ifstatus == Status.ACTIVE {\n            System.out.println\"수취인이 활성화 되었습니다\";\n            return;\n        }\n        System.out.println\"수취인이 비활성화 되었습니다\";\n    }\n}\n\n익명 구현 객체는 일반 클래스처럼 클래스가 생성된다.\n- 익명 구현 객체가 사용된 자바 파일을 컴파일을 하게 되면 자동으로 익명 구현 객체의 클래스 파일이 생성된다.\n- 익명 구현 객체가 사용된 자바 파일$번호.class 형식으로 생성된다.\n\n 4. Java8 버전과 그 이전 버전의 interface차이\n default method가 추가되어 일어난 변화\n 1. Java8 이전 interface의 문제점\n- 인터페이스가 함수의 구현을 강제한다.\n- 강제하지 않기 위해 abstrict class - 추상 클래스를 만들어 함수의 몸체를 비우는 식으로 구현할 수 있다.\n  \n예제코드\njava\npublic interface Foo{\n    void A;\n    void B;\n    void C;\n}\n\npublic abstract class FooAbstrict implements Foo{\n    @Override\n    void A{}\n    @Override\n    void B{}\n    @Override\n    void C{}\n}\n\npublic class FooImpl extends FooAbstrict{\n\n    @Override\n    void A{\n        System.out.println\"DO A\";\n    }\n}\n\n1. Foo라는 interface의 모든 메서드A, B, C에 대해 구현을 강제하지 않기 위해 FooAbstrict에서 함수의 몸체를 비워서 구현했다\n2. Foo를 구현할 FooImpl는 FooAbstrict 추상 클래스로 인해 Foo interface의 모든 메서드의 구현하지 않아도 된다.\n\n 2. Java8 버전의 interface\n- default method가 생겨 위와 같은 방식이 아닌 interface에서 구현을 강제하지 않을 수 있는 방법을 제공한다.\n\n예제코드\njava\npublic interface Foo{\n    default void A{};\n    default void B{};\n    default void C{};\n}\n\npublic class FooImpl extends Foo{\n\n    @Override\n    void A{\n        System.out.println\"DO A\";\n    }\n}\n\n\n 3. 그래서 어디서 사용했었나요?\nSpring Web MVC의 설정을 제어하는 WebMvcConfigurer를 예로 들 수 있다.\n\nJava 8 이전에는 WebMvcConfigurerAdapter를 상속받아 구현했지만,  \n default method 기능이 추가되며 WebMvcConfigurer를 구현하면 된다.\n- WebMvcConfigurer 공식문서https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html\n- WebMvcConfigurerAdapter 공식문서https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.html",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "템플릿 콜백 패턴 - Template Callback Pettern",
    "url": "/programming/2022/03/29/템플릿-콜백-패턴---template-callback-pettern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "",
    "content": "템플릿 콜백 패턴 - Template Callback Pettern",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "Executor Framework",
    "url": "/programming/2022/03/29/executor-framework/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 고수준 High-Level Concurrency 프로그래밍를 지원하는 Framework",
    "content": "Executor Framework\n: 고수준 High-Level Concurrency 프로그래밍를 지원하는 Framework\n\n- Executor에 스레드를 만들고 관리하는 작업을 위임한다.\n- Executor, ExecutorService, ScheduledExecutorService\n  > 주로 Executor를 사용하는 것 보다 Executor를 상속받은 ExecutorService를 사용한다.\n- Executors를 통해 Executor, ExecutorService, ScheduledExecutorService를 생성할 수 있다.\n- JDK5 부터 지원한다.\n  > JDK5이전에는 개발자가 직접 Thread Pool를 만들어 관리했다.\n\n 하는 역할\n- 스레드 생성\n  > 애플리케이션이 사용할 스레드 풀을 만들어 관리한다.\n- 스레드 관리\n  > 스레드의 생명주기를 관리한다.\n- 작업처리 및 실행\n  > 스레드로 실행할 작업task을 언제든지 실행할 수 있게 한다.\n\n 간단한 사용 예시\n ExecutorService 생성\nExecutors를 통해 ExecurotService를 생성할 수 있다. \n> 다음 메소드를 제공하여 스레드 풀을 개수 및 종류를 정할 수 있다.\n- Executors.newFixedThreadPoolint\n  > 인자 개수만큼 고정된 스레드 풀을 만든다.\n- Executors.newCachedThreadPool\n  > 필요한 만큼 스레드 풀을 생성한다.\n- Executors.newSingleThreadExecutor\n  > 스레드가 한개인 ExecutortService객체를 생성한다.\n\n예시 - 10개의 Thread Pool 생성\njava\nExecutorService executorService = Executors.newFixedThreadPool10;\n\n\n ExecutorService에 task 할당하기\nExecutorService는 Runnable과 Callable task를 실행할 수 있다.\n- 결과가 없는 task는 executeRunnable를 사용한다.\n- 결과가 있는 task는 Future를 반환하는   \n  submitRunnable, submitRunnable, T resulte, submitCallable<T>를 사용한다.\n\n예시 - Runnable\n\nexecutorService.execute\n   -> System.out.println\"Hello world!\"\n\nexecutorService.execute\n   -> System.out.println\"Hello thread!\"\n\n\n\n예시 - Callable\njava\nCallable<String> callable =  -> {\n    StringBuilder sb = new StringBuilder;\n    forint i = 0; i < 10; i++\n        sb.appendi;\n\n    return sb.toString;\n};\n\nFuture<String> submit = executorService.submitcallable;\nSystem.out.printlnsubmit.get; // 출력 0123456789 \n\n- Future.get\n  - 해당 스레드의 작업 결과를 가져온다.\n  - InterruptedException에 대한 예외처리가 필요하다.\n\n ExecutorService 종료하기\nExecutorService는 ExecutorService를 종료하기 위한 두가지 매서드를 제공한다.\n\n shutdown\n> Graceful Shutdown\n\n: 이 method가 실행될 때, 새로운 task가 할당되는 것을 막고 이미 전에 제출된 task가 실행되는 것을 기다린 후 종료한다.\n- shutdown를 실행한 후 task를 실행하면 RejectedExecutionException이 발생한다.\n\n예시 코드\njava\nexecutorService.execute -> {\n    try {\n        Thread.sleep1000L;\n    } catch InterruptedException e {\n        e.printStackTrace;\n    }\n    System.out.println\"before shutdown\";\n};\nexecutorService.shutdown;\nexecutorService.execute -> System.out.println\"after shutdown\"; \n\n예시 출력결과\nsh\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task TestMain$$Lambda$16/0x0000000800066040@2133c8f8 rejected from java.util.concurrent.ThreadPoolExecutor@43a25848Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecutionThreadPoolExecutor.java:2055\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.rejectThreadPoolExecutor.java:825\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.executeThreadPoolExecutor.java:1355\n\tat TestMain.mainTestMain.java:25\nbefore shutdown\n\n\n shutdownNow\n: 모든 활성된 task을 즉시 종료하려 시도하고 새로운 task가 할당되는 것을 막는다.\n\n예시 코드\njava\nexecutorService.execute -> {\n    try {\n        Thread.sleep1000L;\n    } catch InterruptedException e {\n        e.printStackTrace;\n    }\n    System.out.println\"Hello World\";\n};\nexecutorService.shutdown;\nexecutorService.execute -> System.out.println\"Hello World\"; \n\n예시 출력결과\nsh\njava.lang.InterruptedException: sleep interrupted\n\tat java.base/java.lang.Thread.sleepNative Method\n\tat TestMain.lambda$main$1TestMain.java:18\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorkerThreadPoolExecutor.java:1128\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.runThreadPoolExecutor.java:628\n\tat java.base/java.lang.Thread.runThread.java:829\nException in thread \"main\" java.util.concurrent.RejectedExecutionException: Task TestMain$$Lambda$16/0x0000000800066040@2133c8f8 rejected from java.util.concurrent.ThreadPoolExecutor@43a25848Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecutionThreadPoolExecutor.java:2055\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.rejectThreadPoolExecutor.java:825\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.executeThreadPoolExecutor.java:1355\n\tat TestMain.mainTestMain.java:25\nbefore shutdown\n\n- InterruptedException가 발생한 것을 통해 곧바로 task를 종료하려 시도한 것을 알 수 있다.",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Stream",
    "url": "/programming/2022/03/29/stream/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> 숙지하지 않아도 사용할 수 있지만, Stream은 여러 메서드에서 함수형 인터페이스를 사용하므로 숙지하는게 좋다.\n- 람다 표현식\n- 메서드 레퍼런트",
    "content": "먼저 숙지해야 하는 것\n> 숙지하지 않아도 사용할 수 있지만, Stream은 여러 메서드에서 함수형 인터페이스를 사용하므로 숙지하는게 좋다.\n- 람다 표현식\n- 메서드 레퍼런트\n Stream\n: 연속적인 요소element들에 대한 순차/병렬 aggregate operations를 지원하는 API이다.\n> Sequence of elements supporting sequential and parallel aggregate operations\n- 데이터를 담는 저장소ex. Collecation이 아니다. \n- 대부분의 오퍼레이션의 인수는 함수형 인터페이스를 받으므로 람다, 메서드 레퍼런스를 활용한 개발이 가능하다.\n- Functional in nature, Stream이 처리하는 데이터 소스는 변경하지 않는다.\n- Stream으로 처리하는 데이터는 오직 한 번만 처리된다.\n- 무제한일 수 있다. &rarr; 실시간으로 들어온 데이터를 처리할 수 있다.\n  > Short Circult 메서드를 사용해 제안할 수 있다.\n- 중개 오퍼레이션은 Lazy 하다. &rarr; 종료 오퍼레이션이 오지 않는 이상 실행되지 않는다.\n- 쉬운 병렬처리가 가능하다.\n  > parallelStream 으로 가능하다. 하지만 오히려 threed를 사용해 비용이 증가할 수 있다.\n\n\n Stream 파이프라인\n<img src=\"/assets/images/posts/programming/stream-api-ex.png\">\n\n- 0 또는 다수의 중개 오퍼레이션 - intermediation operation과  한개의 종료 오퍼레이션 - terminal operation으로 구성한다.\n- Stream의 데이터 소스는 오직 종료 오퍼레이션을 실행할 때 처리한다.\n\n 중개 오퍼레이션\n- Stream을 리턴한다.\n- Stateless / Stateful 오퍼레이션으로 구분할 수 있다.\n  > 대부분 Stateless이다.\n- Filtering - filter, distinct\n- Mapping - map, flatMap\n- Restricting - limit, skip\n- Sorting - sorted\n- Iterating - peek\n> 버전에 따라 추가되거나 삭제될 수 있다.\n\n\n 종료 오퍼레이션\n- Stream을 리턴하지 않는다.\n- Stream에 대한 최종연산을 수행한다.\n- collect, allMatch, count, forEach, min, max 등...\n\n 사용 예시\n등록된 온라인 강의를 특정 조건에 따라 검색하는 예시\n- OnlineClass 객체의 이름의 첫 시작, 종강여부에 따라 검색할 것이다.\n\n OnlineClass 객체\njava\npublic class OnlineClass {\n    public String username;\n    public String className;\n    public boolean isClosed;\n\n    static boolean isClosedOnlineClass oc{\n        return oc.isClosed;\n    }\n\n    public OnlineClassString username, String className, boolean isClosed{\n        this.username = username;\n        this.className = className;\n        this.isClosed = isClosed;\n    }\n}\n\n 실제 로직\njava\npublic static void mainString args {\n    // 강의 저장\n    List<OnlineClass> onlineClasses = new ArrayList<>\n            Arrays.asList          // 강사이름  // 강의 이름             //종강 여부 \n                    new OnlineClass\"egoging\", \"WEB class HTML/CSS/JS\", false,\n                    new OnlineClass\"egoging\", \"WEB + AI\", true,\n                    new OnlineClass\"김영한\", \"JPA 실전 강의\", false,\n                    new OnlineClass\"김영한\", \"JPA 활용 실전 강의\", true\n            \n    ;\n\n    // 강의 이름이 WEB으로 시작하는 수업 필터링 \n    System.out.println\"=== 이름이 WEB으로 시작하는 수업 ===\";\n    onlineClasses.stream\n            .filteroc -> oc.className.startsWith\"WEB\"\n            .forEachoc -> System.out.printlnoc.className;\n    System.out.println; // 한칸 줄바꿈을 위한 코드\n\n    // 종강된 수업 필터링\n    System.out.println\"=== 종강된 수업 ===\";\n    onlineClasses.stream\n            .filterOnlineClass::isClosed // 부정 연산을 사용할 떄 Predicate.notOnlineClass::isClosed\n            .forEachoc -> System.out.printlnoc.className;\n    System.out.println; // 한칸 줄바꿈을 위한 코드\n\n    // 종강되지 않은 수업 필터링\n    System.out.println\"=== 종강되지 않은 수업 ===\";\n    onlineClasses.stream\n        .filterPredicate.notOnlineClass::isClosed\n        .forEachoc -> System.out.printlnoc.className;\n}\n\n 결과\nsh\n=== close된 수업 ===\nWEB + AI\nJPA 활용 실전 강의\n\n=== 이름이 WEB으로 시작하는 수업 ===\nWEB class HTML/CSS/JS\nWEB + AI\n\n=== 종강되지 않은 수업 ===\nWEB class HTML/CSS/JS\nJPA 실전 강의",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "api",
      "java8"
    ]
  },
  {
    "title": "템플릿 메서드 패턴 - Template Method Pattern",
    "url": "/programming/2022/03/29/템플릿-메서드-패턴---template-method-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 김영한 인프런 핵심 원리 - 고급편https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8\n- 예제 코드https://github.com/siwony/spring-core-principl...",
    "content": "템플릿 메서드 패턴 - Template Method Pattern\n 참고자료\n- 김영한 인프런 핵심 원리 - 고급편https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8\n- 예제 코드https://github.com/siwony/spring-core-principle-advanced/tree/main/src/test/java/com/siwony/ifl_spring_advanced/trace/template\n\n 변하는 것과 변하지 않는 것을 분리\nGOF의 디자인 패턴에서는 템플릿 메서드 패턴을 다음과 같이 정의한다.\n> 작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기한다.  \n> 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있다.\n\n<p align=\"center\"> <img align=center width=200 src=\"/assets/images/posts/programming/tamplate-method-pattern.png\"></p>\n\n이를 풀어서 설명하면  \n부모 클래스에 골격인 알고리즘의 골격인 템플릿을 정의하고, 일부분만 자식 클래스에 정의하는 것이다. 이렇게 템플릿 메서드 패턴을 사용하면 특정 부분만 변경할 수 있다.\n\n 예제 - 비즈니스 로직의 수행 속도를 측정하여 로깅하기\n> 실습환경: SpringBoot + lombok + junit5\n다음과 같이 비즈니스 로직을 실행하는 메서드가 2개 logic1, logic2 가 있다.\njava\n@Test\npublic void executeLogic{\n    logic1;\n    logic2;\n}\n\nprivate void logic1 {\n    // 비즈니스 로직 실행\n    log.info\"비즈니스 로직1 실행\";\n    // 비즈니스 로직 종료\n}\n\nprivate void logic2 {\n    // 비즈니스 로직 실행\n    log.info\"비즈니스 로직2 실행\";\n    // 비즈니스 로직 종료\n}\n\n위와 같이 비즈니스 로직를 실행하는 logic1, logic2가 있다. 이 2개의 메서드에 비즈니스 로식의 수행속도를 측정하고 싶다면 코드를 다음과 같이 추가하면 된다.\njava\n@Test\npublic void executeLogic{ ... }\n\nprivate void logic1 {\n    long startTime = System.currentTimeMillis;\n    // 비즈니스 로직 실행\n    log.info\"비즈니스 로직1 실행\";\n    // 비즈니스 로직 종료\n    long endTime = System.currentTimeMillis;\n    long resultTime = endTime - startTime;\n    log.info\"resultTime={}\", resultTime;\n}\n\nprivate void logic2 {\n    long startTime = System.currentTimeMillis;\n    // 비즈니스 로직 실행\n    log.info\"비즈니스 로직2 실행\";\n    // 비즈니스 로직 종료\n    long endTime = System.currentTimeMillis;\n    long resultTime = endTime - startTime;\n    log.info\"resultTime={}\", resultTime;\n}\n\n출력 예시\nsh\n23:10:25.701 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직1 실행\n23:10:25.703 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - resultTime=3\n23:10:25.705 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직2 실행\n23:10:25.705 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - resultTime=0\n\n끝났다 우리는 비즈니스 로직에 대한 수행시간을 측정할 수 있게 되었다. \n\n하지만 위에 작성한 코드는 다음과 같은 문제를 가지고 있다.\n- 메서드에 순수 비즈니스 로직과 부가적인 로직이 섞여 단일-책임-원칙SRP에 위반된다.\n- 비즈니스 로직을 제외한 수행시간을 측정하는 로직은 계속 중복되고 있다.\n  > 중간에 끼어있는 비즈니스 로직으로 인해 따로 함수화하기도 힘들다.\n\n이러한 문제를 해결하기 위해 템플릿 메서드 패턴을 사용해 보자\n\n 비즈니스 로직의 시간을 측정하는 템플릿 추상 클래스 생성\njava\n@Slf4j\npublic abstract class TimeMeasurementTemplate<T> {\n\n    public void execute{\n        long startTime = System.currentTimeMillis;\n        // 비즈니스 로직 실행\n        T result = call;\n        // 비즈니스 로직 종료\n        long endTime = System.currentTimeMillis;\n        long resultTime = endTime - startTime;\n        log.info\"resultTime={}\", resultTime;\n    }\n\n    protected abstract T call;\n}\n\nexecute에서는 변하지 않는 로직 즉, 우리가 중복을 없애고 싶었던 시간 측정을 로직을 템플릿으로 정의하고,  \ncall에서는 변하는 로직 즉, 함수화를 번거롭게 만들었던 비즈니스 로직을 구현한다.\n\njava\n@Test\nvoid executeLogic{\n    TimeMeasurementTemplate<Void> template1 = new TimeMeasurementTemplate<> {\n        @Override\n        protected Void call {\n            log.info\"비즈니스 로직1 실행\";\n            return null;\n        }\n    };\n    template1.execute;\n\n\n    TimeMeasurementTemplate<Void> template2 = new TimeMeasurementTemplate<> {\n        @Override\n        protected Void call {\n            log.info\"비즈니스 로직2 실행\";\n            return null;\n        }\n    };\n    template2.execute;\n}\n\n출력 결과\nsh\n23:46:35.475 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직1 실행\n23:46:35.477 main INFO com.siwony.ifl_spring_advanced.trace.template.code.TimeMeasurementTemplate - resultTime=3\n23:46:35.479 main INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직2 실행\n23:46:35.479 main INFO com.siwony.ifl_spring_advanced.trace.template.code.TimeMeasurementTemplate - resultTime=0\n\n- 이렇게 템플릿 메서드 패턴을 이용해 시간을 측정하는 로직과, 비즈니스 로직를 분리하여 SRP를 충족했다.\n- 그리고 반복되는 코드가 사라짐으로 코드의 응집력이 높아졌다.\n\n 하지만, 템플릿 메서드 패턴은 상속이 가진 단점을 그대로 가져간다.\n- 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합된다.\n  > 자식 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.  \n  > \"자식 클래스에서 부모 클래스의 기능을 사용한 것이 있나?\"\n- 상속 구조를 사용하기 때문에 별도의 클래스/익명 내부 클래스를 만들어야 해서 구조가 복잡하다.\n\n템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴은 전략-패턴Strategy PatternStrategy-Pattern.md이다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "Atomic",
    "url": "/programming/2022/03/29/atomic/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "에 정의 되어 있고 멀티 쓰레드 환경에서 동기화에 의존하지 않고, 원자성을 보장하게 해주는 Atomic API에 대해 소개하려고 한다.",
    "content": "Atomic\njava.util.concurrent.atomic에 정의 되어 있고 멀티 쓰레드 환경에서 동기화에 의존하지 않고, 원자성을 보장하게 해주는 Atomic API에 대해 소개하려고 한다.\n\n Atomic Access\nAPI소개전 Atomic Access의 개념을 알아보자\n\nOracle 자바 레퍼런스에 나와있는 Atomic Access의 정의는 다음과 같다.\n> In programming, an atomic action is one that effectively happens all at once.  \n> An atomic action cannot stop in the middle: it either happens completely, or it doesn't happen at all. No side effects of an atomic action are visible until the action is complete.\n\n글을 요약하자면 처음부터 끝까지 완전히 수행되거나, 아예 아무것도 수행되지 않아야 하는 Action이라고 한다.\n\n 왜 끝가지 수행되거나, 아예 아무것도 수행되지 않아야 할까\n티켓 구매 서비스에서 유명한 연예인의 콘서트에 예매하는데 티켓이 1개 남은 상황에서 여러명이 동시적으로 구매하려고 하는 경우를 생각해보면\n\n1. 1번 회원 결제 성공\n2. 티켓 수량 업데이트가 끝나지 않은 상황에서 2번 회원도 결제에 성공했다.\n3. 티켓 수량이 0 으로 변경되었지만 2번 회원은 이미 돈을 지급한 상태이다.\n4. 서비스 장애가 발생했다!\n\n\n티켓 구매라는 작업이 정상적으로 수행되려면 1번 회원의 결제 결과가 재고 수량에 반영되기 전 2번 회원의 결제 시도는 잠시 미뤄야 한다.\n\n하나의 스레드가 모든 작업을 차례대로 처리한다면, 작업 간 공유하는 데이터의 일관성이 깨지는 일은 생기지 않을 것이다. 하지만, 수많은 요청을 빠르게 처리하려면 멀티스레드가 필연적으로 사용된다.  \n\n여러 개의 작업이 쪼개서 번갈아 가며 실행하는 멀티스레드 환경에 비 원자 연산이 수행되면 위와 같은 문제가 발생할 수 있으므로 Atomic 연산이 필요하다.\n\n Atomic Action의 특징\n- 인터러브 - Interleave 하지 않는다.\n- 스레드 간섭에 대한 걱정을 하지 않고 사용할 수 있다.\n- 메모리 일관성 - consistency 오류가 발생할 수 있으므로 동기화해야 하는 필요성을 제거하지 않는다.\n\n\n Atomic Type\nAtomic Type은 단일 변수에 대해 Atomic Operations를 지원한다.\n- Wrapping 클래스의 일종\n  > 참조타입, 원시타입 두 종류의 변수에 모두 적용가능함\n- 사용시 내부적으로 CAS - Compare And Swap 알고리즘을 사용해 lock없이 동기화 처리를 한다.\n  > non-blocking으로 원자성을 보장한다\n\n 주요 Class\n- AtomicBoolean\n- AtomicInteger\n- AtomicLong\n- AtomicReference\n- AtomicIntegerArray\n- AtomicDoubleArray\n- AtomicReferenceArrays\n\n 주요 Method\n- get : 현재 값을 반환한다.\n- setnewValue : newValue로 값을 변경한다.\n- getAndSetnewValue : 원자적으로 값을 업데이트하고 원래의 값을 반환한다.\n- compareAndSetexpect, update : 원자적으로 값을 업데이터 하고 원래의 값을 반환한다.\n- 숫자형 Atomic Type의 경우 증감연산을 할 수 있는 메서드를 추가적으로 제공한다.\n\n\n Atomic VS synchronized 키워드\n synchronized 키워드\n특정 Thread가 해당 블럭 전체를 lock하기 떄문에 bloking이 발생한다.\n\n Atomic\nCAS 알고리즘을 통해 Non-Blocking 상태로 동기화 문제를 해결할 수 있다.\n\n Atomic class의 내부\n> Java11 기준\njava\npublic class AtomicBoolean implements java.io.Serializable {\n\n    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe;\n    private volatile int value;\n\n    생략...\n\n    public final int getAndSetint newValue {\n        return U.getAndSetIntthis, VALUE, newValue;\n    }\n\n    생략...\n}\n\ngetAndSet method에서 U.getAndSetInt를 사용하는데 이것이 CAS 알고리즘이다.\n\njdk.internal.misc.UnsafegetAndSetInt의 구현을 보면\n\njava\n    @HotSpotIntrinsicCandidate\n    public final int getAndSetIntObject o, long offset, int newValue {\n        int v;\n        do {\n            v = getIntVolatileo, offset;\n        } while !weakCompareAndSetInto, offset, v, newValue;\n        return v;\n    }\n\ncompareAndSwapInt를 호출해 메모리에 저장된 값과 현재 CPU에 캐시 된 expect 값을 비교해 같은 경우만 update를 실행한다.  \n\n자세히 설명하면, 현재 연산에서 기대하는 값과 메모리상에서의 값이 일치하지 않는다면 중간에 다른 스레드가 관여한 것으로 판단하여 write를 실패시키고 재시도를 한다.\nlock-free 방식으로 루프를 돌기 때문에 block, unblock 상태 변경 처리에 드는 비용이 발생하지 않는다.\n\n> lock-free  \n> 멀티스레드 환경에서 동시에 호출해도 정확한 결과를 만들어주는 알고리즘\n> - 여러개의 스레드에서 동시에 작업이 호출되었을 경우 정해진 시간마다 적어도 한개의 작업이 호출되는 알고리즘이다.\n\ngetIntVolatile는 native로 구현되어 볼 수 없다.\n\n\n\n\n Reference\n- https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html\n- https://zion830.tistory.com/58\n- https://n1tjrgns.tistory.com/244",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Singleton Pattern",
    "url": "/programming/2022/03/29/singleton-pattern/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": ": 어떠한 클래스객체가 유일하게 1개만 존재해야 할때 사용하는 패턴  \n즉, 어떤 클래스가 최초 한번만 메모리를 할당하고Static 그 메모리에 객체를 만들어 사용하는 디자인 패턴\n- 싱글톤으로 생성된 객체는 무조건 한번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이 \n- 객체 생성을 제활용 할 수 있어 불필요한 메모리 낭비를 방지한다.\n- Spring...",
    "content": "Singleton Pattern\n: 어떠한 클래스객체가 유일하게 1개만 존재해야 할때 사용하는 패턴  \n즉, 어떤 클래스가 최초 한번만 메모리를 할당하고Static 그 메모리에 객체를 만들어 사용하는 디자인 패턴\n- 싱글톤으로 생성된 객체는 무조건 한번 생성으로 전역성을 띄기에 다른 객체와 공유가 용이 \n- 객체 생성을 제활용 할 수 있어 불필요한 메모리 낭비를 방지한다.\n- Spring에서 Bean은 기본적으로 Singleton으로 관리를한다.\n- 현실세계에서 프린터, 개발에서는 TCP Socket connet등에 자주 사용한다.\n\n 문제점\n- 전역성을 띄면서 다른 객체와 공동으로 사용할때만 효율적이다\n- 싱글톤으로 만든 객체의 역할이 복잡해지면 해당 싱글톤 객체를 사용하는 다른 객체간의 결함도가 높아진다.\n    > 즉, OCPOpen-Close Principle에 위반된다.\n- 싱글톤 객체를 수정할 경우 싱글톤 객체를 사용하는 곳에서 사이드 이팩트 발생 확률이 존재한다.\n- 멀티 쓰래드환경에서 동기화 처리 문제가 일어날 수 있다.\n\n Singleton 구현 방법\nReference: https://elfinlas.github.io/2019/09/23/java-singleton/  \n\n static block\njava\npublic class ExampleClass {\n    //Instance\n    private static ExampleClass instance;\n\n    //private construct\n    private ExampleClass {}\n\n    static {\n        try { instance = new ExampleClass;}\n        catchException e { throw new RuntimeException\"Create instace fail. error msg = \" + e.getMessage ; }\n    }\n\n    public static ExampleClass getInstance {\n        return instance;\n    }\n}\n\n- static 블럭을 사용힐 경우 클래스가 로딩될 때 한번만 실행을 하게 되는 특성을 사용한 방법\n- 인스턴스가 사용되는 시점이 아닌 클래스 로딩 시점에 실행이 된다.\n\n lazy init\n>static 방법을 개선하여 클래스 로딩 시점이 아닌 인스턴스가 필요하여 요청할 때 생성되는 형태로 작성 \njava\npublic class ExampleClass {\n    //Instance\n    private static ExampleClass instance;\n\n    //private construct\n    private ExampleClass {}\n\n    public static ExampleClass getInstance {\n        if instance == null { instance = new ExampleClass;}\n        return instance;\n    }\n}\n\n- 멀티 쓰레드 환경에서 취약\n- 쓰레드가 동시에 getInstance 메서드를 호출하게 되면 인스턴스가 두 번 생성되는 문제가 발생한다.\n\n Thread safe + lazy\njava\npublic class ExampleClass {\n    //Instance\n    private static ExampleClass instance;\n\n    //private construct\n    private ExampleClass {}\n\n    public static synchronized ExampleClass getInstance {\n        if instance == null { instance = new ExampleClass;}\n        return instance;\n    }\n}\n\n- synchronized 키워드를 통해쓰레드에서 동시 접근에 대한 문제를 해결했다.\n- synchronized 키워드는 성능 저하를 발생시킨다.\n\n Holder\n> 현제 JAVA Singleton 생성에서 사용하는 대표적인 방법이다.\njava\npublic class ExampleClass {\n\n    //private construct\n    private ExampleClass {}\n\n    private static class InnerInstanceClazz {\n        private static final ExampleClass instance = new ExampleClass;\n    }\n\n    public static ExampleClass getInstance {\n        return InnerInstanceClazz.instance;\n    }\n\n- JVM의 클래스 로더 메커니즘과 클래스의 로드 시점을 이용하여 내부 클래스를 통해 생성 시킴으로써 쓰레드 간의 동기화 문제를 해결한다.\n\n\n Reference\n- https://elfinlas.github.io/2019/09/23/java-singleton/",
    "tags": [
      "TIL",
      "coding",
      "development",
      "Design-pattern",
      "java"
    ]
  },
  {
    "title": "JCF - Java Collection Framework",
    "url": "/programming/2022/03/29/jcf---java-collection-framework/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "Java Collection Framework는 공통적으로 재사용 가능한 수집 데이터 구조를 구현하는 클래스 및 인터페이스의 집합이다.",
    "content": "JCF - Java Collection Framework\nJava Collection Framework는 공통적으로 재사용 가능한 수집 데이터 구조를 구현하는 클래스 및 인터페이스의 집합이다.\n\n JFC 상속 구조\n<img src=\"/assets/images/posts/programming/collection-framework-structure.jpeg\">\n\n 컬렉션 프레임워크 구성요소\n- 컬렉션 인터페이스 : 모든 컬렉션 인터페이스 java.util패키지에 있다.\n- 컬렉션 클래스     : 모든 컬렉션 클래스는 java.util, java.util.concurrent 패키지에 있다.\n- 컬렉션 알고리즘   : 검색, 정렬, 셔플과 같은 기능을 제공한다.\n\n 1. 컬렉션 인터페이스 - Collection Interface\n- 공식문서 : https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html\n 컬렉션 프레임워크 대표적인 인터페이스\n- List<E>\n- Set<E>\n- Map<K, V>\n\n 1-1. Collection 인터페이스\nCollection인터페이스는 직접적인 구현은 제공하지 않으며 모든 컬렉션 클래스가 구현해야 하는 메서드를 포함하고 있다.\n\n 1-2. List \n- 순서 있는 데이터의 집합으로 데이터의 중복을 허용한다.\n- Random access를 허용한다.\n- ArrayList, LinkedList, Vector, Stack\n\n 1-3. Set 인터페이스\n- 중복 요소를 포함할 수 있다.\n- Random access를 허용하지 않는다.\n  > LinkedHashSet 제외\n- HashSet, TreeSet, LinkedHashSet\n\n 1-4. SortedSet 인터페이스\n요소를 오름차순으로 유지하는 Set이다.\n- 구현체는 TreeSet이 있다.\n\n 1-5. Queue 인터페이스\nQueue 인터페이스는 처리하기 전에 요소를 보유하는 데 사용된다.\n- 기본 컬렉션 작업 이외에 삽입, 추출 및 검사 작업을 제공한다.\n- 일반적으로 Queue 요소를 FIFO 방식으로 정렬하며 예외에는 우선순위 큐 - PriorityQueue가 있다.\n\n 1-6. Deque\n양쪽 긑에 요소 삽입 및 제거를 지원한다.\n- 구현된 글래스는 ArrayDeque가 있다.\n\n 2. Map 인터페이스\n- Key-Value\n- 중복 Key가 존재할 수 없다.\n- 각 키는 하나의 값만 매핑할 수 있다.\n- HashMap, TreeMap, LinkedHashMap, Hashtable, Properties\n\n 2-1 SortedMap \n매핑을 오름차순의 키 순서로 유지하는 Map이다.\n- 구현체는 TreeMap이 있다.\n\n 3. 기타 인터페이스 그룹\n\n 3-1. Iterator 인터페이스\nIterator 인터페이스는 어떤 컬렉션이든 반복적으로 수행하기 위한 메서드를 제공한다.\n- 컬렉션 프레임워크에서는 Enumeration대신 Iterator를 사용한다.\n- Iterator 디자인 패턴을 구현한다.\n- iterator를 통해 컬렉션으로 부터 Iterator instance를 가져올 수 있고 컬렉션을 순회하는 도중에 엘리먼트를 삭제할 수 있다.\n\n 3-2. ListIterator 인터페이스\n- 어느 방향이든 목록을 탐색하고 반복하면서 목록을 수정하고, 목록에서 반복자의 현재 위치를 가져올 수 있다\n- 커서 위치는 previous, next에 대한 호출에 의해 반환될 요소 사이에 위치한다.\n\n 3-3. Concurrent 인터페이스 그룹\n- BlockingQueue \n- TransferQueue\n- BlockingDeque\n- ConcurrentMap\n- ConcurrentNavigableMap\n\n 4. 컬렉션 클래스 - Collection Class\nArrayList, LinkedList, HashSet, TreeSet, PriorityQueue, ArrayDeque, HashMap, TreeMap, LinkedHashMap, Vector, Stack, Dictionary, Hashtable, Properties\n\n Concurrent 클래스\nCopyOnWriteArrayList, CopyOnWriteArraySet, ConcurrentHashMap\n\n Abstract 클래스\nAbstractList, AbstractSequenctailList, AbstractSet, AbstractQueue\n\n 4-1. ArrayList 클래스\n- resizable-array이면서 비동기이다.\n  > 동기화가 필요하면 Collections.synchronizeList를 통해 동기화가 보장되는 List를 반환받아 사용한다.\n- ArrayList는 내부적으로 배열을 이용하여 요소를 저장한다.\n- thread-safe하지 않다.\n\n 4-2. LinkedList 클래스 \n- Queue, Deque 속성 메서드를 가지고 있다.\n- Queue, Deque의 메서를 포함하고 있따.\n- 내부적으로 연결 리스트를 이용한다.\n- thread-safe하지 않다.\n\n 4-3. HashSet 클래스\nHashMap에 의해 지원되는 Set 인터페이스의 구현체이다.\n- 요소의 순서를 보장하지 않는다.\n- null를 허용한다\n- - thread-safe하지 않다.\n\n 4-4. TreeSet 클래스\nTreeMap의 근본이 되는 NavigableSet 구현이다.\n- thread-safe하지 않다.\n\n 4-5. PriorityQueue 클래스\n우선순위 큐\n- thread-safe하지 않다.\n\n\n 4-6. ArrayDeque\nDeque인터페이스의 동적 배열 구현체 이다.\n- thread-safe하지 않다.\n\n\n 5. Map 인터페이스 그룹의 클래스\n 5-1. HashMap 클래스\n- threa-safe하지 않다.\n- null를 허용하지 않는다.\n- 앨리먼트의 순서를 보장하지 않는다.\n\n 5-2. TreeMap 클래스\n- Red-Baclk 트리 기반 NavigableMap의 구현체다.\n- thread-safe하지 않다.\n\n 5-3. LinkedHashMap 클래스\n- LinkedHashMap\n- null를 허용한다.",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "java-collection-framework"
    ]
  },
  {
    "title": "Optional",
    "url": "/programming/2022/03/29/optional/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "- 지속적인  방어가 필요하다.\n- NPE를 방어할 코드를 지속적으로 추가해야 하므로 비즈니스 로직이 복잡해진다.",
    "content": "Optional\n 등장 배경\n null에 대한 문제점\n- 지속적인 NPE - NullPointException 방어가 필요하다.\n- NPE를 방어할 코드를 지속적으로 추가해야 하므로 비즈니스 로직이 복잡해진다.\n\n JAVA8 이전에 메서드에서 존재하지 않는값null을 리턴할 수 있을 때 처리하는 방법\n- 예외를 던진다. &rarr; 비용이 발생한다.\n  - stack trace를 출력한다.\n  - 만약 다른 예외로 throw시 추가적인 로직을 작성해야 한다.\n- null을 리턴한다. &rarr; 비용 문제가 없지만 그 코드를 사용하는 개발자는 주의해야 한다.ex. NPE\n\n 함수형 프로그래밍에서 영감을 얻다.\nJava는 존재하지 않는 값을 표현하기위해 null을 사용한다면,  \nScala나 Haskell같은 함수형 언어들은 존재할지 안 할지 모르는 값을 표현할 수 있는 별개의 타입을 가지고 있다.  \n&rarr; 이를 보고 영감을 받아 Optional이 탄생했다.\n\nOptional은 존재할지 안 할지 모르는 값을 다룰 수 있는 여러가지 기능들을 제공한다.\n Optional\n: \"null이 될 수도 있는 객체”을 감싸고 있는 일종의 Wrapper Class이다.\n- NPE를 유발할 수 있는 null을 직접 다루지 않아도 된다.\n- 명시적으로 해당 변수가 null일 수도 있다는 가능성을 표현할 수 있다.\n  > null에 대한 처리를 강제할 수 있다.\n\n 기본적인 사용 방법\n Optional 변수\n- 제네릭을 지원하기 때문에 선언시 명시한 타입 파라미터에 따라 감쌀 수 있다.\njava\nOptional<Member> optMember;  // Member타입을 감싸는 Optional\nOptionalInt maybeInteager;  // int타입의 Optional\n\n\n 주의할 점\n 1. 리턴값으로만 사용하는 것을 권장한다.\n> 메소드 매개변수 타입, 맵의 키 타입, 인스턴스 필드타입으로 사용하지 말자.\n\n 2. Optional을 리턴하는 메소드에서 null을 리턴하지 말자.\n- Optional자체가 해당 값이 \"존재할지 안 할지 모르는 값\"이므로 Null를 반환하면 안된다.\n  > 개발에 큰 혼선을 야기한다. &rarr; Optional이 제공하는 기능을 사용하하면 NPE가 발생한다.\n 3. 기본타입primitive type용 Optional이 따로 존재하므로 기본타입을 사용하고 싶으면 사용한다. \n- OptionalInt, OptionalLong 등...\n  > 그냥 Optional를 사용하면 내부적으로 Auto boxing/unboxing이 일어나므로 오버해드가 발생한다.\n 4. Collection, Map, Stream Array, Optional은 Opiontal로 감싸지 말자.\n- 값이 비어있다는 것을 표현할 수 있는 객체이므로 Optional를 사용할 필요가 없다.\n\n Optional API 사용 방법\n Optional 만들기\n- Optional.ofT type\n- Optional.ofNullableT type\n- Optional.emptyT type\n\n Optional속 값의 유무\n- isPresent\n- isEmpty Java11 부터 추가\n\n예시\njava\nMember member = null;\nOptional<Member> optMember = Optional.ofmember;\nSystem.out.printlnoptMember.isPresent; // false\nSystem.out.printlnoptMember.isEmpty; // true\n\n\n Optional에 있는 값 가져오기\n- get\n  > 만약 해당 값이 비어있다면 NoSuchElementException이 발생한다.  \n  하지만 get으로 바로 꺼내는 방식보다 앞으로 나올 방식으로 값을 꺼내 사용하는 것을 지양해야 한다.\n\n예시\njava\nMember getMember1 = Optional.ofnew Member.get;\n\nMember member = new null;\nMember getMember2 = Optional.ofNullablemember.get; //NoSuchElementException\nMember getMember3 = Optional.ofmember.get; // NullPointException\n\n Optional에 값이 있는 경우에 해당 식을 실행하기\n- ifPresentConsumer\n  \n예시\njava\nOptional<Member> optMember = Optional.ofnew Member\"siwony\";\nMember nullMember = null;\nOptional<Member> optNullmember = Optional.ofNullalbenullMember;\n\noptMember.ifPresentmember -> System.out.printlnmember.getName // siwony출력\noptNullmember.ifPresentmember -> System.out.printlnmember.getName // 아무것도 출력되지 않음\n\n\n Optional에 값이 있으면 가져오고 없는 경우에 T를 리턴하라.\n- orElseT  \n\n예시\njava\nMember nullMember = null;\nOptional<Member> optNullmember = Optional.ofNullalbenullMember;\nMember newMember = optNullmember.orElsenew Member\"siwony\";\nSystem.out.printlnnewMember.getName // siwony 출력\n\n- orElse에 넘겨준 인수는 어쩃든 어떠한 연산을 무조건한다. 임의의 값을 넘겨주기 때문\n- 상수의 값을 넘겨줄 때 사용한다.\n  > 동적으로 어떠한 작업을 통해 값을 반환하기 원하면 orElseGet를 사용하는게 좋다.\n\n Optional에 값이 있으면 가져오고 없는 경우에 해당 Supplier를 실행후 어떤 값을 리턴해라\n- orElseGetSupplier\n  \n예시\njava\nOptional<Config> optConfig = Optional.ofnew Config\"start\";\n// 만약 config가 null이라면 status가 ready인 config 객체를 반환한다.\nConfig config = optConfig.orElseGet -> new Config\"ready\"; \nSystem.out.printlnconfig.status; // start반환\n\n- 어떠한 값을 동적으로 처리한 후 값을 반환하고 싶을 때 사용한다.\n\n Optional에 값이 있으면 가져오고 없는 경우에 해당 Exception을 throw해라\n- orElseThrowSupplier\n\n예시\njava\nOptional<Member> optMember = memberRepository.findByUsername\"siwony\";\n//만약 member가 조회가 되지 않으면 MemberNotFound라는 Exceptionn사용자 지정 Exception을 던진다\nMember member = optMember.orElseThrow -> new MemberNotFoundException; \n//만약 Exception을 인수로 넘겨주지 않으면 NoSuchElementException가 발생한다.\nMember member = optMember.orElseThrow;  \n\n- 기본값은 NoSuchElementException\n\n Optional에 들어있는 값 걸러내기\n- filterPredicate\n\n예시\njava\nOptional<Member> optMember = memberRepository.findByUsername\"siwony\";\n//member의 getAge의 반환값이 18이 아니면 emtpy Optionl를 반환한다.\nOptional<Member> member = optMember.filtermmeber -> member.getAge != 18;\n\n- filter를 사용할 Optional은optMember 해당 객체member가 비어있지 않다는 가정하여 사용한다.\n\n Optional에 들어있는 값 변환하기\n- 무조건 Optional타입을 반환한다.\n- 특정 element를 다른 형식으로 반환한다.\n1. mapFunction\n  \n예시\njava\nOptional<Member> optMember = memberRepository.findByUsername\"siwony\";\n//member의 getAge의 반환값이 18이 아니면 emtpy Optionl를 반환한다.\nOptional<Integer> member = optMember.mapmeber -> member.getAge;\n\n\n2. flatMapFunction\n> Optional 안에 들어있는 인스턴스가 Optional인 경우에 사용한다.\n\n예시\njava\nOptional<Member> optMember = memberRepository.findByUsername\"siwony\";\n\n// map을 사용하는 경우\nOptional<Optional<Plan>> member = optMember.mapmeber -> member.getPlan;\n\n// flatMap을 사용하는 경우\nOptional<Plan> member = optMember.flatMapmeber -> member.getPlan;",
    "tags": [
      "TIL",
      "coding",
      "development",
      "java",
      "api",
      "java8"
    ]
  },
  {
    "title": "CompletableFuture",
    "url": "/programming/2022/03/29/completablefuture/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "프로그래밍에 대한 여러 기능을 제공하는 인터페이스.\n> 공식 문서https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html",
    "content": "CompletableFuture\n비동기 - Asynchronous 프로그래밍에 대한 여러 기능을 제공하는 인터페이스.\n> 공식 문서https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html\n\n 기존 Future의 단점\n- Future를 외부에서 완료 시킬 수 없다.\n  > 취소하거나 get에 타임아웃을 설정할 수는 있다.\n- 블로킹 코드Future.get를 제외하고 작업이 끝났을 때 콜백을 실행할 수 없다.\n  > 추가적인 작업이 필요하면 Future.get뒤에 작업을 해야 한다.\n- 여러 Future를 조합할 수 없다.\n- 예외 처리용 API를 제공하지 않는다.\n\n\nJDK8부터 CompletableFuture 인터페이스가 소개되었고, Future 인터페이스를 구현함과 동시에 CompletionStage 인터페이스를 구현한다. CompletionStage는 비동기 연산 Step을 제공해서 계속 매서드 체이닝 - Method Chaining 형태로 조합이 가능하다.\n\n 구현된 interface\n- Futurehttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html\n- CompletionStagehttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html\n\n Fork/Join Framework\nCompletableFuture는 Fork/Join 기반으로 만들어졌다.\n\nFork/Join Framework의 동작 원리는 \n1. 작업을 잘게 나눌 수 있을 때까지 split 하고\n2. 작업 큐에 있는 tail task를 다른 쓰레드가 나누어 병렬처리한 후, \n3. join하여 합산한다.  \n\nCompletableFuture의 기본 Thread Pool은 Fork/Join Thread Pool ForkJoinPool.commonPool를 사용한다.\n\n\n 사용방법\nCompletableFuture도 Future처럼 결과값을 가져오는것ex. get을 하지 않으면 선언해 놓은 작업Task은 실행은 되지만 main thread에서는 아무 영향이 없다.\n 비동기로 작업 실행하기\n- 리턴값이 없는 경우: runAsync\n- 리턴값이 있는 경우: supplyAsync\n\n runAsync- 리턴값이 없는 경우\n코드 예시\njava\nCompletableFuture<Void> future = CompletableFuture.runAsync\n         -> System.out.println\"Hello \" + Thread.currentThread.getName\n;\n\nVoid futureValue = future.get;\nSystem.out.println\"void type CompletableFuture: \" + futureValue;\n\n출력 예시\nsh\nHello ForkJoinPool.commonPool-worker-19\nvoid type CompletableFuture: null\n\n- 리턴값이 없는 task이므로 future.get의 결과값은 Void타입에 null이 반환되었다.\n- 따로 Thread Pool를 정해주지 않아도 ForkJoinPool를 이용했다.\n> Void 타입이란?  \n> void 타입을 클래스로 나타낸 타입이다. 기본생성자가 private로 되어있어 인스턴스를 생성할 수 없으므로 Void 타입으로 선언한 변수의 값은 null이 들어갈 수 밖에 없다. 일부 특수상황리플렉션, 제네릭을 제외한 평상시에는 사용하지 않는 게 좋다.\n\n supplyAsync- 리턴값이 있는 경우\n코드 예시\njava\nCompletableFuture<String> future = CompletableFuture.supplyAsync\n         -> {\n            String hello = \"Hello \";\n            System.out.printlnhello + Thread.currentThread.getName;\n            return hello;\n        }\n;\n\nString futureValue = future.get;\nSystem.out.println\"String type CompletableFuture: \" + futureValue;\n\n출력 예시\nsh\nHello ForkJoinPool.commonPool-worker-19\nString type CompletableFuture: Hello \n\n\n Executors Thread Pool 사용하기\n- runAsync, supplyAsync둘다 사용가능하다.\n- Runnable, Callable다음 인자로 Executors를 사용해 Thread Pool를 사용할 수 있다,\n\n코드 예제\njava\nExecutorService executorService = Executors.newFixedThreadPool5; // 추가된 부분!\n\nCompletableFuture<String> future = CompletableFuture.supplyAsync\n         -> {\n            String hello = \"Hello \";\n            System.out.printlnhello + Thread.currentThread.getName;\n            return hello;\n        }, executorService // 추가된 부분!\n;\n\nString futureValue = future.get;\nSystem.out.println\"String type CompletableFuture: \" + futureValue;\n\n\n출력 예시\nsh\nHello pool-1-thread-1\nString type CompletableFuture: Hello \n\n- ForkJoinPool이 아닌 그냥 pool로 출력되는 것을 확인할 수 있다.\n\n 콜백 제공하기\n> thenApplyFunction, thenAcceptConsumer, thenRunRunnable\n- 메서드 체이닝 형태로 콜백을 제공할 수 있다.\n- 콜백이 온다 해도 get를 사용해야 작업의 결과를 얻을 수 있다.\n- 콜백 자체를 또 다른 스레드에서 처리할 수 있다.\n\n thenApplyFunction - 결과값을 다른 타입으로 변경한다.\n코드 예시\njava\nCompletableFuture<String> future = CompletableFuture.supplyAsync\n         -> \"Hello\"\n.thenApply\n        String::toUpperCase\n;\n\nString futureValue = future.get;\nSystem.out.println\"thenApply: \" + futureValue;\n\n출력 예시\nsh\nthenApply: HELLO\n\n\n thenAcceptConsumer - 결과값을 이용해 반환값이 없이 추가적인 행동만 한다.\n코드 예시\njava\nCompletableFuture<Void> future = CompletableFuture.supplyAsync\n         -> \"Hello\"\n.thenAccepts -> {\n    System.out.printlns + \" thenAccept: \" + Thread.currentThread.getName;\n};\n\nVoid futureValue = future.get;\nSystem.out.println\"thenApply: \" + futureValue;\n\n출력 예시\nsh\nHello thenAccept: main\nthenApply: null\n\n- 현 예제의 thenAccept는 main 스레드에서 실행되었지만, ForkJoinPool에 있는 Thread를 사용하기도 한다.\n- thenAccept으로 전달한 콜백 앞선 콜백을 실행한 쓰레드나 그 쓰레드를 파생시킨 부모에서 실행된다.\n\n thenRunRunnable - 결과값을 받지 않고 다른 작업을 처리하는 콜백\n코드 예시\njava\nCompletableFuture<Void> future = CompletableFuture.supplyAsync\n         -> \"Hello\"\n.thenRun -> {\n    System.out.println\"thenRun: \" + Thread.currentThread.getName;\n};\n\nVoid futureValue = future.get;\nSystem.out.println\"thenApply: \" + futureValue;\n\n출력 예시\nsh\nthenRun: main\nthenApply: null\n\n\n- 현 예제의 thenAccept는 main 스레드에서 실행되었지만, ForkJoinPool에 있는 Thread를 사용하기도 한다.\n- thenRun으로 전달한 콜백 앞선 콜백을 실행한 쓰레드나 그 쓰레드를 파생시킨 부모에서 실행된다.\n\n 작업 조합하기\n thenCompost - 두 작업이 서로 이어서 실행하도록 조합한다.\n코드 예시\njava\npublic class CompletableFutureEX {\n\n    public static void mainString args throws ExecutionException, InterruptedException {\n        CompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n                 -> {\n                    System.out.println\"Hello \" + Thread.currentThread.getName;\n                    return \"Hello \";\n                }\n        .thenComposeCompletableFutureEX::getWorldFuture;\n\n        String helloWorldFuture = helloFuture.get;\n        System.out.println\"helloWorldFuture = \" + helloWorldFuture;\n    }\n\n    // thenCompose의 인수를 메서드 레퍼런스로 넘겨주기 위해 만든 메서드\n    private static CompletableFuture<String> getWorldFutureString message {\n        return CompletableFuture.supplyAsync\n                 -> {\n                    System.out.println\"World \" + Thread.currentThread.getName;\n                    return message + \"World\";\n                }\n        ;\n    }\n}\n\n출력 예시\nsh\nHello ForkJoinPool.commonPool-worker-19\nWorld ForkJoinPool.commonPool-worker-5\nhelloWorldFuture = Hello World\n\n\n thenCombin - 두 작업을 독립적으로 실행하고 둘 다 종료 되었을 떄 콜백 실행\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n;\n\nCompletableFuture<String> worldFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"World \" + Thread.currentThread.getName;\n                return \"World\";\n        }\n;\n\nCompletableFuture<String> helloWorldFuture = helloFuture.thenCombineworldFuture, hello, world -> hello + \" \" + world;\nSystem.out.println\"helloWorldFuture.get = \" + helloWorldFuture.get;\n\n출력 예시\nsh\nWorld ForkJoinPool.commonPool-worker-5\nHello ForkJoinPool.commonPool-worker-19\nhelloWorldFuture.get = Hello World\n\n\n allOf - 여러 작업을 모두 실행하고 모든 작업결과에 대해 콜백을 실행한다. CompletableFuture<Void> 반환\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n;\n\nCompletableFuture<String> worldFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"World \" + Thread.currentThread.getName;\n                return \"World\";\n        }\n;\n\nCompletableFuture<Void> voidCompletableFuture = CompletableFuture.allOfhelloFuture, worldFuture\n                .thenAcceptSystem.out::println;\n\nSystem.out.println\"voidCompletableFuture = \" + voidCompletableFuture.get;\n\n출력 예시\nsh\nSpring ForkJoinPool.commonPool-worker-23\nHello ForkJoinPool.commonPool-worker-19\nWorld ForkJoinPool.commonPool-worker-5\nnull\nvoidCompletableFuture = null\n\nthenAccept를 통해 \"Hello\"와 \"World\"가 출력되길 기대했지만 null이 반환되었다.   \n왜냐하면 CompletableFuture는 제네릭으로 Void를 받고 있기 떄문이다.\n\n만약 위 예시 코드에서 \"Hello\"와 \"Wold\"를 출력하고 싶으면 조금 복잡하지만 앞으로 나올 방식으로 출력할 수 있다.\n\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n;\n\nCompletableFuture<String> worldFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"World \" + Thread.currentThread.getName;\n                return \"World\";\n        }\n;\n\n// Stream을 사용하기 위해 ArrayList를 생성한다.\nList<CompletableFuture<String>> futuresAsList = Arrays.asListhelloFuture, worldFuture;\nCompletableFuture futuresAsArray = futuresAsList.toArrayCompletableFuture::new;\n\nCompletableFuture<List<String>> listCompletableFuture = CompletableFuture.allOffuturesAsArray\n        .thenApplyv -> futuresAsList.stream\n                .mapCompletableFuture::join\n                .collectCollectors.toList\n        ;\n\nlistCompletableFuture.get.forEachSystem.out::println;\n\n\n출력 예시\nsh\nHello ForkJoinPool.commonPool-worker-19\nWorld ForkJoinPool.commonPool-worker-5\nHello\nWorld\n\n- thenApply인수로 넘겨준 Function이 실행되는 시점은 이미 작업이 완료되는 시점이므로 모든 작업들을 가져올 수 있다.\n- 위 방법은 아무것도 블로킹 - blocking 처리가 되지 않는다.\n  > 이해가 되지 않지만 일단 받아드리자\n\n anyOf - 여러 작업 중에 가장 빨리 끝난 하나의 결과에 콜백 실행\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n;\n\nCompletableFuture<String> worldFuture = CompletableFuture.supplyAsync\n         -> {\n                System.out.println\"World \" + Thread.currentThread.getName;\n                return \"World\";\n        }\n;\n\nCompletableFuture<Void> voidCompletableFuture = CompletableFuture.anyOfhelloFuture, worldFuture.thenAccept\n        System.out::println\n;\nvoidCompletableFuture.get;\n\n\n출력 예시\nsh\nWorld ForkJoinPool.commonPool-worker-5\nHello ForkJoinPool.commonPool-worker-19\nWorld\n\n\n 예외 처리하기\n exeptionallyFunction - 해당 task에 예외가 발생하면 Function를 실행한다.\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                boolean throwError = true;\n\n                ifthrowError\n                throw new IllegalArgumentException;\n\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n.exceptionally\n        ex -> { //해당 task에 대한 Exception\n                System.out.printlnex;\n                return \"Error!\";\n        }\n;\n\nSystem.out.printlnhelloFuture.get;\n\n\n출력 예시\nsh\njava.util.concurrent.CompletionException: java.lang.IllegalArgumentException\nError!\n\n\n handleBiFunction - 해당 task의 정상 결과와 예외 결과를 종합적으로 처리할 수 있다.\n- 예외 여부에 상관없이 무조건 실행된다.\n\n코드 예시\njava\nCompletableFuture<String> helloFuture = CompletableFuture.supplyAsync\n         -> {\n                boolean throwError = false; // 해당 변수가 false면 Exception이 발생하지 않는다.\n\n                ifthrowError\n                throw new IllegalArgumentException;\n\n                System.out.println\"Hello \" + Thread.currentThread.getName;\n                return \"Hello\";\n        }\n.handle\n        result, ex ->{\n                ifex != null{\n                return \"Error!\";\n                }else{\n                return result;\n                }\n        }\n;\nSystem.out.printlnhelloFuture.get;\n\n출력 예시\nsh\n throwError가 false인 경우 \nHello ForkJoinPool.commonPool-worker-19\nHello\n\n throwError가 true 경우 \nHello ForkJoinPool.commonPool-worker-19\nError!",
    "tags": [
      "concurrent",
      "TIL",
      "coding",
      "development",
      "java"
    ]
  },
  {
    "title": "Google Guava",
    "url": "/programming/2022/03/29/google-guava/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "FCM를 통해 push 알람로직을 작성하는 중 관련 API의 코드를 뜯어보는 중 Guava에 대한 언급이 있어 찾아보게 되었다.",
    "content": "Google Guava\n 배경\nFCM를 통해 push 알람로직을 작성하는 중 관련 API의 코드를 뜯어보는 중 Guava에 대한 언급이 있어 찾아보게 되었다.\n\n Guava란?\n구글리 작성한 Java 오픈소스 라이브러리 이다. \n- 유용한 유틸리티 함수와 클래스를 다양하게 제공한다,\n- Apache Commons 프로젝트의 대안이 될 수 있다\n- Java8 버전 이후 Guava에서 제공하던 기능을 유사하게 제공하게 됨에따라 역할이 다소 모호해졌다.\n\n> Apache Commons Lang + Apache Commons Collections + 유용한 유틸 => Google Guava\n\n 장점\n- 버그 발생률을 현저히 줄일 수 있다.\n- 장황하고 비효율적인 코드를 줄일 수 있다.\n- 개발 표준을 준수하는 코드를 작성할 수 있다.\n- 위의 장점들로 인해 생상성이 증가한다.",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "쿼리 메소드 기능",
    "url": "/back-end/2022/03/29/쿼리-메소드-기능/",
    "category": "back-end",
    "date": "2022-03-29",
    "excerpt": "> 만약 findByUsername같이 Entity 종속적인 기능을 사용하려면 어떻게 해야 할까? Spring JPA는 쿼리 메소드라는것을 제공한다.",
    "content": "쿼리 메소드 기능\n> 만약 findByUsername같이 Entity 종속적인 기능을 사용하려면 어떻게 해야 할까? Spring JPA는 쿼리 메소드라는것을 제공한다.\n 쿼리 메소드 기능 3가지\n- 메소드 이름으로 쿼리 생성\n- 메소드 이름으로 JPA NamedQuery 호출\n- @Query 어노테이션을 사용해서 리파지토리 인터페이스에 쿼리 직접 정의\n\n 메소드 이름으로 쿼리 생성\n: 메소드 이름을 분석하여 JPQL 쿼리를 실행한다.\n\n이름과 나이를 기준으로 회원을 조회하려면?\n 순수 JPA Repository 코드\njava\n public List<Member> findByUsernameAndAgeGreaterThanString username, int age {\n      return em.createQuery\"select m from Member m where m.username = :username\n  and m.age > :age\"\n              .setParameter\"username\", username\n              .setParameter\"age\", age\n              .getResultList;\n}\n\n\n Spring Data JPA\njava\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n    List<Member> findByUsernameAndAgeGreaterThanString username, int age;\n}\n\n- 쿼리 메소드 필터 조건: 공식문서 참고https://docs.spring.io/spring-data/jpa/docs/current/reference/html/jpa.query-methods.query-creation\n- 조회: find...By, read...By, get...By\n  > findHelloBy 처럼 ...에 식별하기 위한 내용설명이 들어가도 된다.  \n  > 자세한건 공식문서\n- COUNT: count...By 반환타입 long\n- EXISTS: exists...By 반환타입 boolean\n- 삭제: delete...By, remove...By 반환타입 long\n- DISTINCT: findDistinct, findMemberDistinctBy\n- LIMIT: findFirst3, findFirst, findTop, findTop3\n\n> 참고: 필드명이 변경되면 인터페이스에서도 똑같이 변경해줘야 한다.  \n> 그렇지 않으면 애플리케이션 시작 시점에 에러가 나온다.  \n> 이러한점이 JPA큰 장점이다.\n\n 메소드 이름으로 JPA NamedQuery 호출\n: JPA의 NamedQuery를 호출할 수 있다.\n> 실무에서 사용할 일이 별로 없다.  \n> 대신 @Query를 사용하여 Repository 메소드에 쿼리를 직접 정의한다.\n\n @NamedQuery 어노테이션으로 Named 쿼리 정의\njava\n@Entity\n@NamedQuery\n    name=\"Member.findByUsername\",\n    query=\"select m from Member m where m.username = :username\"\n\npublic class Member{\n    ...\n}\n\n JPA를 직접 사용해서 Named 쿼리 호출\njava\npublic class MemberRepository {\n    public List<Member> findByUsernameString username {\n        ...\n        List<Member> resultList = \n        em.createNamedQuery\"Member.findByUsername\", Member.class\n                .setParameter\"username\", username\n                .getResultList;\n    }\n}\n\n DATA JPA를 사용하여 Named 쿼리 호출\njava\n@Repository\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n//    @Queryname = \"Member.findByUsername\" //생략가능하다. 알아서 위에 선언된 Member를 찾아간다.\n    List<Member> findByUsername@Param\"username\" String username;\n}\n\n- Spring Data JPA는 선언한 \"도메인 클래스 + . + 메서드 이름' 으로 Named 쿼리를 찾아서 실행한다.\n- 실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략을 사용한다.\n- 필요하면 전략을 변경 가능하지만 권장x\n  > 참고https://docs.spring.io/spring-data/jpa/docs/current/reference/html/repositories.query-methods.query-lookup-strategies \n\n @Query를 사용하여 Repository 매서드에 쿼리 정의하기\n> 가장 권장하는 방식이다.  \n> 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다.  \n> 복잡하면 주로 @Query를 통해 실무에서 많이 사용한다.\n\n 메서드에 JPQL 쿼리 작성\njava\npublic interface MemberRepository extends JpaRepository<Member, Long> {\n    @Query\"select m from Member m where m.username= :username and m.age = :age\"\n    List<Member> findUser@Param\"username\" String username, @Param\"age\" int\n    age;\n}\n\n- @org.springframework.data.jpa.repository.Query 어노테이션을 사용한다.\n- 실행할 메서드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있음\n- JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있다!\n\n DTO 조회하기\n예제 DTO\njava\n@Data\n  public class MemberDto {\n      private Long id;\n      private String username;\n      private String teamName;\n      public MemberDtoLong id, String username, String teamName {\n          this.id = id;\n          this.username = username;\n          this.teamName = teamName;\n      }\n}\n\n예제 Repository\njava\n    @Query\"select new com.study.datajpa.dto.MemberDtom.id, m.username, t.name from Member m join m.team t\"\n    List<MemberDto> findMemberDto;\n\n- JPA new 명령어를 사용하고, 생성자가 맞는 DTO가 필요하다.  \n  &rarr; JPA와 사용방식이 동일하다.\n\n 파라미터 바인딩\n 위치기반\n> 실무에서 사용하지 않는다. 가독성및 유지보수성이 매우 떨어진다.\nsql\nselect m from Member m where m.username = ?0\n\n\n 이름기반\nsql\nselect m from Member m where m.username = :name\n\n\n파라미터 파인딩\njava\npublic interface MemberRepository extends JpaRepository<Member, Long>{\n\n    @Query\"select m from Member m where m.username = :name\"\n    Member findMembers@Param\"name\" String username;\n}\n\n\n 컬렉션 파라미터 바인딩\nCollection 타입으로 in절을 지원한다.\njava\n    @Query\"select m from Member m where m.username in :names\"\n    List<Member> findByNames @Param\"names\" Collection<String> names;\n\n\n 반환타입\n> Spring Data JPA는 여러 반환타입을 지원한다.\njava\nList<Member> findListByUsernameString username; //컬렉션\nMember findMemberByUsernameString username //단건\nOptional<Member> findOptionalMemberByUsername;\n\n\n 컬렉션 \n> List 등...\n\n- 결과가 없을떄는 빈 빈 컬렉션을 반환한다. &rarr; null에대한 보장을 해준다.\n\n 단건 조회\n- 결과 없음: null 반환\n- 결과가 2건 이상 : javax.persistence.NonUniqueResultException 예외 발생\n\n 참고 단건 조회결과가 없을때 JPA와 data JPA의 차이\n>Spring Data JPA는 내부에서 JPQL의 Query.getSingleResult 메서드를 호출한다.  \n>조회 결과가 없으면 javax.persistence.NoResultException 예외가 하지만  \n>스프링 데이터는 JPA는 예외를 무시하고 대신 null을 반환한다.",
    "tags": [
      "spring",
      "jpa",
      "data-jpa",
      "TIL"
    ]
  },
  {
    "title": "Java install",
    "url": "/programming/2022/03/29/java-install/",
    "category": "programming",
    "date": "2022-03-29",
    "excerpt": "> 필자는 open jdk 11버전을 선택했다.",
    "content": "Java install\n openJDK 설치\n> 필자는 open jdk 11버전을 선택했다.\nsh\nsudo apt install openjdk-11-jdk\n\n\n 그후 java가 잘 설치되어 있는지 확인해보자\nsh\njava -version",
    "tags": [
      "java",
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "힙 - Heap",
    "url": "/cs/2022/03/19/힙---heap/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ">  =  ",
    "content": "힙 - Heap\n> 힙 - heap = 이진 힙 - binary heap \n\n최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전 이진트리 - complete binary tree를 기반으로 한 자료구조이다.\n\n- 우선순위 큐 - Priority Queue를 구현하기 위해 만들어졌다.\n- 이진 탐색 트리 - BST와 달리 중복된 값을 허용한다.\n- 높이는 logn + 1\n- 삽입/삭제/조회의 시간 복잡도 Ologn\n\n 종류\n 최대 힙 - Max Heap\n부모 노드의 키 값이 자식 노드보다 크거나 같은 완전 이진 트리 이다.\n> 부모노드 >= 자식노드\n\n<img src=\"/assets/images/posts/cs/max-heap.png\">\n\n 최소 힙 - Min Heap\n부모 노드의 키 값이 자식 노드보다 작거나 같은 완전 이진 트리 이다.\n> 부모노드 <= 자식노드\n\n<img src=\"/assets/images/posts/cs/min-heap.png\">",
    "tags": [
      "data-structure",
      "non-linear",
      "tree",
      "TIL"
    ]
  },
  {
    "title": "B-Tree",
    "url": "/cs/2022/03/19/b-tree/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리이다.\n- 정렬된 순서를 보장한다.\n- 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있다.",
    "content": "B-Tree\n이진트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리이다.\n- 정렬된 순서를 보장한다.\n- 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있다.\n\n> DB에서는 B트리에서 발전된 B+트리를 사용한다.\n\n\n B-Tree의 조건\nB트리는 이진트리와 다르게 하나의 노드에 많은 수의 정보를 가질 수 있다.\n\n최대 M개의 자식을 가질 수 잇는 B트리를 M차 B트리라고 하며 다음과 같은 특징을 같는다.\n- 노드는 최대 M개 부터 M / 2개 까지의 자식을 가질 수 있다.\n- 노드에는 최대 M - 1개 부터 M / 2 - 1개의 키가 포함될 수 있다.\n- 노트의 키가 x개라면 자식의 수는 x + 1개 이다.\n- 최소차수는 자식수의 하한값을 의미하며, 최소차수가 t라면 M = 2t - 1을 만족한다.\n  > 최소차수 t가 2라면 3차 B트리 이며, key의 하한은 1개이다.\n\n B-Tree의 예시\n다음은 차수가 3인 B트리이다.\n- <span style=\"color:skyblue\">파란색</span>: 각 노드의 Key\n- <span style=\"color:red\">빨간색</span>: 자식 노드를 가르키는 포인터\n\n1. key들은 노드 안에서 항상 정렬된 값을 가진다\n2. 이진 검색 트리처럼 자식들은 항상 key보다 작은값을 가지고, 오른쪽은 큰 값을 가진다.\n3. 키마다 value를 가지고 있다.\n   > 아래 그림에서는 생략되었다.\n\n<img src=\"/assets/images/posts/cs/b-tree-basic.png\">\n\n\n 검색 & 삽입 과정\nhttps://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree\n\n 1. key 검색과정\n루트노드에서 시작하여 하향식으로 검색을 수행한다.\n\n1. 루트 노드에서 시작하여 key들을 순회하면서 검사한다.\n   1. 만일 k와 같은 key를 찾았다면 검색을 종료한다.\n   2. 검색하는 값과 key들의 대소관계를 비교하여 어떠한 key들 사이에 k가 들어간다면 해당 key사이의 자식노드로 내려간다.\n2. 해당 과정을 리프노드에 도달할 때까지 반복한다.\n   1. 만약 리프노드에도 k와 같은 key가 없다면 검색을 실패한다.\n\n 2. 삽입과정\n1. 트리가 비어있으면 루트 노드를 할당하고 k를 삽입한다.\n   1. 만약 루트노드가 가득 찼다면 노드를 분할하고, 리프노드가 생성된다.\n2. 이후부터는 삽압하기에 적절한 리프노드를 찾아 k를 삽입한다.\n   > 삽입위치는 노드의 key값과 k값을 검색 연산과 동일한 방법으로 비교하면서 찾는다.",
    "tags": [
      "data-structure",
      "non-linear",
      "tree",
      "TIL"
    ]
  },
  {
    "title": "Node,Js 설치(mac)",
    "url": "/back-end/2022/03/19/nodejs-설치mac/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "터미널에  를 입력하면 Node.js 가 설치됩니다.",
    "content": "Node,Js 설치mac\n 설치 \n터미널에 brew install node 를 입력하면 Node.js 가 설치됩니다.\n 유용한 npm 모듈\n nodemon\n설치방법\nbash\n$ npm install -g nodemon --save \n--save는 package.json에 dependency 항목에 추가됨\n\n사용법 nodemon <실행파일>\nNode.js 는 싱글스레드 기반이여서 에러 한번만 일어나면 서버가 다운이 되버린다.  \n그러면 개발할떄마다 다시 node <실행파일> 를 계속 입력해줘야하지만 nodemon은 계속 실행해준다.",
    "tags": [
      "nodejs",
      "TIL"
    ]
  },
  {
    "title": "동시성 & 병렬성 - Concurrency & Parallelism",
    "url": "/cs/2022/03/19/동시성-병렬성---concurrency-parallelism/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "<img src=\"/assets/images/posts/cs/concurrency-and-parallelism.png\">",
    "content": "동시성 & 병렬성 - Concurrency & Parallelism\n 동시성 & 병렬성 요약\n<img src=\"/assets/images/posts/cs/concurrency-and-parallelism.png\">\n\n|동시성|병렬성|\n|----|----|\n|동시에 \"실행되는 것\" 같이 보이는 것|실제로 동시에 여러 작업이 처리되는 것|\n|한번에 많은 것을 처리한다.|한번에 많은 일을 처리한다.|\n|논리적인 개념|물리적인 개념|\n|내부적으로 Context Switch가 일어난다.||",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "연관관계 관리",
    "url": "/back-end/2022/03/19/연관관계-관리/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "repo: https://github.com/siwony/HelloJPA/tree/relationshipManage05",
    "content": "repo: https://github.com/siwony/HelloJPA/tree/relationshipManage_05\n 연관관계 관리\n\n 글로벌 페치 전략 설정\n- 모든 연관관계를 지연로딩으로\n- @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연로딩으로 변경\n\n 영속성 전의 설정\n- Order &rarr; Delivery를 영속성 전이 ALL 설정\n- Order &rarr; OrderItem을 영속성 전이 ALL 설정",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "고아 객체(ORPAN)",
    "url": "/back-end/2022/03/19/고아-객체orpan/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 부모 엔티티와 자식관계가 끊어진 엔티티\n- 고아 객체 제거: 부모 엔티티와 자식관계가 끊어진 엔티티를 제거한다.\n- \n- \n- ",
    "content": "고아 객체ORPAN\n: 부모 엔티티와 자식관계가 끊어진 엔티티\n- 고아 객체 제거: 부모 엔티티와 자식관계가 끊어진 엔티티를 제거한다.\n- orpanRemoval = true\n- java\n  Parent parent1 = em.findParent.class, id;\n  parent1.getChildren.remove0 // 자식 엔티티를 컬렉션에서 제거\n  \n- DELETE FROM CHILD WHERE ID=?\n\n 예시\n부모 클래스\njava\n@Entity\npublic class Parent {\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    @OneToManymappedBy=parent, orpanRemova =true\n    private List<Childe> childList = new ArrayList<>;\n\n    public void addChildeChild Child{\n        childList.addchild;\n    }\n}\n\n자식 클래스\njava\n@Entity\npublic class Child {\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn\"parent_id\"\n    Parent parent;\n\n결과\njava\nChilde child1 = new Child;\nChilde child2 = new Child;\n\nParent parent = new Parent;\nparent.addChildchild1;\nparent.addChildchild2;\n\nem.flush; //DB에 변경 내역 추가\nem.clear; //영속성 컨텍스트 초기화\n\nParent findParent = em.findParent.class, parent.getId; // 처음 추가했던 parent조회\nem.removefindParent // 처음 추가했던 parent를 제거하여 추가됬던 2개의 자식이 고아가되어 삭제 된다.\n\n\n\n\n\n 주의\n- 참조가 제거된 객체는 다른 곳에서 참조하지 않는 고아객체로 간주하고 삭제한다.\n  \n- 참조하는 곳이 하나일 때만 사용해야 한다. &rarr; 엔티티가 개인소유 일 때\n- @OneToOne, @OneToMany만 가능하다.\n\n\n참고  \n>개념적으로 부모를 제거하면 자식은 고아가 된다.    \n>따라서 객체 제거 기능을 사용하면 부모를 제거할 때 자식도 함께  제거된다.  \n>이것은 CascadeType.REMOVE처럼 동작한다.\n\n 영속성 전이 + 고아 객체, 생명주기\n CascadeType.ALL + orphanRemovel=true\n: 두 옵션을 모두 활성화하면 부모 엔티티를 통해 자식 앤티티의 생명주기를 관리 할 수있다.\n- 주로 도메인 주도 개발DDD의 Aggregate Root개념을 구현할 때 유용하다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "build.gradle plugins{} error",
    "url": "/back-end/2022/03/19/buildgradle-plugins-error/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> only buildscript {} and other plugins {} script blocks are  \n> allowed before plugins {} blocks, no other statements are allowed 에러 해결",
    "content": "build.gradle plugins{} error\n> only buildscript {} and other plugins {} script blocks are  \n> allowed before plugins {} blocks, no other statements are allowed 에러 해결\n\nbuild.gradle의 플러그인 구성은 plugins{}와 apply plugin의 두 가지 형식이 있다.  \n\n하지만, plugins{} 방식으로 구성을 하려면 plugins의 위치가 중요하다.  \n\n 예제코드\ngradle\ngroup = 'com.moment'\nversion = '0.0.1-SNAPSHOT'\ndescription = 'the'\njava.sourceCompatibility = JavaVersion.VERSION_11\n\nplugins {\n    id 'java'\n    id 'maven-publish'\n    id 'org.springframework.boot' version '2.4.2'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n}\n\n다음과같이 plugins{...} 코드 위에  buildscript{} 및 기타 plugins{} 를 제외한 코드가 있다.  \n그러면 이제 아래와 같은 error를 startup 시점에 발생시킨다.\n\n error 코드\nsh\nBuild file '{ProjectDir}/build.gradle' line: 5\n\nCould not compile build file '{ProjectDir}/build.gradle'.\n> startup failed:\n  build file '{ProjectDir}/build.gradle': 5: only buildscript {} and other plugins {} script blocks are allowed before plugins {} blocks, no other statements are allowed\n\n\n> {ProjectDir} : 자신의 프로젝트위치를 말합니다.\n\n 해결방법\nplugins{...} 코드위에 buildscript{} 및 기타 plugins{} 를 제외한 script를 작성하지 않으면 된다.\n 예제코드\ngradle\nplugins {\n    id 'java'\n    id 'maven-publish'\n    id 'org.springframework.boot' version '2.4.2'\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE'\n}\n\ngroup = 'com.moment'\nversion = '0.0.1-SNAPSHOT'\ndescription = 'the'\njava.sourceCompatibility = JavaVersion.VERSION_11",
    "tags": [
      "TIL",
      "gradle",
      "build-tool"
    ]
  },
  {
    "title": "커맨드 객체 - Command Object",
    "url": "/back-end/2022/03/19/커맨드-객체---command-object/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 를 통해 들어온 들을 를 이용하여 객체에 정의되어있는 속성에 Binding 되는 Object를 의미한다.",
    "content": "커맨드 객체 - Command Object\n: HttpServletRequest를 통해 들어온 RequestParameter들을 setter를 이용하여 객체에 정의되어있는 속성에 Binding 되는 Object를 의미한다.\n\n 필요성\nSpring Boot에서 다음과 같이 Parameter로 요청을 받는 코드가 있다.\njava\n@PostMapping\"signup\"\npublic String upload\n        @RequestParamvalue = \"email\", required = true String email,\n        @RequestParamvalue = \"password\", required = true String password,\n        @RequestParamvalue = \"profile\", required = false String profile,\n        @RequestParamvalue = \"profileImg\", required = false MultipartFile profileImg {\n    ...\n    userService.signupemail, password, profile, profileImg;\n    ...\n    return result;\n}\n\n\n위 코드는 인자가 많고 인수를 검증하는 코드가 있어 지저분하다. Controller는 데이터를 받고 설정 후 검증까지 한다. 이를 분리 할 수 없을까?\n\n아래 작성된 코드와 같이 RequestParam값을 객체로 바운됭 하여 RequestParam의 값을 받는다.  \n추가적으로 bean validation을 활용하면 아래와 같이 바운딩되는 값에 대해 검증이 가능하다.\njava\n// signup controller\n@PostMapping\"signup\"\npublic String upload@Valid MemberSignupDto memberSignupDto { // @Modle\n    ...\n    userService.signupmemberSignupDto;\n    ...\n    return result;\n}\n\n//MemberSignupDto 객체\n@Getter @Setter\n@NoArgsConstructor @AllArgsConstructor\npublic class MemberSignupDto{\n    String email;\n    String password;\n\n    String profile;\n    MultipartFile profileImg;\n}\n\n\n 커맨드 객체의 바운딩 규칙\n> 두 가지 규칙 모두 setter가 존재해야 한다.\n 1. NoArgsConstructor와 AllArgsConstructor 둘 다 있는 경우\nNoArgsConstructor 호출 &rarr; setter를 호출하여 parame을 필드에 각각 초기화\n\n 2. AllArgsConstructor만 있는 경우\nAllArgsConstructor 호출 &rarr; RequestParameter을 필드에 각각 초기화 &rarr; setter 호출하여 RequestParameter를 필드에 각각 다시 초기화하여 덮어씌운다.",
    "tags": [
      "spring-mvc",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "소프트웨어 테스트",
    "url": "/cs/2022/03/19/소프트웨어-테스트/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "-  소프트웨어 테스트는 소프트웨어가 문제가 없다를 보이는 것이 아니라 문제가 있다를 밝히는 과정이다.  \n- 즉, 문제를 밝혀 그 문제를 해결하고 소프트웨어의 신뢰성을 높이는 일련의 과정이다.\n- SWLC소프트웨어 생명주기의 프로세스중에 테스트에 해당된다.",
    "content": "소프트웨어 테스트\n-  소프트웨어 테스트는 소프트웨어가 문제가 없다를 보이는 것이 아니라 문제가 있다를 밝히는 과정이다.  \n- 즉, 문제를 밝혀 그 문제를 해결하고 소프트웨어의 신뢰성을 높이는 일련의 과정이다.\n- SWLC소프트웨어 생명주기의 프로세스중에 테스트에 해당된다.\n\n> SWLC소프트웨어 생명주기 :  \n> 요구사항 분석 &rarr; 시스템 명세 단계 &rarr; 설계 &rarr; 구현 &rarr; 테스트 &rarr; 유지보수\n\n 정의\n- 노출되지 않은 숨어있는 결함Fault을 찾기 위해 소프트웨어를 작동시키는 일련의 행위와 절차\n- 오류 발견을 목적으로 프로그램을 실행하여 품질을 평가하는 과정 \n- 품질을 개선하기 위한 일련의 활동\n- 일반적으로 테스트 케이스에 따라 SW를 동적으로 실행시켜 예상결과치와 비교 분석\n- SW의 동작과 성능, 안정성이 요구되는 수준을 만족하는지 확인하기 위한 결함을 발견하는 메커니즘\n\n 목적\n- 프로그램에 잠재된 오류의 발견\n- 기술적인 기능 및 성능의 확인\n- 사용자 만족도 향상\n- 제품 신뢰도 향상\n\n 테스트의 일반적인 원리\n|원리|내용|원인|\n|--|--|--|\n|결함발견|- 결함 제거가 아닌 결함의 발견을 목적 | 테스트 본연의 역활|\n|불완정성|- 완전한 테스트는 불가능하다.<br>- 무한경로, 무한 입력 값, 무한 타이핑 불가능| 자원의 한계|\n|초기 집중<br>요르돈 법칙|- 개발 설계 시 부터 테스트 고려<br>- 결함의 조기 발견 및 재유입 방지|품질 비용 감소|\n|결함 집중|- 결함의 80%는 20%의 특정 모듈에 집중된다.|파레토 법칙|\n|살충제 패러독스|- 동일한 테스트 전략, 기법을 적용 할 시 내성이 생긴다.<br>더이상 새로운 결함을 찾아 내지 못한다.|테스트에 특화된 코딩|\n|정황 의존적|- 테스트는 주변 환경에 영향을 받음|외부요소, 심리 요소|\n|오류-부재의 궤변|- 요구 사항을 충족시키지 못한다면,<br>결함을 발견하고 모두 제거하여도 좋은 테스트라 볼 수 없다.|테스터의 수동적 자세|\n\n> 요르돈 법칙 :  \n> Snowball Effect, 눈덩이 법칙, 결함 증폭 모델  \n> 소프트웨어 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게되어 비용이 커진다는 법칙\n\n 소프트웨어 테스트의 종류\n<img width=500px src=\"/assets/images/posts/cs/kinds-of-test.jpg\">\n\n Back Box Testing - 블렉 박스\u001c테스팅\n: 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 동작을 검사하는 방식이다.\n- 올바른 입력과 올바르지 않은 입력을 입력하여 올바른 출력이 나오는지 테스트하는 기법이다.\n- 사용자 관점의 테스트 방법이라 볼 수 있다.\n\n Whilte Box Testing - 화이트 박스 테스팅\n: 시스템의 내부 설계를 고려한 테스팅으로서 시스템의 코드 내부의 로직에 대한 지식을 기반으로 수행된다.\n- 응용 프로그램의 내부 구조, 동작, 내부 소스 코드 검사하는 테스트 방식이다.\n- 커버리지Coverage를 통하여 테스팅된다.\n- 개발자 관점의 테스트 방법이라 볼 수 있다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Eager/LAZY loading",
    "url": "/back-end/2022/03/19/eagerlazy-loading/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "<img width=400px src=./img/when-member-get-team.png>",
    "content": "Eager/LAZY loading\n 과연 Member만 조회할 때 Team도 조회해야 할까?\n<img width=400px src=./img/when-member-get-team.png>\n\n- 단순히 Member만 조회하는 로직에서는 굉장히 비효율적이다.\n- Member를 조회하는데 Team을 조회하는 비효율적인 상황이 일어난다.\n\n&rarr; LAZY지연 loading을 이용하여 이 부분을 해결할 수 있다.\n\n LAZY\n: 연관된 엔티티를 즉시Eager로 가져오는 것이 아닌 Proxy대리자 객체를 통해 필요할 때만 연관된 엔티티를 가져오는것  \nfetch = FetchType.LAZY  \n> 비즈니스 로직에서 연관된 엔티티를 조회하는 경우가 별로 없는 경우\n\n<img width=450px src=./img/lazy-loading.png>\n\njava\n@Entity\npublic class Member {\n\n@Id @GeneratedValue \nprivate Long id;\n\n@Columnname = \"USERNAME\"\nprivate String name; \n\n@ManyToOnefetch = FetchType.EAGER // @JoinColumnname = \"TEAM_ID\"\nprivate Team team;\n//etc....\n}\n\n- 실제로 LAZY를 통해 조회를하면 Team의 Proxy 객체를 조회한다.  \n  &rarr; Proxy 객체는 아무값도 없다.\n\n 1. LAZY를 사용한 프록시를 통한 조회\n<img width=450px src=./img/lazy-proxy-find.png>\n\njava\nTeam team = member.getTeam; // 프록시 객체\nteam.getTeam // 실제 Team을 사용하는 시점에서 초기화 -> 이때 쿼리를 날린다.\n\n- Member 단독으로 조회할 때는 LAZY가 효율적이다.\n- Member가 90%정도 단독으로 사용한다면 LAZY가 효율적이다.\n- 하지만 Member와 Team을 동시에 조회해야 할 경우가 엄청 많은 경우 EAGER즉시 loading이 이득이다.\n\n EAGER\n: 한방쿼리를 날려 연관된 엔티티를 한꺼번에 조회한다. &rarr; Proxy가 필요 없다.  \nfetch = FetchType.EAGER  \n> 비즈니스 로직에서 연관된 엔티티를 조회하는 경우가 많은 경우\n\n<img width=450px src=./img/eager-loading.png>\n\n 1. EAGER를 사용한 조회\n<img width=400px src=./img/eager-find.png>\n\n- JPA 구현체는 가능하면 조인을 사용하여 SQL을 한 번에 함께 조회한다.\n\n 2. EAGER 주의 사항 - 실무경험 공유 \n- 가급적 지연 로딩만 사용하자특히 실무에서\n- 즉시로딩을 적용하면 예상치 못한 SQL이 발생한다.\n  > 연관된 테이블이 10개 이상이라고 생각해보자 끔찍하다.\n- 즉시로딩은 JPQL에서 N + 1 문제를 발생한다. &rarr; 그냥 LAZY로 설정하고 FETCH JOIN을 사용하자.\n  1. 만약 select m from Member m 라는 JPQL을 사용하면 &rarr; 대충 쿼리가 select  from member 이런 식으로 나간다..\n  2. Member를 조회했지만 연관된 엔티티가 EAGER로 되어있다.\n  3. 그러면 다시 한번 연관된 엔티티를 조회하기 위해 query가 또나온다.\n    > N + 1: 1처음 쿼리를 날리면 N개의 쿼리가 따라온다.\n- @OneToMany, @ManyToMany는 기본이 지연로딩이다.\n\n 마무리 - 실무 \n 모든 연관관계에 지연 로딩을 사용해라\n 실무에서 즉시 로딩을 사용하지 마라 &rarr; 상상치 못한 쿼리가 나간다.\n JPQL fetch join이나, 엔티티 그래프 기능을 사용해라",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "값 타입 컬렉션",
    "url": "/back-end/2022/03/19/값-타입-컬렉션/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 값 타입을 하나 이상 저장할 때 사용한다.\n- ,  사용한다.\n- DB는 컬렉션같은 테이블을 저장할 수 없다.\n- 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.",
    "content": "값 타입 컬렉션\n: 값 타입을 하나 이상 저장할 때 사용한다.\n- @ElementCollection, @CollectionTable 사용한다.\n- DB는 컬렉션같은 테이블을 저장할 수 없다.\n- 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.\n\n<img width=400px src=\"/assets/images/posts/back-end/value-type-collection.png\">\n\njava\n@Entity\n@Getter @Setter\npublic class Member{\n\n    @Id @GeneratedValue\n    @Columnname = \"MEMBER_ID\"\n    private Long id;\n\n    private String username;\n\n    @Embedded\n    private Address homeAddress;\n\n    @ElementCollection\n    @CollectionTablename = \"FAVORITE_FOOD\", joinColumns = @JoinColumnname = \"MEMBER_ID\"\n    private Set<String> favoriteFoods = HashSet<>;\n\n    @ElementCollection\n    @CollectionTablename = \"ADDRESS\", joinColumns = @JoinColumnname = \"MEMBER_ID\"\n    private List<Address> addressHistory = HashList<>;\n}\n\n\n 값 컬렉션 사용\n참고: 값 타입 컬렉션은 영속성 전의Cascade + 고아객체 제거 기능이 필수로 들어가 있다.\n\n 값 타입 저장 예제\njava\nMember m = new Member;\nm.setUsername\"member1\";\nm.setAddressnew Address\"city1\", \"street1\", \"100000\"\n\nm.getFavoriteFoods.add\"치킨\";\nm.getFavoriteFoods.add\"피자\";\nm.getFavoriteFoods.add\"족발\";\n\nm.getAddressHistory.addnew Address\"old1\", \"street1\", \"10000\"\nm.getAddressHistory.addnew Address\"old2\", \"street2\", \"10000\"\n\nem.persistm;\n\n\n- 컬렉션은 다른 테이블이여도 라이프 사이클이 같다. &rarr; 같이 저장됬다.\n- 위 예제의 값타입의 라이프 사이클은 Member에 의존한다.\n\n 값 타입 조회 예제\njava\nMember m = new Member;\nm.setUsername\"member1\";\nm.setAddressnew Address\"city1\", \"street1\", \"100000\"\n\nm.getFavoriteFoods.add\"치킨\";\nm.getFavoriteFoods.add\"피자\";\nm.getFavoriteFoods.add\"족발\";\n\nm.getAddressHistory.addnew Address\"old1\", \"street1\", \"10000\"\nm.getAddressHistory.addnew Address\"old2\", \"street2\", \"10000\"\n\nem.persistm;\n\nem.flush;  em.clear;\n\nMember findM = em.findMember.class, m.getId; // 기본타입은 지연로딩이 된다. \n\nList<Address> addressHistory = findM.getAddresHistory; // 이때 addressHistory 를 쿼리를 날려 불러온다. \n\nSet<String> favoriteFoodss = findM.getFavoriteFood; //이떄 favoriteFood를 불러온다.\n\n- 값 타입 컬렉션들은 기본적으로 지연로딩이 된다.\n\n 값 타입 수정 예제\njava\nMember m = new Member;\nm.setUsername\"member1\";\nm.setAddressnew Address\"city1\", \"street1\", \"100000\"\n\nm.getFavoriteFoods.add\"치킨\";\nm.getFavoriteFoods.add\"피자\";\nm.getFavoriteFoods.add\"족발\";\n\nm.getAddressHistory.addnew Address\"old1\", \"street1\", \"10000\"\nm.getAddressHistory.addnew Address\"old2\", \"street2\", \"10000\"\n\nem.persistm;\n\nem.flush;  em.clear;\n\nMember findM = em.findMember.class, m.getId;\n// homeCity를 newCity로 바꾸고 싶으면\n// findM.getHomeAddress.setCity\"newCity\"; // 다음과 같이 바꾸면 부작용이 일어날 수 있다.\nAddress a =  findM.getHomeAddress;\nfindM.setMemberAddressnew Address\"newCity\", a.getStreet, a.getZipcode; //완전히 새로운 객체로 교체를 해야한다.\n\n// 치킨을 한식으로 바꾸기\nfindM.getFavoritFoods.remove\"치킨\";\nfindM.getFavoritFoods.add\"한식\"; // 컬렉션의 값만 변경해도 업데이트 쿼리가 날라간다.\n\n// address 바꾸기\nfindM.getAddressHistory.removenew Address\"old1\", \"street\", \"10000\"; // Address 에equals로 값을 비교하여 지운다. Address에 equals를 오버라이드 해야한다.\nfindM.getAddressHistory.addnew Address\"newCity1\", \"street\", \"10000\";  // addressHistory의 모든값이 제거되고 다시insert가 된다.\n\n- 값 타입은 불변해야 하기 떄문에 통제로 교체를 해야한다.\n\n\n 값 타입 컬렉션 제약사항\n- 값 타입은 식별자가 없다.\n- 값을 변경하면 추적이 어렵다.\n- 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 관련된 모든 데이터를 삭제하고,  \n  값 타입 컬렉션에 있는 현재값을 모두 다시 저장한다.\n- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 된다. null 입력x, 중복 저장x\n\n 값 타입 컬렉션 대안\n- 실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다 관계를 고려한다.\n- 일대다 관계를 위한 엔티티를 만들고, 여기에서 값타입을 사용한다.\n- 영속성 전이Cascade + 고아 제거를 사용해서 값 타입 컬렉션 처럼 사용한다.\n- ex. AddressEntity",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "고급매핑 - 상속관계 매핑",
    "url": "/back-end/2022/03/19/고급매핑---상속관계-매핑/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> JPA는 DB의 슈퍼타입/서브타입 과 같은 어떠한 논리적 기법을 어떤 3가지 방법으로 매핑을 하던 모든 매핑을 지원한다.",
    "content": "고급매핑 - 상속관계 매핑\n> JPA는 DB의 슈퍼타입/서브타입 과 같은 어떠한 논리적 기법을 어떤 3가지 방법으로 매핑을 하던 모든 매핑을 지원한다.\n 상속관계 매핑\n: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑하는것   \n<img width=550px src=./img/inheritance-relationship-mapping.png>\n\n: 객체의 상속, 구조, DB의 슈퍼타입 서브타입 관계를 매핑한다.\n- 객체는 상속관계가 있지만, DB는 상속관계가 없다.\n- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다.\n\n 상속관계 매핑의 종류\n- 조인 전략 &rarr; 각각 테이블로 변환\n  \n- 단일 테이블 전략 &rarr; 통합 테이블로 변환\n- 구현 클래스마다 테이블 전략 &rarr; 서브타입 테이블로 변환\n\n 1. 조인 전략\n: 각각 테이블로 변환한다.  \n> 굉장히 정규화된 방법이다. 설계를 기본적으로 깔고 들어가야 한다.  \n\n<img width=500px src=./img/join-strategy.png>\n\n- @Inheritancestrategy = InheritanceType.JOINED\n- 슈퍼타입 테이블의 \"기본키\"를 서브타입 테이블의 \"기본키\"겸 \"외래키\"로 둔다.\n  \n- 그후 상위 테이블은 조인할 테이터를 구분할 수 있는 구분 컬럼을 둔다.\n\n 장점\n- 테이블을 정규화 할 수 있다\n- FK 참조 무결성 제약조건 활용가능하다\n- 저장공간이 효율화 된다.\n\n 단점\n- 조회시 조인을 많이 사용한다. &rarr; 성능 저하\n  >근데 그렇게 크게 문제가 될건 아니다. - 김영한\n- 조회 쿼리가 복잡하다.\n- 데이터 저장시 INSERT query를 2번 호출한다.\n\n 예시 코드\njava\n@Entity\n@Inheritancestrategy = InheritanceType.JOINED \n@DiscriminatorColumn // 무슨타입인지 알려주는 DTYPE 컬럼추가\npublic abstract class Item{\n\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n    private int price;\n}\n\n@Entity\n@DiscriminatorValue\"A\" //이렇게 DTYPE을 지정 할 수 있다.\npublic class Album extends Item{\n\n    private String artist;\n}\n\n@Entity\npublic class Movie extends Item{\n\n    private String director;\n    private String actor;\n}\n\n@Entity\npublic class Book extends Item{\n\n    private String author;\n    private String isbn;\n}\n\n\n 2. 단일 테이블 전략\n: 통합 테이블로 변환한다. &rarr; 걍 다 합쳐버린다.  \n> 테이블은 단순하지만 객체지향적으로 상속하게 되어있을수 있다.\n\n<img width=500px src=./img/single-table-strategy.png>\n\n- 성능적으로 좋다. 쿼리도 적게 나간다.\n- 테이블이 단일 테이블이라 내가 무슨 타입인지 모르므로 기본으로 DTYPE이 들어간다.  \n  >조인 전략은 어쨌든 DTYPE없어도 내가 무엇인지 찾을 수 있지만...\n\n 장점\n- 일반적으로 조회 성능이 빠르다. &rarr; 조인이 필요 없으므로 \n- 조회 쿼리가 단순하다.\n\n 단점\n- 데이터 무결성에 문제가 있다. &rarr; 자식 엔티티가 매핑한 컬럼은 모두 null을 허용한다.\n- 조회 성능이 오히려 느려질 수 있다. &rarr; 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있기 때문이다.\n  > 이 정도 임계점을 넘기가 힘들다.\n\n 예시코드\n> 그냥 상위 Entity에 Inheritancestrategy = InheritanceType.SINGLE_TABLE 를 해주면 된다.\njava\n@Entity\n@Inheritancestrategy = InheritanceType.SINGLE_TABLE \n//@DiscriminatorColumn // 이거 없어도 DTYPE이 넣어진다. 필수적으로 생성된다.\npublic abstract class Item{\n\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n    private int price;\n}\n\n\n\n 3. 구현 클래스마다 테이블 전략\n: 서브타입 테이블로 변환한다. &rarr; 중복되어도 그대로 사용한다.   \n이 전략은 DB 설계자와 ORM 전문가 둘 다 추천하지 않는다!\n> 너무 비효율적이다. 모든 테이블을 다 찾아야된다. 이건 쓰면 안된다!\n \n<img width=600px src=./img/each-implements-class-table-strategy.png>\n\n- 중간의 아이템을 만들지 않고 중복되는 컬럼을 각각의 테이블에 넣는다.\n\n\n 장점\n- 서브 타입을 명확하게 구분해서 처리할 때 효과적\n- NotNull 제약조건을 사용할 수 있다.\n\n 치명적인 단점\n- 여러 자식 테이블을 함께 조회할 때 성능이 느리다. &rarr; UNION QUERY를 날려야 한다.\n- 자식 테이블을 통합해서 쿼리하기 어렵다 &rarr; 변경이라는 관점에서 보면 엄청 안좋다.\n\n 예시코드\njava\n@Entity\n@Inheritancestrategy = InheritanceType.TABLE_TER_CLASS \n//@DiscriminatorColumn  의미가 없다. 테이블 자체가 다르다.\npublic abstract class Item{\n\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n    private int price;\n}\n\n\n DTYPE\n: 상속 관계 매핑시 부모 클래스에서 자식 클래스를 구분할 컬럼명이다.\n- @DiscriminatorColumn\n- DTYPE의 기본값은 각 자식의 클래스명이다.\n- @DiscriminatorValue\"사용자지정값\" 처럼 자식테이블에 지정해 줄 수 있다.\n\nDTYPE 필요한 이유\n- 객체에서 봤을때는 무엇을 조인해야되는지 알 수 있다.\n- 하지만 DB에 쿼리를 날렸을 때 어떠한 테이블로 인하여 값이 들어왔는지 모른다.  \n  Album? Movie? Book?\n- DTYPE은 운영상 있는게 좋다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "객체지향 쿼리 언어",
    "url": "/back-end/2022/03/19/객체지향-쿼리-언어/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- JPQL\n- JPA Criteria\n- QueryDSL\n- 네이티브 SQL\n- JDBC API 직접사용, MyBatis, SpringJdbcTemplate 함께 사용",
    "content": "객체지향 쿼리 언어\n JPA는 다양한 쿼리 방법을 지원한다.\n- JPQL\n- JPA Criteria\n- QueryDSL\n- 네이티브 SQL\n- JDBC API 직접사용, MyBatis, SpringJdbcTemplate 함께 사용\n\n 하지만 JPA만으로 모든 문제들을 해결 할 수는 없다.\n- JPA를 사용하면 엔티티 객체를 중심으로 개발한다.\n- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색한다.\n- 모든 DB 데이터를 객체로 변환하여 검색하는 것은 불가능하다.\n- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요하다.\n\n JPQL\n: 객체 지향 SQL\n- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공한다.\n- 데이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리이다.\n- SQL을 추상화해서 특정 DB SQL에 의존하지 않는다.\n\n 예제\njava\nString jpql = \"select m From Member m where m.age > 18\";\n\nList<Member> result = em.createQueryjpql, Member.class.getResultList;\n\n실행된 SQL\nsql\nselect \n    m.id as id,\n    m.age as age,\n    m.USERNAME as USERNAME,\n    m.TEAM_ID as TEAM_ID\nfrom Member m\nwhere m.age>18\n\n\n Criteria\n> 너무 복잡하고 실용성이 없다 QueryDSL을 사용권장한다.\n- 문자가 아닌 자바코드로 JPQL을 작성할 수 있다\n- JPQL 빌더 역활을한다\n- JPA 공식 기능\n\n queryDSL\n> 일단 JPQL 먼저하면 쉽다. 기능전 JPQL - 김영한 \n- 문자가 아닌 자바코드로 JPQL을 작성할 수 있다\n- JPQL 빌더 역활을한다\n- 컴파일 시점에 문법 오류를 찾을 수 있다\n- 동적쿼리 작성이 편리하다.\n- 실무사용이 권장된다.\n\n 네이티브 SQL 소개\n- JPA가 제공하는 SQL을 직접 사용하는 하는 기능이다.\n- JPQL로 해결할 수 없는 특정 DB에 의존적인 기능일때 사용한다.\n- ex. 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트",
    "tags": [
      "spring",
      "jpa",
      "JPQL",
      "TIL"
    ]
  },
  {
    "title": "JPA Auditing",
    "url": "/back-end/2022/03/19/jpa-auditing/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> MembershipApi를 만들면서 유저 가입일을 추가해보고싶었다.",
    "content": "JPA Auditing\n 사용동기\n> MembershipApi를 만들면서 유저 가입일을 추가해보고싶었다.\n\n Auditing 활성화\n자신의 SpringBoot Application class에 @EnableJpaAuditing를 추가한다.\njava\n@EnableJpaAuditing //추가한것\n@SpringBootApplication\npublic class Aouth2Application {\n\n\tpublic static void mainString args {\n\t\tSpringApplication.runAouth2Application.class, args;\n\t}\n}\n\n\n JPA Auditing으로 생성시간/수정시간 자동화\njava\n@Getter\n@MappedSuperclass\n@EntityListenersAuditingEntityListener.class\npublic abstract class BaseTimeEntity {\n    @CreatedDate\n    private LocalDateTime createdDate;\n\n    @LastModifiedDate\n    private LocalDateTime modifiedDate;\n}\n\nBaseTimeEntity 클래스를 만들어 모든 Entity의 상위 클래스가 되어  \nEntity 들의 createDate, modifiedDate를 자동으로 관리하는 역활\n- @Getter : lombok이 해당 필드에 대한 기본 Getter를 생성해준다.\n- @MappedSuperclass : JPA Entity 클래스들이 BaseTimeEntity를 상속할 경우  \n필드들createdDate, modifiedDate도 칼럼으로 인식하도록 한다.\n- @CreatedDate: Entity가 생성되어 저장될 때 시간이 자동 저장된다.\n- @LastModifiedDate : 조회한 Entity의 값이 변경할 때 시간이 자동저장된다\n\n 내 프로젝트에 적용\n UserEntity\njava\n@Entity\n@Tablename = \"user\"\n@Getter\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User extends BaseTimeEntity{\n\n    @JsonIgnore\n    @Id\n    @Columnname = \"user_id\"\n    @GeneratedValuestrategy = GenerationType.IDENTITY\n    private Long userId;\n\n    @Columnname = \"username\", length = 50, unique = true\n    private String username;\n\n    @JsonIgnore\n    @Columnname = \"password\", length = 100\n    private String password;\n\n    @Columnname = \"nickname\", length = 50\n    private String nickname;\n\n    @JsonIgnore\n    @Columnname = \"activated\"\n    private boolean activated;\n\n    @ManyToMany\n    @JoinTable\n            name = \"user_authority\",\n            joinColumns = {@JoinColumnname = \"user_id\", referencedColumnName = \"user_id\"},\n            inverseJoinColumns = {@JoinColumnname = \"authority_name\", referencedColumnName = \"authority_name\"}\n    private Set<Authority> authorities;\n}\n\n유저의 기본적인 정보들이 담겨져 있는 User Entity 이다.  \n미리 구현해놓은 singup API 를 사용하여 유저를 생성하면  \n<img width=\"500\"  src=\"/assets/images/posts/back-end/signup-API-postman.png\">  \n만들어진 시간과 수정시간이 정상적으로 데이터베이스에 입력이 되었다.  \nsingup api는 DB에 저장된 값을 리턴해준다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "값 타입 과 불변 타입",
    "url": "/back-end/2022/03/19/값-타입-과-불변-타입/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 복잡한 객체 세상을 조금이나마 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.",
    "content": "값 타입 과 불변 타입\n 값 타입\n: 복잡한 객체 세상을 조금이나마 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.\n\n 값 타입 공유 참조\n- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다.\n- 부작용side effect이 발생할 수 있다. &rarr; 만약 발생한다면 찾기 엄청 어렵다.  \n<img width=450px src=\"/assets/images/posts/back-end/value-type-side-effect.png\">\n\njava\nAddress address = new Address\"city\", \"street\", \"10000\";\n\nMember member = new Member;\nmember.setUsername\"member1\";  \nmember.setHomeAddressaddress;  \nem.persistmember;\n\nMember member2 = new Member;\nmember2.setUsername\"member2\";\nmember2.setHomeAddressaddress; //  member의 homeAddress와 member2 의 homeAddress는 서로 같다 \nem.persistmember2;\n\nmember.getHomeAddress.setCity\"newCity\"; // update 쿼리가 두개나간다. member1과, member2에 대한 update쿼라\n\n\n\n 값타입 복사\n- 값 타입을 실제 인스턴스인 값을 공유하는 것은 위험하다.\n- 대신 값인스턴스을 복사하여 사용한다.  \n  <img width=450px src=\"/assets/images/posts/back-end/value-type-copy.png\">\n\njava\nAddress address = new Address\"city\", \"street\", \"10000\";\n\nMember member = new Member;\nmember.setUsername\"member1\";  \nmember.setHomeAddressaddress;  \nem.persistmember;\n\nAddress copyAddress = new Addressaddress.getCity, address.getStreet, address.getZipcode;\n\nMember member2 = new Member;\nmember2.setUsername\"member2\";\nmember2.setHomeAddresscopyAddress; \nem.persistmember2;\n\nmember.getHomeAddress.setCity\"newCity\"; \n\n\n\n 객체 타입의 한계\n- 항상 값을 복사하여 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.  \n  &rarr; 휴먼에러 발생\n\n- 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이다.\n- 자바 기본 타입에 값을 대입하면 값을 복사한다.\n- 객체 타입은 참조 값에 직접 대입하는 것을 막을 수 없다. &rarr; 객체공유를 막을 수 없다.\n\n 불변 타입\n: 생성 시점 이후 값을 절대 변경할 수 없는 객체\n> 불변이라는 작은 제약으로 부작용이라는 큰 재앙을 막을 수 있다.\n\n- 객체 타입을 수정할 수 없게 만들면 기본 타입의 부작용을 원천 차단한다.\n  \n- 생성자로만 값을 설정하고 수정자Setter를 만들지 않으면 된다.\n- 참고. Integer 과 String은 자바가 제공하는 대표적인 불변 객체",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Node.js 에 MySQL 연결하기",
    "url": "/back-end/2022/03/19/nodejs-에-mysql-연결하기/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "mysql 설치후 mysql 모듈을 설치합니다.",
    "content": "Node.js 에 MySQL 연결하기\n MySQL 모듈을 설치합니다.\nbash\n$ npm install mysql\n\n DB연결하기\nmysql 설치후 mysql 모듈을 설치합니다.\njavascript\nconst mysql      = require'mysql';\nconst connection = mysql.createConnection{\n  host     : 'localhost',  //호스트 주소\n  user     : 'GF_test1',   //mysql user\n  password : '1234',       //mysql password\n  database : 'testGF8'     //mysql DB\n};\n\nconnection.connect;\n\nconnection.query'SELECT  from test', error, rows, fields => {\n  if error throw error;\n  console.log'User info is: ', rows;\n};\n\nconnection.end;\n\n- connection 변수는 연결할 때 사용 되는 정보를 저장함\n- connect; 함수가 mysql에 연결\n- query‘mysql query’, callback; 에서 실제 데이터 베이스의 값을 다룸  \n  mysql query 에너는 mysql query문이 들어감\n- end 함수를 통해 mysql 을 종료합니다.  \nquery매세드에 select  from test 라는 쿼리문을 작성해서  \ntest테이블에 있는 값을 꺼내 와 콘솔에 출력하는 코드를 작성해봤다.\n콘솔에 출력하면 값은 값의 타입은 배열이고 컬럼은 JSON 방식인것을 알 수 있습니다.  \n!node-mysql-query/assets/images/posts/back-end/node.js-mysql-select-query.png\n\n IF 오류가 뜬다면?\n> Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client  \n만약 이런 애러가 11번째 줄에서 throw 되어서 나타났다면, 먼저 확인해야 될것은  \nuser랑 password가 잘못되어 있을수도 있다.   \n그래도 에러가 뜬다면 유저에게 권환을 주지 않았거나, 유저 자체를 만들지 않았을 것이다.  \n지금부터 오류를 고쳐보다.\n\n 유저 조회\n일단은 유저를 관리하는 mysql 이라는 database에 접속을해야한다. use mysql를 입력한다.  \n그뒤 유저를 조회해보자\nsql\n> select user, host from user;\n\n그러면 유저랑, host가 보여질것이다.\n여기서 host는 localhost local내에서 접속이 가능한것이고 % 는 어디서나 접속할 수 있다는것을 말한다.\n이제 유저를 만들어 볼것이다. 유저를 이미 만들어져 있으면 유저 권한 설정으로 이동하면 된다.\n\n 유저 생성 및 권환주기\nsql\n> create user '유저이름'@'호스트host'identified with mysql_native_password by '비밀번호'\n\nhost에는 대표적으로 localhost, %가 있다.%은 외부에서도 접속이 가능하다는것이다.   \nhost는 localhost로 하는게 안전하다. 꼭 필요하지 않는이상 localhost로 하는게 좋다. \nsql\n> grant all privileges on . to '유저이름'@'%';\n\n이렇게 하면 모든 데이터베이스에 접속이 가능하다.  \n하지만 모든 데이터베이스에 접속하는것은 위험하다. 그러므로  \nsql\n> grant all privileges on DB명. to 유저user@localhost\n--ex grant all privileges on cat. test@localhost\n-- cat이라는 DB접속 권환을 test유저에게 localhost에서 사용가능하게 줬다.\n\n이런식으로 특정 DB만 접속할 수 있도록 하는게 비교적 안전해진다.\n\n Sequelize\nsequelize 는 node.js 의 ORMObject Releaition Mapping 모듈이다.  \n관계형 DB를 사용할떄 객체를 이용해 간편하게 쿼리문을 작성하지 않고 사용할 수 있게 해준다.  \n자세한 sequelize 사용법은 여기./sequelize.md 에서 확인할 수 있다.\n how to use?\nbash\n> npm install sequelize sequelize-cli --save\n\n를 통해 모듈을 다운받고\nbash\n> sequelize init\n\n을 통해 sequelize 를 사용할 수 있게 파일구조나 필요한 설정파일들을 생성해준다.",
    "tags": [
      "nodejs",
      "TIL"
    ]
  },
  {
    "title": "Spring 구조(DAO, DTO, Entity, Controller, Service)",
    "url": "/back-end/2022/03/19/spring-구조dao-dto-entity-controller-service/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "<img wdith=\"450px\" src=\"/assets/images/posts/back-end/spring-package-flow.png\">",
    "content": "Spring 구조DAO, DTO, Entity, Controller, Service\n 전체구조 \n<img wdith=\"450px\" src=\"/assets/images/posts/back-end/spring-package-flow.png\">\n\n DAOData Access Object\nrepository package  \n: DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체  \n- 실제로 DB에 접근하는 객체 &rarr; Data Access\n- SQL를 사용개발자가 직접 코딩하여 DB에 접근한 후 적절한 CRUD API를 제공\n    - JAP 대부분의 기본적인 CRUD method를 제공하고 있다.\n- ex Spring Data JPA 예시\n    java\n    public interface BoardRepository extends CrudRepository<Board, Long>{}\n    \n    >Board테이블에 기본키의 자료형은 Long\n DTOData Transfer Object\nDTO package  \n: 계층간 데이터 교환을 위한 객체를 말한다 여기서 계층이란  \n컨트롤러, 뷰, 비지니스 계층, 퍼시스턴스 계층을 말한다.\n\n- 계층간 데이터 교환을 위한 객체 이다\n- DB에서 데이터를 얻어 Service나 Controller 등으로 보내는 객체\n- 로직을 갖고 있지 않은 순수한 Object이다 getter/setter메서드만 가지고있다.\n- Request와 Response용 DTO는 View를 위한 클래스\n    - 자주 변경이 필요한 클래스\n    - Persentaion Model\n    - toEntity 메서드를 통해서 DTO에서 필요한 부분을 이용하여 Entity로 만든다.\n    - Controller Layer에서 Response DTO형태로 Client에 전달\n\n Entity\nDomain Package\n- 실제 DB 테이블과 매칭될 클래스\n    - @Entity, @Column, @Id 등 사용\n- 최대한 외부에서 Entity 클래스의 getter를 사용하지 않도록 해당 클래스 안에서 필요한 로직method을 구현\n JPA entity 예시\njava\nimport lombok.;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.UpdateTimestamp;\n\nimport javax.persistence.;\nimport java.time.LocalDateTime;\n\n@Entity // Entity라고 명시\n@NoArgsConstructoraccess= AccessLevel.PROTECTED // 기본생성자 protected로 생성\n@Getter // getter 생성\npublic class Board {\n    @Id @GeneratedValuestrategy= GenerationType.SEQUENCE\n    private Long id;\n\n    @Columnnullable=false\n    private String title;\n\n    @Column\n    private String content;\n\n    @Columnupdatable=false\n    @CreationTimestamp\n    private LocalDateTime regDatetime;\n\n    @Columnnullable=false\n    private String regUserId;\n\n    @UpdateTimestamp\n    private LocalDateTime editDatetime;\n\n    @Column\n    private String editUserId;\n\n    @Builder\n    private BoardLong id, String title, String content, String regUserId, String editUserId {\n        this.id = id;\n        this.title = title;\n        this.content = content;\n        this.regUserId = regUserId;\n        this.editUserId = editUserId;\n    }\n\n}\n\n Entity class 와 DTO class 를 분리하는 이유\n- View Layer 와 DB Layer의 역활을 철저히 하기위해\n- 테이블과 매핑되는 Entity클래스가 변경되면 여러 클래스에 영향을 끼치게 되는 반면 View와 통신하는 DTO 클래스Request / Response 클래스는 자주 변경되므로 분리\n controllerweb\n- 해당 요청 url에 따라 적절한 view 와 mapping처리\n- @Autowired Service를 통해 service 의 method 를 이용\n- 적절한 ResponseEntityDTO를 body에 담아 Client에 반환\n\n service\n- @Autowried Repository 를 통해 repository의 method를 이용\n- 적절한 business Logic 처리 \n- DAO로 DB에 접근하고 DTO로 데이터를 전달받은 다음, 비지니스 로직을 처리해 적절한 데이터를 반환",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "DB 스키마 자동생성",
    "url": "/back-end/2022/03/19/db-스키마-자동생성/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 애플리케이션 실행 시점에 을 자동 생성한다.\n- 테이블 중심의 개발에서 객체 중심으로 개발하게 된다.\n- 을 활용해서 에 맞는 을 생성한다.",
    "content": "DB 스키마 자동생성\n- 애플리케이션 실행 시점에 DDL을 자동 생성한다.\n- 테이블 중심의 개발에서 객체 중심으로 개발하게 된다.\n- DB 방언을 활용해서 DB에 맞는 DDL을 생성한다.\n\n 속성\nhibernate.hbm2ddl.auto\n|옵션|설명|\n|---|---|\n|create|기존테이블 삭제 후 다시 생성 DROP + CREATE|\n|create-drop|create와 같으나 종료시점에 table DROP한다.|\n|update|변경분만 반영운영DB에 사용하면 안된다.|\n|validate|엔티티와 테이블이 정상 매핑되었는지만 확인|\n|none|사용하지 않음|\n\n 주의사항\n- 운영 장비에는 절대 create, create-drop, update 사용하면 절대 안된다.\n- 생성된 DDL은 개발 장비에서만 사용한다.\n- 개발 초기 단계 create 혹은 update\n- 테스트 서버 update 혹은 validate\n- 스테이징과 운영 서버 validate 혹은 none\n\n결론  \n운영서버에 사용하지 마라 실무에서 사용하다. x 될수도 있다.\n> drop the table\n\n DDL 생성기능\n: DDL을 자동 생성할 때만 사용되고 JPA 실행 로직에 영향을 주지 않는다.\n- 제약조건 추가: 회원 이름은 필수적이고, 10자를 초과할 수 없으면\n    @Columnnullalbe = false, length = 10\n- 유니크 제약조건 추가  \n    TableuniqueConstraints = {@UniqueConstraint name = \"NAME_AGE_UNIQUE\", ColumnNames = {\"NAME\", \"AGE\"}}",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Cross Site Request Forgery, 사이트간 요청 위조)",
    "url": "/back-end/2022/03/19/cross-site-request-forgery-사이트간-요청-위조/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 웹사이트의 취약점을 이용하여 사용자가 의도하지 않은 요청을 송신하도록 하는 공격을 의미힌다\n> HTTP의 Stateless 특성에 기인한 특정 웹 애플리케이션에 대해 일련의 요청 들의 상관관계를 특정할 수 없으므로 세션 유지 등에 일반적으로 쿠키 정보 등이 조건만 만족하면 자동으로 송신되기 떄문에 가능하다.",
    "content": "Cross Site Request Forgery, 사이트간 요청 위조\n: 웹사이트의 취약점을 이용하여 사용자가 의도하지 않은 요청을 송신하도록 하는 공격을 의미힌다\n> HTTP의 Stateless 특성에 기인한 특정 웹 애플리케이션에 대해 일련의 요청 들의 상관관계를 특정할 수 없으므로 세션 유지 등에 일반적으로 쿠키 정보 등이 조건만 만족하면 자동으로 송신되기 떄문에 가능하다.\n 공격시나리오\n1. 공격자가 공격코드를 가진 웹페이지를 제작하여 공개 or 특정 웹사이트에 공격용 코드를 삽입\n2. 피해자가 공격자가 준비해둔 페이지에 접속\n3. 피해자피해자의 브라우저는 공격자가 준비해둔 요청을 서버로 송신\n\n 공격방법\n> 정형화된 수법은 없고 웹에 요청을 보낼 수 있는 모든 방법이 공격 방법이 될 수 있다.  \n\nex\njavascript, ajax, form 방법, img태그를 이용한 방법 등..\n\n 방어 방법\n &nbsp; 1 Referrer 검증\n- Request Header에 있는 요청을 한 페이지의 정보가 담긴 Referrer 속성을 검증하여 차단하는 방법\n- 같은 도메인 상에서 요청이 들어오지 않는다면 차단하는것\n- 대부분 방어가 가능\n\n &nbsp; 2 Security TokenCSRF token\n- 랜덤한 수를 사용자의 세션에 저장하여 사용자의 모든 요청Request에 대하여 서버 쪽에서 검증하는 방법\n- 요청을 받을 떄마다 백엔드에서 세션에 저장된 토큰값과 요청 파라미터에서 전달되는 토큰 값이 같은지 검증\n\n &nbsp; 3 Double Submit Cookie\n- Security Token 검증의 한 종류\n- 세션을 사용할 수 없는 상황에서 사용할 수 있다.\n- Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방어 기법\n- 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고 동일한 난수 값을 요청 파라미터혹은 헤더에도 저장하여 서버로 전송\n- 서버단에서 쿠키의 토큰값과 파라미터의 토큰값이 일치하는지 검사\n- 서버에 따로 토큰 값을 저장할 필요가 없어 세션을 이용한 검증보다 개발 공수가 적은 편\n- 피싱 사이트에서 도메인이 달라 쿠키에 값을 저장하지 못하므로Same Origin 정책 가능한 방어 기법",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "Spring Security Filter",
    "url": "/back-end/2022/03/19/spring-security-filter/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ">Spring Security는 서블릿 컨테이너를 지나기 전에 필터를 통해 인증, 인가를 한다.",
    "content": "Spring Security Filter\n>Spring Security는 서블릿 컨테이너를 지나기 전에 필터를 통해 인증, 인가를 한다.\n\n\n 서블릿 컨테이너Servlet Container\n: tomcat과 같은 웹 애플리케이션을 서블릿 컨테이너라고 부른다.  \n<img width=450px src=./img/servlet-container.png>\n\n- 웹 애플리케이션JAVA EE Application 은 기본적으로 필터와 서블릿으로 구성되어 있다.  \n- filter는 체인처럼 엮여있기 때문에 필터 체인이라고도 불리는데, 모든 request 는 이 필터 체인을 반드시 거쳐야만 서블릿 서비스에 도착하게 된다.\n\n\n Spring Security의 필터체인\n<img width=550px src=./img/spring-security-filter-chain.png>  \n\n- 스프링 시큐리티는 DelegationFilterProxy라는 필터를 만들어 메인 필터체인에 끼워넣고, 그 아래 다시 SecurityFilterChain 그룹을 등록한다.\n- 이 필터체인은 한개 이상이고, url 패턴에 따라 적용하는 필터체인을 다르게 할 수 있다.\n- web resource는 패턴을 따르더라도 필터를 무시ignore하고 통과시켜주기도 한다.\n\n Spring Boot 필터\nSpring Security와 관련된 Filter들은 연결된 여러 Filter들로 구성되어있다. 이 때문에 Chain이라는 표현을 사용하고 있다  \n<img width=500px src=./img/security-filter-chain-2.png>\n\n필터체인에는 다양한 필터들이 들어간다.  \n<img width=450px src=./img/security-filters.png>\n\n각각의 필터는 각각의 서로 다른 관심사를 해결한다.  \n\n 스프링 Security가 무슨 필터가 동작하는지 확인하는 방법\nSpring Security의 설정Class @EnableWebSecurity 에 debug 속성을 ture로 준다.  \n@EnableWebSecuritydebug = \"true\"",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "sequelize",
    "url": "/back-end/2022/03/19/sequelize/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": node.js 의 ORMObject Releaition Mapping 모듈이다.  ",
    "content": "sequelize\n: node.js 의 ORMObject Releaition Mapping 모듈이다.  \n\n how to use?\nbash\nnpm install sequelize sequelize-cli\n\n위 명령어를 통해 sequelize 모듈과 sequelize-cli 모듈을 받아온다.  \nsequelize-cli는 cli로 모델을 쉽게 생성할 수 있다.  \n다음 명령어를 통해 초기화를 한다.\nbash\n> sequelize init\n\n root 디렉토리에 아래와같은 디렉토리/파일이 생긴다.  \n여기서 root 디렉토리는 현제 작업하고있는 프로젝트의 최상위 디렉토리를 말한다.  \n예시로 <code>npm init</code>으로 초기화한 디렉토리를 말한다.\nbash\n|-- config\n|   -- config.json\n|-- migrations     \n|-- models\n|   -- index.js   \n|-- seeders        \n\n sequelize 디렉토리별 정의\n- config : DB설정파일, 사용자이름, DB이름, 비밀번호 등이 들어가 있다.\n- migrations : Git과 비슷하게 DB변화하는 과정을 추측해나아가는 정보로 실제 DB에 반영할 수 있고 취소할 수 있다.\n- models : DB 각 테이블의 정보 및 필드타입을 정의하고 하나로 모은다.\n- seeders : table에 기본 데이터를 넣고싶을때 사용한다.\n 디렉토리를 정리해보자\nroot에는 너무많은 디렉토리, 소스코드, 설정파일들이 있다   \n우리는 저 많은 디렉토리들을 하나의 디렉토리로 정리하여 묶을 필요가 있다.  \n먼저 위에서 생성했던 파일들을 제거하자. 그리고 .sequelizerc 파일을 프로젝트 최상위에 생성한다.  \n그후 .sequelizerc 파일을 아래와 같이 작성한다.  \nJavaScript\n// .sequelizerc\nconst path = require'path';\n\nmodule.exports = {\n    'config': path.resolve'src/db/config/config.json',\n    'models-path': path.resolve'src/db/models',\n    'seeders-path': path.resolve'src/db/seeders',\n    'migrations-path': path.resolve'src/db/migrations'\n}\n \nsequelize init 를 통해 초기화하면 root에 /src/db 경로로 sequelize 구성 파일과 디렉토리가\n 설정\nconfig/config.json 에 들어가면 json 형식으로 DB 정보가 작성되어있을것이다. \nJavaScript\n{\n  \"development\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_development\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  },\n  \"test\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_test\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  },\n  \"production\": {\n    \"username\": \"root\",\n    \"password\": null,\n    \"database\": \"database_production\",\n    \"host\": \"127.0.0.1\",\n    \"dialect\": \"mysql\"\n  }\n}\n\n처음으로 sequelize를 초기화 했으면 기본적으로 development에 입력되어있는 DB정보로 개발이 이루어 질것이다.  \n자신이 설정한 mysql DB에 따라 정보를 수정한다. 개발을 할것이기에 <code>development</code> 에 있는 정보를 수정하자\n참고로 password는 String 형으로 받아야 된다 그러므로 큰따음표\"로 묶어줘야한다.  \n안그러면 <code>ERR_INVALID_ARG_TYPE</code> 에러가 발생할것이다  \n~~필자는 비밀번호가 1234였는데 비밀번호를 큰따음표\"로 안묶어서 에러때문에 2시간동안 고생했다~~  \n\n DB모델링\n간단하게 User라는 table 모델을 만들게되면\nbash\nsequelize model:generate --name User --attributes id:integer, name:string\n\nmodel/user.js가 아래처럼 만들어진다. 2020, 12, 20 기준\njavascript\n'use strict';\nconst {\n  Model\n} = require'sequelize';\nmodule.exports = sequelize, DataTypes => {\n  class User extends Model {\n    /\n      Helper method for defining associations.\n      This method is not a part of Sequelize lifecycle.\n      The models/index file will call this method automatically.\n     /\n    static associatemodels {\n      // define association here\n    }\n  };\n  User.init{\n    id: DataTypes.INTEGER,\n    name: DataTypes.STRING\n  }, {\n    sequelize,\n    modelName: 'User',\n  };\n  return User;\n};\n\n이렇게 <code>user.js</code> 라는 파일이 <code>model</code> 디렉토리 안에 생기고, Users 라는 테이블이 생기는데  \nUsers로 모델이 생성된 이유는 기본적으로 sequelize에서 자동으로 첫글자는 대문자, 복수형 로 변환해준다.   \n\n if모델을 수정했다면\nbash\n> sequelize db:migrations\n\n이 명령어를 꼭 입력해줘야한다, 이유는 모델이 수정이 되도 최종적으로 DB에 반영하는것은  \nmigrations 폴더 안에있는 타임스탬프-create-user.js형식의 파일이다.\n\n\n DB모델 반영\n>server를 실행할 파일에 models/index.js를 연결해주면 설계한대로 반영이 될것이다.  \n\n참고\n- 자동으로 생기는 attribute: id, createdAt, updatedAt",
    "tags": [
      "nodejs",
      "TIL"
    ]
  },
  {
    "title": "순차 리스트 - Sequential List",
    "url": "/cs/2022/03/19/순차-리스트---sequential-list/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 구현할 자료들을 논리적인 순서대로 메모리에 연속하여 저장하는 자료구조이다.\n- 데이터가 컴퓨터 메모리에 저장될 때 저장 시작 위치부터 빈자리 없이 순서대로 저장된다.  \n  > &rarr; 데이터의 시작 위치와 원소의 크기를 안다면 특정 원소의 위치를 알 수 있다.\n- 자료의 논리적인 순서와 물리적인 순서가 일치하는 구현 방식이라고 할 수 있다.",
    "content": "순차 리스트 - Sequential List\n: 구현할 자료들을 논리적인 순서대로 메모리에 연속하여 저장하는 자료구조이다.\n- 데이터가 컴퓨터 메모리에 저장될 때 저장 시작 위치부터 빈자리 없이 순서대로 저장된다.  \n  > &rarr; 데이터의 시작 위치와 원소의 크기를 안다면 특정 원소의 위치를 알 수 있다.\n- 자료의 논리적인 순서와 물리적인 순서가 일치하는 구현 방식이라고 할 수 있다.\n\n 특징\n- 구현이 비교적 간단하다. 배열을 사용하면 된다.\n- 크기가 고정되어있다.\n- 인덱스를 활용해 랜덤 엑세스가 가능하다.\n- 논리적인 순서와 물리적인 순서가 같다.\n  > 삽입과 삭제시, 물리적인 순서와 논리적인 순서를 맞추기 위한 데이터 이동이 발생한다. &rarr; 오버해드가 야무지다.\n\n 순차 리스트배열의 구성요소\n- 배열 이름 - array name\n  > 배열 그 자체와는 별개로 배열의 이름 지칭배열 선언\n- 배열 변수 - array variable\n  > 배열 전체 이름을 갖는 변수 처럼 활용\n- 배열 요소 - array element\n  > 배열의 각 성분 원소들\n- 배열 크기 - array size\n  > 배열 요소의 갯수\n- 배열 인수/키/인덱스/첨자 - array index\n  > 특정 요소를 참조하는 수단, 통상적으로 정수이며 0부터 시작한다.\n\n 데이터 삽입 / 삭제\n> 4번 인덱스에 숫자 7를 삽입할 것이다.  \n> 삽입이 끝난 후 3번 인덱스의 값을 삭제할 것이다.\n\n\n|       | 0 | 1 | 2 | 3 | 4 | 5 | 6 |\n|-------|---|---|---|---|---|---|---|\n|삽입 전 | 1 | 2 | 3 | 4 | 5 | 6 |   |\n|삽입 중 | 1 | 2 | 3 |   | 4 | 5 | 6 |\n|삽입 후삭제 전 | 1 | 2 | 3 | 7 | 4 | 5 | 6 |\n||\n|삭제 중 | 1 | 2 |   | 7 | 4 | 5 | 6 |\n|삭제 후 | 1 | 2 | 7 | 4 | 5 | 6 |   |\n1. 삽입 하기 위해 3번 인덱스를 비워야한다.\n2. 4번 인덱스를 비우려면 3번 인덱스 기준으로 뒤에있는5, 6, 7 인덱스 모든 데이터의 인덱스를 기준으로 1씩 뒤로 이동한다.\n   > 오버헤드가 발생한다.\n3. 2번 인덱스의 값을 제거한다.\n4. 2번 인덱스의 빈공간이 생겼으므로 3번 인덱스 기준으로 뒤에 있는 데이터는 1씩 앞으로 이동한다.\n\n 시간 복잡도\n- 배열의 맨 앞에 삽입/삭제하는 경우 : On\n- 배열의 맨 뒤에 삽입/삭제하는 경우 : O1\n- 배열의 중간에 삽입/삭제하는 경우 : On\n\n 탐색\n- 인덱스로 랜덤 엑세스가 가능하다.\n  > 시간 복잡도 O1\n- 하지만 인덱스 속 값을 모르면 순차적으로 탐색해야 하므로\n  > 시간 복잡도 On\n\n 정리\n 장점\n- 인덱스를 가지고 있어 바로 접근 가능 시간복잡도 O1\n  > 자료구조의 크기가 클수록 이득이다.\n- 연속된 메모리 공간에 존재하기 때문에 관리하기가 편하다.\n\n 단점\n- 삽입과 삭제가 어렵고 오래 걸린다.\n  > 원소를 삽입하거나 삭제할 경우, 해당 원소 이후의 모든 원소들을 한칸씩 밀거나 당겨야 한다.\n- 크기를 변경할 수 없다.\n  > 크기를 변경하기 위해서는 원하는 크기의 새로운 배열을 선언한 뒤 값을 복사해야 함.\n- 크기를 변경할 수 없어 공간 낭비가 발생할 수 있따.\n  > 자료구조의 크기를 100으로 선언하고 10개만 사용하면 나머지 90개의 메모리 낭비가 생긴다.\n\n 언제 사용할까?\n- 데이터 개수가 확실하게 정해져 있을 때\n- 데이터 삽입/삭제 빈도가 적을 때\n- 검색이 빈번하게 일어날 때",
    "tags": [
      "data-structure",
      "linear",
      "list",
      "TIL"
    ]
  },
  {
    "title": "데이터 중심 설계",
    "url": "/back-end/2022/03/19/데이터-중심-설계/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "실습 repo: https://github.com/siwony/HelloJPA/tree/dbDrivenDesign01",
    "content": "실습 repo: https://github.com/siwony/HelloJPA/tree/dbDrivenDesign_01\n 데이터 중심 설계\n\n ERD\n<img width=450px src=./img/data-driven-design-table.png>\n\n 객체 다이어그램\n<img width=450px src=./img/data-driven-design-object.png>\n\n 데이터 중심 설계의 문제점\n> 현재 방식은 객체설계를 테이블 설계에 맞춘 방식이다.\n- 테이블의 외래키를 객체로 그냥 가져온다.\n- 객체 그래프 탐색이 불가능하다.\n- 참조가 없으므로 UMLUnified Modeling Language도 잘못됬다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Spring Boot file Req, Res 처리",
    "url": "/back-end/2022/03/19/spring-boot-file-req-res-처리/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "~~이 글은 siwony의 엄청난 삽질을 통해 작성되었습니다.~~  ",
    "content": "Spring Boot file Req, Res 처리\n~~이 글은 siwony_의 엄청난 삽질을 통해 작성되었습니다.~~  \n 동기\nJubJubhttps://github.com/GSM-Web-Technology/Jup-Jup-Server프로젝트에서 기자재 정보와 기자재이미지를 DB에 저장하는 기능의 필요하다.\n 문제점\n 1. Back-end를 하면서 File처리를 다루어 본적이 없었다.\n 2. File을 Client에게서 어떻게 받고 전달하는지에 대한 지식이 없었다.\n 3. Spring을 이번프로젝트에서 처음 사용했다.\n~~다 구글링하면 해결된다. just do googling~~  \n MultipartFile 으로 파일 req, res\n 파일 받기Request\nJubJub 프로젝트에서 기자재를 저장하는 Controller 이다.  \nfile을 받는 방법은 그냥 MultipartFile타입의 변수로 받으면된다.\njava\n    @PostMapping\"/equimpent\"\n    public void save@RequestParam\"img_equipment\" MultipartFile img_equipment, \n                    @RequestParam String name,\n                    @RequestParam String content,\n                    @RequestParam int count throws Exception {\n        EquipmentUploadDto equipmentUploadDto\n                = EquipmentUploadDto.builder\n                .img_equipmentimg_equipment\n                .namename\n                .contentcontent\n                .countcount\n                .build;\n        equipmentService.saveequipmentUploadDto;\n    }\n\n주의사항\n- form-data를 보내므로 @RequestBody같은 어노테이션을 붙이면안됨\n-  MultipartFile 외에 primitive type의 fields를 함께 수신하고 싶다면파일이랑 json을 같이 보내는 등, \n    파일을 제외한 나머지 필드들의 타입은 무조건 text로 해야한다  \n    >위에 코드에서 name, countentm count를 Dto를 이용해서 데이터를 body에서 받지 않고 RequsetParam으로 전달받은 이유도 이와 같다.Body 에 json요청 불가능\n 파일 Client에 보내기Response\nClient가 /equipment/img/{name} 으로 Get방식의 요청을 하면 서비스에서 name으로 DB에 해당 이미지를 찾아 Controller에 전달후 img를 byte배열로 응답을 한다.\njava\n    @GetMappingvalue=\"/equipment/img/{name}\", produces=MediaType.APPLICATION_OCTET_STREAM_VALUE\n    public byte findByNameGetEquipment_img@PathVariable String name throws Exception {\n        return equipmentService.findByNameGetEquipment_imgname;\n    }\n \n<img width=\"400\" src=\"/assets/images/posts/back-end/eximg.png\">\n\n예시로 나는 img 태그를 이용해 가져와지는지 테스트했다.",
    "tags": [
      "spring-boot",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Stack Frame",
    "url": "/cs/2022/03/19/stack-frame/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.\n- 함수의 호출과 함께 할당된다.\n- 함수의 호출이 완료되면 소멸된다.\n- 자료구조 stack이 사용된다.",
    "content": "Stack Frame\n 메모리에서 Stack이란?\n함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.\n- 함수의 호출과 함께 할당된다.\n- 함수의 호출이 완료되면 소멸된다.\n- 자료구조 stack이 사용된다.\n\n Stack Frame이란?\n함수가 호출되면 스텍에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 복귀 주소, 함수에서 선언된 지역변수등이 저장되는데 이러한 스택영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임 - stack frame 이라고 한다.\n\n실행 중인 함수는 자신만의 스택 영역을 사용하게 되어 Stack Frame을 열게되고, 종료 시 Stack Frame을 닫게 된다.",
    "tags": [
      "Memory",
      "TIL"
    ]
  },
  {
    "title": "List",
    "url": "/cs/2022/03/19/list/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 리스트는 다른  , , ,  등과 같은 다른 자료구조 구현에 활용될 기초 자료구조이다.",
    "content": "List\n: 리스트는 다른  Stack, Queue, Tree, Graph 등과 같은 다른 자료구조 구현에 활용될 기초 자료구조이다.\n\n 특징\n- 자료를 순서대로 한 줄로 저장하는 자료구조.\n- 여러 자료가 일직선으로 서로 연결된 선형 구조입니다.\n- 제일 처음 데이터를 Head이라고 표현한다.\n- 제일 마지막 데이터를 Tail이라고 표현한다.\n\n 선형 구조인 List의 종류\n- Sequent Listsequential-list.md\n- Linked Listlinked-list.md\n  - Singly Linked List\n  - Circular Linked List\n  - Doubly Linked List",
    "tags": [
      "data-structure",
      "linear",
      "list",
      "TIL"
    ]
  },
  {
    "title": "Sprint Security의 다양한 Filter",
    "url": "/back-end/2022/03/19/sprint-security의-다양한-filter/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 응답 헤더에 security 관련 헤더를 추가해주는 역할을 담당한다.\n- 딱히 신경쓸 필요는 없다\n- Security FilterChain에서 3번째로 동작하는 SecurityFilter이다.",
    "content": "Sprint Security의 다양한 Filter\n\n HeaderWriterFilter\n: 응답 헤더에 security 관련 헤더를 추가해주는 역할을 담당한다.\n- 딱히 신경쓸 필요는 없다\n- Security FilterChain에서 3번째로 동작하는 SecurityFilter이다.\n\n 다음과 같은 security 관련 header 를 추가한다.\n- XContentTypeOptionsHeaderWriter: 마임 타입 스니핑 방어.\n- XXssProtectionHeaderWriter: 브라우저에 내장된 XSS 필터 적용.\n- CacheControlHeadersWriter: 캐시 히스토리 취약점 방어.\n- HstsHeaderWriter: HTTPS로만 소통하도록 강제.\n- XFrameOptionsHeaderWriter: clickjacking 방어.\n\n CsrfFlter\n: CSRF attack 을 방어하기 위한 filter 이다.\n- Spring의 CsrfFilter 는 CSRFtoken 을 활용하여 CSRF attack 을 방어한다.\n CsrfFilter란?CSRF.md\n\n CorsFilter\n: 허가된 사이트나 클라이언트의 요청인지 검사한다.\n- Cors교자 출처 리소스 공유 관련 필터이다.\n\n LogoutFilter\n: 로그아웃에 대한 처리를 담당하는 필터이다.\n\n UsernamePasswordAuthenticationFilter\n: 설정된 로그인 URL로 오는 요청을 감시하며, 유저 인증 처리한다.\n- ID와 PW를 사용하는 form 기반 인증에서 사용한다.\n- AuthenticationManager를 통한 인증 실행\n- 인증 성공 시, 얻은 Authentication 객체를 SecurityContext에 저장 후 AuthenticationSuccessHandler 실행\n- 인증 실패 시, AuthenticationFailureHandler 실행\n\n Session Management\n: 서버의 세션 정책을 검사하는 필터\n- session-fixation 공격을 방어\n- 세션 타임아웃을 감지\n- 인증된 사용자가 동시에 열 수 있는 세션 수를 제한하는 등에 사용\n\n ConcurrentSessionFilter\n: 동시에 여러 세션관리하는 filter이다.\n- SessionManagementFilter에서 최대 세션 허용 개수를 초과할 경우 session.expireNow를 통해서 세션을 만료 시킨다.\n\n RememberMeAuthenticationFilter\n: 세션이 사라지거나 만료가 되더라도 쿠키 또는 DB를 사용하여 저장된 토큰 기반으로 인증을 지원하는 필터이다.\n- RemebmerMe 쿠키 여부 확인하여 인증한다.\n\n BearerTokenAuthenticationFilter\n: Authorization 해더에 Bearer 토큰 인증처리한다.\n- 주로 JWT인증을 할때 사용한다.\n\n RequestCacheAwareFilter\n: 특정 로직 성공후, 이전 요청 정보를 캐시에 담는다.\n- 현재 요청과 관련있는 캐시 요청이 있는지 확인하고 있다면 캐시 요청을 처리해준다.\n- 주로 로그인 성공후 이정 요청 정보를 재구성하기 위해 사용한다.\n\n SecurityContextHolderAwareRequestFilter\n: Security 관련 서블릿 API 를 지원해주는 필터이다.\n- 딱히 신경쓸 일은 없는 필터\n- 큐리티 관련 메서드들을 스프링 시큐리티 기반으로 구현체를 연결해주는 역할을 한다.\n\n AnonymousAuthenticationFilter\n: 익명/인증 사용자를 구분하기 위한 필터\n- 인증객체 Authentication 의 유무에 따라서 처리 \n- 인증객체가 없을때 임의의 사용자로 인증객체를 생성 AnonymousAuthenticationToken\n- 세션에 저장하지 않는다.\n\n ExceptionTranslationFilter\n: Spring Security 인가AccessDeniedException와 인증AuthenticationExceptionException 을 처리하는 필터 예외 처리하는 필터\n\n FilterSecurityInterceptor\n: 어떤 리소스에 접근하기 전 마지막에 AccessDecisionManager를 사용하여 인가처리를 하는 필터\n- FilterChainProxy가 호출하는 Filter중 하나이다.\n- 대부분의 경우에 가장 마지막에 사용된다.",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "영속성 컨텍스트 - 내부 동작",
    "url": "/back-end/2022/03/19/영속성-컨텍스트---내부-동작/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> 영속성 컨텍스트는 JPA를 이해하는데 가장 중요하다.",
    "content": "영속성 컨텍스트 - 내부 동작\n> 영속성 컨텍스트는 JPA를 이해하는데 가장 중요하다.\n Entity ManagerFactory 와 EntityManager\n<img width=500px src=./img/entity-manager-factory.png>\n\n1. 고객이 요청할 때마다 EntityManagerFactory를 통해 EntityManager를 생성한다.\n2. EntityManager은 내부적으로 커넥션 풀을 사용해서 DB를 사용하게 된다.\n  \n주의\n- EntityManagerFactory는 하나만 생성해서 애플리케이션 전체에서 공유해야 한다.\n- Entity Manager은 Threed 간 공유하면 안 된다.\n  > 사용하고 버려야 한다.\n- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행한다.\n\n 영속성 컨텍스트\n: entity를 영구히 저장하는 환경 \n- ex EntityManger.persistentity  \n- Entity를 영속성 컨텍스트 안에 넣는다.\n- 영속성 컨텍스트는 논리적인 개념 즉, 눈에 보이지 않는다.\n- EntityManager를 통해 영속성 컨텍스트에 접근한다.\n\n Entity의 생명주기\n 1. 비영속new/transient  \n: 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태  \n<img width=400px src=./img/not-persistence.png>\n\njava\n//객체만 생성한 상태비영속\nMamber member = new Member;\nmember.setId\"member1\";\nmember.setUsername\"회원 1\";\n\n\n 2. 영속managed  \n: 영속성 컨텍스트에 관리 되는 상태\n\n<img width=400px src=./img/managed.png>\n\njava\n// 객체를 생성한 상태 비영속\nMember member = new Member;\nmember.setId\"member1\";\nmember.setUsername\"회원1\";\nEntityManager entityManager = entityManagerFactory.createEntityManager;\nentityManager.getTransaction.begin;\n// 객체를 저장한 상태 영속\nentityManager.persistmember;  //이떄 쿼리가 날라가지 않는다.\n\n\n 3. 준영속detached  \n: 영속성 컨텍스트에 저장되었다가 분리된 상태  \njava\n//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태\nem.detachmember;\n\n 4. 삭제removed  \n: 삭제된 상태  \njava\n//객체를 삭제한 상태삭제 이는 DB에서도 삭제가 된다.\nem.removemember;\n\n\n 영속성 컨텍스트 장점\n\n 1차 캐시\n- 한 트랜잭션 내에서만 사용 가능하다. 즉 트랜잭션이 종료되면 사라진다.\n- JPA에서는 조회시 영속성 컨텍스트를 먼저 조회한다.\n<img align=center width=450px src=./img/1st-cash.png>\n\njava\nMamber member = new Mamber;\nmember.setId\"member1\";\nmember.setUsername\"회원 1\";\n\n//1차 캐시에 저장\nem.parsistmember;\n//1차 캐시에서 조회\nMember findMember = em.findMemeber.class, \"member1\"\n\n<img align=center width=450px src=./img/1st-cash-db.png>\n\njava\nMember findMember2 = em.findMember.class, \"member2\";\n\n\n 동일성identity보장\n- 1차 캐시로 반복 가능한 읽기REPEATABLE READ 등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공 한다.\n- 같은 트랜잭션 내에서만 동일성을 보장한다.\njava\nMember a = em.findMember.class, \"member1\";\nMember b = em.findMember.class, \"member1\";\n\nSystem.out.printlna == b; //동일성 비교 true\n\n\n 트랜잭션을 지원하는 쓰기 지연 - transactional write-behind\n- JPA는 commit을 하기 전까지 insert query를 날리지 않아 최적화할 여지를 준다.\n- 그래서 버퍼링 같은 기능을 한다. 쿼리를 모았다가 한 번에 날린다.\n<p float=left>\n<img width=400px src=./img/persist-lazy.png>\n<img width=400px src=./img/persist-lazy-commit.png>\n</p>\n\n\njava\nEntityManager em = emf.createEntityManager;\nEntityTransaction tx = em.getTransaction;\n\n//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.\ntx.begin; // 트랜잭션 시작\nem.persistmemberA;\nem.persistmemberB;\n\n//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.\n//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.\ntx.commit; // 트랜잭션 커밋\n\n 변경 감지Dirty Checking\n<img width=450px src=./img/dirty-checking.png>\n\n1. 커밋된 시점에서 내부적으로 flush가 호출된다.\n2. 1차 캐시의 스냅샷과 entity를 비교하여 객체가 변경되었는지 비교한다.\n3. 2번에서 변경사항이 나오면 쓰기 지연 SQL 저장소에 쿼리를 미리 만들어 저장한다.\n4. DB에 update query를 반영한다.\n5. DB에 commit 한다.\njava\nEntityManager em = emf.createEntityManager;\nEntityTransaction tx = em.getTransaction;\ntx.begin; // 트랜잭션 시작\n\n// 영속 엔티티 조회\nMember memberA = em.findMember.class, \"memberA\";\n\n// 영속 엔티티 데이터 수정\nmemberA.setUsername\"hi\";\nmemberA.setAge10;\n\n/ \n/ em.updatemember 이런 코드가 있어야 하지 않을까?\n/ Dirty Checking덕분에 안해도 된다.\n/\n\ntx.commit; // 트랜잭션 커밋\n\n\n Entity 삭제\njava\n//삭제 대상 엔티티 조회\nMember memberA = em.findMember.class, \"memberA\";\nem.removememberA; //엔티티 삭제",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Servlet",
    "url": "/back-end/2022/03/19/servlet/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": Java를 이용하여 웹페이지를 동적으로 생성하는 server side 프로그램이다.\n> 웹 프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 규현 규칙을 지킨 자바 프로그래밍 기술\n- 서블릿은 자바 기반의 CGI 프로그램이며 CGI 규칙에 따라 웹 서버와 데이터를 주고받는다.\n- 자바를 사용하여 웹...",
    "content": "Servlet\n: Java를 이용하여 웹페이지를 동적으로 생성하는 server side 프로그램이다.\n> 웹 프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 규현 규칙을 지킨 자바 프로그래밍 기술\n- 서블릿은 자바 기반의 CGI 프로그램이며 CGI 규칙에 따라 웹 서버와 데이터를 주고받는다.\n- 자바를 사용하여 웹을 만들기 위해 필요한 기술이다.\n- javax.Servlet.http.HttpServlet 클래스를 상속받아 사용한다.\n\n 웹 어플리케이션의 실행 과정\n<img width=500px src=\"/assets/images/posts/back-end/web-application-run-process.png\">\n\n1. 웹 브라우저가 웹 서버에게 요청을 전송한다.\n2. 웹 서버는 클라이언트가 요청한 프로그램을 찾아서 실행한다.\n3. 해당 프로그램은 작업을 수행한 후 그 결과를 웹 서버에게 돌려준다.\n4. 웹 서버는 그 결과를 HTTP 형식에 맞춰 웹 브라우저에게 보낸다.\n\n이때 웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGICommon Gateway Interface라고 한다.\n\n웹 서버에 의해 실행되며 CGI 규칙에 따라 웹 서버와 데이터를 주고받도록 작성된 프로그램을 CGI 프로그램이라 한다.  \n\n Servlet의 특징\n- 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트\n- Java Threed를 이용하여 동작한다.\n- MVC 패턴에서 controller로 이용한다.\n- HTTP 프로토콜 서비스를 지원하는 javax.Servlet.http.HttpServlet 클래스를 상속받는다.\n- UDP보다 처리 속도가 느리다.\n- HTML 변경 시 Servlet을 재 컴파일해야한다.\n\n Servlet의 장점\n- threed를 이용하여 요청을 처리하므로 빠르다.\n- 플랫폼에 독립적이다. JAVA의 JVM\n- 보안Servlet Container\n\n Servlet동작 과정\n<img width=650px src=\"/assets/images/posts/back-end/servlet-process.png\">\n\n 1. 사용자의 요청\n: 사용자가 웹서버에 요청을 전달한다.  \n   &rarr; 만약 Servlet에 대한 요청인 경우 WAS에 요청을 전달한다.\n\n 2. Web Container에서 request, response객체 생성\n: Web Container는 사용자의 요청에 대한 HttpServletRequest 객체와, HttpServletResponse 객체를 생성한다.\n\n 3. 사용자 요청처리\n1. Web Container에서 배포서술자web.xml를 참조하여 사용자가 요청한 URL이 어떤 Servlet에 mapping되는지 찾는다.\n\n2. 사용자가 요청한 Servlet이 이전에 요청된적 없다면 객체를 생성한후 init 호출후 메모리에 로드한다.  \n   if 이전에 객체를 생성한 적이 있으면 다시 생성하지 않는다.\n3. Web Container에서 사용자의 요청을 처리할 Threed를 처리한다.\n4. Threed가 생성된 후 해당 Threed를 통해 Servlet의 service를 실행한다.\n5. service 에서 사용자의 요청 HTTP method에 따라 doGet, doPost, doPut, doDelete가 호출된다.  \n   &rarr; 앞에서 생성한 HttpServletRequest, HttpServletResponse 객체를 Tomcat에 의해 인수로 전달받는다.\n\n 4. 응답\n: doGet 또는 doPost 등. 을 호출되어 사용자 요청에 따른 페이지를 생성한 뒤  \n그것이 담긴 HttpServletResponse객체를 Web Container에서 HTTP Response로 바꾸어 Web Server에 전송한다.\n\n 5. 소멸\n1. HttpServletRequest, HttpServletResponse 객체를 소멸시킨다.\n2. Threed를 종료시킨다.\n\n HttpServletRequest\n> 사용자가 요청시 HttpServletResponse와 함께 웹컨테이너에서 자동으로 생성해준다\n- 사용자의 요청과 관련된 정보파라미터와 동작을 가지고 있는 객체\n- Servlet의 service 인자로 넘겨준다.\n\n 주요 기능\n- 요청 파라미터 조회\n- 사용자가 전달한 session 정보가 담겨있는 session 객체 조회\n- Request scope범위 안에 존제하는 component간 공유 데이터 조회\n\n HttpServletResponse\n> 사용자가 요청시 HttpServletRequest와 함께 웹컨테이너에서 자동으로 생성해준다\n- 동일 정보와 동작을 가지고있는 객체\n- Servlet의 service 인자로 넘겨준다.\n\n 주요 기능\n- 다른 페이지로 Redircet\n- Response Header정보 설정\n- 쿠키저장\n\n Life cycle\n1. Servlet 객체 생성은 최초 1회 이루어진다.\n2. init Servlet 초기화 또한 최초 1회만 이루어진다.\n3. service 는 특정 HTTP 요청GET, POST 등을 처리하는 메서드 doGet, doPost 등를 호출한다.\n4. 서버는 destroy를 호출하여 Servlet을 제거한다.  \n   &rarr; 자원을 해제할때, Servlet이 수정되어 대시 메모리에 로딩해야 하는 경우, 서버가 종료될때\n\n Servlet Container\n: 구현되어 있는 Servlet클레스를 규약에 맞게 Servlet을 관리해주는것\n\n서버에 만들어진 Servlet이 스스로 작동하는 것이 아니라, Servlet을 관리 해주는 것이 필요한데, 이러한 역할을 하는 것이 바로 Servlet Container 이다.\n\n즉 Servlet을 '요구사항 명세서'라고 표현하면, Servlet container는 그 명세서를 보고 개발하는 '개발자' 이다.  \n\n클라이언트의 요청Request을 받아주고 응답Response할 수 있게, 웹서버와 소켓으로 통신한다.  \n\n대표적으로 tomcat이 있다.  \n\n<img width=600px src=\"/assets/images/posts/back-end/servlet-container.png\">\n\n1. 일반적으로 사용자는 서버에서 오직 정적인 웹페이지만을 요청할 수 있다.\n2. 만약 사용자가 본인의 입력을 기초로한 웹페이지를 자유롭게 얻고 싶다면 이 방법은 제한적이다.\n3. Servlet Container는 server side에서 동적으로 웹페이지를 생성하기 위해 Java를 사용한다.\n4. 때문에 웹서버와 서블릿들이 상호작용할 때 서블릿 컨테이너는 필수적이다.\n\n Servlet Container의 역활\n 1. 웹서버와의 통신 지원\nServlet과 Web서버가 쉽게 통신할 수 있게 한다.\n- 일반적으로 소켓을 만들고 listen, accept 등을 해야하지만 Servlet Container는 이러한 기능을 API로 제공한다.\n- 개발자가 Servlet에 구현해야할 비즈니스 로직에 대해 집중할 수 있도록 도와준다.\n\n 2. 서블릿 생명주기Life Cycle 관리 \n서블릿의 생명주기를 관리한다.\n1. Servlet 클래스를 로딩하여 인스턴스화\n2. 초기화 메소드를 호출 \n3. 요청이 들어오면 적절한 서블릿 메소드를 호출\n4. Servlet 소멸 시 Garbage Collection 진행\n\n 3. 멀티쓰레드 지원 및 관리 \n다중 쓰레드를 생성 및 운영을 관리한다.\n1. Servlet Container는 요청이 올 때 마다 새로운 Java threed 하나 생성\n2. HTTP 서비스 메소드를 실행하고 나면, threed는 자동으로 소멸\n3. 원래는 threed를 관리해야 하지만 서버가 multi threed를 생성 및 운영해준다  \n   &rarr; 안정성에 대해 걱정하지 않아도 된다.\n\n 4. 선언적인 보안 관리\n- 개발자는 보안에 관련된 내용을 Servlet 또는 Java 클래스에 구현해 놓지 않아도된다.\n- 보안관리는 XML 배포 서술자에 기록하므로 자바 소스코드를 수정하여 다시 컴파일 하지 않아도 보안관리가 가능하다.\n\n 웹 서버와 Servlet Container의 요청을 처리\n<img width=500px src=\"/assets/images/posts/back-end/web-server-servlet-container.png\">\n\n1. 웹서버가 HTTP 요청을 받는다\n2. 웹서버는 요청을 Servlet Container로 전달한다.\n3. Servlet이 Container에 없다면, Servlet을 동적으로 검색하여 컨테이너의 주소 공간에 로드한다.\n4. 컨테이너가 서블릿의 init 메소드를 호출하면, 서블릿이 초기화된다.  \n   서블릿이 처음 로드됬을 때 한번만 호출\n5. 컨테이너가 서블릿의 service 메소드를 호출하여 HTTP 요청을 처리한다.  \n   요청의 데이터를 읽고, 응답을 만들어낸다\n6. 웹서버는 동적으로 생성된 결과를 올바른 위치에 반환한다.\n\n 이 과정에서 JVM의 역활\n- 각 요청들을 \"분리된 threed\" 내부에서 처리한다.  \n Servlet을 사용하는것은 JVM이 각 요청을 분리된 자바 threed 내부에서 처리하도록 하는것이다.  \n- 각 서블릿은 HTTP 요청에 응답하는 특정한 요소들이 있는 자바 클래스이다.\n- 서블릿 컨테이너는 하나의 JVM에서 동작하지만 컨테이너가 여러개의 JVM들을 필요로하는 문제들이 존재하기도 한다.",
    "tags": [
      "java-ee",
      "TIL"
    ]
  },
  {
    "title": "다양한 연관관계 매핑(실전)",
    "url": "/back-end/2022/03/19/다양한-연관관계-매핑실전/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "실습 repo: https://github.com/siwony/HelloJPA/tree/variousRelationshipMapping03",
    "content": "실습 repo: https://github.com/siwony/HelloJPA/tree/variousRelationshipMapping_03\n 다양한 연관관계 매핑실전\n 엔티티 - 배송, 카테고리 추가\n<img width=450px src=./img/various-relationship-mapping-entity.png>\n\n ERD\n<img width=450px src=./img/various-relationship-mapping-erd.png>\n\n N:M 관계는 1:N, N:1로\n: 테이블의 N:M 관계는 중간 테이블을 이용하여 1:N, N:1\n- 실전에서 중간 테이블은 단순하지 않다.\n- @ManyToMany는 제약: 필드 추가 x, 엔티티 테이블 불일치\n- 실전에서는 @ManyToMany 사용하지 말자.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Plugin-not-found 해결방법",
    "url": "/back-end/2022/03/19/plugin-not-found-해결방법/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "어느날 intellij에서 maven 기반 SpringBoot 프로젝트를 하고있었는데 다음과 같은 에러가 났다.",
    "content": "Plugin-not-found 해결방법\n어느날 intellij에서 maven 기반 SpringBoot 프로젝트를 하고있었는데 다음과 같은 에러가 났다.\n\n<img width=550px src=\"/assets/images/posts/back-end/plugin-not-found.png\">\n\n 원인 및 해결\n위에 이미지 처럼 오류가나면 Maven plugin의 버전이 명시가 되지 않아서 나는 에러이다.\nxml\n    <build>\n        <plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t\t<version>2.4.2</version> //여기!!!!\n\t\t\t\t<configuration>\n\t\t\t\t\t<excludes>\n\t\t\t\t\t\t<exclude>\n\t\t\t\t\t\t\t<groupId>org.projectors</groupId>\n\t\t\t\t\t\t\t<artifactId>lombok</artifactId>\n\t\t\t\t\t\t</exclude>\n\t\t\t\t\t</excludes>\n\t\t\t\t</configuration>\n\t\t\t</plugin>\n        </plugins>\n    </build>\n\n다음과같이 version을 명시해 주면 해결된다.",
    "tags": [
      "maven",
      "TIL",
      "build-tool"
    ]
  },
  {
    "title": "HTTP POST 메서드와 Content-Type",
    "url": "/back-end/2022/03/19/http-post-메서드와-content-type/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "Spring Boot를 사용해 API서버를 만들면 POST메서드를 통해 요청을 받을 때 body에 JSON형태로 통신한다는 전제로 개발을 하게 된다.  ",
    "content": "HTTP POST 메서드와 Content-Type\nSpring Boot를 사용해 API서버를 만들면 POST메서드를 통해 요청을 받을 때 body에 JSON형태로 통신한다는 전제로 개발을 하게 된다.  \n\n하지만, JSON 형태가 아닌 다른 형식으로 클라이언트에서 요청을 보내야 할 때가 있다.  \n파일을 전송하거나 파일과 데이터를 함께 전송하고 싶으면 multipart/form-data 형식으로 요청하고,  \nPOST 형식에서 QueryString 형태로 body에 값을 전송하고 싶다면 application/x-www-form-urlencoded 형식으로 요청한다.\n\n multipart/form-data\n각각의 데이터를 구분하는 boundary와 데이터를 구분하는 boundary 사이에 데이터와 데이터를 구분하는 Content-Type이 필수적으로 있는 요청 방식\n\n요청 예시\nhttp\nPOST /foo HTTP/1.1\nContent-Length: 68137\nContent-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"description\"\n---------------------------974767299852498929531610575\n\nsome text\n\n---------------------------974767299852498929531610575\nContent-Disposition: form-data; name=\"myFile\"; filename=\"foo.txt\"\nContent-Type: text/plain\n\ncontent of the uploaded file foo.txt\n\n---------------------------974767299852498929531610575--\n\n\n application/x-www-form-urlencoded\n&로 분리되고, = 기호로 키와 값을 연결하는 key-value tuple로 인코딩되는 형식의 요청 방식\n\n예시\nhttp\nPOST / HTTP/1.1\nHost: foo.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 13\n\nsay=Hi&to=Mom\n\n\n 이 문서를 정리하게 된 동기\n@RequestBody를 통해 특정 API에서 데이터를 받을 때 Content-Type이 application/x-www-form-urlencoded인 요청받았다면 다음과 같은 에러가 발생한다.\njson\n{\n    \"timestamp\": \"2021-11-30T14:01:38.862+00:00\",\n    \"status\": 415,\n    \"error\": \"Unsupported Media Type\",\n    \"trace\": \"org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'multipart/form-data;boundary=--------------------------626757645175388487558235;charset=UTF-8' not supported\\n\\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConvertersAbstractMessageConverterMethodArgumentResolver.java:206\\n\\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConvertersRequestResponseBodyMethodProcessor.java:160 ...\",\n    \"message\": \"Content type 'multipart/form-data;boundary=--------------------------626757645175388487558235;charset=UTF-8' not supported\",\n    \"path\": \"/board/write\"\n}\n\n이 문서는 위와 같은 에러를 겪고 Content-Type의 개념과 Content-Type 별 요청을 어떻게 처리해야 하는지 궁금하게 되었고 이를 공부한 후 작성한 글이다. \n\n applicationx-www-form-urlencoded Content-Type의 데이터를 받는 방법\n 1. @RequestParam\n> 지저분한 방법이라 3번을 사용하는 것을 추천한다.\njava\n@PostMappingvalue = \"signup\"\npublic String upload@RequestParam String email,\n                        @RequestParam String password {\n\n    return \"응애\";\n}\n\n\n 2. @RequestBody MultiValueMap<K, V>\nMultiValueMap과 함께 @RequestBody를 사용하면 AnnotationMethodHandlerAdapter에 의해 FormHttpMessageConverter가 등록하게 된다.\n\njava\n@PostMapping\"signup\"\npublic String upload@RequestBody MultiValueMap<String, String> data { \n    log.info\"MultiValueMap<String, String>: {}\", data;\n    return data.toString;\n}\n\nContent-Type은 application/x-www-form-urlencoded이고 /signup에 name=siwony&password=1234 이렇게 요청을 보내면 다음과 같이 로깅이 되어 출력된다.\nsh\nMultiValueMap<String, String>: {email=siwon103305@gmail.com, password=siwon}\n\nMultiValueMap은 Map<K, List<V>>을 상속받고 있다. 이유는 \n\n 3. @ModelAttribute\n커맨드 객체command-object.md와 함께 @ModelAttribute를 사용하면 2번과 같이 FormHttpMessageConverter가 등록되어 해당 객체로 바인딩 할 수 있다.\n- @ModelAttribute는 생략 가능하다.\njava\n@PostMapping\"signup\"\npublic String upload@ModelAttribute MemberDto memberDto { \n    log.info\"MultiValueMap<String, String>: {}\", memberDto;\n    return data.toString;\n}\n\n\n// MemberDto\n@Getter @NoArgsConstructor  // Getter와 기본생성자는 무조건 존재해야 한다.\npublic class MemberDto{\n    private String email;\n    private String password;\n}\n\n\n multipart/form-data의 데이터를 받는 방법\n\n 1. @RequestParam\n지저분한 방법이라 2번을 사용하는 것을 추천한다.\n\n예시\njava\n@PostMappingvalue = \"signup\"\npublic String upload@RequestParam String email,\n                    @RequestParam String password,\n                    @RequestParam Multipart img {\n    return \"응 그래\";\n}\n\n\n 2. @ModelAttribute \napplicationx-www-form-urlencoded Content-Type의 데이터를 받는 방법이랑 똑같이 인자에  \n@ModelAttribute + 커맨드객체 와 같은 방법으로 사용한다.  \n하지만 요청시 데이터를 받아 바운딩 할 객체에는 다음 예시와 같이 MultipartFile객체가 존재해야된다.\n\n 올바른 예시\njava\n// controller\n@PostMapping\"signup\"\npublic String login@ModelAttribute MemberDto memberDto { \n    log.info\"MultiValueMap<String, String>: {}\", memberDto;\n    return data.toString;\n}\n\n============================================================\n\n// MemberDto\n@Getter @NoArgsConstructor  // Getter와 기본생성자는 무조건 존재해야 한다.\npublic class MemberDto{\n    private String email;\n    private String password;\n    private MultipartFile img;\n}\n\n만약 위 예시의 MultipartFile타입의 img맴버 변수가 없을 경우 해당 요청의 Content-Type은 applicationx-www-form-urlencoded로 판단하고 415에러가 발생한다.\n\n이는 @PostMapping의 consumes속성에 application/x-www-form-urlencoded를 지정하면 된다.\n> 하지만 구지 file데이터를 받지 않는데 multipart/form-data를 사용해야 하는 이유가 있을까?\n\n consumes속성을 바꾼 예시\njava\nimport org.springframework.http.MediaType;\n\n// class 선언 생략\n\n@PostMappingvalue = \"signup\", consumes = MediaType.MULTIPART_FORM_DATA_VALUE\npublic String login@ModelAttribute MemberDto memberDto {\n    log.info\"MemberDto: {}\", memberDto;\n    return memberDto.toString;\n}",
    "tags": [
      "spring-mvc",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Spring Security Authentication",
    "url": "/back-end/2022/03/19/spring-security-authentication/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": authenticated 가 true인 Authentication 객체를 SecurityContext 에 갖고 있는 상태를 말한다. 단 Authentication이 AnonymousAuthenticationToken 만 아니면 된다.",
    "content": "Spring Security Authentication\n\n Spring Security에서의 로그인\n: authenticated 가 true인 Authentication 객체를 SecurityContext 에 갖고 있는 상태를 말한다. 단 Authentication이 AnonymousAuthenticationToken 만 아니면 된다.\n로그인 == Authenticationauthenticated = true only if Authentication != AnonymousAuthenticationToken\n\n Spring Security Authentication 인증의 기본 구조\n: 필터들 중에 일부 필터는 인증 정보에 관여한다. 이들 필터가 하는 일은 AuthenticationManager 를 통해 Authentication 을 인증하고 그 결과를 SecurityContextHolder 에 넣어준다.  \n<img width=450px src=./img/security-authentication-architecture.png>\n\n 인증 토큰Authentication Token을 제공하는 필터들\n- UsernamePasswordAuthenticationFilter : 폼 로그인 -> UsernamePasswordAuthenticationToken\n- RememberMeAuthenticationFilter : remember-me 쿠키 로그인 -> RememberMeAuthenticationToken\n- AnonymousAuthenticationFilter : 로그인하지 않았다는 것을 인증함 -> AnonymousAuthenticationToken\n- SecurityContextPersistenceFilter : 기존 로그인을 유지함기본적으로 session 을 이용함\n- BearerTokenAuthenticationFilter : JWT 로그인\n- BasicAuthenticationFilter : ajax 로그인 -> UsernamePasswordAuthenticationToken\n- OAuth2LoginAuthenticationFilter : 소셜 로그인 -> OAuth2LoginAuthenticationToken, OAuth2AuthenticationToken\n- OpenIDAuthenticationFilter : OpenID 로그인\n\n- Authentication 을 제공Provide 하는 인증제공자는 여러개가 동시에 존재할 수 있고, 인증 방식에 따라 ProviderManager 도 복수로 존재할 수 있습니다.\n\n Authentication의 정보\n: Authentication는 안터페이스로 아래와 같은 정보를 가지고 있다.\n\n- Set<GrantedAuthority> authorities : 인증된 권한 정보\n- principal : 인증 대상에 관한 정보. 주로 UserDetails 객체가 옴\n- credentials : 인증 확인을 위한 정보. 주로 비밀번호가 오지만, 인증 후에는 보안을 위해 삭제함.\n- details : 그 밖에 필요한 정보. IP, 세션정보, 기타 인증요청에서 사용했던 정보들.\n- boolean authenticated : 인증이 되었는지를 체크함.",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "연관관계가 필요한이유",
    "url": "/back-end/2022/03/19/연관관계가-필요한이유/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "연관관계가 없는 객체",
    "content": "연관관계가 필요한이유\n 객체를 테이블에 맞추어 모델링\n연관관계가 없는 객체\n\n<img width=450px src=./img/non-object-relationship.png>\n\n 객체를 테이블에 맞춰 모델링\n참조 대신 외래 키를 그대로 사용\njava\n@Entity\npublic class member{\n\n    @Id @GeneraterValue\n    private Long id;\n\n    @Columnname = \"USERNAME\" \n    private String name;\n\n    @Columnname = \"TEAM_ID\"\n    private Long teamId;\n\n}\n@Entity\npublic class Team{\n    @Id @GeneratedValue \n    private Long id; \n    private String name;\n    //etc.....\n}\n\n\n 외래키 식별자를 그대로 다룬다.\njava\n//팀 저장\nTeam team = new Team;\nteam.setName\"TeamA\"; em.persistteam;\n\n//회원 저장\nMember member = new Member;\nmember.setName\"member1\";\nmember.setTeamIdteam.getId; \nem.persistmember;\n\n\n 식별자로 다시 조회하므로 객체지향적인 방법이 아니다.\njava\n//조회\nMember findMember = em.findMember.class, member.getId;\n//연관관계가 없음\nTeam findTeam = em.findTeam.class, team.getId;\n\n 연관관계가 필요한 이유\n- 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다.\n  \n- 객체는 참조를 사용하여 연관된 객체를 찾는다.\n- 서로 데이터를 저장하는 방식이 다르다.  \n&rarr; 즉, 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.\n\n\n 단방향 연관관계 \n 객체 지향 모델링\n ORM Mapping\n<img width=450px src=./img/object-oriented-modling.png>\n\n 객체의 참조와 테이블의 외래 키를 매핑\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n\n    @Columnname = \"USERNAME\" \n    private String name; \n\n    @ManyToOne\n    @JoinColumnname = \"TEAM_ID\"\n    private Team team; \n    // etc...\n\n\n 연관관계 저장 연관관계 저장\njava\n//팀 저장\nTeam team = new Team;\nteam.setName\"TeamA\"; \nem.persistteam;\n\n//회원 저장\nMember member = new Member; \nmember.setName\"member1\";\nmember.setTeamteam; //단방향 연관관계 설정, 참조 저장 em.persistmember;\n\n\n 객체 그래프 탐색\n> 참조로 연관관계 조회한다.\njava\n//조회\nMember findMember = em.findMember.class, member.getId;\n//참조를 사용해서 연관관계 조회\nTeam findTeam = findMember.getTeam;\n\n 연관관계 수정\njava\n\n// 새로운 팀B\nTeam teamB = new Team; \nteamB.setName\"TeamB\"; \nem.persistteamB;\n\n// 회원1에 새로운 팀B 설정 member.setTeamteamB;\nmember.setTeamteamB;\n\n 양방향 연관관계\n<img width=450px src=./img/bidirectional-mapping.png>\n\n- 테이블은 외래키만 있으면 서로 관계를 알 수 있다 &rarr; 애초에 양방향이라는 개념이 없다.\n- 객체는 각각 참조하는 객체를 세팅해줘야 한다.\n 1. 객체 지향 모델링\n Team 엔티티에 컬렉션 추가\njava\n@Entity\npublic class Team{\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n\n    //반대편MEMBER에team 변수로 매핑된다. 연관관계의 주인은 반대편MEMBER.team이다.\n    @OneToManymappedBy = \"team\"\n    List<Member> mebmers = new ArrayList<Member>;\n}\n\n  반대 방향으로 객체 그래프 탐색\njava\n//조회\nTeam findTeam = em.findTeam.class, team.getId;\n//역방향 조회\nint memberSize = findTeam.getMembers.size;\n\n\n 2. 객체와 테이블이 관계를 맺는 차이\n<img width=450 src=./img/difference-of-obejct-and-table.png>\n\n- 객체는 연관관계가 2개이다.\n    - 회원 &rarr; 팀 연관관계 1개단방향\n    - 팀 &rarr; 회원 연관관계 1개단방향\n- 테이블은 연관관계가 1개이다.\n    - 회원 &harr; 팀의 연관 관계 1개양방향\n        > 애초에 Table은 양방향이라는 개념이 존재하지 않는다.\n\n 3. 객체의 양방향 관계\n- 객체의 양방향 관계는 사실 서로 다른 방향 관계 2개이다.\n- 객체를 양방향으로 참조하려면 단방향 2개를 만들어야 한다.\n\n    예시\n    - A &rarr; B a.getB\n    - B &rarr; A b.getA\n    java\n    class A{\n        B b;\n    }\n    class b{\n        A a;\n    }\n    \n 4. 테이블의 양방향 관계\n- 외래키 하나로 두 테이블의 연관관계 관리\n- MEMBER.TEAM_ID 기본키 하나로 연관관계를 맻는다 &rarr; 양쪽으로 조인할 수 있다.\n\nsql\nSELECT \nFROM MEMBER M\nJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\n\nSELECT \nFROM TEAM T\nJOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID\n\n\n 5. 연관관계의 주인Owner\n> 양방향 매핑은 둘 중 하나로 외래키를 관리해야 한다.\n\n1. 양방향 매핑 규칙\n- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정\n- 연관관계의 주인만이 외래 키를 관리등록, 수정\n- 주인이 아닌쪽은 읽기만 가능하다. &rarr; 조회만 가능하다.\n- 주인은 MappedBy 속성 사용 x \n\n2. 주인을 누구로?  \n: 외래키가 있는 곳을 주인으로 정한다.\n- 여기서는 Member.team이 연관관계의 주인이다.\n- 주로 N다 쪽이 연관관계의 주인이 된다.  \n- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안 된다.\n\n<img width=450px src=./img/who-is-owner.png>\n\n 6. 양방향 연관관계에서 많이 하는 실수\n 연관관계의 주인에 값을 입력하지 않았다 &rarr; 역방향\njava\nTeam team = new Team; \nteam.setName\"TeamA\"; \nem.persistteam;\n\nMember member = new Member;\nmember.setName\"member1\"\n\n//역방향주인이 아닌 방향만 연관관계 설정 \nteam.getMembers.addmember;\n\nem.persistmember;\n\n|ID|USERNAME|TEAM_ID|\n|--|--------|-------|\n|1| member1 | null|\n\n 양방향 매핑시 연관관계의 주인의 값을 입력해야 한다.\n&rarr; 순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야 한다.\n- 그렇지 않으면 객체지향 스럽지 않다.\n\n- 양쪽에 값이 세팅되어있지 않으면 한 객체에는 값이 존재하지만,  \n 반대쪽 객체에는 값이 없는 대참사가 일어난다.  \n    &rarr; 나중에 테스트할 때 Empty 나 null 등 이상하게 값을 가져온다.\njava\nTeam team = new Team; \nteam.setName\"TeamA\"; \nem.persistteam;\n\nMember member = new Member;\nmember.setName\"member1\";\n\n\nteam.getMembers.addmember; //연관관계의 주인에 값 설정\nmember.setTeamteam; \nem.persistmember;\n\n|ID|USERNAME|TEAM_ID|\n|--|--------|-------|\n|1| member1 | 2|\n\n 7. 양방향 연관관계의 주의점\n- 순수 객체 상태를 고려해서 항상 양쪽에 값을 세팅하자.\n- 연관관계 편의 매서드를 생성하자.추천\n    java\n        public class Member{\n            //etc,,,\n\n            public void setTeamTeam team{\n                this.team = team;\n                test.getMembers.addthis;\n            }\n\n            //etc,,,\n        }\n    \n    - setTeam 같은 네이밍보다 changeTeam같은 네이밍을 권장한다.  \n    &rarr; 뭔가 중요한 로직이구나 라는 것을 알아차리기 위해\n    - 한 개만생성하자 &rarr; 두객체중 아무곳이나 만들어도 된다.\n- 무한루프를 조심하자.  \n    ex toString, lombok, JSON 생성라이브러리\n    - lombok에서 toString 생성 쓰지마라\n    - Controller에 절대로 Entity를 반환하지 마라 &rarr; DTO로 변환하여 반환한다.\n\n 양방향 연관관계 정리\n- 단방향 매핑만으로 이미 연관관계 매핑은 완료됐다.  \n    &rarr; 기본적으로 단방향 매핑으로 다 끝내자\n\n- 양방향 매핑은 객체 그래프 탐색 기능이 추가된 것뿐이다.\n- JPQL에서 역방향으로 탐색할 일이 많다\n- 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다 &rarr; 테이블은 변화가 없다.\n- 양방향 연관관계는 그렇게 이득이 되는 것은 없다. &rarr; 걱정거리만 늘어난다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "@Autowired를 이용한 필드주입 보다 생성자 주입을 해야하는가?",
    "url": "/back-end/2022/03/19/autowired를-이용한-필드주입-보다-생성자-주입을-해야하는가/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 순환참조 오류의 방지순환참조-오류의-방지\n    - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않는다.\n- 테스트 코드 작성의 편리\n    - 단순 POJO를 이용한 테스트 코드를 만들 수 있다.\n        > 필드 주입은 Spring DI container없이 의존성을 넣어 줄 방법이 없다. ~~리플렉션 쓰면 가능 할 수도?~~\n    - ...",
    "content": "@Autowired를 이용한 필드주입 보다 생성자 주입을 해야하는가?\n 요약\n- 순환참조 오류의 방지순환참조-오류의-방지\n    - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않는다.\n- 테스트 코드 작성의 편리\n    - 단순 POJO를 이용한 테스트 코드를 만들 수 있다.\n        > 필드 주입은 Spring DI container없이 의존성을 넣어 줄 방법이 없다. ~~리플렉션 쓰면 가능 할 수도?~~\n    - 필수 의존성을 명시할 수 있다.\n- 좀더 좋은코드를 작성할 수 있다.\n- immutable 하다.\n    - 실행 중에 객체가 변하는 것을 막을 수 있다.  \n    - 오류를 사전에 방지할 수 있다.\n\n 순환참조 오류의 방지\n개발을 하다보면 보통 여러 컴포넌트간의 의존성이 생긴다.  \n그중에서도 A가 B를 참조하고, B가 다시 A를 참조하는 순환 참조도 발생할 수 있다.  \n\nex 순환참조의 예  \njava\n@Service\npublic class MadPlayService {\n\n    // 순환 참조\n    @Autowired\n    private MadLifeService madLifeService;\n\n    public void sayMadPlay {\n        madLifeService.sayMadLife;\n    }\n}\n\n@Service\npublic class MadLifeService {\n    \n    // 순환 참조\n    @Autowired\n    private MadPlayService madPlayService;\n\n    public void sayMadLife {\n        madPlayService.sayMadPlay;\n    }\n}\n\n다음과 같은 코드는 서로가 서로를 참조 하고있다.  \n다음과 같이 CommandLineRunner 실험을 하면\njava\n@SpringBootApplication\npublic class DemoApplication implements CommandLineRunner {\n\n    @Autowired\n    private MadLifeService madLifeService;\n    @Autowired\n    private MadPlayService madPlayService;\n\n    @Override\n    public void runString... args {\n        madPlayService.sayMadPlay;\n        madLifeService.sayMadLife;\n    }\n\n    public static void mainString args {\n        SpringApplication.runDemoApplication.class, args;\n    }\n}\n\n구동은 정상적으로 되었지만 그 이후 run method 에서 실행을 하는 과정에서 에러가 생겼다.\njava\njava.lang.StackOverflowError: null\n\tat com.example.demo.GreetService.sayGreetGreetService.java:12 ~classes/:na\n\tat com.example.demo.HelloService.sayHelloHelloService.java:12 ~classes/:na\n\tat com.example.demo.GreetService.sayGreetGreetService.java:12 ~classes/:na\n\tat com.example.demo.HelloService.sayHelloHelloService.java:12 ~classes/:na\n\tat com.example.demo.GreetService.sayGreetGreetService.java:12 ~classes/:na\n\n즉 코드를 실행하기 전까지 오류가 발견되지 않는다는것이다.  \n다음은 생성자 주입을 통한 Injection 이다.\n\njava\n@Service\npublic class MadPlayService {\n    private final MadLifeService madLifeService;\n\n    public MadPlayServiceMadLifeService madLifeService {\n        this.madLifeService = madLifeService;\n    }\n\n    // 생략\n}\n\n@Service\npublic class MadLifeService {\n    private final MadPlayService madPlayService;\n\n    public MadLifeServiceMadPlayService madPlayService {\n        this.madPlayService = madPlayService;\n    }\n\n    // 생략\n}\n\n\n실행결과는 BeanCurrentlyInCreationException이 발생하여 애플리케이션이 구동조차 되지 않는다.\njava\nDescription:\nThe dependencies of some of the beans in the application context form a cycle:\n┌─────┐\n|  madLifeService defined in file ~~~/MadLifeService.class\n↑     ↓\n|  madPlayService defined in file ~~~/MadPlayService.class\n└─────┘\n\n실행결과의 차이가 나는이유는 생성자 주입 방법은 필드 주입이나 수정자 주입과는 빈을 주입하는 순서가 다르다.",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "B+Tree - B+트리",
    "url": "/cs/2022/03/19/btree---b트리/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "동작 방식은 B트리와 유사하나, 리프노드는 연결리스트의 형태를 띄어 선형 검색이 가능하다.",
    "content": "B+Tree - B+트리\n동작 방식은 B트리와 유사하나, 리프노드는 연결리스트의 형태를 띄어 선형 검색이 가능하다.\n\n> 실제 DB의 인덱싱은 B+트리로 이루어져 있다.\n\n\n B+Tree의 특징\n1. 모든 key, data가 리프노드에 모여있다.\n2. 모든 리프노드가 연결리스트의 형태를 띄고 있다.\n    > B트리는 옆에 있는 리프노드를 검사할 때, 다시 루트노드부터 검사해야 하지만 B+트리는 리프노드에서 선형탐식을 수행할 수 있어 시간복잡도가 굉장히 줄어든다.\n3. 리프노드의 부모 key는 리프노드의 첫번째 key보다 작거나 같다.\n\n\nB트리와 같이 M차 B+트리는 다음과 같은 특징을 갖는다.\n- 노드는 최대 M개 부터 M / 2개 까지의 자식을 가질 수 있다.\n- 노드에는 최대 M − 1개 부터 M / 2 − 1개의 키가 포함될 수 있다.\n- 노드의 키가 x개라면 자식의 수는 x+1개 이다.\n- 최소차수는 자식수의 하한값을 의미하며, 최소차수가 t라면 M=2t−1을 만족한다. \n  > 최소차수 t가 2라면 3차 B트리이며, key의 하한은 1개이다.",
    "tags": [
      "data-structure",
      "non-linear",
      "tree",
      "TIL"
    ]
  },
  {
    "title": "Bean",
    "url": "/back-end/2022/03/19/bean/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 컨테이너가 관리하는 Java객체이며, Spring Bean Container에 존재하는 객체를 말한다. \n- Spring IoCInversion of Control 컨테이너에 의해 인스턴스화, 관리, 생성된다.\n- Bean Container는 의존성 주입을 통해 Bean 객체를 사용할 수 있도록 해준다.",
    "content": "Bean\n: Spring IOCInversion Of Control컨테이너가 관리하는 Java객체이며, Spring Bean Container에 존재하는 객체를 말한다. \n- Spring IoCInversion of Control 컨테이너에 의해 인스턴스화, 관리, 생성된다.\n- Bean Container는 의존성 주입을 통해 Bean 객체를 사용할 수 있도록 해준다.\n\n Bean Scope\n빈이 존재할 수 있는 범위를 의미한다.\n\n<img width=600px src=./img/spring-bean-scope-table.png>\n\n 1. Singleton\nSingleton Bean은 Spring Container에서 한 번 생성되고 스프링 컨텍스트가 종료될 때 Distroy된다.\n\n싱글톤은 JVM을 실행하여 클래스 로드를 할 떄 처음 객체가 생성되는 것이 아닌 Spring Container에서 싱글톤으로 관리한다. 즉, 프로그래밍적인 싱글톤이 아니다.\n\n- Spring에서 기본이 된다.\n- 생성된 하나의 인스턴스는 single beans cache에 저장되고, 해당 bean에 대한 요청과 참조가 있으면 캐시된 객체를 반환한다.\n- XML 설정  \n    <bean id=\"...\" class=\"...\" scope=\"singleton\"></bean>\n- annotation 설정  \n    대상 클래스에 @Scope\"singletone\"\n<img width=650px src=./img/spring-bean-singleton.png>\n\n 2. Prototype\n- prototype bean은 모든 요청에서 새로운 객체를 생성하는 것\n- 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계주입, 초기화 까지만 처리한다.\n    > @PreDestory와 같은 종료 메서드를 호출하지 않는다. 자원 회수와 같은 처리는 프로토타입Bean을 요청한 클라이언트가 처리해야 한다.\n- XML 설정\n    XML\n    <bean id=\"...\" class=\"...\" scope=\"prototype\"></bean>\n    \n- annotation  \n    대상 클래스에 @Scope\"prototype\"\n<img width=650px src=./img/spring-bean-prototype.png>\n\n Bean 등록 방법\n 1. XML Spring\n: applicationContext.xml이라는 파일을 src/main/resources 폴더에 추가시킨 후 bean을 등록한다.\n> Java 코드를 이용한 Context 설정이 나오기 전 사용하던 방법이다.\n- class필수: 정규화된 자바 클래스 이름\n- id: bean의 고유 식별자\n- scope: 객체의 범위 sigleton, prototype\n- constructor-arg: 생성 시 생성자에 전달할 인수\n- property: 생성 시 bean setter에 전달할 인수\n- init method와 destroy method\nXML\n<!-- A simple bean definition -->\n<bean id=\"...\" class=\"...\"></bean>\n\n<!-- A bean definition with scope-->\n<bean id=\"...\" class=\"...\" scope=\"singleton\"></bean>\n\n<!-- A bean definition with property -->\n<bean id=\"...\" class=\"...\">\n\t<property name=\"message\" value=\"Hello World!\"/>\n</bean>\n\n<!-- A bean definition with initialization method -->\n<bean id=\"...\" class=\"...\" init-method=\"...\"></bean>\n\n 2. Java Configuration \n: @Configuration이라는 Annotation을 이용하여 XML 대신 Java로 Bean을 생성할 수 있다.\njava\n@Configuration\npublic class ApplicationConfig {\n    @Bean\n    public Car carEngine e {\n    \tCar c = new Car;\n    \tc.setEnginee;\n    \treturn c;\n    }\n\t\n    @Bean\n    public Engine engine {\n    \treturn new Engine;\n    }\n}\n\n1. 위 코드처럼 class에 @Configuration을 달고\n2. Bean으로 사용할 객체를 반환하는 메소드를 만들고\n3. @Bean이라는 어노테이션을 달면 반환된 객체가 Bean Container에 등록된다.\n\njava\npublic class ApplicationContextExam03 {\n    public static void mainString args {\n\t    // 클래스를 매개변수로 넣는다.\n\t    ApplicationContext ac = new AnnotationConfigApplicationContextApplicationConfig.class;\n\t\t\n\t    Car car = ac.getBeanCar.class;\n\t    car.run;\n    }\n}\n\n 3. @ComponentScan\n: Config 클래스에 @Configuration과 @ComponentScan을 같이 등록하면, 패키지 내의 @Bean, @Component , @Controller, @Service, @Repository로 등록된 클래스를 Classpath Scanning 타임에 Bean Container에 등록시켜 준다.\n\n등록방법  \n@Configuration을 이용하여 Bean 설정 파일XML 파일을 대체하는임을 알려주고, @ComponentScan을 이용해 빈으로 등록되기 위한 annotaction이 부여된 클래스들을 자동으로 IoC컨테이너에 등록한다.  \n\nApplicationConfig\njava\n@Configuration\n@ComponentScan\npublic class ApplicationConfig {}\n\nApplication\njava\npublic class Application {\n    public static void mainString args {\n        ApplicationContext context = new AnnotationConfigApplicationContextApplicationConfig.class;\n    }\n}\n\nAnnotaion을 기반으로 Bean들을 등록하기 위해서는 AnnotaionConfigApplicationContext를 이용해야 한다.  \n그리하여 AnnotationConfigApplicationContext의 매개변수로 Bean설정 클래스인 ApplicationConfig를 넘겨주었다.  \n\n범위\n- basePackages의 경우 괄호안에 직접 패키지경로를 직접 적어주어 스캔할 위치를 지정할 수 있다\njava\n@Configuration\n@ComponentScanbasePackages = \"com.mins.spring\"\npublic class ApplicationConfig {}\n\n이 경우 typesafe하지 않아 조금만 철자가 잘못되더라도 scan을 못하는 오류가 나타날 수 있다.\n\n- basePackageClasses 의 경우에는 괄호안에 적힌 Class가 위치한 곳에서부터 모든 어노테이션이 부여된 Class를 bean으로 등록해준다.\njava\n@Configuration\n@ComponentScanbasePackageClasses = Application.class\npublic class ApplicationConfig {}\n\nclass를 통해 기입하기 때문에 훨씬 Typesafe한 방법이다.",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Spring security 시작하자",
    "url": "/back-end/2022/03/19/spring-security-시작하자/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> Spring Security의 설정을 Java 코드로 할 수있다.",
    "content": "Spring security 시작하자\n\n 의존성 추가\n Maven\npom.xml\nxml\n<dependencies>\n  <!-- ... other dependency elements ... -->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n  </dependency>\n</dependencies>\n\n\n\n Gradle\nbuilde.gradle\ngradle\ndependencies {\n  compile \"org.springframework.boot:spring-boot-starter-security\"\n}\n\n\n Spring Security Configuration\n> Spring Security의 설정을 Java 코드로 할 수있다.\n\n다음과 같이 Security 설정은 커스텀 할 수 있다. 다음은 JWT인증을 구현한 Config이다.   \nrefernce: https://github.com/GSM-Web-Technology/Jup-Jup-Server/blob/main/src/main/java/com/gsm/jupjup/config/security/SecurityConfiguration.javaL23\njava\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configureHttpSecurity http throws Exception {\n        http\n                .cors.and\n                .httpBasic.disable // rest api 이므로 기본설정 사용안함. 기본설정은 비인증시 로그인폼 화면으로 리다이렉트 된다.\n                .csrf.disable // rest api이므로 csrf 보안이 필요없으므로 disable처리.\n                .sessionManagement.sessionCreationPolicySessionCreationPolicy.STATELESS // jwt token으로 인증할것이므로 세션필요없으므로 생성안함.\n                .and\n                .authorizeRequests // 다음 리퀘스트에 대한 사용권한 체크\n                .antMatchers\"//signin\", \"//signup\",\"/exception/\", \"//member/\", \"//logout\", \"//dev/\", \"//userinfo\".permitAll // 가입 및 인증 주소, 오류, 이메일 인증은 누구나 접근가능\n                .antMatchers\"//admin/\".hasRole\"ADMIN\" // admin으로 시작하는 요청은 관리자만 접근 가능\n                .anyRequest.authenticated // 그외 나머지 요청은 인증된 사용자만 접근 가능\n                .and\n                .exceptionHandling.accessDeniedHandlernew CustomAccessDeniedHandler //관리자 에러\n                .and\n                .exceptionHandling.authenticationEntryPointnew CustomAuthenticationEntryPointHandler //로그인 에러\n                .and\n                .addFilterBeforejwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class;  // jwt token 필터를 id/password 인증 필터 전에 넣음\n    }\n\n    @Override // ignore check swagger, h2 database resource\n    public void configureWebSecurity web {\n        web.ignoring.antMatchers\"/v2/api-docs\", \"/swagger-resources/\",\n                \"/swagger-ui.html\", \"/webjars/\", \"/swagger/\", \"/h2-console/\", \"/configuration/ui\";\n    }\n\n}\n\nhttp..httpBasic.disable를 지우면 로그인 폼으로 리다렉트 된다.",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "Software Development Life Cycle",
    "url": "/cs/2022/03/19/software-development-life-cycle/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 소프트웨어를 체계적으로 개발하고 관리하기 위해서 개발 과정을 단계별로 나누어 구분한것이다.\n> 모든 일에는 단계적인 계획이 필요하다. 배우거나 기획하거나 만들 때 차근차근 쌓아가야 안정적이다.",
    "content": "Software Development Life Cycle\n: 소프트웨어를 체계적으로 개발하고 관리하기 위해서 개발 과정을 단계별로 나누어 구분한것이다.\n> 모든 일에는 단계적인 계획이 필요하다. 배우거나 기획하거나 만들 때 차근차근 쌓아가야 안정적이다.\n\n\n 소프트웨어 생명주기\n- 1. 요구 분석1-요구-분석\n- 2. 시스템 명세2-시스템-명세\n- 3. 설계3-설계\n- 4. 구현 또는 개발4-구현-또는-개발\n- 5. 테스트5-테스트\n- 6. 유지 보수6-유지-보수\n\n 1. 요구 분석\n개발할 소프트웨어의 기능과 제약조건, 목표 등을 명확히 정의한다.\n- 문제를 분석하는 단계\n- 개발할 소프트웨어의 성격을 이해하고 개발 방법과 필요한 개발 자원이나 예산을 측정한다.\n\n 2. 시스템 명세\n시스템이 어떻게 동작하는지 정의\n- 입력 자료나 처리 내용, 생성되는 출력이 무엇인지 정의하는 단계.\n\n 3. 설계\n명세 단계 2단계에서 정의한 기능을 실제로 수행하기 위한 방법을 논리적으로 결정하는 단계.\n\n1. 시스템 구조 설계  \n 시스템을 구성하는 내부 프로그램이나 모듈간의 관계와 구조를 설계\n\n2. 프로그램 설계  \n: 프로그램 내의 각 모듈에서의 처리 절차나 알고리즘을 설계.\n\n3. 사용자 인터페이스 설계  \n: 시스템을 사용하는 사용자에게 보여지는 프로그램을 설계.\n\n\n 4. 구현 또는 개발\n: 프로그래밍 언어를 사용하여 실제로 프로그램을 작성하는 단계\n\n1. 구조화 프로그래밍  \n   : 지정문, 조건문, 반복문만 사용하여 3가지 제어 구조로 표현\n2. 모듈러 프로그래밍  \n   : 프로그램은 여러 개의 작은 모듈로 나누어 계층 관계를 갖도록 구성\n\n 5. 테스트\n개발한 프로그램을 테스트 하는 단계\n\n1. 단위 테스트  \n   : 시스템의 최소 구성 요소가 되는 모듈에 대해서 개별적으로 시행\n\n2. 통합 테스트  \n   : 단위 테스트를 통과한 모듈을 연결하여 전체 시스템으로 완성하여 통합적으로 시행하는 테스트\n\n3. 인수 테스트  \n   : 완성된 시스템을 인수하기 위해서 실제 자료를 사용한 최종 테스트\n   \n\n 6. 유지 보수\n시스템이 인수되고 설치된 후, 일어나는 모든 활동\n> 소프트웨어 생명 주기 단계에서 가장 오래 걸린다.\n1. 수정형 유지 보수  \n   : 사용중 발견한 프로그램의 오류 수정 작업\n\n2. 적응형 유지 보수  \n   : 시스템과 관련한 환경적 변화에 적응하기 위한 재조정 작업\n\n3. 완전형 유지 보수  \n   : 시스템의 성능을 향상 시키기 위한 개선 작업\n\n4. 예방형 유지 보수  \n   : 앞으로 발생할지 모를 변경사항을 수용하기 위한 대비 작업",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "GRASP",
    "url": "/cs/2022/03/19/grasp/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": General Responsibility Assignment Software Patterns의 약자로 \"일반적인 책임 할당 소프트웨어 패턴\" 이다.\n> GRASP는 상호작용하는 Object에 어떻게 Responsibilities를 할당하는 지에 대한 내용을 담고 있다고 할 수 있다.\n- Object-Oriented 디자인의 핵심은 각 객체에 책임을 부여...",
    "content": "GRASP\n: General Responsibility Assignment Software Patterns의 약자로 \"일반적인 책임 할당 소프트웨어 패턴\" 이다.\n> GRASP는 상호작용하는 Object에 어떻게 Responsibilities를 할당하는 지에 대한 내용을 담고 있다고 할 수 있다.\n- Object-Oriented 디자인의 핵심은 각 객체에 책임을 부여하는 것.\n- 책임을 부여하는 원칙들을 말하고 있는 패턴.\n- 구체적인 구조는 없지만, 철학을 배울 수 있다.\n- 총 9가지의 원칙을 가지고 있다.\n\n GOF와 GRASP의 차이점\n> 이 둘은 비교할 수 없지만 헷갈려서 정리해본다.\n- GOF는 디자인 패턴이지만, GRASP는 디자인 원칙이다.\n  > 디자인 원칙은 디자인 패턴보다 추상적이다.\n\n GRASP를 알기전에 알아야 할 것!\n 모듈화Modularity\n: System을 Module들로 나누고 Components 간에 책임을 할당하는 것이다.\n> Modularity가 바로 Design의 목표라고 할 수 있다.\n\n 모듈화의 이점\n- 개발자의 입장에서 복잡도가 줄어들게 된다.\n    > Module 사이에 작고 간단하고 잘 정의된 interface가 존재하며,  \n    > 비슷한 기능을 하는 그룹이 묶여 한 모듈에 정의가 되면 복잡도가 줄어든다.\n\n 모듈화의 측정방법\nCoupling결합력, Cohesion응집력이 있다.  \n자세한 내용은 여기./OOP.md결합력coupling 참고\n\n GRASP의 9가지 원칙\n 1. Information Expert\n> 객체지향의 기본 원리 중에 하나이다.\n\n: 책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여하는 것이다.\n- 객체는 데이터와 처리로직이 함께 묶여있는 것이다.\n- 정보 은닉을 통해 자신의 데이터를 감추고 오직 Method로만 데이터를 처리하고, 외부에는 그 기능책임만을 제공한다.\n- 역할을 수행할 수 있는 정보, 계산 된 필드 등의 책임을 위임 할 위치를 결정하는데 사용되는 원칙이다.\n\n 책임을 할당하는 방법\n1. 책임을 할당하는 일반적인 방법은 주어진 책임을 확인한다.\n2. 이행하는 데 필요한 정보를 결정한 다음 해당 정보가 저장되는 위치를 결정한 후\n3. 그것을 이행하는 데 필요한 가장 많은 정보를 가지고 있는 Class가 책임을 진다.\n\n객체는 데이터와 처리로직이 함께 묶여 있으며 자신의 데이터를 감추고자 하면 오직 자기 자신의 처리 로직에서만 데이터를 처리하고,   \n외부에는 그 기능역할만을 제공하게 된다.\n\n 2. Creator\n: 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 부여한다.\n\n- Factory Pattern과 관련되어있다.\n\n 예시 - A 객체와 B 객체의 관계가 다음 중 하나라면 A의 생성을 B의 책임로 부여한다.\n- B 객체가 A 객체를 포함하고 있다.\n- B 객체가 A 객체의 정보를 기록하고 있다.\n- A 객체가 B 객체의 일부이다.\n- B 객체가 A 객체를 긴밀하게 사용하고 있다.\n- B 객체가 A 객체의 생성에 필요한 정보를 가지고 있다.\n\n 3. Controller\n: 시스템 이벤트사용자의 요청를 처리할 객체를 만들어 사용하는 것이다.\n> 시스템, 서브시스템으로 들어오는 외부 요청을 처리하는 객체를 만들어 사용하라\n\n- 시스템 이벤트를 처리하는 책임을 전체 시스템 또는 사용 사례 시나리오를 나타내는 non-UI 클래스에 할당한다.\n- 컨트롤러는 수행해야 할 작업을 다른 객체에 위임해야 한다.\n- 활동을 조정하거나 통제해야 하지만 컨트롤러 자체가 많은 일을 해서는 안된다.\n\n 어떤 서브시스템안에 있는 각 객체의 기능을 직접 사용한다면?\n- 서브시스템과 외부간의 coupling이 증가한다.\n- 서브시스템의 객체를 수정할 경우, 외부에 주는 충격이 크다.\n\n Controller객체를 사용한다면?\n서브시스템을 사용하는 입장에서 보면, Controller 객체만 알고 있으면 되므로 사용하기 쉽다.\n\n>  서브시스템\n> : 시스템을 구성하는 요소의 하나로, 그 자체로도 시스템을 형성하고 있는 것.   \n> 시스템이 커지면, 내부를 다시 작은 시스템으로 나누어 생각하는 편이 설계나 관리상으로도 용이하기 때문에 서브시스템이 존재한다.\n\n 4. Low Coupling\n> Object-Oriented 시스템은 각 객체들과 그들 간의 상호작용을 통하여 요구사항을 충족시키는 것을 기본으로 한다.  \n> 그러므로, 각 객체들 사이에 Coupling이 존재하지 않을 수는 없다.\n- 객체들간, 서브 시스템들간의 상호의존도가 낮게 책임을 부여한다.\n- 한 클래스의 변화가 다른 클래스에 미치는 영향이 낮다.\n\n 장점\n- 서브시스템의 재사용성이 높아진다.\n- 시스템 관리가 편해진다.\n\n 5. High cohesion\n: 각 객체가 밀접하게 연관된 역할들만 가지도록 역할을 부여하는 것이다.\n- 한 객체, 한 시스템이 자기 자신이 부여받은 책임만을 수행하도록 짜임새 있게 구성되어 있다면 자연스럽게 Low Coupling이 된다.\n\n 6. Polymorphism다형성\n: 객체의 종류에 따라 행동양식이 바뀌면, 객체의 종류를 체크하는 조건문을 사용하지 말고 polymorphism다형성 기능을 사용하는 것이다.\n- Object-Oriented 시스템은 상속과 Polymorphism다형성을 지원한다.\n\n 7. Pure Fabrication\n: 도메인에 관련된 문제를 대표하는 것이 아니라면 기능적인 책임을 별도로 한 곳으로 관리하는 객체를 만들자.\n\n 어느상황에서 사용하는 것일까?\n- Information Expert 패턴을 적용하여 Low Coupling과 High Cohesion의 원칙이 깨질때\n  - 데이터베이스 정보를 저장하거나, 로그 정보를 기록하는 책임에 대해 생각해 보자. 각 정보는 각각의 객체들이 가지고 있을 것이다.\n  - 이 때 Information Expert 패턴을 적용하면, 각 객체들이 정보를 저장하고, 로그를 기록하는 역할을 담당해야 하지만, 실제로 그렇게 사용하는 사람들은 없다.\n  - 이것은 그 기능들이 시스템 전반적으로 사용되고 있기 때문에 각 객체에 그 기능을 부여하는 것은 각 객체들이 특정 데이터베이스에 종속을 가져오거나, 로그을 기록하는 매커니즘을 수정할 경우, 모든 객체를 수정해야 하는 결과를 가져온다.\n  - 즉 Low Coupling의 원칙이 깨지게 된다.\n- 이러한 상황에서 공통적인 기능을 제공하는 역할을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어야하는데 \n- 이러한 종류의 클래스는 도메인 중심 설계에서 DDD서비스라고 불린다.\n\n 8. Indirection\n: 두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 매개체ex. 객체를 통해 전달하는 것 이다.\n- 주로 Interface인 경우가 많다.\n  > 그런 경우는 Protected Variations 패턴이라 부를 수 있다.\n\n 9. Protected Variations\n: 변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용하는 것이다.\n 예시 - JDBC\n- JDBC는 일련의 인터페이스들로 구성되어 있으며, 각 데이터베이스 벤더들이 인터페이스를 구현한 Concrete 클래스를 제공하고 있다.\n- Driver를 로딩하는 코드를 제외하고는 모두 인터페이스를 사용함으로서 데이터베이스 변경시 Driver 로딩만 바꾸어 주면 되도록 데이터베이스 관련 작업이 필요한 곳에는 안정된 JDBC 인터페이스를 사용한다.\n\n\n\n 마무리\n정리를 해보니 객체지향 설계원칙 SOLID에 일부분 관련이 있었다. 그리고 코드 리펙토링을 진행할 떄 필요한 내용이다. 앞으로 기초를 더욱 단단히 다져보자!\n\n>  출처\n> - Ssabae.log: https://velog.io/@lsb156/GRASP-object-oriented-design\n> - nesoy blog: https://nesoy.github.io/articles/2019-05/GRASP-Pattern\n> - 호롱이네 tistory: https://jjungyooni.tistory.com/entry/GRASP-PATTERN",
    "tags": [
      "OOP",
      "TIL"
    ]
  },
  {
    "title": "Proxy",
    "url": "/back-end/2022/03/19/proxy/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "-  : DB를 통해서 실제 엔티티 객체 조회\n-  : DB 조회를 미루는 가짜Proxy엔티티 객체 조회  \n  <img width=500px src=./img/em-get-reference.png>",
    "content": "Proxy\n em.find vs em.getReference\n- em.find : DB를 통해서 실제 엔티티 객체 조회\n- em.getReference : DB 조회를 미루는 가짜Proxy엔티티 객체 조회  \n  <img width=500px src=./img/em-get-reference.png>\n\n Proxy 객체의 초기화\njava\nMember member = em.getReferenceMember.class\nmember.getName;\n\n<img width=500px src=./img/proxy-object-reset.png>\n\n1. getName을 요청을 한후 Member target의 값이 없다.\n2. 그러면 JPA 영속성 컨텍스트에 초기화를 요청한다.\n3. 영속성 컨텍스트는 DB를 조회후 \n4. 실제 Entity를 생성한다\n5. 그후 진짜 EntityMember과 Member target을 연결해서 getName이 반환된다.\n\n Proxy 객체의 특징\n- 처음 사용할 때 한 번만 초기화된다.\n\n- Proxy대리자객체를 초기화할 때, Proxy 객체가 Entity로 바뀌는 게 아니다.  \n  &rarr; Hibernate Proxy대리자 객체가 Entity를 대신 접근해주는 것이다.\n- 실제 클래스를 상속받아서 만들지고, 실제 클래스와 겉 모양이 같다.\n- 원본 클래스와 타입 체크 시 instance of를 사용해야 한다.  \n  &rarr; 실제 엔티티객체와 비교할지 proxy 객체와 비교할지 모르기 때문이다.\n- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference를 호출해도 실제 엔티티를 반환한다.\n- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태라면 프록시를 초기화할때 예외를 던진다.  \n  &rarr; Hibernate는 org.hibernate.LazyInitializationException 예외를 던진다.\n- 실제 객체의 참조target를 보관한다.  \n  <img width=400px src=./img/proxy-delegate.png>  \n    > proxy가 Entity를 대신 호출해준다. 즉 클라이언트개발자는 Proxy 객체를 통해 Entity를 조회한다.\n\n Proxy 확인\n- 프록시 인스턴스의 초기화 여부 확인  \n  PersistenceUnitUtil.isLoadedObject entity\n- 프록시 클래스 확인 방법  \n  entity.getClass.getName 출력..javasis.. or HibernateProxy\n- 프록시 강제 초기화  \n  org.hibernate.Hibernate.initializeentity;\n- JPA표준은 강제 초기화가 없다  \n  강제 호출: member.getName\n\n 결론\nem.getReference는 안쓰지만 JPA의 내부 동작방식에 대해 알아야 된다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "OSI 7계층",
    "url": "/cs/2022/03/19/osi-7계층/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "> ~~물데네 전세표응~~",
    "content": "OSI 7계층\n> ~~물데네 전세표응~~\n OSI - Open System Interconnection\n: 개방형 시스템간 상호 접속이다.  \n> ISO국제표준화기구에서 컴퓨터의 통신, 네트워크간의 상호 접속을 용이하게 하기 위해 규정한 네트워크 프로토콜로 표준화,  \n> 상호통신을 가능하게 한다.\n\n OSI 7계층의 목적\n: 모든 시스템들이 상호 연결에 대한 문제없도록 표준을 정한것이다.\n\n 계층을 나눈 이유\n- 계층을 나눈 이유는 통신이 일어나는 과정이 단계별로 파악할 수 있다.\n- 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건드리지 않고도 이상이 생긴 단계만 고칠 수 있기 때문이다.\n- 서로의 각 계층은 어떻게 동작하는지 알 필요가 없다. &rarr; 데이터만 알면 된다.\n\n OSI 7계층 - OSI 7 Layer\n: 구조를 7개의 계층으로 분리하여 각 계층간 상호 작용하는 방식을 정해 놓은 것이다.\n- 각 계층은 하위 계층만 사용하고, 상위 계층에게 기능을 제공한다.\n- 일반적으로 하위 계층은 하드웨어, 상위 계층은 소프트웨어로 구현된다.\n\n<img src=\"/assets/images/posts/cs/OSI_7_계층.jpg\">\n\n 1. 물리계층 - Physical Layer\n: 데이터 전기적 신호Bit == 0 or 1로 변환하여 전송한다.\n> 전압, 허브, 네트워크 어댑터, 중계기 및 케이블 사양, 신호 변경디지털,아날로그\n- 어떤 하나의 네트워크에서 기본 네트워크 하드웨어 전송기술들로 구성된다.\n- 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다.\n 장비 \n- 허브, 리피터 등...\n 프로토콜\n- Ethernet.RS-232C 등...\n\n 2. 데이터 링크 계층 - Data Link Layer\n: 물리적인 네트워크를 통해 데이터를 전송하는 수단을 제공한다.\n> MAC 주소, 브리지 및 스위치\n- 포인트 투 포인트Point to Point 간 신뢰성있는 전송을 보장하기 위한 계층이다.\n- 오류없이 한 장치에서 다른 장치로 프레임Frame, 비트의 모음을 전달하는 역할이다.\n  > CRC 기반의 오류 제어와 흐름 제어가 필요하다.\n- MAC 주소를 통해서 통신한다.\n1. 네트워크 위의 개체들 간 데이터를 전달하고\n2. 물리 계층에서 발생할 수 있는 오류를 찾아 내고,\n3. 수정하는 데 필요한 기능적, 절차적 수단을 제공한다.\n\n 장비\n- 브릿지, 스위치 등...\n 프로토콜\n- MAC, PPP, HDLC, Frame-Relay, FDDI, ATM 등...\n\n 3. 네트워크 계층 - Network Layer\n: 데이터를 목적지까지 안전하고 빠르게 IP 통해 라우팅한다.\n> 라우터\n- 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층이다.\n- 라우팅, 흐름 제어, 세그맨테이션segmentation/desegmentation, 오류 제어, 인터네트워킹Internetworking등을 수행한다.\n- 네트워크 계층에서 데이터 단위는 패킷Packet\n\n1. 다양한 길이의 데이터를 네트워크들을 통해 전달하고,\n2. 그 과정에서 전송 계층이 요구하는 서비스 품질QoS을 제공하기 위한 기능적, 절차적 수단을 제공한다.\n\n 장비\n- 라우터, L3 스위치\n 프로토콜\n- IP, ICMP, IGMP\n\n 4. 전송 계층 - Transport Layer\n: 종단간 통신End to End을 다루는 최하위 계층이다\n> 특정 방화벽, 프록시 서버\n- 양 끝단End to end의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 한다.\n   > 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.\n- 데이터 전송을 위해서 Port 번호를 사용한다.\n- 특정 연결의 유효성을 제어한다.\n- 전송 계층에서 데이터 단위는 세그먼트Segment\n 장비\n- Gateway\n 프로토콜\n- TCP, UDP, ARP\n   > 연결형 프로토콜과 비 연결형 프로토콜을 모두 사용한다.\n\n 5. 세션 계층 - Session Layer\n: 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.\n- 동시 송수신 방식duplex, 반이중 방식half-duplex, 전이중 방식Full Duplex의 통신과 함께,  \n  체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.\n- 통신 세션을 구성하는 계층으로, 포트port연결이라고도 할 수 있다.\n- 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리한다.\n\n 프로토콜\n: SSH, TLS 등...\n\n 6. 표현 계층 - Presentation Layer\n: 데이터를 어떻게 표현할지 정하는 역할을 하는 계층이다.\n> 인코딩, 디코딩, 암호화, 복호화\n- 송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화한다.\n- 수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축한다.\n- 데이터의 암호화와 복호화한다.\n 프로토콜\n- ASCII, MPEG, JPEG, MIDI, EBCDIC 등...\n\n 7. 응용 계층 - Application Layer\n: 사용자가 네트워크 자원에 접근하는 방법을 제공한다.\n> 텔넷Telnet, 구글 크롬, 이메일, 데이터베이스 관리\n- 사용자와 가장 밀접한 계층으로 인터페이스 역할이다.\n- 응용 프로세스 간의 정보 교환을 담당한다.\n\n 프로토콜\n- HTTP, SMTP, FTP, Telnet, DNS",
    "tags": [
      "TIL",
      "Network"
    ]
  },
  {
    "title": "연관관계 매핑 시작",
    "url": "/back-end/2022/03/19/연관관계-매핑-시작/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "실습 repo: https://github.com/siwony/HelloJPA/tree/basicMapping02",
    "content": "실습 repo: https://github.com/siwony/HelloJPA/tree/basicMapping_02\n 연관관계 매핑 시작\n- 할수 있으면 최대한 단방향\n- 실무에서 JPQL을 많이 짜기 때문에 양방향이 많다.\n\n 테이블 구조\n> 저번이랑 똑같다.\n\n<img width=450px src=./img/data-driven-design-table.png>\n\n 객체 구조\n<img width=450px src=./img/relationship-mapping-start-object.png>",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "JPQL",
    "url": "/back-end/2022/03/19/jpql/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": Java Persistence Query Language\n- JPQL은 객체지향 쿼리 언어다. &rarr; 엔티티 객체를 대상으로 쿼리한다.\n- SQL을 추상화하여 특정DB SQL에 의존하지 않는다.\n- 결국 SQL로 변환된다.",
    "content": "JPQL\n: Java Persistence Query Language\n- JPQL은 객체지향 쿼리 언어다. &rarr; 엔티티 객체를 대상으로 쿼리한다.\n- SQL을 추상화하여 특정DB SQL에 의존하지 않는다.\n- 결국 SQL로 변환된다.\n\n 문법\n- ex. select m from Member as m where m.age > 18\n- 엔티티와 속성은 대소문자를 구분한다 Member, age\n- JQL 키워드는 대소문자 구분x\n- 엔티티의 이름을 사용한다.\n- 별명은 필수다!m as는 생략가능\n\n 집합과 정렬\nsql\nselect\n    COUNTm,   //회원수\n    SUMm.age, //나이 합\n    AVGm.age, //평균 나이\n    MAXm.age, //최대 나이\n    MINm.age  //최소 나이\nfrom Member m\n\n- GROUP BY HAVING\n- ORDER BY\n\n TypeQuery, Query\n TypeQuery \n: 반환 타입이 명확할 때 사용\njava\n//예시\nTypeQuery<Member> query1 =\n    em.createQuery\"select m from Member m\", Member.class;\nTypeQUery<member> query2 = \n    em.createQuery\"select m.username from Member m\", Member.class;\n\n\n Query\n: 반환 타입이 명확하지 않을 때 사용\njava\nQuery query = \n    em.createQuery\"select m.username, m.age from Member m\"; // 반환을 String,이랑 Int처럼 달라서 타입 정보를 받을 수 없다.\n\n\n 결과 조회 API\n 결과가 여러개 일때\nquery.getResultList  \n- 리스트를 반환한다.\n- 결과가 없으면 빈 리스트를 반환한다.\n\n 결과가 하나 일때\nquery.getSingleResult\n- 결과가 없으면 : javax.persistence.NoResultException\n- 둘 이상이면 : javax.persistence.NonUniqueResultException\n\n 파라미터 바인딩\n 이름 기준\njava\nem.query\"select m from member m where m.username:username\"\n.query.setParameter\"username\", usernameParam;\n\n\n 위치 기준\n> 권장하지 않는다.\njava\nem.query\"select m from Member m where m.username=?1\"\nquery.setParameter1, usernameParam;",
    "tags": [
      "spring",
      "jpa",
      "JPQL",
      "TIL"
    ]
  },
  {
    "title": "Swagger",
    "url": "/back-end/2022/03/19/swagger/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 개발자가 REST API 서비스를 설계, 빌드, 문서화할 수 있도록 하는\n프로젝트 Open Api SpecificationOAS를 위한 프레임워크   ",
    "content": "Swagger\n: 개발자가 REST API 서비스를 설계, 빌드, 문서화할 수 있도록 하는\n프로젝트 Open Api SpecificationOAS를 위한 프레임워크   \n\n사용이유는 다음과 같다\n- 다른 개발팀과 협업을 진행할 경우\n- 이미 구축되어있는 프로젝트에 대한 유지보수를 진행할 경우\n- 백엔드의 API를 호출하는 프론트엔드 프로그램을 제작할 경우\n\n 기능\n- API 디자인\n    >Swagger-editor를 통해 API를 문서화하고 빠르게 명세할 수 있다.\n- API Development\n    >Swagger-codegen을 통해 작성된 문서를 통해 SDK를 생성하여 빌드 프로세스를 간소화 할 수 있도록 도와준다.\n- API Documentation\n    >Swagger-UL를 통해 작성된 API를 시각화 시킨다.\n- API Testingpost man 대체\n    >Swagger-Inspector \n- Standardize\n    >Swagger-hub를 통해 개인, 팀원들이 API정보를 공유하는 HUB\n\n 장점\n- API 정보 현행화 기능\n- API를 통해 Parameter, 응답 정보, 예제 등 Spec 정보 전달 용이\n- 실제 사용되는 Parameter로 테스트 가능\n\n Swagger Tool 종류\n- Swagger Codegen  \n    : Swagger로 정의된대로 클라이언트/서버 코드를 생성하는 CLI 툴\n- Swagger UI  \n    : Swagger API 명세서를 HTML 형식으로 확인할 수 있는툴jupjup에서 활용\n- Swagger Editor  \n    : Swagger 표준에 따른 API 설께서/명세서를 작성하기 위한 에디터\n\n Spring Boot 에 Swagger UI 적용하기\n> Swagger UI를 적용하여 Spring Boot에서 사용하고 있는 REST API를 문서화할 수 있다.\n\n1. 빌드파일에 의존성 추가\n버전 알잘딱 해서 추가하면 된다.\n- SpringFox Swagger2https://mvnrepository.com/artifact/io.springfox/springfox-swagger2\n- SpringFox Swagger UIhttps://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui\n\n\n2. Swagger Config 클래스 작성\njava\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.builders.ResponseMessageBuilder;\nimport springfox.documentation.schema.ModelRef;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.service.ResponseMessage;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n​\nimport java.util.ArrayList;\nimport java.util.Collections;\n​\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n    @Bean\n​\n    public Docket api {\n        return new DocketDocumentationType.SWAGGER_2\n                .select\n                .apisRequestHandlerSelectors.any // 현재 RequestMapping으로 할당된 모든 API 리스트\n                .pathsPathSelectors.any // 모든 API 참조\n                .build;\n    }\n}\n\nSpring Boot 실행후 /swagger-ui.html로 접속하여 swagger UI가 적용된 것을 확인",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Logging",
    "url": "/back-end/2022/03/19/logging/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 프로그램 개발 중이나 완료 후 발생할 수 있는 오류에 대해 디버깅하거나 운영중인 프로그램 상태를 모니터링 하기 위해 필요한 정보log를 기록하는것\n> 로그를 잘 남기는 것은 훌룡한 개발자의 덕목중 하나라고 할 수 있다!\n- 애플리케이션 실행에 대한 추적을 기록하기 위해 메시지콘솔, 파일, DB등 를 작성하는것\n- 디버깅, 사용자 상호 작용 기록발생하는 ...",
    "content": "Logging\n: 프로그램 개발 중이나 완료 후 발생할 수 있는 오류에 대해 디버깅하거나 운영중인 프로그램 상태를 모니터링 하기 위해 필요한 정보log를 기록하는것\n> 로그를 잘 남기는 것은 훌룡한 개발자의 덕목중 하나라고 할 수 있다!\n- 애플리케이션 실행에 대한 추적을 기록하기 위해 메시지콘솔, 파일, DB등 를 작성하는것\n- 디버깅, 사용자 상호 작용 기록발생하는 이벤트 기록 에 사용  \n\n 자바의 주요 Logging Framework\n- native java.util.logging : 별로 사용x\n- Log4j : 몇 년 전까지 사실상 표준으로 사용\n- Logback./SpringBoot/logback.md : log4j 개발자가 만든 log4j의 후속 버전, 현재 많은 프로젝트에서 사용됨 - 현제 SpringBoot의 기본 logging으로 사용하고있다.\n- SLF4jSimple Logging Facade for java : Log4J 또는 Logback과 같은 백엔드 Logger Framework의 facade pattern\n\n 스프링 부트의 로깅 원리\n스프링 부트는 기본적으로 commons logging을 사용한다. 그렇지만 보통 SLF4J를 사용한다\n\nCommons Logging과 SLF4j는 로거 퍼서드 이다. 실제로 로깅을 수행하는것이 아니라, 로거 API를 추상화 해놓은 인터페이스 이다.\n\n 결론\n우리는 Commons Logging 혹은 SLF4j를 사용하는데 \n1. Commons Logging을 써도 어차피 SLF4j로 바뀐다\n2. SLF4j가 Logback logger를 선택한다\n3. 최종적으로 Logback을 쓰게 된다.",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "@MappedSuperclass",
    "url": "/back-end/2022/03/19/mappedsuperclass/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "<img width=450px src=./img/mapped-superclass.png>",
    "content": "@MappedSuperclass\n<img width=450px src=./img/mapped-superclass.png>\n\n- 공통 매핑정보가 필요할 때 사용한다.id, name\n- 엔티티x, 테이블 매핑 x\n- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.\n- 조회 및 검색이 불가능하다.\n- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장한다.\n- ex. JPA Auditing - BaseTimeEntity ./Auditing.md",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "정리",
    "url": "/back-end/2022/03/19/정리/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 식별자가 존재한다.\n- 생명 주기를 관리한다.\n- 공유한다.",
    "content": "정리\n 엔티티 타입의 특징\n- 식별자가 존재한다.\n- 생명 주기를 관리한다.\n- 공유한다.\n\n 값 타입의 정리\n- 식별자가 없다.\n- 생명 주기를 엔티티에 의존한다.\n- 공유하지 않는것이 안전하다. &rarr; 값을 복사해서 사용한다.\n- 불변 객체로 만드는 것이 안전하다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "준 영속 상태",
    "url": "/back-end/2022/03/19/준-영속-상태/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 영속 상태의 Entity가 영속성 컨텍스트에서 분리되는 것\n- 영속에서 준 영속으로 바뀌는 상태\n- 준 영속상태에서는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.",
    "content": "준 영속 상태 \n: 영속 상태의 Entity가 영속성 컨텍스트에서 분리되는 것\n- 영속에서 준 영속으로 바뀌는 상태\n- 준 영속상태에서는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.\n\n> 앞으로 예제 코드는 다음을 생략한다.\n> java\n>  EntityManager em = emf.createEntityManager;\n>  EntityTransaction transaction = em.getTransaction;\n>  transaction.begin; // 트랜잭션 시작\n> ...\n>  //예제 코드 ...\n> ...\n> tx.commit;\n>  \n\n 준 영속 방법\n 1. em.detach영속된 엔티티 객체  \n  : 특정 Entity만 준 영속상태로 바꾼다.\n  java\n  Member member = em.findMember.class, 150L; \n  member.setName\"siwony_\";  \n\n  em.detachmember; //준영속\n\n  tx.commit;  // insert 쿼리문이 날아가지 않는다.\n  \n  - selete 쿼리만 날아가고 insert 쿼리는 날아가지 않는다.\n  - 즉, 영속성 컨텍스트의 기능인 변경 감지Dirty check가 작동하지 않는다.\n\n 2.em.clear  \n  : 영속성 컨텍스트를 완전히 초기화 한다.\n  java\n\n  Member member = em.findMember.class, 150L; //select 쿼리 나감\n  member.setName\"siwony_\";  \n\n  em.clear; //영속성 컨텍스트를 초기화 한다.\n\n  Member member2 = em.findMember.class, 150L; //select 쿼리 나감\n  tx.commit; \n  \n  중간에 한번 em.clear;를 했기 때문에 select 쿼리가 두 번 나간다.\n  > test code를 작성할 때 유용하다.\n\n em.close\n  : 영속성 컨텍스트를 종료한다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Spring Security",
    "url": "/back-end/2022/03/19/spring-security/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> 이 글은 Spring Boot + Spring Security 기준으로 쓰여진 글입니다.",
    "content": "> 이 글은 Spring Boot + Spring Security 기준으로 쓰여진 글입니다.\n 목차\n- Spring Securityspring-security &larr;\n- Spring Security Start!spring-security-start.md\n- Spring Security Filterspring-security-filters.md\n- 다양한 Spring Security Filterspring-security-variety-filters.md\n\n Spring Security\n: 스프링 기반의 어플리케이션의 보안인증, 권한을 담당하는 프레임워크\n- 보안 관련 체계적인 옵션 지원\n- filter 기반으로 동작\n- spring MVC 와 분리되어 관리 및 동작\n> 만약 Spring Security를 사용하지 않는다면 자체적으로 세션을 체크하고 redirect 등을 해야 할 것이다.\n\n 용어 정리\n- 접근 주체Principal : 보호된 대상에 접근하는 유저\n- 인증Authenticate : 현재 유저가 누구인지 확인ex. 로그인\n    >애플리케이션의 작업을 수행할 수 있는 주체임을 증명\n- 인가Authenticate : 현재 유저가 어떤 서비스, 페이지에 접근할 수 있는 권한이 있는지 검사\n- 권한 : 인증된 주체가 애플리케이션의 동작을 수행할 수 있도록 허락되었는지 결정\n    - 권한 승인이 필요한 부분으로 접근하려면 인증 과정을 통해 주체가 증명 되어야만 한다.\n    - 권한 부여에도 두가지 영역이 존재하는데 웹 요청 권한, 메소드 호출 및 도메인 인스턴스에 대한 접근 권한 부여\n\n spring security의 form 기반의 로그인 구조\n아래 그림은 Form 기반 로그인에 대한 플로우를 보여주는 그림이다.\n<p align=center><img width=600 src=../img/spring-security-architecture.png>  <p>\n\n1. 사용자가 Form을 통해 로그인 정보 입력 및 인증 요청\n2. AuthenticationFilter구현체 UsernamePasswordAuthenticationFilter 가  \n    HttpServletRequest에서 사용자가 보낸 아이디와 패스워드를 인터셉트 한다.\n    >FrontEnd 에서 유효성검사를 할 수 있지만 안전을 위해 검사한다. ex. null chk\n3. AuthenticationFilter에게 인증용 객체UsernamePasswordAuthenticationFilter 을 전달 받는다.\n4. 실제 인증을 할 AuthenticationProvider에게 Authentication객체 UsernamePasswordAuthenticationFilter을 다시 전달한다\n5. DB에서 사용자 인증 정보를 가져올 UserDetailsService 객체에게 UserID를 넘겨주고, DB에서 인증에 사용할 사용자 정보사용자 ID, 암호화된 PW, 권환 등를 UserDetails  \n라는 객체로 전달 받는다.\n    >UserDetails인증용 객체와 도메인 객체를 분리하지 않기 위해서 실제 사용되는 도메인 객체에 UserDetails를 상속하기도 한다.\n6. AuthenticationProvider는 UserDetails 객체를 전달 받은 이후 실제 사용자의 입력정보와 UserDetails 객체를 가지고 인증을 시도\n7. 8, 9, 10, 인증이 완료되면 사용자 정보를 가진 Authentication 객체를 SecurityContextHoder 에 담은 후 AuthenticationSuccessHandle를 실행\n    > 실패시 uthenticationFailureHandler를 실행",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "이진 탐색 트리 - Binary Search Tree",
    "url": "/cs/2022/03/19/이진-탐색-트리---binary-search-tree/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "와 를 결합한 자료구조이다.",
    "content": "이진 탐색 트리 - Binary Search Tree\n이진 탐색 - binary search와 연결리스트 - linked list를 결합한 자료구조이다.\n\n이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제를 가능하도록 고안되었다.\n\n이진 탐색의 경우 탐색에 소요되는 시간 복잡성은 Olog n으로 빠르지만 말 그대로 탐색이므로 자료의 입력, 삭제가 불가능하다.  \n연결리스트의 경우 자료 입력, 삭제에 필요한 시간복잡성은 O1로 효율적이지만 탐색시 On의 시간 복잡성이 발생한다.\n\n 규칙\n> 모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들\n1. key는 중복을 허용하지 않는다.\n2. 왼쪽 노드의 키 < 루트 노드의 키 < 오른쪽 노드의 키\n3. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.\n\n 특징\n- 탐색, 삽입, 삭제 연산에 대한 평균 시간복잡도는 OlogN 이다.\\\n- 이진 탐색 트리는 편향 트리 - Skewed Tree가 될 수 있다. 그리하여 최악의 시간 복잡도가 ON 이다\n  - 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다.\n  - 이를 해결하기 위해 레드블랙트리, AVL트리가 있다.\n\n\n 이진 탐색 트리의 ADT\n- 검색 : retreivekey\n- 삽입 : insertkey\n- 삭제 : deletekey\n\n\n Refrenece\n- https://ratsgo.github.io/data%20structure&algorithm/2017/10/22/bst/\n- https://velog.io/@adam2/TREE%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%ACbinary-search-tree\n- https://velog.io/@agugu95/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EA%B7%A0%ED%98%95-RED-BALCKAVL",
    "tags": [
      "data-structure",
      "non-linear",
      "tree",
      "TIL"
    ]
  },
  {
    "title": "Spring security 시작하자",
    "url": "/back-end/2022/03/19/spring-security-시작하자-1/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> Spring Security의 설정을 Java 코드로 할 수있다.",
    "content": "Spring security 시작하자\n\n 의존성 추가\n Maven\npom.xml\nxml\n<dependencies>\n  <!-- ... other dependency elements ... -->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n  </dependency>\n</dependencies>\n\n\n\n Gradle\nbuilde.gradle\ngradle\ndependencies {\n  compile \"org.springframework.boot:spring-boot-starter-security\"\n}\n\n\n Spring Security Configuration\n> Spring Security의 설정을 Java 코드로 할 수있다.\n\n다음과 같이 Security 설정은 커스텀 할 수 있다. 다음은 JWT인증을 구현한 Config이다.   \nrefernce: https://github.com/GSM-Web-Technology/Jup-Jup-Server/blob/main/src/main/java/com/gsm/jupjup/config/security/SecurityConfiguration.javaL23\njava\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configureHttpSecurity http throws Exception {\n        http\n                .cors.and\n                .httpBasic.disable // rest api 이므로 기본설정 사용안함. 기본설정은 비인증시 로그인폼 화면으로 리다이렉트 된다.\n                .csrf.disable // rest api이므로 csrf 보안이 필요없으므로 disable처리.\n                .sessionManagement.sessionCreationPolicySessionCreationPolicy.STATELESS // jwt token으로 인증할것이므로 세션필요없으므로 생성안함.\n                .and\n                .authorizeRequests // 다음 리퀘스트에 대한 사용권한 체크\n                .antMatchers\"//signin\", \"//signup\",\"/exception/\", \"//member/\", \"//logout\", \"//dev/\", \"//userinfo\".permitAll // 가입 및 인증 주소, 오류, 이메일 인증은 누구나 접근가능\n                .antMatchers\"//admin/\".hasRole\"ADMIN\" // admin으로 시작하는 요청은 관리자만 접근 가능\n                .anyRequest.authenticated // 그외 나머지 요청은 인증된 사용자만 접근 가능\n                .and\n                .exceptionHandling.accessDeniedHandlernew CustomAccessDeniedHandler //관리자 에러\n                .and\n                .exceptionHandling.authenticationEntryPointnew CustomAuthenticationEntryPointHandler //로그인 에러\n                .and\n                .addFilterBeforejwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class;  // jwt token 필터를 id/password 인증 필터 전에 넣음\n    }\n\n    @Override // ignore check swagger, h2 database resource\n    public void configureWebSecurity web {\n        web.ignoring.antMatchers\"/v2/api-docs\", \"/swagger-resources/\",\n                \"/swagger-ui.html\", \"/webjars/\", \"/swagger/\", \"/h2-console/\", \"/configuration/ui\";\n    }\n\n}\n\nhttp..httpBasic.disable를 지우면 로그인 폼으로 리다렉트 된다.",
    "tags": [
      "spring",
      "TIL",
      "spring-security"
    ]
  },
  {
    "title": "트리 - Tree",
    "url": "/cs/2022/03/19/트리---tree/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "로 이루어진 자료구조이다.\n- 이 없는 하나의 \n- 혹은, 의 한 종류이다.",
    "content": "트리 - Tree\n노드 - node로 이루어진 자료구조이다.\n- 사이클 - cycle이 없는 하나의 연결 그래프 - Connected Graph\n- 혹은, DAG - Directed Acyclic Graph, 방향성이 있는 비순환 그래프의 한 종류이다.\n\n만약 하나의 노드가 여러개의 자식노드를 가지는 불규칙한 트리의 경우 node를 구현하기가 상당히 복잡해진다.  \n이러한 이유로 실제로는 하나의 노드가 2개의 자식노드만 가지는 이진트리가 많이 사용된다.\n\n 트리의 특징\n- 계층 모델이다.\n  > 예시로 디렉토리가 있다.\n- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.\n- 루트에서 어떤 노드로 가는 경로는 유일하다.\n\n 트리의 구성요소\n노드 - node와 그 노드들을 연결하는 간선 - edge들로 구성되어 있다,\n\n 트리의 조건\n- 트리는 하나의 루트 노드를 갖는다\n- 루트 노드는 0개 이상의 자식 노드를 갖고 있다.\n- 그 자식 노드 또한 0개 이상의 자식 노드를 갖고있고, 이는 반복적으로 정의된다.\n- 트리에는 사이클 - cycle이 존재할 수 없다.\n\n 트리와 관련된 용어\n<img width=700 src=\"/assets/images/posts/cs/tree-ex.png\">\n\n- 루트 노드 - root node : 부모가 없는 노드\n  > 트리는 하나의 루트 노드만을 가진다.\n- 단말 노드 - leaf node : 자식이 없는 노드\n- 내부 노드 - internal node : 자식이 있는 노드\n  > 즉 단말 노드가 아닌 노드를 칭한다.\n- 간선 - edge : 노드를 연결하는 선\n  > link, branch 라고도 부름\n- 형제 - sibling : 같은 부모를 가지는 노드\n- 노드의 크기 - size : 자신을 포함한 모든 자손 노드의 개수\n- 노드의 깊이 - depth : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수\n- 노드의 레벨 - level : 트리의 특정 깊이를 가지는 노드의 집합\n- 노드의 차수 - degree : 하위 트리 수 / 간선 수 = 각 노드가 지닌 가지의 수\n- 트리의 차수 - degree of tree : 트리의 최대 차수\n- 트리의 높이 - heigth : 루트 노드에서 가장 깊숙히 있는 노드의 깊이\n\n\n 이진 트리 - Binary Tree\n이진트리는 트리를 구성하는 노드들의 최대 차수 - degree가 2인 노드들로 구성되는 트리이다.\n- 이진트리의 레벨 i에서 가질 수 있는 최대 노드의 수는 2<sup>i</sup> 이다. i >= 0\n- 깊이가 k인 이진트리가 가질 수 있는 최대 노드의 수는 2<sup>k - 1</sup> 이다. k >= 1\n- 이진 트리의 종류\n  - 완전 이진 트리 - Completable Binary Tree\n  - 전 이진 트리 - Full Binary Tree\n  - 포화 이진 트리 - Perfact Binary Tree\n\n 이진 트리의 종류\n<img src=\"/assets/images/posts/cs/kind-of-tree.png\">\n\n 1. 완전 이진 트리 - Complate Binary Tree\n<img src=\"/assets/images/posts/cs/completable-binary-tree-ex.png\">\n\n1. 트리를 구성하고 있는 임의의 두 단말 노드의 레벨 차이가 1이하\n2. 마지막 레벨을 제외한 모든 레벨에 존재할 수 있는 노드를 갖고 있다.\n3. 왼쪽에서 오른쪽으로 채워진다.\n- 배열을 사용해 효율적으로 표현할 수 있다.\n\n\n 2. 전 이진 트리 - Full Binary Tree\n<img src=\"/assets/images/posts/cs/full-binary-tree-ex.png\">\n\n- 전 이진트리는 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리이다.\n\n 3. 포화 이진 트리 - Perfect Binary Tree\n- 모든 레벨에 노드가 차있는 상태로 최대 노드 수인 2^k-1개로 채워져 있는 트리\n- 전 이진 트리이면서 완전 이진 트리인 경우\n\n 2진 트리순회\n트리는 선형 구조의 자료구조가 아니기 때문에 노드들을 방문할 규칙을 선택해야 한다.\n\n- 표준적인 방법은 전위, 중위, 후위 순회 방법이 있다.\n- 재귀호출을 통해 이를 구현한다.\n\n 전위 순회 - Pre order Traversal\n> 루트 &rarr; 왼쪽 서브트리 &rarr; 오른쪽 서브 트리 \n\n 중위 순회 - In-order Traversal\n> 왼쪽 서브트리 &rarr; 루트 &rarr; 오른쪽 서브트리\n\n 후위 순회 - Post-order Traversal\n> 왼쪽 서브트리 &rarr; 오른쪽 서브트리 &rarr; 루트\n\n 레벨 순회 - Level-order Traversal\n레벨 순서로 방문하는 순회 방법\n\n 2진 트리의 구현\n2진 트리도 Graph의 일종이므로 인접 행렬, 인접 리스트를 통해 구현할 수 있고, Link를 이용해 구현할 수 있다.\n\n 그래프와 트리의 차이\n<img width=\"700\" src=\"/assets/images/posts/cs/graph-vs-tree.png\">\n\n Refrenece\n- https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html\n- https://velog.io/@adam2/TREE\n- https://suyeon96.tistory.com/29?category=403287---%--Link%EB%A-%BC%--%EC%-D%B-%EC%-A%A-%ED%--%-C%--%EC%-D%B-%EC%A-%--%ED%-A%B-%EB%A-%AC%--%EA%B-%AC%ED%--%--%---C%-B%-B-",
    "tags": [
      "data-structure",
      "non-linear",
      "tree",
      "TIL"
    ]
  },
  {
    "title": "자료구조",
    "url": "/cs/2022/03/19/자료구조/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미한다.\n>더  데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.",
    "content": "자료구조\n: 효율적인 접근 및 수정을 가능케 하는 자료의 조직, 관리, 저장을 의미한다.\n>더  데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미한다.\n\n 자료구조의 목표\n- 데이터를 효율적으로 저장, 관리하여 메모리를 효율적으로 사용하기 위함이다.\n- 적절한 자료구조의 사용은 메모리의 용량을 절약하고 실행시간을 단축 시킨다.\n\n 자료구조의 선택기준\n- 자료의 처리시간\n- 자료의 크기\n- 자료의 활용빈도\n- 자료의 갱신정도\n- 프로그램의 용이성\n\n 자료구조의 특징\n 1. 효율성\n- 적절한 자료구조를 선택후 사용한다면 업무의 효율이 증가한다.\n\n 2. 추상화\n> 추상화란 복잡한 자료, 모듈, 시스템 등으로 부터 핵심적인 개념만 간추려 내는 것\n- 자료구조의 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지 중요하다.\n- 그렇기 때문에 구현 외적인 부분에 시간을 더 쏟을 수 있다.\n\n 3. 재사용성\n> 자료구조를 설계할때 특정 프로그램에서만 동작하게 설계하지 않는다.\n- 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계한다.\n  > 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있다.\n\n 자료구조의 구성\n- Insert : 데이터를 어떻게 저장 할 것인가\n- Search : 데이터를 어떻게 탐색 할 것인가\n- Delete : 데이터를 어떻게 삭제 할 것인가\n\n 자료구조의 분류\n<img src=\"/assets/images/posts/cs/data-structure.png\">\n\n- 단순 구조: 프로그래밍에서 사용되는 기본 데이터 타입\n- 선형 구조: 저장되는 자료의 전후관계가 1:1\n- 비선형 구조: 데이터 항목 사이의 관계가 1:n 또는 n:m\n- 파일 구조: 서로 관련된 필드들로 구성된 레코드의 집합인 파일에 대한 자료구조",
    "tags": [
      "data-structure",
      "TIL"
    ]
  },
  {
    "title": "데이터 직렬화",
    "url": "/cs/2022/03/19/데이터-직렬화/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": CS의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 같거나 \"다른 컴퓨터 환경\"에 저장하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다.\n> \"다른 컴퓨터 환경\"은 다른 컴퓨터의 인 메모리, 파일 시스템, 네트워크 연결 링크 간 전송 등을 의미한다.",
    "content": "데이터 직렬화\n 직렬화serialization 의 사전적 의미\n: CS의 데이터 스토리지 문맥에서 데이터 구조나 오브젝트 상태를 같거나 \"다른 컴퓨터 환경\"에 저장하고 나중에 재구성할 수 있는 포맷으로 변환하는 과정이다.\n> \"다른 컴퓨터 환경\"은 다른 컴퓨터의 인 메모리, 파일 시스템, 네트워크 연결 링크 간 전송 등을 의미한다.\n\n위 말을 풀어 해석하면 다음과 같다.  \n\n메모리를 디스크에 저장하거나 네트워크 통신에 사용하기 위한 형식으로 변환하는 것 이라고 할 수 있다.\n\n 직렬화는 왜 필요할까?\n개발 시 어느 언어든 상관없이 데이터들의 구조는 크게 다음과 같다.\n 1. 값 데이터 형식Value Type\n- 우리가 흔히 선언해서 사용하는 int, float, char 등 \n- 값 형식 데이터들은 Stack메모리에 메모리가 쌓이고 직접 접근이 가능하다.\n 2. 참조 형식 데이터Reference Type\n: Java, C, C++ 등 객체Object와 같이 동적 메모리 생성에 관련된 것들을 참조 형식 데이터라 한다.\n1. 해당 형식의 변수를 선언하면 Heap에 메모리가 할당되고,\n2. Stack에서는 이 Heap 메모리를 참조하는Heap에 메모리 번지 주소를 가지고 있음 구조로 되어있다.\n\n이 두가지 데이터 중에서 디스크에 저장하거나 통신에는 값 형식 데이터Value Type만 가능하다.   \n\n이유는 다음과 같다.\n- 참조 형식 데이터는 Stack에 실제 데이터 값이 아닌 Heap에 할당되어있는 메모리 번지 주소를 가지고 있다.\n- 네트워크 통신 관점으로 보면 참조 형식 데이터는 데이터를 전달하는게 아니라 주소를 전달하는 것 이므로 아무 의미없다.\n  > A라는 유저의 특정 주소를 B한테 보내면 무슨의미가 있을까. B유저가 받은 주소값을 참조하면 전혀 데이터가 다른데..\n- 참조 형식 데이터의 Heap 테이터 영역에 저장되어 있는 값을 다른곳에서 사용한다 해도   \n  언어마다 Heap 데이터 영역을 다루는 표준화된 방법이 없다.\n\n그래서 직렬화를 하는이유는?  \n사용하고 있는 데이터들을 파일 저장 혹은 데이터 통신 등 여러 곳에서 파싱 할 수 있는 유의미한 데이터를 만들기 위함이다.\n\n 그래서 직렬화란?\n: 각 주소 값이 가지는 데이터들을 전부 끌어모아 값 형식Value Type데이터로 변환후 데이터를 스트림에 쓰기 위해 연속적인 serial데이터로 변환하는 것이다.\n\n 직렬화의 대표적인예\nBinary, Text, JSON, XML, YML",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "객체 지향 프로그래밍(Object Oriented Programming) 한눈에 보기",
    "url": "/cs/2022/03/19/객체-지향-프로그래밍object-oriented-programming-한눈에-보기/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "> 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.\n> <p align=right>- 어느 객체지향 개발자가&nbsp&nbsp</p>\n<p align=\"center\">\n    <img width=\"350px\" src=\"/assets/images/posts/cs/oop.png\">\n</p...",
    "content": "객체 지향 프로그래밍Object Oriented Programming 한눈에 보기\n> 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.\n> <p align=right>- 어느 객체지향 개발자가&nbsp&nbsp</p>\n<p align=\"center\">\n    <img width=\"350px\" src=\"/assets/images/posts/cs/oop.png\">\n</p>\n\n- 컴퓨터 프로그램을 \"객체Obejct\" 들의 모임으로 파악하고자 하는 프로그래밍의 패러다임이며\n- 각 객체들은 데이터를 주고받을수 있고 데이터를 처리 할 수 있다.\n\n\n OOP의 장점\n강한 응집력Stoing Cohesion과 약한 결합력Weak Coupling을 지향한다.  \n\n클래스에 하나의 문제 해결을 위한 데이터를 모아 놓은 객체를 활용한 프로그램을 지향하므로 응집력 강화하며,  \n클래스 간에 독립적으로 디자인함으로써 결합력을 약하게 할 수 있다.\n- 프로그램을 유연하고 변경이 용이하게 만든다.\n- 프로그램의 개발과 보수를 간편하게 만든다.\n- 직관적인 코드 분석을 가능하게 한다.\n\n 결합력coupling\n: 프로그램의 코드의 한 종류가 다른 것이 얼마나 결합되어 있는지, 얼마나 의존적인지 나타내는 정도\n<img src=\"/assets/images/posts/cs/coupling.png\">\n\n- 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않은 상태를 의미한다.\n- 결합력이 낮으면 변경의 용이하다.\n \n 응집력Cohesion\n: 프로그램의 한요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 아이디어가 뭉쳐있는지 나타내는 정도\n<img src=\"/assets/images/posts/cs/cohesion.png\">\n\n- 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어있다.\n- 지나치게 많은 일을 하지 않으면 \"응집력이 높다.\" 라고 표현  \n    >응집도가 높으면 프로그램을 쉽게 이해할 수 있음\n\n 객체의 3요소\n 상태 유지객체의 상태\n- 객체는 상태 정보를 저장 및 유지해야한다.\n- 이러한 속성Variable은 변수로 정의되어야 한다.\n- 속성값이 바뀜으로, 객체의 상태가 변경 될 수 있어야 한다.\n\n 기능 제공객체의 책임\n- 객체는 기능을 제공해야 한다. &rarr; Method의 재공\n- 외부로 부터 직접 속성에 접근하여 변경 하는것이 아닌  \n 객체가 제공하는 method로 기능이 제공되어야한다.\n\n 고유 식별자 제공객체의 유일성\n- 각각의 객체는 고유한 식별자를 가져야한다.\n- 예를들면 카드번호, 계좌번호 등...\n- DB로 예를들면 PK, Uniqeu Key 등이 해당된다.\n\n OOP의 기본 구성 요소\n 클래스Class\n: 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 속성attribute과 행위behavior를 변수와 메서드로 정의한 것\n- 같은 종류의 집단에 속하는 속성과 행위 정의한 것이다.\n- 다른 클래스와 독립적으로 디자인해야 한다.\n- 필드, 매서드, 생성자로 이루어져 있다.\n 객체Object\n: 클래스의 인스턴스Instance 즉, 클래스라는 설계도를 구현한 것이라 할 수 있다.\n- 상위 클래스의 속성을 가지고 있다\n- 개별적인 특성과 행위Method를 가지고 있다.\n 메서드Method\n: 클래스 내부에 정의된 함수를 말한다.\n- 클래스로부터 생성된 객체를 사용하는 방법\n- 객체의 속성을 조작하는데 사용\n\n OOP의 특성\n &nbsp; 캡슐화Encapsulation\n> 캡슐화를 제대로 하면 정보 은닉data hiding은 자연스럽게 따라온다.\n- 객체의 속성data fields과 행위메서드, methods를 하나로 묶는다.\n  > 무작전 묶는게 아니라 객체가 맡은 역할을 수행하기 위한 하나의 목적으로 묶는다\n- 실제 구현 내용 일부를 외부에 감추어 은닉한다. &rarr; 객체가 제공해야하는 필수적인 로직만 외부에 공개한다.\n- 데이터를 절대로 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근해야한다.\n  > 이를 위해 주로 필드는 private나 protected를 사용해서 접근을 제한한다.\n- 접근지정자 ex public, private, protected, default\n\n &nbsp; 추상화Abstraction\n: 공통의 속성이나 기능을 묶어 이름을 붙이는 것\n> 객체 지향적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴수 있다.\n\n- 객체들이 가진 공통의 특성들을 파학하고 불필요한 특성들을 제거하는 과정\n- 객체들이 가진 동작들을 기준으로 이용자들이 동작만 쉽게 구동할 수 있도록한다.\n\n &nbsp; 상속Inheritance\n- 이미 정의 되어있는 상위 클래스와 메소드를 비롯한 모든 속성을 하위 클래스가 물려받는것\n    >모든 클래스는 Object클래스를 상속받고 있다.\n- 재사용, 유연성이 증가한다.\n\n &nbsp; 다형성Polymorphism\n- 한 요소에 여러 개념을 넣어 놓는 것\n- 객체 관계를 조직적으로 나타낼 수 있다.\n- ex @Overriding을 통해 부모클래스의 method를 자식이 제지정할 수 있다.\n\n SOLID - 객체지향 개발 5대 원리\n SRP:단일 책임 원칙Single Responsibility Principle\n: 객체는 하나의 책임만을 맡아야 한다.\n- 변화에 대한 유연성 확보\n- 낮은 결합도, 높은 응집도 추구\n\n OCP: 개방-폐쇄 원칙Open Closed Principle\n: 모듈은 확장에는 열려 있어야 하고 변경시에는 닫혀 있어야한다.  \n- 상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신의 변화에 대해서 폐쇄적이지만,  \n&nbsp; 인터페이스는 외부의 변화에 대해서 확장을 개방해 줄 수 있다.\n- 이러한 부분은 JDBC, Hibernate등 JAVA StreamI,O 에서 찾아볼 수 있다.\n\n LSP: 리스코프 치환 원칙Liscov Substitution Principle\n: 자식 클래스는 언제나 자신의 부모 클래스를 대체 할 수 있다.\n- 즉 인터페이스만 알면 구현체를 몰라도 사용 가능해야한다.\n- 다형성\n\n ISP: 인터페이스 분리 원칙InterFace Segregation Principle\n: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.\n- 인터페이스를 다시 작게 나누어 만든다.\n- 두 개 이상의 인터페이스가 필요한 경우 다중 인터페이스 상속으로 구현하는 것이 좋다.\n\n DIP: 의존성 역전 원칙Dependency Inversion Principle\n: 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”\n- 상위, 하위 모듈은 모두 추상화에 의존해야 한다.\n- 세부사항이 추상화에 의존해야한다.",
    "tags": [
      "OOP",
      "TIL"
    ]
  },
  {
    "title": "Entity",
    "url": "/back-end/2022/03/19/entity/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": DB에서 영속적으로 저장된 데이터를 자바 객체로 매핑하여 '인스턴스의 형태' 로 존재하는 데이터  \n>Entity 클래스는 실제 DataBase의 테이블과 1 : 1로 매핑 되는 클래스로, DB의 테이블내에 존재하는 컬럼을 속성필드으로 가져야 한다.",
    "content": "Entity\n: DB에서 영속적으로 저장된 데이터를 자바 객체로 매핑하여 '인스턴스의 형태' 로 존재하는 데이터  \n>Entity 클래스는 실제 DataBase의 테이블과 1 : 1로 매핑 되는 클래스로, DB의 테이블내에 존재하는 컬럼을 속성필드으로 가져야 한다.\n\n다음은 Spring Data JPA를 적용한 Entity이다.\njava\n@Entity\n@Tablename = \"product\"\n@Getter  @Setter\npublic class Product {\n    @Id\n    @GeneratedValuestrategy = GenerationType.IDENTITY\n    private Long id;\n\n    @Columnlength = 100, nullable = false\n    private String name;\n\n    @Columnnullable = false \n    private int price;\n\n    @ManyToOne //n : 1 연관관계\n    @JoinColumnname =\"category_id\",nullable = false\n    private Category category;\n\n    // 1 : n 연관관계\n    @OneToManymappedBy = \"product\"\n    private Set<Cart> carts;\n}\n\n\ntable 이 아니라 entity인 이유\n> 기본적으로 JPA는 모든 필드를 불러오게 한다.  \n> 하지만 모든 케이스에서 모든 필드를 다루지 않는다  \n> 그래서 테이블은 한개지만, entity or DTO는 경우에 따라서 여러 개를 만들 수 있다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "임베디드 타입",
    "url": "/back-end/2022/03/19/임베디드-타입/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> 객체지향스럽게 개발을 하려고 쓰는 것이다.",
    "content": "임베디드 타입\n> 객체지향스럽게 개발을 하려고 쓰는 것이다.\n\n: 새로운 값 타입을 직접 정의할 수 있다.\n- JPA는 임베디드 타입embedded type이라 한다.\n- 주로 기본값 타입을 모아서 만들어서 복합값 타입이라고 한다.\n- int, String과 같은 값 타입\n\n 임베디드 타입 사용법\n- @Embeddable: 값 타입을 정의하는 곳에 표시\n- @Embedded: 값 타입을 사용하는 곳에 표시\n- 기본 생성자 필수\n\n 임베디드 에제\n 요구사항\n- 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. \n    >  근데 뭔가 간단하게 추상화를 할 수 있지 않을까? 좀 더 클래스를 쪼개고 싶다.\n\n  <img width=100px src=./img/embedded-member.png>\n\n- 다음과 같이 회원 엔티티는 이름, 근무 기간, 집 주소를 가진다. &rarr; 좀더 추상화를 해봤다.  \n  <img width=300px src=./img/embedded-member-2.png>\n\n 최종 설계\n<img width=450px src=./img/embedded-type-modling.png>\n\n- 그냥 클래스를 쪼갠 것이다\n  \n 임베디드 타입과 테이블 메핑\n<img width=450px src=./img/embedded-type-table-mapping.png>\n\n- DB 입장에서는 변경할 것이 없다. &rarr; DB는 테이터를 잘 다루기만 하면 되니까...\n- 하지만 객체는 데이터뿐만 아니라 매서드라고 하는 기능, 행위까지 들고 있으므로 이렇게 묶어서 얻는 이득이 많다.\n\n 코드\njava\n// Period 기간 entity \n@Embeddable\n@Getter @Setter\npublic class Period{\n\n    private LocalDateTime startDate;\n    private LocalDateTime endDate;\n}\n\n// Address 주소 entity\n@Embeddable\n@Getter @Setter\npublic class Address{\n\n    private String city;\n    private String street;\n    private String zipcode;\n}\n\n// Member entity\n@Entity\n@Getter @Setter\npublic class Member{\n    \n    @Id @GeneratedValue\n    private Long id;\n\n    private String username;\n\n    @Embedded\n    private Period period;\n\n    @Embedded\n    private Address address;\n}\n\n\n\n 임베디드 타입 장점\n- 재사용할 수 있다.\n  \n- 높은 응집도\n- Perid.isWrok처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있다.\n- 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티 티에 생명주기를 의존함\n\n 결국 임베디드란?\n- 엔티티의 값일 뿐이다.\n  \n- 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.\n- 객체와 테이블을 아주 세밀하게find-grained 매핑하는것이 가능하다.\n- 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수보다 클래스의 수가 더 많다.\n\n 임베디드 타입과 연관관계\n<img width=450px src=./img/embedded-type-relationship.png>\n\n>표준 스펙에 나와있다.\n- 엔티티는 임베디드 타입을 가질 수 있다.\n  \n- 임베디드는 임베디드 타입을 가질 수 있다.\n- 임베디드 타입은 엔티티를 가질 수 있다.\n\n 속성 재정의\n- 한 엔티티 내에서 같은 값 타입을 사용하면 컬럼이 중복되어버린다.\n- @AttributeOverrides, @AttributeOverride를 사용해서 컬럼 명 속성을 재정의할 수 있다.\n\n예시  \nMember Entity에 집주소 뿐만아니라 회사 주소까지 필요할 수 있다.\njava\n@Entity\n@Getter @Setter\npublic class Member{\n    \n    @Id @GeneratedValue\n    private Long id;\n\n    private String username;\n\n    @Embedded\n    private Period period;\n\n    @Embedded\n    private Address homeAddress;\n\n    @Embedded\n    @AttributeOverrides\n        @AttributeOverridename=\"city\",\n                column=@Columnname = \"WORK_CITY\"\n        @AttributeOverridename=\"street\",\n                column=@Columnname = \"WORK_STREET\"\n        @AttributeOverridename=\"zipcode\",\n                column=@Columnname = \"WORK_ZIPCODE\"\n    \n    private Address workAddress;\n}",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "express-generator",
    "url": "/back-end/2022/03/19/express-generator/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 라는 패키지를 통해서 프레임워크에 필요한 과 기본 구조를 잡을 수 있는 패키지 이다.",
    "content": "express-generator\n: Express-generator라는 패키지를 통해서 프레임워크에 필요한 pakage.json과 기본 구조를 잡을 수 있는 패키지 이다.\n install 및 express 프로젝트 만들기\nnode.js, npm 이 설치되어있다는 가정하에 설명을 할것이다. 설치방법./how-to-install-nodejs.md  \nbash\n> npm install -g express-generator\n\n위 명령어는 npm 으로 express-generator가 전역으로 설치를 해준다.  \n전역으로 설치한 이유는 나중에도 사용할것이기에 했다.  \n그후 express 기본구조를 잡아볼것이다.\nbash\n> express \"express-project\" --view=ejs\n\n이렇게 하면 현제 명령어를 실행한 디렉토리 기준으로 /express-project 에 express 프로젝트가 만들어진다.\n\"express-project\" 등 프로젝트 이름을 생략할 수 있는데 그 경우 현제 디렉토리에 프로젝트가 생성된다.  \n그후 package.json 에 있는 모듈들을 설치 할것이다.\nbash\n> npm i\n\n를 하면 package.json에 있는 모듈들을 자동으로 설치해줄것이다.\n nodemon 적용하기\nnodemon./how-to-install-nodejs.md이 설치가 되어있다는 가정으로 설명할것이다.  \n<code>package.json</code> 파일에 있는 script 부분을 수정할것이다.\njson\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n  },\n\n를 \njson\n  \"scripts\": {\n    \"start\": \"node ./bin/www\",\n    \"dev\": \"nodemon ./bin/www\"\n  },\n\n와 같이 바꿔줄것이다. 개발을할때 <code>npm run dev</code>를 통해 nodemon으로 실행할 수 있고  \n일반적으로 npm start를 하면 npm 으로 실행할것이다.",
    "tags": [
      "nodejs",
      "TIL"
    ]
  },
  {
    "title": "JPA(Java Persistence API)",
    "url": "/back-end/2022/03/19/jpajava-persistence-api/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 데이터를 영속화 하는 API",
    "content": "JPAJava Persistence API\n: 데이터를 영속화 하는 API\n\n JPA사용하기 이전의 문제점  \n SQL를 직접 사용\nSQL 중심적인 개발을 피하기 어렵다\n- 기존 JDBC만 사용하면 반복적이며 비슷한 SQL 문을 많이 만들어야한다.ex. CRUD\n    > 개발자가 SQL 매퍼가 되어버린다. \n- 추가적인 요구사항이 들어왔을 때 DB query, 객체 등 의존하는 여러 코드를 수정해야 한다.\n    > 만약 컬럼이 하나 더 추가된다면, 가장 먼저 SQL Query를 수정해야 할것이고,  \n    > 그다음 Entity 그다음 그와 관련된 로직 등... 수정해야 된다.\n\n 패러다임의 불일치\n> 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.\n> <p align=right>- 어느 객체지향 개발자가</p>\n\n- 객체와 RDB는 다른 데이터구조를 가진다. 즉, 객체로 DB를 조회할 수 없다.\n- 객체지향적 설계를 하게 되면 DB table과 JAVA 객체 간의 매핑하는 소모적인 작업을 지속해야 한다.\n\n    <img width=500px src=./img/jpa-table-object-relation.png>\n\n    > 객체 모델은 외래키가 필요 없고 단지 참조만 있으면 되지만  \n    > 테이블은 참조가 필요 없고 외래 키만 있으면 된다.\n\n\n JPA의 사용이유\n- SQL 문을 개발자가 만들지 않기 때문에 객체 중심적인 개발을 할 수 있다.\n- 특정 RDBMS 문법에 종속적이지 않은 개발이 가능하다.\n  > JPA는 RDBMS 벤더가 달라도 설정만 해주면 알아서 쿼리가 나간다!\n- 영속성 컨택스트는 효율적인 SQL 처리에 크게 기여하여 성능상의 이점\n- 객체답게 모델링 할수록 SQL과 매핑하는 작업만 늘어나게 되어 SQL에 의존적으로 설계하게 되는 문제를   \n  JPA는 객체를 마치 List와 같은 Java Collection에 저장하듯이 DB에 저장하여 문제를 해결한다.\n\n JPA는 특정 DB에 종속적이지 않다.\n- 각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르다\n    > DB의 방언이라고 한다.\n- 가변 문자: MySQL은 VARCHAR, Oracle은 VARCHAR2\n- 문자열을 자르는 함수: SQL 표준은 SUBSTRING, Oracle은\nSUBSTR\n- 페이징: MySQL은 LIMIT , Oracle은 ROWNUM\n\n JPA 구동 방식\n<img width=400px src=./img/jpa-work.png>\n\n\n JPA의 가장 중요한 2가지\n- 객체와 RDB 매핑ORM\n- 영속성 컨텍스트",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "ADT - Abstract Data Type",
    "url": "/cs/2022/03/19/adt---abstract-data-type/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 추상자료형ADT이란 구체적인 기능의 완성을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 말한다.\n> ex.  \n> C언어의 구조체, 객체지향 프로그램언어c++, c, java의 interface,  \n> 연결리스트, 스택, 큐, 우선순위 큐, 이진 트리, 딕셔너리, 서로 집합, 해시 테이블, 그래프 등...",
    "content": "ADT - Abstract Data Type\n: 추상자료형ADT이란 구체적인 기능의 완성을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것을 말한다.\n> ex.  \n> C언어의 구조체, 객체지향 프로그램언어c++, c, java의 interface,  \n> 연결리스트, 스택, 큐, 우선순위 큐, 이진 트리, 딕셔너리, 서로 집합, 해시 테이블, 그래프 등...\n\n- 데이터나 연산이 무엇What인지는 정의되지만, 데이터나 연산을 어떻게How 구현할 것인지는 정의되지 않는다.\n- 즉, 구체적인 구현 방법을 다루지 않는다.\n  >  이는 자료구조에서 다룬다.\n\n ADT의 구성요소\n- Characters - 데이터속성의 선언\n- Opertions - 연산의 선언",
    "tags": [
      "data-structure",
      "ADT",
      "TIL"
    ]
  },
  {
    "title": "SpringBoot",
    "url": "/back-end/2022/03/19/springboot/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "Spring Famework는 아래 세 가지의 특성을 이용해 결합도를 낮추는 방식으로 Application을 개발할 수 있다.\n- Dependency Injection\n- Inversion of Control\n- Aspext Oriented Programming",
    "content": "SpringBoot\nSpring Famework는 아래 세 가지의 특성을 이용해 결합도를 낮추는 방식으로 Application을 개발할 수 있다.\n- Dependency Injection\n- Inversion of Control\n- Aspext Oriented Programming\n\n하지만 SpringSpring Famework의 환경 설정은 EJB보다 나아졌다 하더라도 여전히 복잡하다.\n> Transaction Manager, Hibernate Datasource, Entity Manager, Session Factory 등...\n\nSpring Boot는 최소한의 작업으로 Spring Famework를 사용하기 위해 등장했다.\n\n> Spring Boot makes it easy to create stand-alone,  \n> production-grade Spring based Applications that you can \"just run\".  \n> \n> Spring Boot는 \"그냥 실행할 수 있는\" 프로덕션 등급의 Spring 기반 애플리케이션을 쉽게 만들 수 있다.\n\n\n 주요 특징\n 1. 'starter' 의존성 제공\n빌드 구성을 단순화 하기위해 'starter'의존성을 제공한다.\n> spring-boot-starter-{라이브러리 이름}\n\n 2. 라이브러리 버전 자동관리\nSpring Framework에서 버전을 수동적으로 관리했다면 Spring Boot에서는 Spring 라이브러리 뿐만 아니라 서드파티 라이브러리들도 호환되는 버전으로 알아서 관리해준다.\n\n 3. SpringFramework 설정 자동화\n@EnableAutoConfiguration 어노테이션을 선언하면 Spring에서 자주 사용했던 설정들을 알아서 등록한다.\n\n 4. 내장 Tomcat, Netty\nSpringBoot는 Starter의존성에 WAS를 내장하고 있으므로 WAR file로 배포할 필요가 없다.\n> Tomcat은 spring-boot-starter-web의존성에, Netty는 spring-boot-starter-webflux의존성에 내장되어 있다.\n\n 5. Spring Actuaor를 제공한다. \n메트릭, 상태 확인 및 외부 구성과 같은기능을 제공한다.\n\n 6. XML설정과 code 생성을 요구하지 않는다.\n\n SpringBoot의 목표\n- Spring 개발에 대해 빠르고, 광범위하게 적용할 수 있는 환경\n- 기본값 설정이 있지만 설정을 바꿀 수 있다.\n- 대규모 프로젝트에 공통적인 비 기능 제공 보안, 모니터링 등..\n- XML 구성 요구사항이 전혀 없다.\n\n SpringBoot는 Spring initializr로 프로젝트를 다운받을 수 있다.\nlink: https://start.spring.io\n\n\n Reference\n- https://spring.io/projects/spring-boot\n- https://www.bottlehs.com/springboot/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%86%8C%EA%B0%9C/",
    "tags": [
      "spring-boot",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "gRPC - google Remote Procedure Call",
    "url": "/network/2022/03/19/grpc---google-remote-procedure-call/",
    "category": "network",
    "date": "2022-03-19",
    "excerpt": "1. PC의 개념이 없던 시절 프로그램은 하나의 메인 프레임에서 동작하는 Monolothic구조로 설계되었다.\n2. 기술 발전에 따라 PC와 같은 소형 컴퓨터 장비들이 등장함.\n3. 기업 입장에서 고가인 메인 프레임워크를 비교적 저렴한 저가의 워크스테이션 서버로 대체하고 싶지만, 메인 프레임워크의 초고사양 서비스를 워크스테이션 서버에서 그대로 제공하기엔 한...",
    "content": "gRPC - google Remote Procedure Call\n\n 1. gRPC의 등장배경\n 1-1. Server-Client\n1. PC의 개념이 없던 시절 프로그램은 하나의 메인 프레임에서 동작하는 Monolothic구조로 설계되었다.\n2. 기술 발전에 따라 PC와 같은 소형 컴퓨터 장비들이 등장함.\n3. 기업 입장에서 고가인 메인 프레임워크를 비교적 저렴한 저가의 워크스테이션 서버로 대체하고 싶지만, 메인 프레임워크의 초고사양 서비스를 워크스테이션 서버에서 그대로 제공하기엔 한계가 있다.\n4. 때문에, 메인 프레임워크의 기능을 워크스테이션 서버로 분산시키고, 네트워크 연결로 서비스하는 방식Server-Client Model을 채택하게 된다.\n\n이처럼 서버와 개인 PC 간 통신이 중요해 지며, OSI 7 layer, TCP/IP 등 네트워크 계층 구조가 정의되고 발전되기 시작한다.\n\n 1-2. IPC - Inter Process Comunication\n프로세스는 기본적으로 상호 독립적이지만, 필요에 따라 프로세스간 정보를 교환해야 하는 경우가 생긴다. 이 때 별도 수단을 활용하여 프로세스 간 통신 방법론을 통칭하여 IPC - Inter Process Comunication 라고 한다.\n- socket, message queue, pipe, rpc, rest등이 있다.\n\n 1. Socket\nsocket이란, OSI 7 layer 구조의 Application LayerL7에서 Transport PortL4의 TCP 또는 UDP를 이용하기 위한 수단이다.\n\nsocket은 대부분 언어에서 API로 제공되어 편리하지만 다음과 같은 단점이 있다.\n- 일련의 통신 과정을 직접 구현하므로 통신 관련 장애를 개발자가 직접 처리해야 한다.\n- 서비스가 고도화될 수록 수 많은 데이터가 돌아다니게 될텐데, 이에 따라 data formatting 을 하는 것도 점점 어려워지게 된다.\n\n\n이런 소켓의 한계에서 RPC가 등장하게 되었다.\n 2. RPC - Remote Procedure Callrpc.md\n이름 그대로 네트워크로 연결된 서버 상의 프로시저함수, 메서드 등를 원격으로 호출할 수 있는 기능이다.\n- 통신이나 call방식에 신경쓰지 않고 원격지의 자원을 사용할 수 있다.\n- IDL - Interface Definication Language기반으로 다양한 언어를 가진 환경에서 쉽게 확장할 수 있다.\n\n\nRPC는 상당히 획기적인 방법론이었으며, 분산 환경의 등장에 따라 함께 발전해 온 오래된 기술이며 여러 구현체 CORBA, RMI 등이 있었지만...  \n이들 모두\n- 구현의 어려움\n- 지원 기능의 한계\n\n등으로 제대로 활용되지 못하고 REST가 우위를 점하게 된다.\n\n 3. REST\nREST는 HTTP/1.1 기반으로 URI를 통해 모든 Resource을 명시하고 HTTP Method를 통해 처리하는 아키텍쳐이다.\n\n- HTTP를 계승하여 별도 작업 없이 쉽게 사용할 수 있다.\n\n하지만... \n- REST는 표준이 아닌 방법론이기 때문에 parameter와 응답 값이 명시적이지 않다.\n- HTTP 메소드의 형태가 제한적이기 때문에 세부 기능 구현에는 제약이 있다.\n  > ex. 로그인을 POST로 구현함\n- data format으로 xml, json을 많이 사용하는데...\n  - xml은 복잡하고 비효율적인 구조로 속도가 느리고,\n  - json은 제공 데이터의 한계로 파싱 후 추가 형변환이 필요하다.\n  - xml, json모두 string 기반이라 사람이 읽기 편하지만 데이터 전송 및 처리를 위해선 별도의 Serialization이 필요하다.\n\n 2. gRPC의 개념과 특징\n> Socket, REST의 한계를 극복하고 기존 RPC구현체들의 단점을 보완한 기술\n\ngRPC는 google에서 개발한 오픈소스 RPCrpc.md 프레임워크이다.\n\n이전까지 RPC기능은 제공하지 않고 메세지JSON 등을 Serialize할 수 있는 프레임워크인 PBProtocol Buffer, 프로토콜 버퍼만을 제공해왔는데,  \nPB기반 Serizlaizer와 HTTP/2를 결합하여 RPC프레임워크를 탄생시켰다.\n\n 특징\n- HTTP/2를 사용한다.\n- Protocol Buffer로 데이터를 전달한다.\n  > Proto File만 배포하면 환경과 프로그램 언어에 구애받지 않고 서로 간 통신이 가능하다.\n\n 3. gRPC의 핵심 기술\n 3-1. HTTP/2\n\n HTTP/1의 문제점\n- HTTP/1은 기본적으로 요청이 올때만 서버가 응답을 하는 구조로 매 요청마다 connection을 생성해야 하고, \n- cookie등 많은 메타 데이터를 저장하는 header가 요청마다 중복 전달되어 느렸다.\n\n HTTP/2의 장점\n- HTTP/2에서는 하나의 connetion으로 여러개의 메시지를 주고받으며, \n- header를 압축하여 중복 제거 후 전달하기에 HTTP/1보다 효율적이다.\n- 필요시 클라이언트의 요청 없이 서버가 리소스를 전달할 수 있어 클라이언트의 요청을 간소화할 수 있다.\n\n<img width=\"450\" src=\"/assets/images/posts/network/httpv1-vs-httpv2-connection.png\">\n\n 3-2. Protocol Buffer\nProtocol Buffer는 google사에서 개발한 구조화된 데이터를 직렬화 - Serialization하는 기법이다.\n\n아래 예제처럼 같은 정보를 저장해도 \n- text기반인 json의 경우 82byte가 소요되지만,  \n- 직렬화된 protocol buffer는\n  1. 필드 번호, 필드 유형 등을 1byte로 받아 식별하고,  \n  2. 주어진 length만큼 읽도록 하여 단지 33byte만 필요하게 된다.\n\n json\njson\n{\n    \"userName\": \"Martin\",\n    \"favouriteNumber\": 1337,\n    \"interests\": \"daydreaming\", \"hacking\"\n}\n\n protocal buffer\nproto\nmessage Person {\n    required string user_name        = 1;\n    optional int64  favourite_number = 2;\n    repeated string interests        = 3;\n}\n\n<img width=650 src=\"/assets/images/posts/network/protobuf-byte.png\">\n\n 3-3. Proto File\nProtocol Buffer 에서 사용하는 데이터 타입에 대한 정의 같은 Protocol Buffer 의 기본 정보를 명세한다.\n> 공식문서: https://developers.google.com/protocol-buffers/docs/proto3\n\n 1. Message & Field\nProto File에서는 주고 받는 data들을 message 라는 것으로 정의한다.\n\nproto\nsyntax = \"proto3\"\n\nmessage SearchRequest {\n    string query_1 = 1;\n    string query_2 = 2;\n    int32 page_number = 3;\n    int32 result_per_page = 4;\n}\n\n\n- Naming\n  - message 이름은 CamelCase 권장\n  - field 이름은 snake_case 권장\n  - 숫자 표기시 문자 뒤에 표기\n- Field Tag = Field number  \n  : 메시지에 정의된 필드들은 각각 고유한 번호를 가지게되고 이는 Enconding 이후 binary data에서 필드를 식별하는데 사용된다.\n  - Field Tag는 최소 1, 최대 536,870,911=229–1 로 지정 가능하다.\n  - 19000 ~ 19999는 프로토콜 버퍼 구현을 위해 reserved 된 값이므로 사용할 수 없다.\n- proto2 VS proto3  \n  syntax = “proto3”을 지정해줌으로써 proto version 3의 규약을 따르겠다고 선언했다. 이를 명시하지 않으면 default로 version2 문법을 따른다.\n  - proto2 지원 언어 : C++, Java, Python, Go 등...\n  - proto3 지원 언어 : C++, Java, Python, Go, Ruby, Objectice-C, C, JavaScript, PHP, Dart 등...\n- Proto File Field Rule\n  - required : 필수로 가져야 할 필드 only use proto2\n  - optional : 해당 필드를 가지지 않거나 하나만 가짐 only use proto2\n  - repeated : 임의 반복 가능한 필드 번호 및 값의 순서는 보존\n  - packed=true 옵션 : key-value 쌍 형태에서 value만 반복\n\nproto2 의 경우 required 와 optional 을 필드별로 무조건 명시해야한다.\n\n 2. Package\npackage는 message type 이름을 중첩없이 구분할 때 사용한다.\n\npackage 미사용 예제\nproto\nmessage Open{\n    //...\n}\n\nmessage Foo{\n    Open open = 1;\n}\n\n\npackage 사용 예제\nproto\npackage foo.bar\nmessage Open{\n    //...\n}\n\nmessage Foo{\n    Open open = 1;\n}\n  \n\n 3. Service\nService는 RPC를 통해 서버가 클라이언트에게 제공할 함수의 형태를 정의한다. \n- 서비스명과 RPC 메소드명 모두 CamelCase 형태를 권장한다.\n- stream옵션을 주지 않으면 request-response로 동작하지만, stream 옵션을 주면 RPC를 구현할 수 있다.\n\nUnary RPC 예시\nproto\nservice SearchService {\n   rpc Search SearchService returns SearchResponse;\n}\n\n\n양방향 Streaming RPC 예시\nproto\nservice SearchService {\n    rpc Search stream SearchRequest returns stream SearchResponse\n}\n\n\n\n Reference\n- https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460\n- https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html",
    "tags": [
      "protocol",
      "rpc",
      "TIL"
    ]
  },
  {
    "title": "Gradle",
    "url": "/back-end/2022/03/19/gradle/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> Java 진영에서 사용하는 Build Tool../build-tool.md이다.",
    "content": "Gradle\n> Java 진영에서 사용하는 Build Tool../build-tool.md이다.\n\n 하는일\n- Artifacts Build한다.\n- Dependencies를 관리한다.\n\n 특징\n- Ant처럼 매우 유연한 범용 Build Tool 이다.\n- Maven과 같은 구조화 된 build frameWork이다. 구조의 전환이 가능\n- Maven, lvy등 기존 저장소 인프라 또는 pom.xml 파일과 ivy.xml 파일에 대한 migration의 편이성 제공\n    > 참고. maven to gradle migration./maven-to-gradle-migration.md\n- 멀티 프로젝트 Build를 지원한다.\n- 의존성 관리의 다양한 방법을 제공한다.\n- Build script를 xml이 아닌 Groovy 기반의 DSL을 사용한다.\n  > 참고. DSL: Domain Specific Language의 약자로 특정 도메인산업, 분야등 특정 영역에 특화된 언어를 말한다.\n- 기존 Build를 구성하기 풍부한 Domain modle 제공한다.\n- Gradle 설치 없이 Gradle Wrapper를 이용하여 빌드를 지원한다.\n\n 장점\n- Gradle은 Groovy라는 언어를 이요하여 코드로서 설정정보를 구성하기 때문에 구조적인 장점이 있다. + 간결한 정의가 가능하다.\n  > Ant, Maven과 같은 기존에 빌드툴은 xml형식을 이용하여 정적인 설정정보를 구성했다.\n- 프로젝트를 설정주입방식으로 정의하기 때문에 maven의 상속 구조보다 재사용에 용이하다.\n\n 기본구조\n- 모든 Gradle script는 하나 이상의 project로 구성되며, 하나이상의 task로 구성된다\n  > Project  \n  소스를 jar로 모으거나, java 프로젝트를 컴파일하거나, 테스트를 실행하고, 어플리케이션을 배포하는 등의 업무로 구성된다.\n\n  > Task  \n  작업의 최소단위이다.\n- Gradle은 Java6 버전 이상의 VM환경에서 사용가능하며, 설치를하거나 gradle wrapper를 이용하여 실행환경을 구성할 수 있다.\n\n 프로젝트 구조\n\n├── build.gradle\n├── gradle\n│   └── wrapper\n│       ├── gradle-wrapper.jar\n│       └── gradle-wrapper.properties\n├── gradlew\n├── gradlew.bat\n├── settings.gradle\n└── src\n    ├── main\n    │   ├── java\n    │   │   └── temp\n    │   │       └── App.java\n    │   └── resources\n    └── test\n        ├── java\n        │   └── temp\n        │       └── AppTest.java\n        └── resources\n\n build.gradle\n: Gradle의 기본 빌드 파일이다.  \n이 파일에 프로젝트의 빌드에 대한 내용을 명시한다.\n\n /gradle/wrapper/gradle-wrapper.jar\n: Gradle Wrapper 파일이다. gradlew 명령어로 프로젝트를 빌드 할 때 이 파일을 참조하여 설정 파일을 구성하므로 gradle build와 다르게 새로운 환경에 대한 영향이 없다.\n /gradle/wrapper/gradle-wrapper.properties\nGradle Wrapper 설정 파일이다.\n gradlew, gradlew.bat\n- gradlew - Unix용 실행 스크립트\n- gradlew.bat - Windows용 실행 스크립트\n setting.gradle\n: 프로젝트의 설정 정보 파일이다.  \n멀티 프로젝트를 구성할 때 하위 프로젝트들과의 관계를 여기서 서술해야 한다.  \n명시된 정보를 기준으로 프로젝트를 구성하게 된다.\n /src\n프로젝트의 소스 폴더가 된다.  \n/src/main/java와 /src/main/test 디렉토리 이름처럼 구조를 보면 maven과 동일하다.",
    "tags": [
      "TIL",
      "gradle",
      "build-tool"
    ]
  },
  {
    "title": "TCP/IP 4계층",
    "url": "/cs/2022/03/19/tcpip-4계층/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": DARPA에서   프로토콜을 미 국방성의 통신 표준으로 채택하면서 해당 네트워크 통신 과정을 4개의 계층으로 나누어 설명한 것이다.\n- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고 받을 수 있도록 하는 인터넷 표준 프로토콜이다.\n- 업계에서 실제적으로 사용되는 컴퓨터 통신 체계의 실질적인 표현 방법이다.",
    "content": "TCP/IP 4계층\n: DARPA에서  TCP/IP 프로토콜을 미 국방성의 통신 표준으로 채택하면서 해당 네트워크 통신 과정을 4개의 계층으로 나누어 설명한 것이다.\n- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고 받을 수 있도록 하는 인터넷 표준 프로토콜이다.\n- 업계에서 실제적으로 사용되는 컴퓨터 통신 체계의 실질적인 표현 방법이다.\n\n<img width=650 src=\"/assets/images/posts/cs/tcp-ip-4-layer.png\">\n\n 1. 네트워크 엑세스 계층 - Network Access Layer\n: 물리적 연결, 전기 신호의 변환/제어, 네트워크 기기 간 데이터 전송 및 물리 주소를 결정한다.\n> MAC, LAN, 패킷망 등에 사용한다.\n- 데이터 단위: 프레임Frame\n- 물리 주소ex. MAC 주소를 참조해 장비간 전송을 담당한다.\n- 기본적으로 에러검출/패킷의 프레임화를 담당한다.\n  > 최종적으로 데이터 전송을 하기 전 패킷헤더에 MAC주소와 오류 검출을 위한 부분을 첨부한다.\n- OSI 7계층의 물리 계층, 데이터 링크 계층에 해당된다.\n- 보통 1계층을 물리적 계층 - Physical Layer과 데이터 링크 계층 - Data Link Layer로 나눠 TCP/IP 5계층으로 이야기하기도 한다. \n\n 프로토콜\n- Ehternet, IEEE802, PPP, HDLC, X.25, RS-232C 등...\n\n 장비\n- 브리지, 스위치, 허브 등...\n\n 2. 인터넷네트워크 계층 - Internet Layer\n: 다른 네트워크와의 통신을 위한 경로와 논리적 주소IP주소 결정한다.\n- 데이터 단위: 패킷packet\n- 단말을 구분하기 위해 논리적인 주소 - Logical Address인 IP를 할당한다.\n- 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공한다.\n- 라우팅 - Routing 기능을 처리한다.\n- 패킷단위의 데이터 구성\n  > 데이터 + IP Header\n- 요즈음 클래스 리스 방식을 사용한다.\n    > 서브넷마스크로 네트워크와 호스트 주소를 구분한다.\n\n 프로토콜\n- IP, ARP, ICMP, RARP, OSPF 등...\n\n 장비 \n- 라우터 등...\n\n 3. 전송 계층 - Transport Layer\n: 데이터 전송의 신뢰성 확보하고, 2계층에서 보내온 데이터의 정렬 및 오류 정정ex. TCP/UDP한다.\n- 데이터 단위: 세그먼트Segmen\n  > 발신, 수신, 포트주소, 오류검출코드\n- 통신 노드 간의 연결 제어 및 자료 송수신을 담당\n- 애플리케이션 계층의 세션과 데이터그램 통신서비스를 제공한다.\n- 포트 번호를 논리적 주소로 사용한다.\n> - TCP는 패킷에 하나라도 오류가 있으면 재전송을 통해 에러를 복구하기 떄문에 TCP 헤더에 붇는 정보가 많다.\n> - 하지만 UDP는 패킷을 중간에 잃거나 오류가 발생해도 대처하지 않기 때문에 간단한 구조를 가진다.\n\n 프로토콜\n- TCP, UDP, RTP, RTCP 등\n\n 장비\n- 게이트웨이\n\n 4. 응용 계층 - Application Layer\n: 사용자에게 제공되는 어플리케이션에 사용하는 통신의 움직임을 결정한다.\n- 데이터 단위: Data/Message\n- 응용프로그램application들이 데이터를 교환하기 위해 사용되는 프로토콜이다.\n- 사용자 응용프로그램 인터페이스를 담당한다.\n\n 프로토콜\n- FTP, SSH, DNS, TELNET, HTTP 등...",
    "tags": [
      "TIL",
      "Network"
    ]
  },
  {
    "title": "메모리의 구조",
    "url": "/cs/2022/03/19/메모리의-구조/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "> 프로그램은 보조 기억 장치에 보관되어있다가 실행되면 필요한 부분만 따로 주기억장치RAM에 로드한다.  \n> 메모리의 구조를 알기 전에 먼저 프로그램의 실행 순서를 알아보자!\n> \n<img width=550 src=\"/assets/images/posts/cs/execute-program.png\">",
    "content": "메모리의 구조\n 프로그램 실행 순서\n> 프로그램은 보조 기억 장치에 보관되어있다가 실행되면 필요한 부분만 따로 주기억장치RAM에 로드한다.  \n> 메모리의 구조를 알기 전에 먼저 프로그램의 실행 순서를 알아보자!\n> \n<img width=550 src=\"/assets/images/posts/cs/execute-program.png\">\n\n프로그램의 실행 순서를 요약하자면 프로그램이 실행되면 OS는 메모리RAM에 공간을 할당한다.\n\n 이 때 할당해주는 메모리 공간은 4가지Code, Data, Heap, Statck이 있다.\n> 이 md는 Code, Data, Heap, Stack에 관해 설명할 것이다.\n\n 메모리 구조\n메모리 구조는 다음과 같다.  \n<img src=\"/assets/images/posts/cs/memory-structure.png\">\n\n 코드Code 영역\n: 실행할 프로그램의 코드가 저장되는 영역 == 텍스트code영역\n- 실행 파일을 구성하는 명령어컴파일된 기계어들이 올라가는 메모리 영역이다.  \n  함수, 제어문, 상수 등\n- 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.\n\n 데이터Data 영역\n: 프로그램의 전역 변수와 정적Static 변수, 문자열 상수가 저장되는 영역이다.\n- 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리가 소멸된다.   \n  &rarr; 프로그램과 라이프 사이클이 같다.\n\n 스텍statc 영역\n: 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.\n- 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다.\n- 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임Stack Frame이라고 한다.\n- 컴파일 시 크기가 결정된다.\n- 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.\n 장점\n- 낭비되는 공간이 없다.\n- 나의 명령만으로 메모리 조작과 어드레스 조작이 가능하다.\n 단점\n- 한계가 있어 한계를 초과하도록 삽입할 수 없다.ex. stack overflow &rarr; 유연성이 부족하다.\n\n 힙Heap 영역\n사용자가 직접 관리할 수 있고, 관리 해야만 하는 메모리 영역이다.\n- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.\n  > Java는 garbage collectorGC, swift는 Auto Reference CountingARC가 관리한다.\n- 클래스, 클로저 등\n- 런타임시 크기가 결정된다.\n- 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.\n\n 장점\n- 프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우에 사용 가능하다.\n- 개체가 너무 커서 스택 할당자에 맞지 않는 경우 사용 가능.\n\n 단점\n- 할당/해제 작업 인한 속도 저하\n    > 해제 작업같은 경우에는 주로 병합을 사용할때 해제 작업에 더 많은 주기가 필요하다.\n- 힙 손상으로 인한 속도 저하\n    > 이중 해제, 해제 후 블록 사용, 블록 경계를 벗어나 덮어쓰기 등이 가장 많이 발생한다.\n- 힙 경합으로 인한 속도 저하\n    - 두 개 이상의 쓰레드에서 동시에 데이터에 액세스하려고 하면 경합이 발생 한다.   \n    즉, 한 쪽 쓰레드의 작업이 완료되어야 다른 쪽 쓰레드의 작업이 진행될 수 있다.\n    > 다중 프로세서 시스템에서 일어나는 문제 중 가장 큰 문제다.\n\n>  높은 주소? 낮은 주소?\n> 0x00000000가장 낮은 주소는 상대적으로 0xFFFFFFFF가장 높은보다 주소가 낮다.  \n> 반대로 0xFFFFFFFF의 주소값은 0x00000000보다 상대적으로 주소가 높다.\n\n이글을 잇는 다음글은 Stack과 Heap의 차이점에 대한 글이 될 예정!\n 자료조사 후기\n이러한 메모리 구조도 모르고 코딩을 하고 있었던 나 자신이 부끄럽다.. ///  \n한편으로는 내 코드가 어떤 식으로 저장되며 동작하고 있었다는 것을 꺠달아 설래기 시작했다.  \n앞으로 기본적인 공부를 열심히 해보자!\n\n원래는 직렬화에 대해 공부하다가 메모리에 대한 공부를 하게 되었는데 직렬화 정리 끝내고 JVM에 대한 정리를 해야겠다",
    "tags": [
      "Memory",
      "TIL"
    ]
  },
  {
    "title": "연결 리스트 - Linked List",
    "url": "/cs/2022/03/19/연결-리스트---linked-list/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 연결 리스트는 노드node들로 이어진 리스트를 말한다.  ",
    "content": "연결 리스트 - Linked List\n: 연결 리스트는 노드node들로 이어진 리스트를 말한다.  \n 연결리스트의 예 - 단일 연결 리스트\n<img width=\"600\" src=\"/assets/images/posts/cs/linked-list-ex.png\">\n\n- 노드는 보통 데이터를 저장하는 부분과, 다음 노드를 가르키는 부분으로 구성된다.\n- 연결 리스트는 처음과 끝을 가르키는 포인터들을 이용해 리스트를 관리한다.\n- 단일 연결리스트, 원형 연결 리스트, 이중 연결 리스트가 있다.\n\n 노드의 구조 예 - 단일 연결 리스트\n<img width=\"150\" src=\"/assets/images/posts/cs/linked-list-node-structure.png\">\n\n- 노드는 데이터를 갖고있는 데이터 필드와 리스트의 다음 원소를 가리키는, 링크필드포인터로 구성된다.\n\n 연결 리스트 특징\n- 포인터로 연결한다.\n  > 원소들이 메모리 내 어느 위치에도 가능\n- 크기가 가변적이다.\n  > 메모리가 허용하는 만큼 커질 수 있음\n- 원소의 순서 유지되고, 순차 접근을 한다.\n  > 원소의 순서는 링크를 이용하여 유지시켜 준다, 탐색시 순차적으로 접근해야 하므로 시간복잡도 ON을 가진다.\n- 선형 리스트에 비해 구현이 어렵다.\n  > 포인터의 저장 필요에 저장공간이 조금더 많이 소요되나, 빈공간을 거의 없게 할 수 있다.\n- 다른 자료구조추상자료형, ADT의 기반이 된다.\n  > 큐, 스택, 해시 테이블 등\n\n 연결 리스트 단점\n 1. 캐싱에 적합하지 않은 구조\n> 탐식시 연결 리스트보다 배열순차 리스트가 연결 리스트를 압도한다 이유가 무엇일까?\n\n<img src=\"/assets/images/posts/cs/cpu-cache.jpeg\">\n\n결론은 컴퓨터에 있는 캐시Cache라는 저장 공간이 그 이유다.  \n1. CPU는 메인메모리에 적재load된 소스코드를 한줄씩 읽어서 처리하는데   \n  메인메모리RAM의 경우 CPU에 비해 데이터 처리 속도가 압도적으로 느리다.\n2. 때문에 CPU에서 작업을 완료해도 RAM에 있는 데이터나 소스코드가 전송되지 않아서 CPU가 오랜시간 대기하는 경우가 생긴다.\n3. 이러한 문제를 해결하기 위해 이 둘 사이에 캐시라는 저장공간을 만들고 RAM에 적재된 정보 중 일부를 캐시에 미리 적재한다.\n   > 캐시는 SRAM기반으로 DRAM기반의 RAM보다 훨씬 빠르다.\n4. CPU는 RAM이 아닌 캐시에서 정보들을 가져오게 되고 이러한 캐싱 방식을 이용하면 CPU가 쉬는 시간을 극도로 줄일 수 있다.\n\n왜 연결 리스트는 캐싱에 적합하지 않을까?\n- 배열: 같은 타입의 데이터들이 연속된 메모리에 저장되어 있어 이 데이터들을 한번에 캐시로 넘길 수 있다.\n- 연결 리스트: 데이터를 메모리 곳곳에 저장한 뒤, 이들을 주소로만 연결한 구조이기 때문에 데이터가 캐시로 한번에 넘어 올 수 없다.\n\n 2. 복잡한 연산에 따른 오버헤드\n: 일반적으로 배열리스트의 연산들보다 연결리스트의 연산들이 훨씬 복잡하다.\n- 모든 연산을 수행할 때 더 많은 명령어가 필요하고 때문에 더 많은 오버헤드가 발생하게 된다.\n- 알고리즘의 시간 복잡도 이외에도 추가적인 시간들이 소모된다.\n\n 3. 주소 저장으로 인한 공간 낭비\n: 데이터 이외에도 주소에 대한 정보를 반드시 가지고 있어야하기 때문에 주소에 대한 용량이 소모된다.\n- 정수형 리스트의 경우 데이터integer, 주소integer를 저장하기 때문에 배열리스트와 비교하여 2배의 용량이 필요하다. \n- 하지만 빈 값을 허용하지 않는다.\n\n 1. 단일 연결 리스트 - Singly Linked List\n: 포인터를 통해 단방향으로 다음 노드를 가르키는 자료구조이다.  \n<img src=\"/assets/images/posts/cs/single-linked-list.png\">\n\n- 모든 원소가 데이터, 링크 쌍으로 이루어져 있다.\n- 원소의 삽입과, 삭제가 용이하다.\n\n 삽입 / 삭제 연산\n> 일반적으로 삽입/삭제 연산은 상수, O1 시간복잡도를 갖는다.  \n> 하지만 현실적인 삽입/삭제 연산은 탐색이 포함되므로 결국 O1 + n즉, On의 시간복잡도를 가진다.\n\n 1. 맨 앞에 노드 삽입\n> Head만 있으면 되므로 O1의 시간복잡도를 갖는다.\n<img width=\"700px\" src=\"/assets/images/posts/cs/singly-list-head-insert.png\">\n\n1. 새로운 노드를 생성한다.\n2. 새로운 노드의 링크를 헤더 다음으로 가리키도록 한다.\n3. 헤더의 링크는 새로운 노드를 가르키게 한다.  \n\n\n 2. 맨 뒤에 노드 삽입\n> On의 시간복잡도를 가진다.\n<img width=\"700px\" src=\"/assets/images/posts/cs/마지막_노드_추가.png\">\n\n1. 새로운 노드를 생성한다.\n2. 마지막 노드를 찾는다.\n3. 마지막 노드는 새로운 노드를 가르키게 한다\n\n 3. 원하는 곳index에 노드 삽입\n> 원하는 노드를 탐색 후 삽입하므로 시간복잡도 On + 1즉, On를 갖는다.\n\n<img width=\"700px\" src=\"/assets/images/posts/cs/인덱스_노드_추가.png\">\n\n1. 새로운 노드를 생성한다.\n2. 특정 인덱스의 노드cru와 그 이전 노드prev를 찾는다.\n3. prev가 새로운 노드를 가르키고, 새로운 노드가 cur를 가리키도록 한다.\n\n 4. 특정 노드 삭제\n> 원하는 노드를 탐색 후 삭제하므로 시간복잡도 On + 1즉. On를 갖는다.\n<img src=\"/assets/images/posts/cs/인덱스_노드_삭제.png\">\n\n1. 삭제할 노드를 없앤다.\n2. 삭제할 노드의 이전 노드의 포인터를 삭제할 노드의 다음 노드로 지정해주면 된다.\n\n 단일 연결 리스트의 단점\n- 이전 리스트의 값을 확인하려면 다시한번 탐색을 해야 한다.\n\n 2. 원형 연결 리스트 - Circular Linked List\n: 리스트의 마지막 노드헤드의 링크가 첫 번째 노드를 가리키는 연결 리스트이다.  \n<img width=\"600\" src=\"/assets/images/posts/cs/circular-linked-list.png\">\n\n- 헤드의 링크link는 리스트의 첫 번째 노드를 가르킨다.\n  > 리스트의 처음이나 마지막에 노드를 삽입하는 연산이 편리해진다.\n\n 삽입 연산\n 1. 앞부분 삽입 연산 - Head다음 위치에 삽입\n> 시간복잡도는 Head만 알고 있으면 되므로 탐색이 필요하지 않아 O1이다.\n\n<img width=\"400\" src=\"/assets/images/posts/cs/circular-linked-front-insert.png\">\n\n1. 새로 삽입할 node의 link를 head의 link로 할당\n   > head는 리스트의 삽입 이전 첫번째 노드의 포인터를 가지고 있기 때문\n2. head의 link를 node로 할당\n\n순서가 변경되면 안된다. 만약 2를 먼저 실행하면 새로 삽입할 node의 link를 지정할 주소를 알지 못한다.\n\n 2. 뒷부분 삽입 연산\n<img width=\"400\" src=\"/assets/images/posts/cs/circular-linked-back-insert.png\">\n\n1. node의 link를 head의 link로 할당\n2. head의 link를 node로 할당\n   > head는 리스트의 제일 마지막 노드를 의미하므로\n3. head를 node로 변경\n\n순서가 변경되면 안된다. 2과정이 먼저 일어나면 지정할 주소를 잃어버리게 된다.\n\n 3. 원하는 곳index에 노드 삽입\n단일 연결리스트의 3번 삽입 연산과 같다.3-원하는-곳index에-노드-삽입\n다만 head가 맞는지 아닌지 예외처리를... 해야 할 것이다뇌피셜\n\n 삭제 연산\n단일 연결리스트의 4번 삭제 연산과 같다.4-특정-노드-삭제\n\n 3. 이중 연결 리스트 - Doubly Linked List\n: 각 노드가 선행 노드와 후속 노드에 대한 링크를 가지는 리스트이다.\n<img src=\"/assets/images/posts/cs/doubly-linked-list.png\">\n\n- 노드의 왼쪽 링크left link는 현제 노드의 왼쪽 노드를 가르킨다. \n- 노드의 오른쪽 링크right link는 현재 노드의 오른쪽 노드를 가르킨다.\n- 헤드노드도 노드로 이루어져 있다.\n- 노드가 양방향으로 연결되어 있으므로 탐색도 양방향이 가능하다.\n- 하지만 노드의 포인터는 단일 연결 리스트에 비해 1개 더 늘어난다.\n\n>참고. right link == previous link, left link == next link\n\n 헤드노드 - head Node\n: 데이터를 가지지 않고 오로지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드이다.\n- 헤드 포인터만의 구별이 필요하다. &rarr; 헤드노드에는 데이터가 없다.\n- 리스트가 공백상태라면 헤드노드만 존재하는 상태이다.\n- 왼쪽 링크left link: 리스트의 마지막 노드를 가리킨다\n- 오른쪽 링크right link: 리스트의 맨 첫번째 노드를 가리킨다.\n\n\n 삽입 연산\n> new_node를 before의 앞쪽에 삽입하는 연산  \n> 시간 복잡도: 특정노드의 위치를 정확하게 알면 O1, 탐색이 필요하면 On + 1 즉, On\n\n<img src=\"/assets/images/posts/cs/doubly-insert-ops.png\">\n\n> 이상적인 순서는 1 &rarr; 2 &rarr; 3 &rarr; 4 이지만 순서마다 차이가 날 수 있다.\n1. new_node의 left link가 before를 가리킨다.\n2. new_node의 right link가 before의 rlink를 가리킨다.\n3. before의 right link의 left link가 new_node를 가르킨다.\n4. before의 right link는 now_node를 가르킨다.\n\n2, 3번은 무조건 4번 앞에 수행되어야 한다.\n\n필요한 예외 처리 - 선행자를 찾을 수 없을때 즉, 해당 리스트가 없을 때초기화 x\n\n 삭제 연산\n> 삭제하려는 노드를 removed변수로 받아서 삭제 연산을 수행한다.  \n> 시간 복잡도: 특정노드의 위치를 정확하게 알면 O1, 탐색이 필요하면 On + 1 즉, On\n\n<img src=\"/assets/images/posts/cs/doubly-delete-ops.png\">\n\n> 순서는 상관 없다.\n1. removed의 left link는 removed의 right link를 가르킨다.\n   > 삭제할 노드의 이전 노드가 없을 때\n2. removed의 right link는 removed의 left link를 가르킨다.\n   > 삭제할 노드의 다음 노드가 없을 때",
    "tags": [
      "data-structure",
      "linear",
      "list",
      "TIL"
    ]
  },
  {
    "title": "Querydsl",
    "url": "/back-end/2022/03/19/querydsl-1/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": Querydsl 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있도록 해 주는 프레임워크이다\n- Querydsl은 타입에 안전한 방식으로 HQL 쿼리를 실행하기 위한 목적으로 만들어졌다.\n- Querydsl은 Java code로 query를 만들 수 있다.",
    "content": "Querydsl\n: Querydsl 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있도록 해 주는 프레임워크이다\n- Querydsl은 타입에 안전한 방식으로 HQL 쿼리를 실행하기 위한 목적으로 만들어졌다.\n- Querydsl은 Java code로 query를 만들 수 있다.\n\n 왜 사용할까?\n- Spring Boot와 스프링 데이터JPA는 복잡한 쿼리와 동적 쿼리를 하기 힘들다.\n- 하지만 네이티브 query를 사용하기에는 문자열를 사용해야 되고 문제를 Runtime에 확인할 수 밖에 없다.\n\n 사용 예시\n불편한 순간이라는 익명 게시판을 모두 select해서 DTO로 반환하는 매서드 이다. UncomportableDomain &rarr; UncomfortableResponseDto\njava\n    @Query\"SELECT new com.moment.the.uncomfortable.dto.UncomfortableResponseDtotable.uncomfortableIdx, table.content, table.goods, answer\" +\n            \"FROM UncomfortableDomain table LEFT JOIN table.answerDomain answer \" +\n            \"ORDER BY table.uncomfortableIdx DESC \"\n    \n    List<UncomfortableResponseDto> uncomfortableViewAll;\n\n여기에서는 @Query를 통해 JPQL를 직접 문자열로 작성했다. 그래서 다음 문제점들을 가지고 있다.\n- Compile시점에 해당 Query문에 있는 에러를 찾기 힘들다.\n- 만약 native query를 사용했다면 runtime일일히 오류를 찾아야 한다.\n\n위 매서드를 Querydsl로 바꾸면 다음과 같다.\njava\npublic List<UncomfortableResponseDto> uncomfortableViewAll {\n    return queryFactory\n            .fromuncomfortableDomain\n            .selectProjections.constructorUncomfortableResponseDto.class, // 생성자를 통해 DTO로 select한다.\n                uncomfortableDomain.uncomfortableIdx,\n                uncomfortableDomain.content,\n                uncomfortableDomain.goods\n            \n    .fetch;\n}\n\n- Java code로 만들어 IDE의 도움과 컴파일 시점에 오류를 해결할 수 있다.\n- 반북되는 부분은 따로 메서드를 이용해 재사용이 가능하다!  \n  재사용 예시\n  java\n      JPAQuery<UncomfortableResponseDto> convertToDto{\n        return queryFactory\n                .fromuncomfortableDomain\n                .selectProjections.constructorUncomfortableResponseDto.class, // 생성자를 통해 DTO로 select한다.\n                        uncomfortableDomain.uncomfortableIdx,\n                        uncomfortableDomain.content,\n                        uncomfortableDomain.goods\n                ;\n    }\n\n    public List<UncomfortableResponseDto> uncomfortableViewAll {\n        return convertToDto.fetch;\n    }\n\n  \n\n Querydsl 적용방법 - SpringBoot with gradle\n build.gradle\nplugins 부분\ngroovy\nplugins {\n\n    ...\n    id 'io.spring.dependency-management' version '1.0.11.RELEASE' // Spring프로젝트의 의존성을 관리한다.\n\n    id \"com.ewerk.gradle.plugins.querydsl\" version \"1.0.10\" // querydsl plugin\n    id \"io.franzbecker.gradle-lombok\" version \"3.0.0\" // Q-Type error 발생 시 추가\n}\n\n- Querydsl를 사용하기 위해com.ewerk.gradle.plugins.querydsl plugin를 추가한다.\n- 만약 Q-Type error 발생 시 io.franzbecker.gradle-lombok plugin를 추가한다.\n\ndependencies 부분\ngroovy\ndependencies {\n    ...\n\n    implementation 'com.querydsl:querydsl-jpa' // 추가\n\n    ...\n}\n\n- Querydsl를 사용하기 위해com.querydsl:querydsl-jpa의존성을 추가한다.\n\nQuerydsl관련 task작성\ngroovy\ndef querydslDir = \"$buildDir/generated/querydsl\" as String // queryDSL이 생성하는 QClass 경로 설정\nquerydsl {\n    jpa = true\n    querydslSourcesDir = querydslDir\n}\nsourceSets {\n    main.java.srcDir querydslDir\n}\nconfigurations {\n    querydsl.extendsFrom compileClasspath\n}\ncompileQuerydsl {\n    options.annotationProcessorPath = configurations.querydsl\n}\n\n Q-class 생성하기\nQ-class란 APT를 이용해 Entity의 정보를 가지고 생성되는 class이다.\n\n> APT - Annotation Processing Tool  \n> Annotation 이 있는 기존코드를 바탕으로 새로운 코드와 새로운 파일들을 만들 수 있고, 이들을 이용한 클래스에서 compile 하는 기능도 지원해준다.\n\n 1. Entity 생성\n> Q-class를 생성하기 전 그에 필요한 Entity가 있어야 된다.\n\n예시 Entity\njava\n@Entity\n@Getter @Setter\npublic class Hello {\n    @Id @GeneratedValue\n    private Long id;\n}\n\n\n 2. Q-class 생성\n1. Gradle 콘솔 사용방법\nsh\n linux, macOS\n./gradlew clean compileQuerydsl\n\n windows\n./gradlew.bat clean compileQuerydsl\n\n\n2. Gradle IntelliJ 사용법\n1. Gradle &rarr; Tasks &rarr; build &rarr; clean  \n   <img width=400 src=\"/assets/images/posts/back-end/gradle-clean.png\">\n2. Gradle &rarr; Tasks &rarr; other &rarr; compileQuerydsl  \n   <img width=\"400\" src=\"/assets/images/posts/back-end/create-qclass.png\">\n\n예시 Q-class는 위 코드 예시의 Entity를 기반으로 만들었다.  \n<img src=\"/assets/images/posts/back-end/q-class-generate-ex.png\">",
    "tags": [
      "spring",
      "querydsl",
      "TIL"
    ]
  },
  {
    "title": "Build Tool",
    "url": "/back-end/2022/03/19/build-tool/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 빌드 도구는 빌드 자동화를 시켜주는 실행가능한 프로그램만들어 주는 프로그램을 말한다.",
    "content": "Build Tool\n: 빌드 도구는 빌드 자동화를 시켜주는 실행가능한 프로그램만들어 주는 프로그램을 말한다.\n\n> 빌드 자동화  \n> : 실행가능한 프로그램을 만들어주는 과정으로써 코드를 컴파일해서 binary code로 만들고 패키징하며 코드를 테스트하고 실행가능한 프로그램이 나오기 까지의 과정\n\n> 빌드  \n> : 소스코드 파일들을 컴퓨터에서 실행할 수 있는 소프트웨어로 변환하는 일련의 과정으로, 컴파일, 테스팅, 배포 등 모든 과정의 집합이다.\n\n Build Tool의 역활\n- 빌드 과정을 자동으로 수행해준다.\n- 라이브러리 추가 및 관리\n\n 자바 진영에서의 빌드 도구\n> 출시 순서는 내림차순\n- Ant\n- Maven\n- Gradle\n\n Java 진영에서의 Build Tool의 사용목적\nJava 프로그램은 다음가ㅗ 같이 많은 파일artifacts을 포함하고 있다.\n- Java Source code\n- Java Byte code\n- XML files\n- Graphic and audio file\n- Directory structures\n\n이모든 파일을 충동없이 Build하는건 힘들일이다.  \nBuild Tool은 우리가 소스를 작성하는 것과 동시에 빌드 할 수 있도록 도와주는 일이다.",
    "tags": [
      "TIL",
      "build-tool"
    ]
  },
  {
    "title": "기본키 매핑",
    "url": "/back-end/2022/03/19/기본키-매핑/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "@Id 만 사용한다.",
    "content": "기본키 매핑\n\n 기본키 매핑 방법\n 1. 직접 할당\n@Id 만 사용한다.\n\n 2. 자동 생성\n@Id 와 @GeneratedValue를 사용한다.  \n- IDENTITYIDENTITY-전략 : DB에 위임, MYSQL\n- SEQUENCESEQUENCE-@SequenceGenerator : DB 시퀀스 오브젝트 사용, ORACLE\n    - @SequenceGenerator 필요\n- TABLETABLE-전략: 키 생성용 테이블 사용, 모든 DB에서 사용 가능하다\n    - @TableGenerator 필요\n- AUTO: 방언에 따라 자동 지정, 기본값\n\n 기본키 자동 생성 전략\n IDENTITY 전략\n: 기본 키 생성을 DB에 위임한다.\n- MySQL, PostagreSQL, SQL Server, H2DB 에서 사용 \n    > MySQL은 AUTO_INCREMENT\n- AUTO_INCREMENT는 DB INSERT SQL을 실행한 이후 ID값을 알 수 있다.\n- em.persis 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자 조회한다.\n    >즉, INSERT SQL을 실행할 때까지 기본키 값을 확인할 수 없다.\n\n SEQUENCE @SequenceGenerator\n: DB 시퀀스 오브젝트 사용한다.\n- 아이디 값을 임의로 넣으면 안 된다.\n- 영속성 컨텍스트에 값을 저장할 때 DB sequence에서 기본키 값을 가져온다.\n    > insert 쿼리는 날아가지 않는다.\n\n\n속성\n|속성|설명|기본값|\n|---|---|----|\n|name|식별자 생성기 이름|필수|\n|sequenceName|DB에 등록되어 있는 시퀀스 이름|hibernate_sequence|\n|initialValue|DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 떄 처음 1 시작하는 수를 지정한다.|1|\n|allocationSize|시퀀스 한 번 호출에 증가하는 수 성능 최적화에 사용, DB 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야한다.|50|\n|catalog, schema| DB catalog, schema 이름||\n\n예시\njava\n@Entity\n@SequenceGenerator\n    name = \"MEMBER_SEQ_GENERATOR\",\n    sequenceName = \"MEMBER_SEQ\",\n    initialValue = 1, allocationSize = 1\npublic class Member {\n    @Id\n    @GeneratedValuestrategy = GenerationType.SEQUENCE,\n            generator = \"MEMBER_SEQ_GENERTOR\"\n    privat Long id;\n}\n\n\n TABLE 전략\n: 키 생성 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내 내는 전략\n- 모든 DB에 적용 가능하나 성능이 않좋다.\n> 그냥 사용잘 안 한다. 알아만 두자\nsql\ncreate table MY_SEQUENCES \n    sequence_name varcar255 not null,\n    next_val bigint,\n    primary key  sequence_name \n\n\njava\n@Entity\n@TableGenerator\n    name = \"MEMBER_SEQ_GENERATOR\",\n    table = \"MY_SEQUENCES\",\n    pkColumnValue = \"MEMBER_SEQ\", allocationSize = 1\npublic class Member {\n    \n    @Id\n    @GeneratedValuestrategy = GenerationType.TABLE,\n            generator = \"MEMBER_SEQ_GENERATOR\"\n    private Long id;\n}\n\n@TalbeGenerator - 속성\n|속성|설명|기본값|\n|---|---|----|\n|name|식별자 생성기 이름|필수|\n|table|키생성 테이블명|hibernate_sequences|\n|pkColumnNmae|시퀀스 컬럼명|sequence_name|\n|valueColumnNa|시퀀스 값 컬럼명|next_val|\n|pkColumnValue|키로 사용할 값 이름|엔티티 이름|\n|initialValue|초기 값, 마지막으로 생성된 값이 기준이다|0|\n|allocationSize|시퀀스 한 번 호출에 증가하는 수성능 최적화에 사용됨|50|\n|catalog, schema| DB catalog, schema 이름||\n|uniqueConstraintsDDL|유니크 제약 조건을 지정할 수 있다.||\n\n 권장하는 식별자 전략\n- 기본 키 제약 조건\n    - null이 아니다.\n    - 유일해야 한다.\n    - 불변해야 한다.엄청 어렵다\n- 대체키를 사용한다.미래까지 이 조건을 만족하는 자연키는 찾기 어렵다\n- 권장: Long형10억이 넘어도 동작 + 대체키 + 키 생성전략\n\n실무 경험 공유\n- 주민등록번호를 기본 키로 쓰고 있었다.\n- 나라에서 \"주민등록번호를 보관하면 안 된다\"라고 정책이 바뀌었다.\n- 문제는 기본키 가 아니라 기본키를 사용하는 외래키로 주민번호를 가지고 있을 것이다.\n- 마이그래이션을 진행할 때 엄청 난리 났다.\n- 만약 대체키를 사용했으면 주민등록번호 테이블을 지우거나 다른 테이블로 대체했으면 됬었다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "CORS 문제 해결",
    "url": "/back-end/2022/03/19/cors-문제-해결/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "> the moment학교가 불편한 순간 프로젝트에서 협업 도중생긴 CORS이슈  \n> 여기는 CORS에 대해 다룹니다.",
    "content": "CORS 문제 해결\n> the moment학교가 불편한 순간 프로젝트에서 협업 도중생긴 CORS이슈  \n> 여기는 CORS에 대해 다룹니다.\n CORS란?\n: Cross-Origin Resource Sharing교차 출처 리소스 공유 의 약자로  \n 브라우저에서 실행 중인 스프립트에서 시작되는 cross-origin HTTP 요청을 제한하는 브라우저 보안 기능이다.\n\n브라우저는 same-origin policy동일 출처 정책에 의해 cross-origin의 리소스를 요청을 차단한다.\n\n cross-origin 종류\n- 다른 도메인 ex. foo.com &rarr; example.com\n- 다른 하위 도메인 ex. google.com &rarr; docs.google.com\n- 다른 포트 ex. foo.com &rarr; foo.com:800\n- 다른 프로토콜 ex. https://foo.com &rarr; http://foo.com\n\n 해결방안\n제일 쉬운 해결방안은 서버 단에서 특정 origin 혹은 모든 origin 을 허용하도록 설정 하면 된다.\n\nWebMvcConfigurer 를 상속받은 WebConfig를 다음과 같이 작성한다.\njava\n@Configuration\npublic class WebMvcConfig implements WebMvcConfigurer {\n    @Override\n    public void addCorsMappingsCorsRegistry registry {\n        registry.addMapping\"/\" // 모든 요청에 대해서 허용\n                // http://localhost:8080, http://localhost:5000 에서 들어오는 요청을 허용한다.\n                .allowedOrigins\"http://localhost:8080\", \"http://localhost:5000\" \n}\n\n하지만 여기에서 끝나면 GET, POST 요청은 정상적으로 요청이 되지만   \nHEAD, PUT, DELETE HTTP method에 대해서는 CORS가 발생한다.\n\nSpringBoot 에서는 allowedOrigins 를 통해 CORS허용을 하면 기본적으로 GET, POST, HEAD 만 허용을 해준다.  \n따라서 allowedMethods를 이용해 허용할 HTTP Method를 추가해준다.\njava\n@Override\npublic void addCorsMappingsCorsRegistry registry {\n    registry.addMapping\"/\" // 모든 요청에 대해서\n            .allowedOrigins\"http://localhost:8080\", \"http://localhost:5000\", \"\" // local, docker\n            .allowedMethods\n                    HttpMethod.GET.name,\n                    HttpMethod.HEAD.name,\n                    HttpMethod.POST.name,\n                    HttpMethod.PUT.name,\n                    HttpMethod.DELETE.name\n            \n        ;\n}",
    "tags": [
      "spring-boot",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "Spring Boot 한글 깨짐 현상 해결 방법",
    "url": "/back-end/2022/03/19/spring-boot-한글-깨짐-현상-해결-방법/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "Controller에서 혹은 에서 한글로 된 문자열을 받을 때 깨짐 현상이 일어날 수 있다.",
    "content": "Spring Boot 한글 깨짐 현상 해결 방법\n 한글 깨짐 현상이 일어나는 곳\nController에서 @PathVariable혹은 @RequestParam에서 한글로 된 문자열을 받을 때 깨짐 현상이 일어날 수 있다.\n 해결방법\n>application.properties에 아래와 같이 추가한다.\nproperties\n Charset of HTTP requests and responses. Added to the \"Content-Type\" header if not set explicitly.\n Spring Boot 2.3.0부터 기본값이다.\nserver.servlet.encoding.charset=UTF-8 \n Enable http encoding support.\nserver.servlet.encoding.enabled=true\n Force the encoding to the configured charset on HTTP requests and responses.\nserver.servlet.encoding.force=true",
    "tags": [
      "spring-boot",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "프로젝션",
    "url": "/back-end/2022/03/19/프로젝션/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": SELECT 절에 조회할 대상을 지정하는것\n- 프로잭션으로 관리되는 Entity는 모두다 영속성 컨텍스트에 관리된다.",
    "content": "프로젝션\n: SELECT 절에 조회할 대상을 지정하는것\n- 프로잭션으로 관리되는 Entity는 모두다 영속성 컨텍스트에 관리된다.\n 프로젝션 대상\n 1. 엔티티\n SELECT m FROM Member m\njava\nList<Member> result = \n  em .createQuery\"SELECT m FROM Member m\", Member.class.getResulteList;\n\nMember findMember = result.get0;\nfindMember.setAge20 //업데이트 쿼리가 나간다 즉 영속성 컨텍스트에 관리가 된다.\n\n> JPQL에서 조회한 Member는 영속성 컨텍스트에 관리된다.  \n> &rarr; Age를 변경했더니 업데이트 쿼리가 나갔다.\n\n SELECT m.team FROM Member m\n> Memeber에서 Team을 가져오려면 결국 Member와 Team을 join해야한다.\njava\n//List<Team> result = em .createQuery\"SELECT m.team FROM Member m\", Team.class.getResulteList; // 명시적조인\n//\nList<Team> result = \n  em .createQuery\"SELECT t FROM Member m join m.team t\", Team.class.getResulteList;\n\n- SELECT m.team FROM Member m과 같이 묵시적 조인을 하지 않는게 좋다.\n  >나중에 운영하면서 쿼리를 튜닝해야 할떄가 생긴다.\n- SELECT t FROM Member m join m.team t 와 같이 명시적 조인을 하자\n\n 2. 임베디드\n SELECT m.address FROM Member m\n>address는 city, street, zipcode를 가지고 있는 임베디드 타입이다.\n- select address from Address a 와 같이 사용할 수 없다 어디에 소속되어 있는지 명시 줘야한다.\n\n 3. 스칼라 타입\n SELECT m.username, m.age FROM Member m \n- DISTINCT로 중복 제거 &rarr; 중복된 데이터 제거\n  java\n  em.createQuery\"select distinct m.username, m.age from Member\".getResultList;\n  \n  \n 여러 값 조회\nSELECT m.username, m.age FROM Member m\n 1. Query 타입으로 조회\n> 가장 권장하지 않는다. 너무 귀찮다.\njava\nList resultList = \n  em.createQuery\"SELECT m.username, m.age FROM Member m\".getResultList;\n\nObject o = resultList.get0;\nObject  result = Obejct o;\nSystem.out.println\"username = \" + result0 // username = 조회된_유저이름\nSystem.out.println\"age = \" + result1 // username = 조회된_유저나이\n\n 2. Object 타입으로 조회\n> 이것도 권장하지 않는다.\njava\nList<Obejct> resultList = \n  em.createQuery\"SELECT m.username, m.age FROM Member m\".getResultList;\n\nObject result = resultList.get0;\nSystem.out.println\"username = \" + result0 // username = 조회된_유저이름\nSystem.out.println\"age = \" + result1 // username = 조회된_유저나이\n\n 3. new 명령어로 조회\n> 제일 간단하다.  \nSELECT new jpabook.jpql.UserDTOm.username, m.age FROM Member m  \n- 패키지 명을 포함한 전체 클래스 명을 입력해야한다. &rarr; 문자열이기 때문에 무조건 클래스명을 명시해야 한다.\n- 순서와 타입이 일치하는 생성자 필요하다.\nMemberDto\njava\n@Getter @Setter\npublic class MemberDto{\n  private String username;\n  private int age;\n\n  public MemberDtoString username; int age{\n    this.username = username;\n    this.age = age;\n  }\n}\n\n결과\njava\nList resultList = \n  em.createQuery\"SELECT new foo.MemberDtom.username, m.age FROM Member m\".getResultList;\n\nMemberDto memberDto = result.get0;\n\nSystem.out.println\"username = \" + memberDto.getUsername // username = 조회된_유저이름\nSystem.out.println\"age = \" + memberDto.getAge // username = 조회된_유저나이",
    "tags": [
      "spring",
      "jpa",
      "JPQL",
      "TIL"
    ]
  },
  {
    "title": "플러시(flush)",
    "url": "/back-end/2022/03/19/플러시flush/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 영속성 컨텍스트의 변경내용을 DB에 반영하는 것\n- 영속성 컨텍스트를 비우지 않는다.\n- 영속성 컨텍스트의 변경내용을 DB에 동기화한다.\n- 이라는 작업 단위가 중요하다. -> 커밋 직전에만 동기화 하면 된다.",
    "content": "플러시flush\n: 영속성 컨텍스트의 변경내용을 DB에 반영하는 것\n- 영속성 컨텍스트를 비우지 않는다.\n- 영속성 컨텍스트의 변경내용을 DB에 동기화한다.\n- transaction이라는 작업 단위가 중요하다. -> 커밋 직전에만 동기화 하면 된다.\n\n> 앞으로 예제 코드는 다음을 생략합니다.\n> java\n>  EntityManager em = emf.createEntityManager;\n>  EntityTransaction transaction = em.getTransaction;\n>  transaction.begin; // 트랜잭션 시작\n> ...\n>  //예제 코드 ...\n> ...\n> tx.commit;\n>  \n\n 플러시 발생 시 일어나는 일들\n- 변경 감지Dirty check\n- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록\n- 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송등록, 수정, 삭제 쿼리  \n  > 1차 캐시가 비워지는것이 아니다.\n    \n 플러시를 발생시키는 방법\n- em.flush - 직접 호출\n- 트랜잭션 커밋 - 플러시 자동호출\n  transaction.commit\n- JPQL Query 실행 - 플러시 자동 호출\n    java\n    em.persistmemberA;\n    em.persistmemberB;\n\n    //중간에 JPQL 실행\n    query = em.createQuery\"selete m from Member m\" , Member.class;\n    List<Member> members= query.getResultList;\n    \n    JPQL를 실행하면 DB에서 조회하므로 쓰기 지연 SQL 저장소에 있는 쿼리를 DB에 날리고 JPQL문을 실행한다. \n\n 플러시 모드 옵션\n- FlushModeType.AUTO 기본값  \n  : commit 이나 query를 실행할 때 플러시  \n\n- FlushModeType.COMMIT  \n  : 커밋할 때만 플러시\n\nCOMMIT옵션을 사용할 일이 별로 없다. - 김영한",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Spring Framework",
    "url": "/back-end/2022/03/19/spring-framework/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "Spring Framework는 자바 플랫폼을 위한 오픈소스 애플리케이션으로써, 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능들을 종합적으로 제공하는 경량화된 솔루션이다",
    "content": "Spring Framework\nSpring Framework는 자바 플랫폼을 위한 오픈소스 애플리케이션으로써, 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능들을 종합적으로 제공하는 경량화된 솔루션이다\n\nSpring은 특정한 하나의 프레임워크가 아닌 여러가지 기술들의 모음이라고 할 수 있다.\n> Web BE개발에 사용되는 Spring은 Spring Framework라고 부르는게 더 정확한 표현이다.\n\n\n Spring Framework의 등장 배경\nSpring은 초기 J2EEJava EE 사양의 복잡성으로 2003년에 만들어졌다.\n\nSpring은 JavaEE와 현재의 Jakarta EE를 대체하기 위해 만들어졌다고 생각할 수 있지만, 상호보완적인 관계이다.  \nSpring은 Jakarta EE 플랫폼 사양을 수용하지 않으며, 전통적인EE 제품에서 신중하게 선택된 개별 사향들과 통합된다.\n\nSpring의 등장 배경이 되는 JaaEE문제점 중 EJB의 기술 침투를 하나 소개하겠다.\n\n EJB의 기술 침투 문제\n당시 EJB의 개념이 획기적이었기 떄문에 J2EE 서버 개발 밴더들은 EJB 스펙을 구현한 여러 WAS를 출시했다.\n> EJB란 Enterprise 개발을 단순화하기 위해 발표한 스펙이다. \"비즈니스 객체들을 관리하는 컨테이너를 만들어서 필요할 때 마다 컨테이너로 부터 객체를 받는 식으로 관리하면 좋을 거 같다.\"라는 생각으로 EJB가 시작되었다.\n\n하지만, 보안, 트랜잭션, 분산 컴퓨팅 등 컨테이너의 여러 서비스를 사용하기 위해 EJB스펙을 무조건 따라야 하고, EJB 컨테이너가 없을 때 WAS의 여러 서비스를 사용할 수 없었다. 또한,\n\nEJB의 스펙을 지키기 위해 사용하려는 메서드보다. 상속 및 구현해야 하므로 불필요한 코드가 늘어났다. 그러면서 벤더마다 EJB 컨테이너를 구현한 내용이 다르므로 다른 컨테이너로 변경하기 어려웠다.\n\n이러한 문제가 발생한 원인은 비즈니스 로직에 EJB라는 특정 기술이 종속되어 있다는 것이다. 이를 기술 침투라고 하는데 EJB의 가장 큰 단점이다.\n\nSpring은 POJO기반 프레임워크로써 비 기술 침투적이다.\n\n Spring의 대표적인 특징\n 1. 경량 컨테이너\nSpring은 불필요하게 무겁지 않다\n\n경량 컨테이너로서 자바 객체를 직접 관리, 객체 생성, 소멸 같은 객체의 생명주기 관리하며, 개발자는 스프링으로부터 필요한 객체 얻어올 수 있다.\n- Spring Framework는 여러 모듈로 구성되어 필요한 모듈만 이용할 수 있다.\n  > Spring MVC 없이 Spring JDBC를 사용할 수 있다.\n\n> 경량 컨테이너라는 것은 기준에 따라 달라질 수 있다. JavaEE보다 경량 컨테이너이지만 Guice와 Plexus와 같은 POJO 기반 컨테이너와 비교할 때 무거운 컨테이너로 취급된다.\n\n 2. POJO - Plain Old Java Object../../Programming/Java/POJOPlain-Old-JAVA-Object.md\nSpring 컨테이너에 저장되는 자바 객체는 특정 인터페이스를 구현하거나, 특정 클래스를 상속받지 않아도 된다.\n\n이로인해 개발자는 특정 라이브러리나 JavaEE와 같은 컨테이너의 특정 기술에 종속적이지 않게되어 다음과 같은 장점이 있다.\n- 테스트코드 작성이 비교적 쉽다.\n- 유지보수와 확장성 및 불필요한 상속과 구현으로 인한 제약사항이 없다.\n\n 3. IoC - Inversion of ControlIOCInversion-Of-Control.md\n> Spring의 핵심이다.\n\n이를 직역하면 제어의 역전인데, 이렇게 불리는 이유는 객체Bean의 생성, 주입과 같은 객체의 흐름을 개발자가 아닌 Spring Framework가 제어하기 때문에 제어권이 개발자에서 프레임워크로 넘어갔다는 의미이다.\n> Spring Core의 IoC Container가 이를 담당한다.\n\nIOC는 DI - Dependency Injection, DL - Dependency Lockup에 의해 구현된다.\n\n 4. DIDIDependency-Injection.md - Dependency Injection\n설정 파일을 통해 객체 간의 의존관계를 설정할 수 있다. 각각의 계층이나 서비스들 간에 의존성이 존재할 경우, 프레임워크가 서로 연결시켜준다.\n\n- 필드 주입, 생성자 주입, Setter 주입 방식으로 DI를 지원한다. \n  > 필드 주입은 권장하지 않는다.\n\n 5. AOP - Aspect Oriented Programming\n트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.\n\n로깅과 같은 로직을 비즈니스 로직이 아닌 외부에서 적절한 시기에 처리하므로 개발자는 비즈니스 로직에 집중할 수 있고, 부가적인 로직을 모듈화함으로 응집력이 높아진다.\n\n 6. 추상화된 트랜잭션 관리 제공\nPlatformTransactionManager를 추상화하여 추상화된 트랜잭션 관리를 지원하며, 설정파일xml, java, property 등을 이용한 선언적인 방식 및 프로그래밍을 통한 방식을 모두 지원한다.  \n<img width=600 src=\"/assets/images/posts/back-end/transaction-abstract.png\">\n\n 7. 영속성과 관련된 다양한 서비스 제공\nhibernate와 같은 데이터베이스 처리 와 같은 프레임워크 혹은 라이브러리를 연결할 수 있는 인터페이스를 제공한다.\n\n 8. MVC 패턴 - Model view Controller pattern\nModel View Controller 구조로 사용자 인터페이스와 비지니스 로직을 분리하여 개발하는 것이다. MVC에서는 Model1과 Model2로 나누어져 있으며 일반적인 MVC는 Model2를 지칭한다.\n\nMVC1은 view와 데이터 처리를 Controller가 담당하고, MVC2는 view와 데이터처리를 각각 분리하는 구조이다.\n\n 여담\nSpring6, SpringBoot3부터 java17이상만 지원한다고 한다.\n- https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6\n\n Reference\n- https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/overview.htmloverview\n- https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/overview.html\n- https://blog.outsider.ne.kr/729\n- https://khj93.tistory.com/entry/Spring-Spring-Framework%EB%9E%80-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%ED%95%B5%EC%8B%AC-%EC%A0%95%EB%A6%AC\n- https://blog.naver.com/dktmrorl/222117116193\n- https://naming0617.tistory.com/32",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "IPC - Inter Process Comunication",
    "url": "/cs/2022/03/19/ipc---inter-process-comunication/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.\n- Socket, Shared Memory, Message Queue, Pipe 등이 해당된다.",
    "content": "IPC - Inter Process Comunication\n: 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.\n- Socket, Shared Memory, Message Queue, Pipe 등이 해당된다.\n\n TODO\nIPC종류 찾기\n\n Reference\n- https://ko.wikipedia.org/wiki/프로세스_간_통신",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "CASCADE(영속성 전이)",
    "url": "/back-end/2022/03/19/cascade영속성-전이/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 특정 가 상태 변화를 연관된 에 전파시키는 옵션이다.\n> 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.",
    "content": "CASCADE영속성 전이\n: 특정 Entity가 상태 변화를 연관된 Entity에 전파시키는 옵션이다.\n> 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.\n\n<img width=450px src=./img/cascade.png>\n\n- 단일 엔티티에 종속적일 때 사용한다. &rarr; 단일 소유자\n- 엔티티 생명주기가 거의 유사할떄 사용한다.\n CASCADE 저장\n@OneToManymappedBy=\"parent\", cascade=CascadeType.PERSIST  \n<img width=450px src=./img/cascade-save.png>\n\n 예시\n부모 클래스\njava\n@Entity\npublic class Parent {\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    @OneToManymappedBy=parent, casecade= CaseCadeType.ALL\n    private List<Childe> childList = new ArrayList<>;\n\n    public void addChildeChild Child{\n        childList.addchild;\n    }\n}\n\n자식 클래스\njava\n@Entity\npublic class Child {\n    @Id @GeneratedValue\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn\"parent_id\"\n    Parent parent;\n\n결과\njava\nChild child1 = new Child;\nChild child2 = new Child;\n\nParent parent = new Parent;\nparent.addChildchild1;\nparent.addChildchild2;\n\nem.persistparent // 부모가 영속화 되면 자식도 같이 영속화 된다.\n// em.persistchild1 caseCade로 인하여 부모와 함께 영속화 되어 안해도됌\n// em.persistchild2\n\n\n 주의사항\n- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.\n- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화 하는 것만 제공할뿐 \n- 자식의 소유자가 하나일 때만 사용하자. ex 게시판 \n\n 종류\n- ALL : 모두 적용\n- PERSIST : 영속\n- REMOVE : 삭제\n- MERGE : 병합\n- REFRESH : REFRESH\n- DETACH : DETACH",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "그래프 - Graph",
    "url": "/cs/2022/03/19/그래프---graph/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": "란 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조이다.",
    "content": "그래프 - Graph\n그래프 - Graph란 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조이다.\n\n 용어 정리\n<img src=\"/assets/images/posts/cs/graph-ex.png\">\n\n 정점 - vertex\n노드 - node라고하며 데이터가 저장되는 그래프의 기본 원소이다.\n\n 간선 - edge\n링크 - link라고하며 정점 간의 관계를 나타낸다\n\n 인접 정점 - adjacent vertex\n하나의 정점에서 간선에 의해 직접 연결되어 있는 정점을 뜻한다.\n> 위 그래프에서 정점 C의 인접 정점은 A, D이다.\n\n 차수 - degree\n정점에 연결된 간선의 수\n> 정점 A의 차수는 3이고 모든 정점의 차수를 합하면 8이다.\n\n- 무방향 그래프에서 하나의 간선은 두 개의 정점에 인접하기 때문에 간선 수에 2배를 해주면 된다.\n- 방향 그래프의 경우 외부에서 오는 간선의 수를 진입 차수 - in-degree라고 하며, \n- 외부로 향하는 간선의 수를 진출 차수 - out-degree라고 한다.\n\n 경로 - path\n간선을 따라갈 수 있는 길을 말하며, 정점을 나열하여 표시한다.\n\n 경로의 길이 - length\n경로를 구성하는 데 사용된 간선의 수를 뜻한다.\n\n 단순 경로 - simple path\n경로 중 반복되는 간선이 없는 경로\n\n 사이클 - cycle\n시작 정점과 종료 정점이 같은 단순 경로를 뜻한다.\n\n 그래프 ADT\n 객체\n정점의 집합과 건선의 집합\n\n 연산\n- create : 그래프 생성\n- insertVertexv : 그래프에 정점 v 삽입\n- insertEdgeu, v : 그래프에 u정점과 v정점을 연결하는 간선 삽입\n- deleteVertexv : 그래프에서 정점 v 삭제 v에 연결된 모든 간선도 함께 삭제\n- deleteEdgeu, v : 그래프에서 u정점과 v정점을 연결하는 간선 삭제\n- adjacentv : 정점 v에 인접한 모든 정점을 반환\n\n 구현 방법\n인접 행렬, 인접 리스트 로 구현할 수 있다.\n\n 1. 인접 행렬 - Adjacency Materix\n<img width=450 src=\"/assets/images/posts/cs/adjacency-matrix-ex.png\">\n\n 장점\n- 두 점에 대한 연결 정보를 조회할 때 O1시간복잡도를 가진다.\n  > 2차원 배열 속 모든 정점들의 간선 정보를 담는다.\n- 정점i의 차수를 구할 때는 다음과 같이 인접행렬M의 i번째 행의 값을 모두 더하면 되므로 On의 시간복잡도를 가진다.  \n$$degreei= \\sum_{k=0}^{n-1} Mik$$\n\n- 구현이 비교적 간단하다.\n\n 단점\n- 모든 간선의 수를 알아내려면 모든 정점에 대해 간선 정보를 대입해야 하므로 On²의 시간복잡도를 가진다.\n- 무조건 2차원 배열이 필요하여 필요 이상의 공간이 낭비된다.\n\n 2. 인접 리스트\n<img width=450 src=\"/assets/images/posts/cs/adjacency-list.png\">\n\n 장점\n- 정점들의 연결 정보를 탐색할 때 On의 시간복잡도를 가진다. n = 간선의 갯수\n- 필요한 만큼의 공간만 사용하기 때문에 공간의 낭비가 적다.\n\n 단점\n- 두 정점을 연결하는 간선을 조회하거나 정점의 차수를 알기 위해서는 정점의 인접 리스트를 탐색해야 하므로 정점의 차수만큼의 시간이 필요하다. Odegreev v = 정점\n\n- 구현이 비교적 어렵다.\n\n 3. 인접 행렬 vs 인접 리스트\n<img width=700 src=\"/assets/images/posts/cs/matrix-vs-list.png\">\n\n- 정점의 개수에 비해 간선의 개수가 매우 적은 희소 그래프에서는 인접 리스트가 유리할 수 있다.\n- 모든 정점간에 간선이 존재하는 완전그래프 에서는 인접 행렬이 유리할 수 있다.\n\n다음글 트리 - tree../tree/tree.md\n\n Reference\n- https://suyeon96.tistory.com/32---%--%EA%B-%B-%EB%-E%--%ED%--%--%--%EC%-A%A-%EC%--%B-\n- https://coding-factory.tistory.com/610",
    "tags": [
      "data-structure",
      "non-linear",
      "graph",
      "TIL"
    ]
  },
  {
    "title": "상속관계 매핑(실전)",
    "url": "/back-end/2022/03/19/상속관계-매핑실전/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "실습 repo: https://github.com/siwony/HelloJPA/tree/inheritMapping04",
    "content": "실습 repo: https://github.com/siwony/HelloJPA/tree/inheritMapping_04\n 상속관계 매핑실전\n 요구사항 추가\n- 상품의 종류는 음반, 도서, 영화가 있고 이후 더 확장될 수 있다.\n- 모든 데이터는 등록일과 수정일이 필수다.\n\n 엔티티 모델\n<img width=450px src=./img/inherit-relationship-mapping-entity.png>\n\n 테이블 설계\n<img width=450px src=./img/inherit-relationship-mapping-table.png>",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Paging",
    "url": "/back-end/2022/03/19/paging/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- setFirstResultint startPosition : 조회 시작 위치0부터 시작\n- setMacResultint maxResult : 조회할 데이터 수",
    "content": "Paging \n\n JPA는 페이징을 두개의 API로 추상화 되어있다.\n- setFirstResultint startPosition : 조회 시작 위치0부터 시작\n- setMacResultint maxResult : 조회할 데이터 수\n  \n 예시\njava\nList<Member> em.createQuery\"select m from Member m order by m.age desc\", Member.class\n    .setFirstResult0\n    .setMaxResults10\n    .getResultList;\n\nforMember member1 : result{\n    System.out.printlnresult // 10개의 member.toString 이 출력된다.\n}",
    "tags": [
      "spring",
      "jpa",
      "JPQL",
      "TIL"
    ]
  },
  {
    "title": "캐시 메모리 - Cache Memory",
    "url": "/cs/2022/03/19/캐시-메모리---cache-memory/",
    "category": "cs",
    "date": "2022-03-19",
    "excerpt": ": 속도가 빠른 장치CPU와 느린 장치메모리 사이에서 병목현상을 줄이기 위한 고속 이다.\n> 병목현상  \n> : 어떤 시스템 내 데이터의 집중적인 사용으로 인해\b  전체 시스템에 절대적 영향을 미치는 부분에 사용빈도가 늘어나 그 부분의 성능이 저하되어 전체 시스템이 마비되는 현상을 의미한다.\n- CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용...",
    "content": "캐시 메모리 - Cache Memory\n: 속도가 빠른 장치CPU와 느린 장치메모리 사이에서 병목현상을 줄이기 위한 고속 Buffer Memory이다.\n> 병목현상  \n> : 어떤 시스템 내 데이터의 집중적인 사용으로 인해\b  전체 시스템에 절대적 영향을 미치는 부분에 사용빈도가 늘어나 그 부분의 성능이 저하되어 전체 시스템이 마비되는 현상을 의미한다.\n- CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤,\n- 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.\n  > 즉, 캐시는 메모리 접근의 지역성을 이용하는 장치이다.\n- 캐시 메모리는 비싸므로 용량이 적다\n  > 보통 수십 KByte ~ 수백 KByte 나중에 변경 될 수 있음\n\n<img src=\"/assets/images/posts/cs/cache.png\">\n\n> 현재 우리가 사용하고 있는 컴퓨터들은 모두 캐시 메모리 2 ~ 3개L1, L2, L3를 사용한다.\n\n 듀얼 코어 프로세서의 캐시 메모리\n: 각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장된다.\n- L1: CPU 내부에 존재\n- L2: CPU와 RAM 사이에 존재\n- L3: 보통 메인보드에 존재한다고 함\n\n> 만약 L1 캐시가 128kb면, 64/64로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고,  \n> 나머지 64kb에는 실행 후 명령어를 임시저장한다. 명령어 세트로 구성, I-Cache - D-Cache\n\n 적중과 실패\n캐시메모리가 있는 컴퓨터 시스템은 CPU가 메모리에 접근하기 전 먼저 캐시 메모리에서 원하는 데이터의 존재 여부를 확인한다.  \n이때 필요한 데이터가 있는 경우를 적중hit, 없는 경우를 실패miss라고 한다.\n\n- 캐시 적중일 때\n  > 캐시 메모리의 데이터를 CPU 레지스터에 복사한다.\n- 캐시 실패/메모리 적중일 때\n  > 메모리의 데이터를 캐시 메모리에 복사하고, 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사한다.\n- 캐시, 메모리 실패일 때\n  > 보조 기억장치에서 필요한 데이터를 메모리에 복사한다.   \n  > 메모리에 복제된 내용을 캐시 메모리에 복제한다. 캐시 메모리의 복제된 데이터를 CPU 레지스터에 복제한다.\n 적중률\n: 요청한 데이터를 캐시메모리에서 찾을 확률\n\n         캐시 메모리의 적중 횟수\n적중률 = -----------------------\n         전체 메모리의 참조 횟수\n\n\n\n 캐시 메모리 동작원리 - 지역성\n: 데이터 접근이 시간적, 공간적, 순차적으로 가깝게 일어나는 것이다.\n- 캐시가 효율적으로 동작하려면, 캐시의 적중율Hit-rate를 극대화 시켜야 한다.\n  > 즉 지역성을 가져야 한다.\n- 기억장치 내의 정보를 균일하게 Access하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성이다.\n- 시간 지역성, 공간 지역성이 있다.\n\n 시간 지역성\n: 최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향\n- for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높다.\n- 메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우, 상대적으로 작은 크기의 캐시를 사용해도 효율성을 꾀할 수 있다.\n\n 공간 지역성\n: 특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향\n- A0, A1과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성이 높음\n  > ex. 배열\n\n 순차 지역성\n: 데이터가 순차적으로 액세스되는 경향\n> 데이터가 순차적으로 액세스되는 경향이 있다.\n- 기억장치에 저장된 순서대로 이용될 가능성이 높다.\n  > ex. 배열\n\n 캐시메모리의 구조 및 동작 방식\n Direct Mapped Cache\n: DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식이다.  \n<img width=\"420\" src=\"/assets/images/posts/cs/direct-mapping.png\">\n\n> 현재 그림에서는 메모리 공간이 32개00000~11111이고, 캐시 메모리 공간은 8개000~111인 상황\n- 인덱스 필드: 000를 가르킨다.\n- 태그 필드: 인덱스 제외한 앞의 나머지00, 01, 10, 11를 가르킨다.\n- 캐시메모리는 인덱스 필드 + 태그 필드 + 데이터 필드로 구성된다.\n\n 특징\n- 위 사진처럼 같은 색깔의 데이터를 동시에 사용해야 할 떄 사용한다.\n- Conflict Miss가 발생한다.\n- 간단하고 구현 비용이 낮다.\n- 적중률이 낮아진다.\n\n Fully Associative Cache\n: 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식이다.\n- 저장할 때는 매우 간단하지만, 모든 블럭을 순회해 데이터가 있는지 검사한다.\n- CAMcontent Addressable memory라는 특수한 형태의 메모리 구조를 사용한다\n  > 가격이 비싸다\n\n Set Associative Cache\n: 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식이다.\n> Direct + Fully 방식\n- Direct에 비해 검색 속도는 느리지만, 저장이 빠르다. \n- Fully에 비해 저장이 느린 대신 검색이 빠르다.",
    "tags": [
      "Memory",
      "TIL"
    ]
  },
  {
    "title": "DI(Dependency Injection, 의존성 주입)",
    "url": "/back-end/2022/03/19/didependency-injection-의존성-주입/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 어떤 객체가 사용하는 의존객체를 직접 만들어서 사용하는것이 아니라 주입받아 사용하는 방법  \n>즉 클래스안에  연산자가 들어가 있지 않고 외부에서 객체를 주입해주는것\n- 의존 관계 설정이 컴파일시가 아닌 실행시에 이루어져 모듈들간의 결함도coupling 를 낮출 수 있다.\n- 코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스코드 수정 없이 사용가능\n...",
    "content": "DIDependency Injection, 의존성 주입\n: 어떤 객체가 사용하는 의존객체를 직접 만들어서 사용하는것이 아니라 주입받아 사용하는 방법  \n>즉 클래스안에 new 연산자가 들어가 있지 않고 외부에서 객체를 주입해주는것\n- 의존 관계 설정이 컴파일시가 아닌 실행시에 이루어져 모듈들간의 결함도coupling 를 낮출 수 있다.\n- 코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스코드 수정 없이 사용가능\n- 모의객체 등을 이용한 단위 테스트의 편의성을 높여준다.\n\n<img width=450px src=./img/DIway.jpg>\n\n1. 일반적인 의존성  \n    : A객체가 B와 C객체를 New 생성자를 통해서 직접 생성하는 방법\n2. 의존성 주입을 이용한 방법  \n    : 외부에서 생성 된 객체를 setter, 생성자를 통해 사용하는 방법  \n\n 의존관계 주입 방법\n 1. 생성자 주입\n> 가장 권장하는 방식이다.\njava\npublic class BookService {\n    private final BookRepository bookRepository;\n\n    public BookControllerBookRepository bookRepository {\n        this.bookRepository = bookRepository;\n    }\n}\n\n- 필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함\n- Circular Dependency순환 참조./why-field-injection.md 의존성을 알아 차릴 수 있다.\n- 테스트 코드 작성시 생성자를 통해 의존성 주입이 용이하다.\n\n 2. 필드 주입\n: member field에 @Autowired을 선언하여 주입받는 방법\n> 가장 간단하다.\njava\npublic class BookService {\n\n    @Autowired\n    private BookRepository bookRepository;\n}\n\n- 의존 관계가 눈에 잘 보이지 않아 추상적이고, 이로 인해 의존성 관계가 과도하게 복잡해질 수 있음\n- 즉, 단일 책임 원칙SRP에 반하는 안티 패턴이다.SOLID S위반\n- DI Container와 강한 결합을 가져 외부 사용이 용이하지 않음\n- final 선언불가\n\n 3. Setter 주입\n: setter 메서드에 @Autowired을 선언하여 주입받는 방법\njava\npublic class BookService {\n    private BookRepository bookRepository;\n\n    @Autowired\n    public void setBookRepositoryBookRepository bookRepository {\n        this.bookRepository = bookRepository;\n    }\n}\n\n- 생성자에 모든 의존성을 기술하면 과도하게 복잡해질 수 있는 것을 선택적으로 나눠 주입 할 수 있게 부담을 덜어준다.\n- 의존성이 선택적으로 필요한 경우 사용\n- 생성자 주입 방법과 Setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용\n- final 선언 불가\n\n 4. 일반 메서드 주입\n일반 메서드에 @Autowired를 통해서 주입 받을 수 있다.\njava\npublic class BookService{\n    private BookRepository bookRepository;\n\n    @Autowired\n    public void initBookRepositoy bookRepository{\n        this.bookRepository = bookRepository\n    }\n\n}\n\n\n Spring 에서의 DI\n<img width=450px src=./img/SpringDI.jpg>\n\n IoC 컨테이너에서 Di를 자동으로 해준다\nSpring에서 객체를 Bean 이라고 부르며, 프로젝트가 실행될때 사용자가 Bean으로 관리하는 객체들의 생성과 소멸에 관련된 작업을 자동적으로 행하는데 객체가 생성되는 곳을 Spring에서 Bean 컨테이너 라고 부른다.",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "SpringBoot Maven to Gradle build tool migration!",
    "url": "/back-end/2022/03/19/springboot-maven-to-gradle-build-tool-migration/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- SpringBoot Maven to Gradle build tool migration!springboot-maven-to-gradle-build-tool-migration\n  - Introintro\n      - 프로젝트 환경프로젝트-환경\n    - Migration 동기migration-동기\n      - TheMoment Projectthemomen...",
    "content": "SpringBoot Maven to Gradle build tool migration!\n- SpringBoot Maven to Gradle build tool migration!springboot-maven-to-gradle-build-tool-migration\n  - Introintro\n      - 프로젝트 환경프로젝트-환경\n    - Migration 동기migration-동기\n      - TheMoment Projectthemoment-project\n      - 지속적 통합CI의 자료가 Gradle이 더 많다.지속적-통합ci의-자료가-gradle이-더-많다\n  - 본론본론\n    - Maven Project에 Gradle Project 적용하기maven-project에-gradle-project-적용하기\n    - 의존성 migration의존성-migration\n      - 저장소 선언저장소-선언\n    - Intellij에서 Gradle Project를 불러오자intellij에서-gradle-project를-불러오자\n      - 만약 Intellij가 Gradle을 불러오지 못한다면만약-intellij가-gradle을-불러오지-못한다면\n    - 나는 왜 에러가 뜨는걸까? - gradle lombok error나는-왜-에러가-뜨는걸까---gradle-lombok-error\n      - 문제해결문제해결\n  - 후기후기\n    - 공식문서를보자공식문서를보자\n    - 에러코드를 자세히 읽어보자에러코드를-자세히-읽어보자\n      - 마무리마무리\n\n Intro\n> SpringBoot 개발초기에는 Gradle이 무서운줄 알았다. 하지만 배포를 하다 보니까 Maven이 더 무섭더라.\n\n이글은 Gradle 공식문서를 아주많이 참고했습니다! \n- Gradle 공식문서https://docs.gradle.org/current/userguide/migrating_from_maven.htmlmigmvn:multimodule_builds - Apache Maven에서 빌드 마이그레이션\n\n 프로젝트 환경\n- MacOS\n- Intellij Ultimate\n- Java11/SpringBoot + maven\n- 그후 gradle 추가 예정\n\n>주의  \n>자신의 프로젝트의 규모와 상황에따라 상황이 달라질 수 있습니다.\n\n Migration 동기\n TheMoment Project\n학교에 불편한순간 이라는 프로젝트가 있다. 참고https://github.com/theMomentTeam/the_moment-Server  \n1. 프로젝트를 하기전에 build tool 은 익숙한 maven을 선택했었다.  \n2. 하지만 개발할때 익숙하고 편했지만 배포할때가 문제였다.  \n\n 지속적 통합CI의 자료가 Gradle이 더 많다.\n> 저희 프로젝트는 CI툴을 Jenkins를 사용하려고 합니다.\n\n우리 Project는 CI/CD를 통한 무중단 배포가 목표이다. 그러기 위해서는 CI가 필수관문인데  \n하지만 아무리 검색을 해도 maven을 통한 CI에대한 Jenkins배포를 찾을 수 없었다.\n> 아마 아직 개발 역량이 부족해서 일 수도 있지만 자료는 Gradle이 더 많았다.\n\n 본론\n Maven Project에 Gradle Project 적용하기\n기존 Maven 프로젝트에서 Gradle Project를 시작하는것은 어렵지 않았다.  \n\n다음과같이 입력하면 Gradle Project를 시작할 수 있다.\nbash\ngradle init\n\nMaven프로젝트 디렉토리에서 위와같이 입력했으면  \nFound a Maven build. Generate a Gradle build from this? default: yes yes, no   \n와 같은 메세지가 나온다 Enter 혹은 yes를 입력한다.\n\n그후 \nsh\nSelect build script DSL:\n  1: Groovy\n  2: Kotlin\nEnter selection default: Groovy 1..2\n\n이런식으로 build script를 선택하는것이 나올껀데 Groovy를 선택하자. Enter or 1 입력\n> 참고 : Groovy는 JVM기반에서 실행되는 스크립트 언어이다. Gralde에서 Build Script로 많이 쓰인다.\n\n그러면 Gradle이 알아서 pom.xml에 있는 depedency및 플러그인을 가져온다.\n\n 의존성 migration\n> Gradle의 의존성 관리 시스템은 Maven보다 유연하여   \n> repository, 선언된 의존성, scopeGradle의 의존성 구성 및 의존성 전이의 동일한 개념을 계속 지원한다.  \n\n 저장소 선언\nMaven과 달리 Gradle은 기본 저장소가 없으므로 최소한 하나를 선언 해야한다.  \n> 들어가봤자 라이브러리를 디렉토리명 및 파일을 나열해놔서 별 도움이 안된다.  \n> 굳이 라이브러리를 찾고싶으면 https://search.maven.org/ 여기에서 찾자\n\nBefore\ngradle\nrepositories {\n    mavenLocal //변경전 부분 // 의존성을 로컬에서 찾는다.\n    maven {\n        url = uri'https://repo.maven.apache.org/maven2/'\n    }\n}\n\nAfter\ngradle\nrepositories {\n    mavenCentral //변경된 부분 Maven Central로 의존성 저장소를 바꿈\n    maven {\n        url = uri'https://repo.maven.apache.org/maven2/'\n    }\n}\n\n> Maven Central: 자바진영에서 개발의 필요한 의존성이 저장되어있는 저장소이다.  \n\n\n Intellij에서 Gradle Project를 불러오자\n> 먼저 Gradle plugin이 설치가 되어있어야한다.\n\ngradle init을 한후 gradle 프로젝트에 필요한 파일들이 프로젝트 폴더에 추가 되었으면,   \nGradle build scripts found 이 하단에 나타날것이다. \n\n그후 gradle build 혹은 ./gradlew build 를 입력해서 gradle project로 현제 프로젝트가 build되는지 확인하자. \n\nBuild가 되면 바로 Gradle로 migration하면 되지만,  \n자신에 프로젝트에 어떤 side effect가 올지모르므로 검증후 점진적으로 적용하기 바란다.  \n\n<img src=\"/assets/images/posts/back-end/gradle-build-scripts-found.png\">\n\n그러면 Intellij에서 intellij 하게 gradle의 depedency를 불러올것이다.\n\n 만약 Intellij가 Gradle을 불러오지 못한다면\n자신의 프로젝트에 최상단에서 .idea를 제거하고 Intellij를 제실행하면 해결될것이다.\n\n 나는 왜 에러가 뜨는걸까? - gradle lombok error\n나의 경우에는 compileJava FAILED가 떴다.\n에러코드를 올려보니 \nsh\n                                            etc...\n\n  symbol: method getAdminPwd\n/{PROJECT_ROOT}/src/main/java/com/moment/the/dto/AdminDto.java:33: error: cannot find symbol\n                .adminNamethis.getAdminName\n                               ^\n  symbol:   method setCodeint\n  location: variable result of type CommonResult\n/{PROJECT_ROOT}/src/main/java/com/moment/the/domain/response/ResponseService.java:62: error: cannot find symbol\n        result.setMsgCommonResponse.FAIL.getMsg;\n              ^\n51 errors\n\nFAILURE: Build failed with an exception.\n\n What went wrong:\nExecution failed for task ':compileJava'.\n> Compilation failed; see the compiler error output for details.\n\n Try:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n Get more help at https://help.gradle.org\n\nBUILD FAILED in 1s\n1 actionable task: 1 executed\n\n\ngetter, setter 매서드를 찾을 수 없다는 에러가 51개나 떳다.  \n그러면 lombok이 method를 생성하지 않았다는건데?!\n\n그후 바로 Gradle에 lombok을 적용하는것을 구글링했다. ~~사랑해요 Stack Overflow~~   \n참고 링크 : https://stackoverflow.com/questions/35236104/gradle-build-fails-on-lombok-annotated-classes\n\n 문제해결\nbuild.gradle 에 dependencies에 다음과같이 추가해주면 해결이된다.\n\ngradle\ndependencies{\n  compileOnly 'org.projectlombok:lombok:1.18.16'\n  annotationProcessor 'org.projectlombok:lombok:1.18.16'\n}\n\n버전명시는 자신의 프로젝트에 추가되어있는 lombok 버전과 똑같이 맞추자\n\n그후 Build를 하여 성공했다!\nsh\n> gradle build\n\nBUILD SUCCESSFUL in 668ms\n5 actionable tasks: 5 up-to-date\n\n\n 후기\n 공식문서를보자\nSpringBoot가 그래도 한국에 자료가 많아서 너무 구글링 및 블로그에 의존했던것 같다.  \n이번기회에 공식문서의 중요성을 알게되었다.  \n\n공식문서에는 기타 정보들도 많고 직접적으로 구글링해서 찾아야 할것을 알려준다.  \n다만 한국어가 아니여서 좀많이 아쉬운것같다.. 역시 영어공부를 해야겠다.\n\n 에러코드를 자세히 읽어보자\n여기에서는 안나왔지만 Build Error를 해결하는 도중 에러 메세지를 재대로 안봤다 ㅜ..  \n왜냐하면 intellij에 있는 Terminal를 쓰고있는데하단에 놓고 사용해서 위에가 가려진다..  \n계속 빌드가 실패했다는 메시지만 보였고 가려진 진짜 에러부분을 볼 생각을 못했었다.위에 에러메세지가 있는줄 몰랐다...  \n~~진짜 이거 에러메세지 보고 현타가 엄청왔었다..~~\n\n 마무리\n그래도 이번 기회에 gradle에 대한 생명주기 및 build tool에서 라이브러리를 어떻게 가져오는지에 대해 찾아볼 수 있어서 좋았다.  \n그리고 한층 성장한것같아 기분이 좋다.",
    "tags": [
      "TIL",
      "gradle",
      "build-tool"
    ]
  },
  {
    "title": "Bean Life Cycle",
    "url": "/back-end/2022/03/19/bean-life-cycle/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "IoC의 이점을 얻으려면 컨테이너로 가는 애플리케이션의 흐름에 대한 부분적인 제어를 포기해야 한다. == 인스턴스화\n> 시작시 로직 설정 등에 특별한 주의가 필요하다.",
    "content": "Bean Life Cycle\n Bean Life Cycle에 대해 왜 알아야 할까?\nIoC의 이점을 얻으려면 컨테이너로 가는 애플리케이션의 흐름에 대한 부분적인 제어를 포기해야 한다. == 인스턴스화\n> 시작시 로직 설정 등에 특별한 주의가 필요하다.\n\nBean의 생성자에 로직을 포함 시키거나 객체의 인스턴스화 후에 메서드를 호출할 수 없다. 왜냐하면 우리는 그 과정에 통제권을 가지고 있지 않기 때문이다.\n\n 예시 시작시 로직 실행\njava\n@Component\npublic class InvalidInitExampleBean {\n\n    @Autowired\n    private Environment env;\n\n    public InvalidInitExampleBean {\n        env.getActiveProfiles;\n    }\n}\n\n1. 생성자에서 autowired필드에 접근하려한다.\n2. 생성자가 호출 될 때 Spring Bean은 완전히 초기화 되지 않았다\n   > @Autowired는 필드주입을 하므로 생성자에서 호출하면 당연히 DI가 되지 않았다.\n3. NullPointerException가 발생한다.\n\nSpring은 이러한 상황을 관리하는 몇 가지 방법을 제공한다.\n\n이러한 상황들이 발생할 수 있으므로 우리는 Bean에 대한 생명주기를 알아야 할 필요가 있다.\n\n Spring Bean LifeCycle\n<img width=600 src=\"/assets/images/posts/back-end/bean-lifecycle.png\">\n\n기본적인 Spring Bean LifeCycle은 다음과 같다.\n> Spring 컨테이너 생성 &rarr; Spring Bean 생성/객체 생성 &rarr; 의존관계 주입 &rarr; 초기화 콜백  \n&rarr; Bean 사용 &rarr; 소멸 전 콜백 &rarr; 스프링 종료\n- 단, 생성자 주입 은 객체가 생성되는 동시에 주입된다.\n- 초기화 콜백을 통해 DI가 완료된 상태임을 확인할 수 있다.\n  > 이 때 초기화 작업을 진행해야 함을 알 수 있다.\n- 소멸 콜백을 통해 Spring이 종료되기 전인 상태를 개발자가 확인할 수 있다.\n  > 이 때 종료작업을 안전하게 진행할 수 있다.\n\n Bean 생명주기 콜백 종류 3가지\n1. Spring에서 제공하는 인터페이스 InitializingBean, DisposableBean\n2. 설정 정보에서 초기화 메서드, 종료 메서드 지정하는 방법\n3. @PostConstruct, @PreDestory 어노테이션\n\n 1.  Spring에서 제공하는 인터페이스\njava\n@Component\npublic class ExBean implements InitializingBean, DisposableBean{\n\n    ...\n\n    @Override\n    public void afterPropertiesSet throws Exception{\n        // 초기화\n    }\n\n    @Override\n    public void destroy throws Exception{\n        // 메모리 반납, 연결 종료와 같은 과정\n    }\n}\n\n이 방식의 단점은 다음과 같다.\n- Spring 전용 인터페이스에 코드가 의존한다.\n- 메서드를 오버라이드하기 떄문에 메서드명을 변경할 수 없다.\n- 코드를 커스터마이징할 수 없는 외부 라이브러리에 적용할 수 없다.\n\n 2. 설정 정보에서 초기화 메서드, 종료 메서드 지정하는 방법\njava\npublic class ExBean{\n\n    ...\n\n    public void initialize throws Exception {\n        /// 초기화\n    }\n\n    public void close throws Exception {\n        // 메모리 반납, 연결 종료와 같은 과정\n    }\n}\n\n@Configuration\npublic class LifeCycleConfig{\n\n    @BeaninitMethod = \"initialize\", destroyMethod = \"close\"\n    public ExBean exBean{\n        ...\n    }\n}\n\n이 방식의 장점\n- 메서드 이름을 자유롭게 부여 가능하다.\n- Spring 코드에 의존하지 않음\n- 코드를 커스터마이징 할 수 없는 외부 라이브러리에 적용 가능하다.\n  > 설정 정보를 사용하기 때문에 가능하다.\n\n이 방식에 단점\n- Bean 지정 시 initMethod와 destoryMethod를 직접 지정해야 하는 번거로움이 았다.\n\n@Bean의 destoryMethod 속성의 특징\n- 라이브러리의 대부분 종료 메서드명이 close 혹은 shutdown\n- @Bean의 destoryMethod는 기본값이 inferred 추론으로 등록한다.\n  > 즉, 종료 메서드를 추론하고 자동으로 호출한다.\n- inferred기능을 사용하기 싫다면 명시적으로 destoroyMethod=\"\" 와 같이 공백을 지정해줘야 한다.\n\n 3. @PostConstruct, @PreDestroy 어노테이션\njava\npublic class ExBean{\n    \n    @PostConstruct\n    public void initialize throws Exception {\n        // 초기화\n    }\n\n    @PreDestory\n    public void close throws Exception {\n        // 메모리 반납, 연결 종료와 같은 과정\n    }\n}\n\n@Configuration\npublic class LifeCycleConfig{\n    \n    @Bean\n    public ExBean exampleBean{\n        // 생략\n    }\n}\n\nJSR-250에 정의되어 있어 Spring 이외에 다른 프레임워크가 지원할 수 있다.\n- 최신 스프링에서 권장하는 방법\n  > Java11에서 제거 되어서 사용할 수 없다는 말이 있는데 javax가 아닌 java.xml.ws.annotation가 Deprecated가 된것이므로 상관 없다.\n- 컨포넌트 스캔과 잘 어울린다.\n\n이 방식의 단점\n- 커스터마이징이 불가능한 외부 라이브러리에서 사용 할 수 없다.",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "값 타입 매핑(실습)",
    "url": "/back-end/2022/03/19/값-타입-매핑실습/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "repo: https://github.com/siwony/HelloJPA/tree/valueTypeMapping06",
    "content": "repo: https://github.com/siwony/HelloJPA/tree/valueTypeMapping_06\n 값 타입 매핑실습\n<img width=450px src=\"/assets/images/posts/back-end/value-type-mapping.png\">",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "기본값 타입",
    "url": "/back-end/2022/03/19/기본값-타입/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 생명주기를 Entity에 의존한다.\n- 값 타입을 공유하면 안 된다.\n- ex , ",
    "content": "기본값 타입\n- 생명주기를 Entity에 의존한다.\n- 값 타입을 공유하면 안 된다.\n- ex String name, int age\n\n 자바의 기본 타입은 절대 공유를 안한다.\n- int, double과 같은 기본 타입primitive type 은 절대 공유 x\n- 기본 타입은 항상 값을 복사한다.\n- 래퍼 클래스 혹은 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 x\n\n 기본타입일 경우\njava\nint a = 10;\nint b = a;\n\na = 20;\n\nSystem.out.println\"a = \" a; // a = 20 출력\nSystem.out.println\"b = \" b; // b = 10 출력\n\n- 공유불가능, 변경됨\n 래퍼 클래스일 경우\njava\nInteger a = new Integer10;\nInteger b = a;\n\n//a.setValue20 // 만약 이렇게 값을 바꾸는 즉 변경할 수 없다.\n\nSystem.out.println\"a = \" a; // a = 10 출력\nSystem.out.println\"b = \" b; // b = 10 출력\n\n- 공유가능, 변경 안됨",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "LogBack",
    "url": "/back-end/2022/03/19/logback/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "LogBack은 SpringBoot에서 기본적으로 제공하는 logging로깅라이브러리다.  \n- log4j를 토대로 새롭게 만들었다 여러 단점 및 성능이 log4j보다 향상됐다.",
    "content": "LogBack\nLogBack은 SpringBoot에서 기본적으로 제공하는 logging로깅라이브러리다.  \n- log4j를 토대로 새롭게 만들었다 여러 단점 및 성능이 log4j보다 향상됐다.\n\n 특징\n- SLF4J의 구현체\n- 자바 오픈소스 로깅 프레임워크\n  > 라이브러리라고 하는데 논란의 여지가 있다.\n- log4j, log4j2등과 성능을 비교했을때 logback이 더 훌령한 성능을 보여준다\n  > multi thread 환경에서는 log4j2가 엄청난 퍼포먼스를 보여준다.  \n  > 참고: https://dololak.tistory.com/632\n- spring-boot-starter-web 안에 spring-boot-starter-logging에 구현체가 있다.\n- 로깅을 수행하기 필요한 주요 설정요소는 Logger, Appender, Encoder 3가지가 있다.\n\n 로깅의 설정 요소\n- Logger : 실제 로깅을 수행하는 구성요소로 Level 속성을 통해서 출력할 로그의 레벨을 조절할 수 있다.\n- Appender : 로그 메시지가 출력될 대상을 결정하는 요소\n- Encoder : Appender에 포함되어 사용자가 지정한 형식으로 표현 될 로그메시지를 변환하는 역할을 담당하는 요소\n\n 로깅의 설정방법\n- XML : logback.xml로 설정 파일 작성 후 해당 파일을 클래스패스에 위치시킨다.\n- Groovy : logback.groovy로 설정 파일 작성 후 해당 파일을 클래스패스에 위치시킨다.\n\n logback의 log level\n로그레벨의 순서는 다음과 같다.  \nTRACE > DEBUG > INFO > WARN > ERROR\n1. TRACE : 추적 레벨은 Debug보다 좀더 상세한 정보를 나타낸다.\n   > sql 파라미터의 세부값등 경로 추적을 위해 나타넨다.\n2. DEBUG : 프로그램을 디버깅하기 위한 정보를 표시한다.\n    > 운영서버에서는 표시하지 않도록 설정한다.\n3. INFO : 정보성 로그를 표시한다.\n    > 로그인, 상태변경과 같은로그\n4. WARN : 처리가능한 문제, 하지만 항후 시스템 에러의 원인이 될 수 있는 경고성 메시지\n5. ERROR : 요청을 처리하는 중 오류가 발생한 경우 표시\n\n- 로그에 설정할 수 있는 레벨은 총 5개\n- 위에 순서대로 높은 레벨을 가진다. 출력 레벨의 설정에 따라 설정 레벨 이상의 로그를 출력한다.\n\nex 로깅 레벨 설정을 \"INFO\"로 하였을 경우 \"TRACE\", \"DEBUG\"레벨은 무시\n\n 루트 레벨 전체 로깅 레벨 지정\nproperties\nlogging.level.root = info\n\n\n 패키지별로 로깅 레벨지정\nproperties\nlogging.level.com.god.bo.test=info \nlogging.level.com.god.bo.test.controller=debug\n\n\n 설정 case\n 스프링, 일반 자바프로그램\n: logback.xml 파일을 resources 디렉토리에 만들어서 참조한다.\n\n SpringBoot\n: -logback-spring.xml 파일을 resources 디렉토리에 만들어서 참조한다.\n\n참고 순서  \n1. classpathresources 하위 디렉토리에 logback-spring.xml파일이 있으면 설정 파일을 읽어간다.\n2. logback-spring.xml파일이 없다면 .yml.properties파일의 설정을 읽어간다\n3. logback-spring.xml파일과 .yml.properties파일이 동시에 있으면 .yml.properties 설정 파일을 적용 후 xml파일이 적용된다.\n\n logger 등록 및 사용방법\n- LoggerFactory에서 로거 객체를  불ㅇ운 후, 로그 객체를 이용해서 코드의 원하는 부분에 로그를 출력하면 된다.\n\n 설정예시\n\n1. 전체 level 설정 = info\n2. 특정 컨트롤러 패키지 Log Level 설정 = com.god.bo.test.controller = debug\nproperties\nlogging.level.root=info\nlogging.level.com.god.bo.test=info\nlogging.level.com.god.bo.test.controller=debug\n\n\n reference\n- 전자정부표준프레임워크 Logging서비스https://www.egovframe.go.kr/wiki/doku.php?id=egovframework:rte:fdl:logging\n- 갓대희의 작은공간 : Spring Boot 로그 설정1 - Logbackhttps://goddaehee.tistory.com/206\n- 갓대희의 작은강간 : Log4j, LogBack정리https://goddaehee.tistory.com/45",
    "tags": [
      "spring-boot",
      "spring",
      "TIL"
    ]
  },
  {
    "title": "URL의 Character Set 이 UTF-8이 아니라서 생기는 문제",
    "url": "/back-end/2022/03/19/url의-character-set-이-utf-8이-아니라서-생기는-문제/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ">기자재 관리 시스템Jub-Jubhttps://github.com/GSM-Web-Technology/Jup-Jup-Server server에서 AWS s3에다가 파일을 Delete 기능을 구현하고 있었다.  \n>Create, Read로직은 선배님이 해주셨고 나는 Delete 로직을 구현해야 했다.  ",
    "content": "URL의 Character Set 이 UTF-8이 아니라서 생기는 문제\n 배경\n>기자재 관리 시스템Jub-Jubhttps://github.com/GSM-Web-Technology/Jup-Jup-Server server에서 AWS s3에다가 파일을 Delete 기능을 구현하고 있었다.  \n>Create, Read로직은 선배님이 해주셨고 나는 Delete 로직을 구현해야 했다.  \n\n전반적인 로직은 다음과 같다.  \nCreate 로직은 AWS S3에다가 파일을 업로드 하고, s3에 저장된 그 파일의 URL을 DB에 저장하는 로직이다.  \nRead 로직은 Client 에게 s3에 저장되어있는 파일의 URL를 DB에서 조회하여 반환한다.  \nDelete 로직은 DB에 저장되어 있는 파일를 접근할 수 있는 URL에서 s3내의 저장 경로를 추출하여 s3 접근후 삭제한다.\n 문제 상황\n문제는 Delete 로직을 작성할때 일어났다. URL은 Percent-encoding 라는 방식의 Character Set 을 사용한다.  \n> ex 고양이 -> %EA%B3%A0%EC%96%91%EC%9D%B4  \n \n즉 create 로직에서 Percent-encoding을 UTF-8로 decoding 하여 저장하지 않고 그대로 저장해서 문제가 생겼다.\n\n파일의 이름을 URL에서 추출하니까 한글로 된 리소스는 character set 이 다르므로 원본파일의 이름의 문자열과 URL에서 추출한 이름의 문자열은 전혀 달라 접근을 할 수가 없었다.  \n\n 문제 해결방법\nJava 에서 java.net.URLDecoder.decodeURL, character set 을 이용하여 Create 로직을 다음과 같이 UTF-8로 decode 하여 DB에 저장한다.\njava\nuploadImageUrl = URLDecoder.decodeuploadImageUrl, \"UTF-8\";",
    "tags": [
      "spring",
      "TIL"
    ]
  },
  {
    "title": "REMOTE HOST IDENTIFICATION HAS CHANGED Error",
    "url": "/back-end/2022/03/19/remote-host-identification-has-changed-error/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "어느날 AWS ec2에 SSH접속시 다음과 같은 에러가 나왔다.",
    "content": "REMOTE HOST IDENTIFICATION HAS CHANGED Error\n어느날 AWS ec2에 SSH접속시 다음과 같은 에러가 나왔다.\nsh\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now man-in-the-middle attack!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the ECDSA key sent by the remote host is\n{HOST KEY}\nPlease contact your system administrator.\nAdd correct host key in /Users/{user}/.ssh/known_hosts to get rid of this message.\nOffending ECDSA key in /Users/{user}/.ssh/known_hosts:18\nECDSA host key for {YourIP} has changed and you have requested strict checking.\nHost key verification failed.\n\n\n 문제원인\n> 스누핑과 같은 해킹으로 의심되기 때문에 위와같은 경고를 출력한다.\n\n기존에 접속하던 시스템의 변경으로 인해 저장된 원격 시스템의 고유값이 기존에 저장된 값과 다를때 발생한다.\n\n 해결방법\n1. 다음과 같이 호스트 정보를 업데이트 한다.  \n   ssh-keygen -R  IP or DomainName\n2. known_hosts 파일 직접 수정  \n   에러 문구를 보면 다음과같은 에러메세지를 볼 수 있다.\n   > Offending ECDSA key in /Users/{user}/.ssh/known_hosts:18\n\n   해당 위치로 이동해서 해당 라인을 삭제한다. 위 에러메세지에서는 18줄을 삭제하면 해결된다.",
    "tags": [
      "ssh",
      "TIL"
    ]
  },
  {
    "title": "객체와 테이블 매핑(annotation)",
    "url": "/back-end/2022/03/19/객체와-테이블-매핑annotation/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 컬럼 매핑\n- table과 매핑될 클래스에 가 붙여진다\n- 가 붙은 클래스는 JPA가 관리한다.",
    "content": "객체와 테이블 매핑annotation\n @Entity\n: 컬럼 매핑\n- table과 매핑될 클래스에 @Entity가 붙여진다\n- @Entity가 붙은 클래스는 JPA가 관리한다.\n\n 주의\n- 기본생성자 필수\n  > 접근지정자 public or protected\n- final class, enum, interface, inner class를 사용하면 안 된다.\n- 저장할 필드에 final 키워드는 허용되지 않는다. &rarr; JPA가 Entity를 관리하는데 값이 변경되지 않다면 관리를 할 수 없다.\n\n 속성\n 1. name\n: JPA에서 사용할 Entity의 이름 지정\n- 기본값 : 클래스이름\n- 같은 클래스 이름이 없으면 가급적 기본값 사용\n\n 2. insertable, updatable\n: 등록, 변경가능 여부\n- 기본값 : true\n\n 3. nullableDDL\n: null 값의 허용 여부를 설정\n- false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다.\n\n 4. uniqueDDL\n: @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸때 사용\n\n 5. columnDefinitionDDL\n: DB 컬럼 정보를 직접 줄 수 있다.\n- 기본값 : 필드의 자바 타입과 방언정보 사용\n\n 6. lengthDDL\n: 문자 길이 제약조건, String 타입에만 사용\n- 기본값 : 255\n\n 7. precision, scaleDDL\n: BigDecimal 타입 에서 사용\n- 기본값 : \n    \n    precision=19,  \n    scale=2\n    \n- BigDecimal ,BigInteger 사용\n- precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수 다.\n\n @Table\n: Entity를 매핑할 테이블 지정\n\n 속성\n 1. name\n- 매핑할 테이블 이름\n- 기본값 : Entity 이름사용 \n\n 2. catalog\n: DB catalog 매핑\n\n 3. schema\n: DB schema 매핑\n\n 4. uniqueConstraintsDDL\n: DDL 생성 시 unique 제약 조건 생성\n\n @Enumrated\n: enum 타입 매핑\n 속성\n 1. EnumType.STRING\n: 문자열 자체가 DB에 저장된다.  \n> 기본값이 아니여서 지정을 해줘야한다.\n\n 2. EnumType.ORDINAL\n: Enum의 순서값이 DB 저장된다.  \n절대 사용하지 마라!\n @Temporal\n: 날자 타입 매핑\n\n 속성\nTemporalType.Date  \n: 년-월-일 의 data type\n\nTemporalType.Time  \n: 시:분:초 의 data type\n\nTemporalType.TIMESTAMP  \n: 년-월-일 의 date + time 의 timestampdatetime\n\n @Lob\n: BLOB, CLOB 매핑\n- 속성이 없다\n- CLOB: String, char, java.sql.CLOB\n- BLOB: byte, java.sql,BLOB\n\n Transient\n- 필드 매핑을 하지 않을때\n- DB 저장 및 조회를 하지 않는다\n- 주로 메모리 상에서만 임시로 어떤 값을 보관하고 싶을때 사용한다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "값 타입의 비교",
    "url": "/back-end/2022/03/19/값-타입의-비교/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 동일성identify 비교 : 인스턴스 참조 값을 비교, \n- 동등성equivalence 비교 : 인스턴스 값을 비교, \n- 값 타입의  를 적절하게 재정의",
    "content": "값 타입의 비교\n- 동일성identify 비교 : 인스턴스 참조 값을 비교, ==\n- 동등성equivalence 비교 : 인스턴스 값을 비교, equals\n- 값 타입의 equals 를 적절하게 재정의",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "다양한 연관관계",
    "url": "/back-end/2022/03/19/다양한-연관관계/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- 다중성\n- 단방향, 양방향\n- 연관관계의 주인",
    "content": "다양한 연관관계\n 연관관계 매핑시 고려사항\n- 다중성\n- 단방향, 양방향\n- 연관관계의 주인mappedBy\n\n 다중성\n- 다대일: @ManyToOne\n- 일대다: @OneTomany\n- 일대일: @OneToOn\n- 다대다: @ManyToMany\n    > 실무에서 쓰지마라\n\n 객체와 테이블의 차이\n 테이블\n- 외래키 하나로 양쪽 조인 가능\n- 방향이라는 개념이 없다.\n\n 객체\n- 참조용 필드가 있는 쪽으로만 참조할 수 있다.\n- 한쪽만 참조하면 단방향이다.\n- 양쪽이 서로 참조하면 양방향 &rarr; 사실 단방향이 두 개가 있는것\n    > 이것을 이해해야 연관관계의 주인에 대해 이해할 수 있다.\n  \n 연관관계의 주인\n: FK를 관리하는 참조\n- 객체 양방향 관계는 참조가 두 군데 있어 둘 중 태이블의 기본키를 관리할 곳을 지정해야 한다.\n- 주인의 반대편   \n    외래키에 영향을 주지 않고, 단순 조회만 가능하다.\n\n 다대일N : 1\n 1. 다대일 단방향\n<img width=450px src=./img/many-to-one-single.png>\n\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n\n    @Columnname = \"USERNAME\" private String name; private int age;\n\n    @ManyToOne\n    @JoinColumnname = \"TEAM_ID\"\n    private Team team; \n    // etc...\n}\n\n@Entity\npublic class Team{\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n}\n\n\n- RDB에서 1 : N 이라면N쪽에 외래키를 두어야 한다. \n  \n- 외래키가 있는곳을 기준으로 연관된 참조를 하면 된다.\n- 가장 많이 사용한다.\n\n 2. 다대일N : 1 양방향\n<img width=450px src=./img/many-to-one-multi.png>\n\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n\n    @Columnname = \"USERNAME\" \n    private String name; \n    private int age;\n\n    @ManyToOne\n    @JoinColumnname = \"TEAM_ID\"\n    private Team team; \n    // etc...\n}\n\n@Entity\npublic class Team{\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n\n    @MappedBy\"team\"\n    private List<Member> members = new ArrayList<>;\n}\n\n\n- FK 있는 쪽이 연관관계의 주인 &rarr; 여기 예제에서는 Member에 있다.\n  \n- 양쪽을 서로 참조하도록 개발하는 것\n\n 일대다1 : N\n 1. 일대다 단방향\n> 실무에서 거의 사용하지 않는다.  \n> 다음과 같이 모델링하는 것은 권장하지 않는다.  \n \n일대다 단방향 매핑보다 다대일N : 1 양방향 매핑을 사용하자!!\n\n<img width=450px src=\"/assets/images/posts/back-end/one-to-many-single.png\">\n\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n    @Columnname = \"USERNAME\" \n    private String name; \n    private int age;\n\n    //etc/..\n}\n\n@Entity\npublic class Team{\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n\n    @OneToMany\n    @JoinColumenname = \"TEAM_ID\"\n    private List<member> member = new ArrayList<>;\n\n}\n\n- Team에 외래키가 있으면 Team에 중복이 일어난다 &rarr; 사실상 Team이 다N가 된다.\n  \n- insert를 하면 update쿼리가 한 번 더 나간다. &rarr;\n- 실무에서는 테이블이 한개가 아니라 수십 개를 사용한다.  \n  &rarr; \"난 분명 Team을 건들었는데 Member에 update쿼리가 나가네?\" 라는 상황이 일어난다.\n\n 일대다 단방향 정리\n- 일대다 단방향은 일대다1:N에서 일1이 연관관계의 주인이다.\n  \n- 다N 쪽에 외래키가 있다.\n- 엔티티가 관리하는 외래키가 다른 테이블에 있다.\n- 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조\n- @JoinColumn을 꼭 사용해야 한다.  \n  그렇지 않으면 조인 테이블 방식을 사용한다.\n\n 2. 일대다1 : N 양방향 - 비 권장\n> 이 방법은 야매다 사용하지마라 - 김영한\n\n<img width=450px src=\"/assets/images/posts/back-end/one-to-many-multi.png\">\n\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n    @Columnname = \"USERNAME\" \n    private String name; \n    private int age;\n\n    @ManyToOne\n    //강재로 읽기 전용으로 만들어버린다.\n    @JoinColumnname = \"TEAM_ID\", insertable = false, updatable = false\n    private Team team; \n\n    //etc/..\n}\n\n@Entity\npublic class Team{\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n\n    @OneToMany\n    @JoinColumenname = \"TEAM_ID\"\n    private List<member> member = new ArrayList<>;\n\n}\n\n- 이런 매핑은 공식적으로 존재하지 않는다.  \n  @JoinColumnname = \"TEAM_ID\", insertable = false, updatable = false\n\n- 읽기 전용 필드를 사용해서 양방향처럼 사용하는 방법\n- 결론 : 다대일 양방향을 사용하자\n\n 일대일 관계1 : 1\n 1. 일대일 단방향\n<img width=450px src=./img/one-to-one-single.png>\n\njava\n@Entity\npublic class Member {\n    @Id @GeneratedValue\n    private Long id; \n    @Columnname = \"USERNAME\" \n    private String name; \n    \n    @OneToOne\n    @JoinColumnname = \"LOCKER_ID\"\n    Locker locker;\n\n    //etc/..\n}\n\n@Entity\npublic class Locker{\n\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n    @OneToOnemappedBy=\"locker\"\n    private Member member;\n}\n\n- 외래키를 선택할 수 있다.\n\n- 외래키에 DB 유니크UNIQUE 제약조건 추가\n- 다대일@ManyToOne 단방향 매핑과 유사하다.\n\n 2. 일대일 양방향\n<img width=450px src=./img/one-to-one-single.png>\n\n- 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인이다.\n- 반대편 mappedBy 적용\n  \n 3. 대상 테이블에 FK 단방향 \n<img width=450px src=./img/one-to-one-table-fk.png>\n\n- 단방향 관계를 JPA에서 지원하지 않는다.\n- 양방향 관계는 지원한다.\n\n 4. 대상 테이블에 FK 양방향\n<img width=450px src=./img/one-to-one-multi-fk.png>\n\n- 무조건 즉시 로딩된다. EAGAR\n  \n- Member를 조회하면 Locker가 있는지 없는지 확인해야 하므로  \n  즉시 로딩을 할 수밖에 없다. 반대도 마찬가지\n\n 5. 일대일 정리\n주 테이블 와래키\n- 주 객체가 대상 객체의 참조를 가지는것 처럼,  \n  주 테이블에 외래 키를 두고 대상 테이블을 찾는다.\n\n- 객체지향 개발자 선호\n- JPA 매핑 편리\n- 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능\n- 단점: 값이 없으면 외래 키에 null 허용\n\n대상 테이블에 외래키\n- 대상 테이블에 외래키가 존재\n\n- 전통적인 DB 개발자 선호\n- 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지한다.\n- 단점: 프록시Proxy 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩EAGER된다.\n\n 다대다N : N 관계 - 비 권장\n> 실무에서 쓰면 안 된다. 매핑이 있지만... 알고 안 써야지 모르면 쓰고 싶어 진다.\n\n<img width=450px src=./img/many-to-many.png>\n\n- 관계형 DB는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.\n\n- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 한다. &rarr; 야매로 가능하다.\n\n 객체는 컬렉션을 사용하여 객체 2개로 다대가 관계가 가능하다.\n<img width=450px src=./img/obejct-many-to-many.png>\n\n- @ManyToMany\n- @JoinTable로 연결 테이블을 지정한다\n- 다대다 매핑: 단방향, 양방향 가능\n\n 다대다의 한계\n- 편리해 보이지만 실무에서 사용할 수 없다.\n- 연결 테이블이 단순히 연결만 하고 끝나지 않음\n- 주문 시간, 수량 같은 데이터가 들어올 수 있다.  \n<img width=450px; src=./img/meny-to-meny-product.png>\n\n 다대다 한계 극복\n- 연결 테이블용 Entity를 추가한다. 연결 테이블은 엔티티로 승격\n- @ManyToMany &rarr; @OneToMany, @ManyToOne  \n <img width=450px src=./img/many-to-many-limit-solve.png>\n\n- ORDER에 기본키는 관련 없는 값을 사용해야 한다.  \n- GeneratValue를 이용한다. &rarr; 확장성이 높아진다.\n\n 다대다 결론\n다대다 쓰지 마라 일대다 혹은 대다일 을 사용해라.\n\n anotation 정리\n @JoinColumn - 주요 속성\n: 외래키를 매핑할때 사용한다.\n|속성|설명|기본값|\n|--|--|--|\n|name|매핑할 FK 이름|필드명 + _ + 참조하는 테 이블의 기본 키 컬럼명|\n|referencedColumnName|외래 키가 참조하는 대상 테이블의 컬럼명|참조하는 테이블의 기본 키 컬럼명|\n|foreignKeyDDL|외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.||\nunique, nullable, insertable, updatable, columnDefinition, table,|@Column의 속성과 같다. \n\n @ManyToOne - 주요 속성\n: 다대일 관계 매핑\n|속성|설명|기본값|\n|--|--|--|\n|optional|false로 설정하면 연관된 엔티티가 항상 있어야 한다.|TRUE|\n|fetch|글로벌 페치 전략을 설정한다.| @ManyToOne=FetchType.EAGER, @OneToMany=FetchType.LAZY|\n|cascade|영속성 전이 기능을 사용한다.||\n|targetEntity|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다.||\n\n @OneToMany - 주요 속성\n: 일대다 관계 매핑\n|속성|설명|기본값|\n|--|--|--|\n|optional|false로 설정하면 연관된 엔티티가 항상 있어야 한다.|TRUE|\n|fetch|글로벌 페치 전략을 설정한다.| @ManyToOne=FetchType.EAGER, @OneToMany=FetchType.LAZY|\n|cascade|영속성 전이 기능을 사용한다.||\n|targetEntity|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다.||",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "QueryDSL",
    "url": "/back-end/2022/03/19/querydsl/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "-  통합 테스트시 H2 DB 메모리 모드로 돌려서 사용\n    - 로컬 PC에는 H2 DB 서버 모드로 실행\n    - 개발 운영은 MySQL, Oracle로 한다.\n    - DB 방언을 설정만 바꾸면 가능한 일\n- 테스트, 통합 테스트시 CRUD를 믿고간다.내가 짠 쿼리는 그것을 마저 테스트를 거쳐가야한다.\n    > CRUD 테스트 할 시간에 핵심 ...",
    "content": "QueryDSL\n- SQL, JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API\n- JPA Criteria에 비해서 편리하고 실용적\n- 오픈소스\n\n SQL, JPQL의 문제점\n- SQL, JPQL은 문자열이다 -> Type-Check가 불가능하다.\n- 컴파일 시점에 알 수 있는 방법이 없다. -> 문자열\n- 해당 로직 실행 전까지 작동 여부를 확인을 할 수 없다.\n- 해당 쿼리 실행 시점에 오류를 발견한다.\n\n QueryDSL 장점\n문자가 아닌 코드로 작성가능하다\n- 컴파일 시점에 문법 오류 발견\n- 코드 자동완성IDE 도움\n- 단순하고 쉽다.코드 모양이 JPQL과 거의 비슷하다\n- 동적 쿼리\n\n 실무 경험 공유\n- 수 조 단위의 정산을 하는데, JPA로 다 처리\n- 크리티컬한 결제 같은 시스템도 JPA로 처리\n- SpringBoot + JPA + QueryDSL 기본으로 깔고간다.\n- 유연한 DB변경ex. MySQL -> Oracle의 장점과 테스트\n    - Junit 통합 테스트시 H2 DB 메모리 모드로 돌려서 사용\n    - 로컬 PC에는 H2 DB 서버 모드로 실행\n    - 개발 운영은 MySQL, Oracle로 한다.\n    - DB 방언을 설정만 바꾸면 가능한 일\n- 테스트, 통합 테스트시 CRUD를 믿고간다.내가 짠 쿼리는 그것을 마저 테스트를 거쳐가야한다.\n    > CRUD 테스트 할 시간에 핵심 비즈니스 테스트 코드를 열심히 짜자\n- 빠른 에러발견\n    - 쿼리 떄문에 문제가 발생x\n    - 컴파일 시점에 대부분 오류 발견, 늦어도 애플리케이션 로딩 시점에 발견\n    - 최소한 쿼리 문법 실수나 오류는 거의 발생x\n- 대부분이 비즈니스 로직의 오류",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "JAVA EE (Java Enterprise Edition)",
    "url": "/back-end/2022/03/19/java-ee-java-enterprise-edition/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": ": 엔터프라이즈급 환경에서 사용하는 프로그램을 만드는데 적합한 자바 개발 버전이다.\n> J2EE라고도 불렸다. Java 2 Enterprise Edition 지금은 JAVA EE라고 불린다.",
    "content": "JAVA EE Java Enterprise Edition\n: 엔터프라이즈급 환경에서 사용하는 프로그램을 만드는데 적합한 자바 개발 버전이다.\n> J2EE라고도 불렸다. Java 2 Enterprise Edition 지금은 JAVA EE라고 불린다.\n\n> 엔터프라이즈급 환경: 기업을 대상으로 하는 개발 환경이다.  \n> ex. 은행 전산망 같은 것\n\n- Java SE 플렛폼을 기반으로 그 위에 JAVA EE를 탑재했다.\n- Java EE 플랫폼에서는 여러 API 및 환경을 제공한다.\n- Java 기술로 기업환경의 어플리케이션을 만드는데 필요한 스펙들을 모아둔 스펙 집합이다.\n- Java가 갖는 기본적인 특징인 플랫폼 독립성을 갖추고 있다.\n\n java EE 의 API 및 환경\n- 대규모\n- 다계층\n- 확장성\n- 신뢰성\n- 보안 네트워킹\n\n Java EE 핵심 구성요소 13개\n- Java Servlet./servlet.md\n- JDBC\n- JNDI\n- EJB\n- RMI\n- JSP\n- XML\n- JMS\n- Java IDL\n- JTS\n- JTA\n- 자바 메일\n- JAF",
    "tags": [
      "java-ee",
      "TIL"
    ]
  },
  {
    "title": "값 타입",
    "url": "/back-end/2022/03/19/값-타입/",
    "category": "back-end",
    "date": "2022-03-19",
    "excerpt": "- JPA 데이터 타입./ &larr;\n- 기본값 타입./17.1-default-type.md\n- 임베디드 타입./17.2-embedded-type.md\n- 값 타입과 불변 타입./17.3-value-and-immutable.md\n- 값 타입의 비교./17.4-value-type-compare.md\n- 값 타입 컬렉션./17.5-value-type-coll...",
    "content": "목차\n- JPA 데이터 타입./ &larr;\n- 기본값 타입./17.1-default-type.md\n- 임베디드 타입./17.2-embedded-type.md\n- 값 타입과 불변 타입./17.3-value-and-immutable.md\n- 값 타입의 비교./17.4-value-type-compare.md\n- 값 타입 컬렉션./17.5-value-type-collection.md\n- 정리./17.6-organize.md\n\n 값 타입\n: 복잡한 객체 세상을 조금이나마 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.\n\n JPA의 테이터 타입 분류\n Entity 타입\n- @Entity로 정의하는 객체\n- 데이터가 변해도 식별자가 지속해서 추적하능하다.\n- ex 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식가능하다.\n\n 값 타입\n- 자바 기존타입이나 객체 &rarr; int, String 등 단순 값으로 사용하는 자바 객체\n- 식별자가 없고 값만 있으므로 변경시 추적 불가하다.\n- ex 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체한다.",
    "tags": [
      "spring",
      "jpa",
      "TIL"
    ]
  },
  {
    "title": "Socket",
    "url": "/network/2022/03/17/socket/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "소켓은 네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의  이다.  \n> 소프트웨어로 작성된 추상적인 개념의 통신 접속점이라고 할 수 있다.",
    "content": "Socket\n소켓은 네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의 엔드 포인트 이다.  \n> 소프트웨어로 작성된 추상적인 개념의 통신 접속점이라고 할 수 있다.\n\n오늘날 컴퓨터 간 통신의 대부분은 인터넷 프로토콜을 기반으로 하고 있으므로, 대부분의 네트워크 소켓은 인터넷 소켓이다.\n\n 소켓 종류\n 스트림 TCP\n- 양방향으로 바이트 스트림을 전송한다.\n- TCP를 사용하기 떄문에 연결 지향성을 가진다.\n- 오류 수정, 전송처리, 흐름제어를 보장한다.\n- 송신된 순서에 따라 중복되지 않게 데이터를 수신하므로 &rarr; 오버헤드가 발생한다.\n- 대량의 데이터 전송에 적합하다.\n\n 데이터그램 UDP\n- 명시적으로 연결을 맻지 않아 비 연결형 소켓이다.\n- 데이터의 크기에 제한이 았다.\n- UDP이기 떄문에 전달이 보장되지 않으며 데이터의 손실되도 오류가 발생하지 않는다.\n- 실시간 멀티미디어 정보를 처리하기 위해 주로 사용한다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "너비 우선 탐색 - Breadth-First Search",
    "url": "/algorithm/2022/03/17/너비-우선-탐색---breadth-first-search/",
    "category": "algorithm",
    "date": "2022-03-17",
    "excerpt": "루트 노드혹은 다른 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.",
    "content": "너비 우선 탐색 - Breadth-First Search\n루트 노드혹은 다른 임의의 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다.\n\n- 맹목적인 탐색을 하고자 할 때 사용할 수 있다.\n- 주로 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 사용한다.\n- 큐 - Queue 자료구조를 이용해 구현한다.\n\n\n 동작 원리\nBFS의 동작은 큐를 이용해 지금 위치에서 갈 수 있는 노드를 모두 넣는 방식으로, 큐에 넣는 동시에 방문했다고 체크해야 한다.\n\n 준비물\n- 그래프 혹은 트리\n- Queue\n- 방문여부 확인용 배열\n  > 트리가 아닌 그래프에 꼭 필요하다.\n\n BFS를 통해 해결할 수 있는 문제의 조건\n1. 최소 비용 문제이어야 한다.\n2. 간선의 가중치가 1 이어야 한다.\n3. 정점과 간선의 개수가 적어야 한다.",
    "tags": [
      "graph-search",
      "TIL"
    ]
  },
  {
    "title": "DDD(Domain Driven Design)",
    "url": "/programming/2022/03/17/ddddomain-driven-design/",
    "category": "programming",
    "date": "2022-03-17",
    "excerpt": ": 도메인을 중심으로 하는 개발 방식이다.  \n&rarr; 도메인에 관련된 문제를 해결하는것.\n- 복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나아간다.\n- 복잡한 소프트웨어는 기술 자체의 복잡성 보다 도메인 자체의 복잡성에 기인한다.",
    "content": "DDDDomain Driven Design\n: 도메인을 중심으로 하는 개발 방식이다.  \n&rarr; 도메인에 관련된 문제를 해결하는것.\n- 복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나아간다.\n- 복잡한 소프트웨어는 기술 자체의 복잡성 보다 도메인 자체의 복잡성에 기인한다.\n\n 등장배경\n 빈약한 도메인 모델\n- Getter와 Setter만으로 구성된 모델\n- 데이터만 가지는 데이터홀더 개념\n- Big Service Layer  \n\n&rarr; 모델과 코드의 불일치가 발생하고 소통이 어려워진다.",
    "tags": [
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "WAS - Web Application Server",
    "url": "/network/2022/03/17/was---web-application-server/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": ": DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server\n>ex Tomcat, JBoss, Jeus, Web Sphere 등...\n- HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어소프트웨어 엔진이다.\n-  “웹 컨테이너Web Container”, “서블릿 컨테이너Servlet ...",
    "content": "WAS - Web Application Server\n: DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server\n>ex Tomcat, JBoss, Jeus, Web Sphere 등...\n- HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어소프트웨어 엔진이다.\n-  “웹 컨테이너Web Container”, “서블릿 컨테이너Servlet Container” 라고도 불린다\n    - Container: JSP, Servlet을 실행시킬 수 있는 소프트웨어\n    - 즉 WAS 란 JSP, Servlet 구동 환경제공\n WAS 역활\n- WAS = Web Server + Web Container\n- Web Server 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시\n    - 분산 트랜잭션, 보안, 메시징, 쓰래드 처리 등 기능을 처리하는 분산환경\n    - 주로 DB서버와 같이 수행\n\n 주요기능\n- 프로그램 실행환경과 DB접속 기능 제공\n- 여러 개의 트렌잭션 관리 기능\n- 비즈니스 로직 실행",
    "tags": [
      "web",
      "TIL"
    ]
  },
  {
    "title": "REST, API, REST API",
    "url": "/network/2022/03/17/rest-api-rest-api/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "- RESTREST-Representational-State-Transfer 표현-상태 전이\n- APIAPIApplication-Programming-Interface\n- REST APIREST-API\n- RESTful APIRESTful-API",
    "content": "REST, API, REST API\n 목차\n- RESTREST-Representational-State-Transfer 표현-상태 전이\n- APIAPIApplication-Programming-Interface\n- REST APIREST-API\n- RESTful APIRESTful-API\n REST Representational State Transfer 표현 상태 전이\n: \"웹에 존재하는 모든 자원이미지, 동영상, DB 자원에 고유한 URL을 부여해 활용\"하는 것, 자원을 정의 및 자원에 대한 주소를 지정하는 방법을 의미한다.  \n\n 구체적 개념\n: HTTP URI 를 통해 자원을 명시하고 HTTP Method를 통해 해당 자원의 대한 CRUD Operation을 적용한다.\n- REST는 자원 기반의 구조ROA, Rswource Oriented Architecture설계의 중심에 Resource가 있고, HTTP Method를 통해 Resource를 처리하도록 설계된 것.\n\nCRUD Operation\n- Create : 생성POST\n- Read : 조회GET\n- Update : 수정PUT\n- Delete : 삭제DELETE\n- HEAD : header 정보 조회HEAD\n\n REST 필요 이유?\n- 애플리케이션 분리 및 통합\n- 다양한 클라이언트의 등장\n- 다양한 플랫폼, 디바이스에서 통신할 수 있어야 한다.\n\n\n REST 의 구성요소\n- 자원RESOURCE, URI  \n    : 모든 자원은 고유한 ID를 가지고 ID는 서버에 존재하고 클라이언트는 각 자원의 상태를 조작하기 위해 요청을 보낸다. \n    >HTTP에서 이러한 자원을 구별하는 ID는 'Students/1' 같은 HTTP URL이다.\n- 행위Verb, HTTP Method  \n    : 클라이언트는 URL를 이용해 자원을 지정하고 자원을 조작하기 위해 Method를 사용한다.  \n    >HTTP프로토콜에서는 <U>GET</U>, <U>POST</U>, <U>PUT</U>, <U>DELETE</U> 와 같은 Method를 제공\n- 표현Representations  \n    : 클라이언트가 서버로 요청을 보냈을 때 서버가 응답으로 보내주는 자원의 상태를 Representation이라고 한다. \n    >REST에서 하나의 자원은 JSON, XML, TEXT, RSS등 여러형태의 Representation으로 나타낼수 있다.\n\n 인터페이스의 일관성\n> 인터페이스의 일관성이 잘 지켜졌는지에 따라 REST를 잘 사용했는지 판단 할 수 있다.\n 자원의 식별\n: 웹 기반의 REST에서 리소스를 접근할 떄 URI를 사용한다.  \n\nex  \nhttps://foo.co.kr/user/100  \n- Resource : user\n- 식별자 : 100\n\n 메세지를 통한 리소스 조작\n: Web에서는 다양한 방식Html, json 등..으로 데이터를 전달 할 수 있다.\n- 어떠한 타입을 알려주기위해 HTTP Header에 content-type을 통해 타입을 지정해 줄수 있다.\n- 리소스 조작을 위해 데이터 전체를 전달하지 않고 이를 메세지로 전달한다.\n\n 자기서술적 메세지\n: 요청하는 데이터가 어떻게 처리 되어야 하는지 충분한 데이터를 포함 할 수 있어야한다.\n- HTTP기반의 REST에서는 HTTP Method, Header 정보, URI의 포함되는 정보로 표현 할 수 있다.\n\nGET : https://foo.co.kr/user/100, 사용자 정보 요청  \nPOST : https://foo.co.kr/user, 사용자 정보 생성  \nPUT : https://foo.co.kr/user, 사용자 정보 생성 및 수정  \nDELETE : https://foo.co.kr/user/100, 사용자 정보 삭제  \n\n그외 담지 못 한 정보들을 URI의 메세지를 통하여 표현한다.\n\n Application 상태에 대한 엔진으로써 하이퍼미디어\n:REST API를 개발할 때 단순히 Client요청에 대한 데이터만 응답 해주는 것이 아닌 관련된 리소스에 대한 Link정보까지 같이 포함해야한다.\n\n\n REST 의 특징\n- Uniform Interface인터페이스 일관성  \n    : URL로 지정한 리소스에 대한 조작을 통일하며 한정적인 인터페이스로 수행한다  \n    > HTTP표준에만 따른다면 모든 플랫폼에 사용이 가능하다.\n- Stateless무상태성  \n    : HTTP는 Stateless 프로토콜 이므로 REST 역시 무상태성을 가진다.  \n    > 클라이언트의 Context 를 서버에 저장하지 않는다.\n- Cacheable캐시 기능  \n    : 클라이언트는 서버의 응답을 Cache임시저장 할 수 있어야한다.\n    - 클라이언트가 Cache를 통해 응답을 재사용할 수 있어야한다. &rarr; 이를 통해 서버의 부하를 낮춘다.\n    >웹 표준 HTTP 프로토콜을 그대로 사용하므로, 웹에서 사용하는 기존의 인프라를 그대로 활용가능\n- Self-descriptiveness 자체 표현 구조  \n    : REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다.\n- Client/Server 구조  \n    : 자원이있는 Server, 자원을 요청하는 Client의 구조를 가진다.\n- Layered System계층화  \n    : API서버는 순수 비즈니스 로직을 수행하고 그 앞단에 사용자 인증, 암호화, 로드밸런싱 등을 하는 계층을 추가하여 구조상 유연성을 줄 수 있다.\n\n 장점\n- 쉬운사용\n    > HTTP 프로토콜 인프라를 그대로 사용하므로 별도의인프라를 구축할 필요가 없다.\n- 클라이언트-서버 역활의 명확한 분리\n    > 클라이 언트는 REST API를 통해 서버와 정보를 주고받는다. REST의 특징인 Stateless에 따라 서버는 클라이언트의 Context를 유지할 필요가 없다.\n- 특정 데이터 표현을 사용가능\n    > REST API는 헤더 부분에 URL처리 메소드를 명시하고 필요한 실제 데이터 를 'body'에 표현할 수 있도록 분리, JSON, XNL등 원하는 Representation 언어로 사용가능\n\n 단점\n- 메소드의 한계\n    >REST는 HTTP 메소드를 이용하여 URL를 표현한다.  \n    이러한 표현은 쉬운 사용이 가능하다는 장점이 있지만 메소드 형태가 제한적인 단점이 있다.\n- 표준이 없음\n    >REST는 설계 가이드일 뿐 표준이 아니다.\n\n Resource\n: REST는 자원접근을 URL로 하게된다. 이 때문에 URL 설계시 규칙의 유의해야 한다.\n- '/'의 쓰임세는 계층 관계를 표현시 사용한다.\n- URL로 이루는 resouce들은 명사로 이루어져야 한다.\n- REST resource 간에는 연관 관계를 표현시 다음과 같은 방법을 사용한다.\n    > /리소스명/리소스ID/관계가 있는 다른 리소스  \n    > GET : /users/{userid}/devices has 관계\n- URL에서는 -하이픈을 권장\n- 소문자로 작성\n- 확장자 포함x\n\n APIApplication Programming Interface\n: 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스\n- Client, Server와 같은 서로 다른 프로그램에서 Request, Response을 주고 받을 수 있도록 하는 체계\n- 구현방식을 몰라도 제품/서비스가 서로 커뮤니케이션을 할 수 있다.\n\n\n REST API\n: REST 기반으로 서비스 API를 구현 및 제공 하는 것\n- 공공데이터, 구글 맵, 마이크로 서비스 등 대부분이 REST API를 통해 제공\n- HTTP 표준을 기반으로 구현여 HTTP를 지원하는 프로그램 언어를 사용하여 Client 및 Server를 구현 할 수 있다.\n\n RESTful API\n: HTTP와 URI 기반으로 자원에 접근할 수 있도록 제공하는 애플리케이션 개발 인터페이스\n- REST의 6가지 규칙을 잘 지켜 설계된 API를 지칭한다.\n- 'REST API'를 제공하는 웹 서비스를 'RESTful' 하다고 할 수 있다.\n- RESTful은 REST를 REST답게 쓰기 위한 방법이다.\n    >즉 공식적인 Architecture가 아니다.\n\n 배경\n- 최근의 서버 프로그램은 크로스 플랫폼에 대응을 해야한다.\n- 범용적으로 사용성을 보장하는 서버 디자인이 필요하게 되었다.\n- 웹의 장점을 최대한 활용할 수 있는 Architecture로써 REST를 발표하게 되었다.\n\n 특징\n- 여러시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다. 즉 플렛폼의 제약을 두지 않기위하여 사용한다.\n- HTTP를 지원하는 프로그램 언어로 Client, Server를 구현할 수 있다.",
    "tags": [
      "TIL",
      "http"
    ]
  },
  {
    "title": "URI?, URL?, URN?",
    "url": "/network/2022/03/17/uri-url-urn/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "<p align=\"center\"><img width=600 src=\"/assets/images/posts/network/uri-url-urn.png\"></p>",
    "content": "URI?, URL?, URN?\n<p align=\"center\"><img width=600 src=\"/assets/images/posts/network/uri-url-urn.png\"></p>\n\n URI - Uniform Resource Idntifier\n: 통합 자원 식별자ID, 정보 리소스를 고유하게 식별하고 위치를 지정함  \n- URI의 두가지 형태 URL, URN가 있다. 즉 URL, URN은 URI의 부분집합  \n- URI의 존재는 인터넷에서 요구되는 기본조건으로 인터넷 프로토콜이 항상 붙어다님  \n    ex. http://www.naver.com\n- 응답은 달라질수 있다. .pdf, docx\n\n 단어 뜻\n- Uniform: 리소스를 식별하는 통일된 방식\n- Resource: 자원 URL로 식별할 수 있는 모든것 - 제한x\n- Identifier: 다른 항목과 구분하는데 필요한 정보\n\n URL - Uniform Resource Locator\n: 특정 서버의 한 리소스에 대한 구채적인 위치 서술  \n- URL은 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다.\n- 웹사이트 주소가 요청하는 파일이라기보다는 구분자로 보는것\n\nhttp://example.com/mypage.html - 실제 사이트 URL\n\n\nhttp://img.naver.net/static/www/dl_qr_naver.png - 네이버 앱QR코드의 이미지에 대한 URL\n\n\n 문법\nhttp\nscheme://userinfo@host:port/path?queryfragment\nhttps://www.google.com:443/search?q=hello&hl=ko\n\n- scheme : 주로 프로토콜을 사용한다.\n- userinfo : URL에 사용자정보를 포함해서 인증한다.\n  > 거의 사용하지 않는다.\n- host : 도메인 or IP\n- port : port번호\n- path : 리소스 경로, 계층적 구조\n- query : key=value 형태\n  > query parameter, query string등으로 불림\n- fragment : html 내부 북마크 등에 사용하고, 서버에 전송하는 정보가 아니다.\n- http 80포트, https 443포트는 생략할 수 있다.\n\n URN - Uniform Resource Name\n: 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름  \n- 리소스가 그 이름을 변하지 않게 유지하는 한, 여러종류의 네트워크 접속 프로토콜로 접근해도 문제가 없다.\n- 노출된 URL은 http://blog.com/work/222 인데, http://blog.com/work/list/222 으로 보내면 404 response를 받는다. 이를 보완하기위해 위치 정보와 무관한 리소스를 찾게 해주게 하는 방식\n- 해당 리소스의 위치정보가 아닌 실제 리소스의 이름으로 사용하는 방식\nex. urn:2.19.222 \n\nurn:isbn:0451450523 - URN으로 1926년에 출간된 the Last Unicorn의 도서식별번호\n\n\nurn:oid:2.16.840 - URN으로 미국을 의미하는 OID이다",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "더 나은 URI API를 설계 하는 방법과 HTTP method",
    "url": "/network/2022/03/17/더-나은-uri-api를-설계-하는-방법과-http-method/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "좋은 API설계는 리소스를 식별해야 한다.",
    "content": "더 나은 URI API를 설계 하는 방법과 HTTP method\n좋은 API설계는 리소스를 식별해야 한다.\n\n 리소스의 의미\n회원 API를 예로들면 회원 전체-조회/등록/조회/수정/삭제 API가 있을 때 전체-조회/등록/조회/수정/삭제가 리소스가 아니다.  \n회원이 리소스라고 할 수 있다.\n\n즉, 구체적인 행위 - Method가 아닌 \"하나 또는 여러개의 식별할 수 있는 고유한 것\"을 리소스 라고 할 수 있다.\n\n 1. URL 설계\n- URL은 리소스만 식별하도록 해야 한다.\n  \n다음과 같이 행위를 포함하는게 아닌\n- 회원 전체 조회: /members\n- 회원 등록: /create-member\n- 회원 조회: /read-member-by-id\n- 회원 수정: /update-member\n- 회원 삭제: /delete-member\nw\n리소스만 표현하도록 작성해야 한다.\n- 회원 전체 조회: /members\n- 회원 등록: /members/{id}\n- 회원 조회: /members/{id}\n- 회원 수정: /members/{id}\n- 회원 삭제: /members/{id}\n\n하지만 URL만으로 API를 구분할 수 없다. 이를 HTTP method가 해결한다.\n\n 2. HTTP Method\n 주요 HTTP Method\n- GET: 리소스 조회\n- POST: 요청 데이터 처리\n  > 주로 등록에 사용한다.\n- PUT: 리소스를 대체한다.\n  > 해당 리소스가 없으면 생성\n- PATCH: 리소스 부분 변경\n- DELETE: 리소스 삭제\n\n 기타 HTTP Method\n- HEAD: GET과 동일하지만, 상태줄과 헤더만 반환한다.\n- OPTIONS: 대상 리소스에 대한 통신 가능 옵션메서드를 설명한다.\n  > 주로 CORS에서 사용된다.\n- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정한다.\n- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행한다.\n\n 2-1. GET\n리소스를 조회한다.\n- 서버에게 전달하고 싶은 데이터는 query를 통해 전달한다.\n  > ex. GET /board?page=1&count=10\n- Request Body를 사용할 수 있지만, 지원하는 곳이 적어 권장하지 않는다.\n\n\n 2-2. POST\n요청 데이터를 처리한다.\n- 메시지 바디를 통해 서버로 요청 데이터를 전달한다.\n- 서버는 요청 데이터를 처리한다.\n  > 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.\n- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용된다.\n\n\n 그럼 POST는 도대체 어쩔 때 사용하는건데?\nPOST 메서드는 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청한다.\n- 새 리소스 생성등록\n  > 서버가 아직 식별하지 않은 새 리소스 생성 ex. 회원가입\n- 요청 데이터 처리\n  > 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우 \n  - 주문과 같이 \"결제완료 &rarr; 배달시작 &rarr; 배달완료\" 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우\n  - 예시 POST /orders/{orderId}/start-delivery와 같은 컨트롤 URI를 사용한다.\n- 다른 메서드로 처리하기 애매한 경우\n  > JSON으로 조회 데이터를 넘겨야 할 때, 혹은 회원 탈퇴같이 body에 JSON을 넘겨야 하는 경우\n\nPOST는 리소스를 생성할 때 만 사용하는 게 아니라 다양한 상황에서 사용된다. 서버에서 큰 변화가 일어나거나 다른 메서드로 처리하기 애매할 경우에도 사용한다.\n\nURI설계에서 컨트롤 URI처럼 어쩔 수 없이 동사를 사용해야 하는 경우를 제외하고 모두 리소스를 식별할 용도로 사용하는게 좋다.\n\n 2-3. PUT\n리소스를 대체한다.\n- 리소스가 있나? == true ? 대체 : 생성\n  > 덮어버린다고 생각하면 된다.\n- 클라이언트가 리소스의 정확한 위치를 식별하고 있다.\n\nPUT은 리소스를 덮어버리기 때문에 해당 리소스를 부분 수정하고 싶으면 PETCH를 사용해야 한다.\n\n 2-4. PETCH\n리소스를 부분 변경한다.\n\n 2-5. DELETE\n리소스를 제거한다.\n\n 3. HTTP method의 속성\n 3-1. 안전 - Safe\n- 호출해도 리소스를 변경하지 않는다.\n  > GET, HEAD\n\n 3-2. 멱등 - Idempotent\n> ffx = fx\n\n- 한 번 호출하든, 두 번 조회하든 같은 결과가 조회된다.\n\n 1. 멱등 메서드\n- GET\n  > 여러번 조회해도 같은 결과를 조회한다.\n- PUT\n  > 결과를 대체하므로 같은 요청을 여러번 호출해도 최종 결과가 같다.\n- DELETE\n  > 결과를 삭제하므로 같은 요청을 여러번 수행해도 삭제된 결과는 같다.\n  \n 2. 멱등하지 않는 메서드\n- POST\n  > 여러번 호출하면 계속적으로 데이터가 추가되므로 멱등하지 않다. \n  \n 3. 멱등성의 활용\n- 자동 복구 메커니즘\n- 서버가 TIME OUT 등으로 정상 응답을 주지 않았을 떄, 클라이언트가 같은 요청을 해도 되는지에 대한 판단 근거가 된다.\n\n 4. 멱등성의 주의점\n외부 요인으로 인해 중간에 리소스가 변경되는 것 까지 고려하지 않는다.\n\n- 사용자1 : GET -> {username : A, age : 20}\n- 사용자2 : PUT -> {username : A, age : 30}\n- 사용자1 : GET -> {username : A, age : 30} &rarr; 사용자2의 영향으로 데이터age가 변경됨\n\n 3-3. 캐시 가능 - Cacheable\n- GET, HEAD, POST, PATCH 캐시 가능\n  > 실제로는 GET, HEAD 매서드만 캐시를 사용한다.\n\n Reference\n- https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard",
    "tags": [
      "TIL",
      "http"
    ]
  },
  {
    "title": "쿠키(cookie) 와 세션(session)",
    "url": "/network/2022/03/17/쿠키cookie-와-세션session/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "- HTTP 프로토콜은 Connectionless비연결성 과 Stateless비상태성 라는 특징을 가지고 있다.  \n- 모든 사용자의 요청마다 연결과 해제의 과정을 거치면서 연결상태를 유지하지 않고 연결 헤제 후에도 상태 정보를 저장하지 않기 떄문에 서버의 자원을 크게 절약할 수 있다.  \n- 하지만 HTTP 프로토콜 만으로 자동로그인, 로그인 상태 유지등...",
    "content": "쿠키cookie 와 세션session\n 쿠키Cookie와 세션Session을 사용하는 이유\n- HTTP 프로토콜은 Connectionless비연결성 과 Stateless비상태성 라는 특징을 가지고 있다.  \n- 모든 사용자의 요청마다 연결과 해제의 과정을 거치면서 연결상태를 유지하지 않고 연결 헤제 후에도 상태 정보를 저장하지 않기 떄문에 서버의 자원을 크게 절약할 수 있다.  \n- 하지만 HTTP 프로토콜 만으로 자동로그인, 로그인 상태 유지등 이러한 기능들을 사용할 수 가 없다  \n\n이러한 <U>HTTP Connectionless, Stateless 의 특성들을 보완한 기술이 쿠키, 세션 이다.</U>\n 쿠키cookie\n: 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터이다. \n>쿠키의 데이터 형태는 Key 와 Value로 구성되고 String으로만 이루어져 있고 4KB 이상 저장할 수는 없다.  \n- Cookie를 이용한 Server-Client 흐름\n\n<img width=\"450px\" src=\"/assets/images/posts/network/cookie-server-client.png\">\n\n 배경\n-  클라이언트가 정보를 유지하는 Stateful 한 성격의 서비스가 점점 많아짐  \n로그인을 통해 볼 수 있는 서비스, 장바구니 서비스 등\n- 정보를 유지할 수 없는 Connectionless, Statelses의 성격을 가진 HTTP의 단점을 해결하기 위해 쿠키라는 개념이 도입됨  \n 사용 목적\n1. 세션 관리Session Management\n> 로그인, 사용자 닉네임 등 서버가 알아야할 정보들을 저장\n2. 개인화Personlization\n> 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다.\n3. 트래킹Tracking\n> 사용자의 행동과 패턴을 분석하고 기록 \n 쿠키cookie 구성요소\n|구성요소|설명|\n|------|---|\n|name|쿠키의 이름|\n|value|쿠키의 저장된 값|\n|expires|쿠키가 언제 삭제되는지 결정|\n|domain|쿠키가 사용되는 도매인을 가짐|\n|path|쿠키를 반환할 경로를 결정|\n|secure|보안 연결 설정|\n|httpOnly|Http외에 다른 통신 사용가능설정|\n\n\n 세션Session\n: 비밀번호와 같은 인증 정보를 쿠키에 저장하지 않고 대신에 사용자의 식별자인 JSESSIONIDsession id 를 저장한다.\n>서버에는 인증 정보와 더불어 이 ID에 해당하는 로그인 상태, 마지막 로그인 시간, 닉네임, 만료기한 등의 정보를 저장한다.  \n>보안상 서버는 사용자의 개인 컴퓨터보다는 훨씬 안전하기 때문에 인증에 Session을 이용한다.\n 배경\n쿠키의 트래픽 문제와 쿠키를 변경하는 보안적 이슈를 해결하기 위해 등장\n 세션HTTP Session?\n- server  \n    : HTTP Session id를 식별자로 구별하여 데이터를 접속한 서버 DB에 정보를 저장쿠키 형태x\n- client  \n    : HTTP Session id를 쿠키로 메모리 저장된 형태로 가지고 있다.\n- 메모리에 저장하기 떄문에 브라우저가 종료되면 사라짐\n 세션HTTP Session 절차\n<img width=\"450px\" src=\"/assets/images/posts/network/session-stream.png\">  \n\n1. Client가 서버에 Resource를 요청\n2. 서버에서 HTTP Request를 통해 쿠키에서 <code>Sessio-id</code>를 확인을 한 후 없으면 Set-Cookie를 통해 새로 발행할 <code>Session-id</code> 를 보냄\n3. Client는 HTTP Request Header에 Session-id를 포함하여 원하는 Resource를 요청\n4. Server는 Session-id를 통해 해당 session을 찾아 클라이언트 상태 정보를 유지하여 적절한 응답을 함\n\n 세션Session의 특징\n- Session-id는 브라우저 단위로 저장, 브라우저 종료시 소멸\n- 각 Client에게 고유 ID를 부여ex. 로그인한 유저, 로그아웃한 유저\n- 사용자가 많아질수록 서버 메모리를 많이 차지\n\n 쿠키와 세션의 차이\n- 쿠키와 세션은 비슷한 역활을 하며, 동작원리가 비슷하다.\n  > 세션은 쿠키를 사용한다.\n- 사용자의 정보가 저장되는 위치\n  > 쿠키는 local, 세션은 server에 정보가 저장된다.\n- 정보가 저장되는 위치로 인해 쿠키가 보안이 비교적 좋지않다.\n- 세션은 server에서 처리를 해야 하므로 쿠키보다 느리다.\n- 라이프 사이클\n  - 쿠키: 만료되어도 local에 남을 수 있다.\n  - 세션: 만료시간 상관없이 브라우저 종료시 소멸",
    "tags": [
      "web",
      "TIL"
    ]
  },
  {
    "title": "소프트웨어 개발의 3개의 KEY원칙",
    "url": "/programming/2022/03/17/소프트웨어-개발의-3개의-key원칙/",
    "category": "programming",
    "date": "2022-03-17",
    "excerpt": "> 같은 코드를 반복하지마라.",
    "content": "소프트웨어 개발의 3개의 KEY원칙\n DRY- Don't Repeat Yourself\n> 같은 코드를 반복하지마라.\n\n- 공통적으로 사용되는 코드를 하나의 함수로 만들어 사용하고 관리한다.\n  > 응집력이 증가한다.\n\n KISS - Keep It Simple, Stupid\n> 단순하고 간결하게 디자인 해라\n\n: 소프트웨어 디자인을 간단하고 단순하게 하는 것을 의미한다.\n- 복잡한 설계보다 단순한 설계가 개발/유지보수에 쉽다.\n\n YAGNI - You aren't gonna need it\n> 정말로 필요할때까지 작성하지 말아라.\n\n- 추후에 필요할 것 같은 기능이나 코드가 있더라도 예측하야 미리 추가를 하지말자\n- 필요해 보이지만 사양변경으로 필요가 없어질 수 있다.\n- 기능 추가로 인해 기능의 복잡도도 높아지므로 현재의 코드나 프로젝트 기능에 집중을 방해하는 요인으로 작용하게 되며  \n  버그가 발생할 수 있다.",
    "tags": [
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "서버기반 인증, 토큰기반 인증",
    "url": "/network/2022/03/17/서버기반-인증-토큰기반-인증/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "> 이글은 토큰기반의 인증을 왜 사용하느냐에 중점을 두어서 작성했습니다.",
    "content": "서버기반 인증, 토큰기반 인증\n> 이글은 토큰기반의 인증을 왜 사용하느냐에 중점을 두어서 작성했습니다.\n\n 서버 기반의 인증\n: 클라이언트로부터 요청을 받으면, 클라이언트의 상태를 계속해서 유지하고 이 정보를 서비스에 이용하는 Sateful 서버\n- 세션을 기반으로 정보저장메모리, DB를 이용해 정보 저장\n\n<img width=40% src=./img/server-auth.png>\n\n 문제점\n세션session\n> 로그인 중인 사용자가 늘어날 경우에는 서버의 RAM에 부하가 걸리게 된다  \n\n확장성  \n> 사용자가 늘어나게 되면 더 많은 트래픽을 처리하기 위해 여러 프로세스를 돌리거나 컴퓨터를 추가하는 등 서버를 확장해야한다.  \n> 세션을 사용한다면 세션을 분산시키는 시스템을 설계해야 하지만 이러한 과정은 매우 어렵고 복잡한다.\n\nCORSCross-Origin Resource Sharing\n> 웹 어플리케이션에서 세션을 관리할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있다. 따라서 쿠키를 여러 도메인에서 관리하는 것은 번거롭다.\n\n이러한 문제들을 때문에 token 기반의 인증 시스템을 사용한다.\n\n 토큰 기반의 인증 시스템\n: 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내도록 하여 유효성 검사를한다.\n\n 동작 과정\n<img width=40% src=./img/token-auth.png>\n\n1. 사용자가 로그인을 한다\n2. 서버 측에서 해당 정보검증한다.\n3. 정보가 정확하다면 서버 측에서 사용자에게 Signed 토큰 발급\n    > signed는 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 Signature를 가지고 있다는 것\n4. 클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청을 할 때마다 해당 토큰을 서버에 함께 전달한다. 이때 Http 요청 헤더에 토큰을 포함시킨다.\n5. 서버는 토큰을 검증하고, 요청에 응답한다.\n\n 장점\n- 무상태성Stateless & 확장성Scalability\n    > 토큰은 클라이언트 측에 저장되기 때문에 서버는 완전히 Stateless하며, 클라이언트와 서버의 연결고리가 없기 때문에 확장하기에 매우 적합하다.\n- 보안성\n    > 쿠키 사용에 의한 취약점이 사라지게된다.\n- 확장성Extensibility  \n    : 시스템의 확장성을 의미하는 Scalability와 달리 Extensibility는 로그인 정보가 사용되는 분야의 확정을 의미\n    >  토큰 기반의 인증 시스템에서는 토큰에 선택적인 권한만 부여하여 발급할 수 있으며 OAuth의 경우 Facebook, Google 등과 같은 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.\n- 여러 플랫폼 및 도메인\n    > 서버 기반 인증 시스템의 CORS 해결가능",
    "tags": [
      "web",
      "TIL"
    ]
  },
  {
    "title": "TCP - Trancmission Control Protocol",
    "url": "/network/2022/03/17/tcp---trancmission-control-protocol/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "> 신뢰할 수 있는 프로토콜이며 현재 대부분 사용하고 있다.",
    "content": "TCP - Trancmission Control Protocol\n> 신뢰할 수 있는 프로토콜이며 현재 대부분 사용하고 있다.\n\n 특징\n 1. Trancmission - 연결지향 - TCP 3 way handshake 가상연결\n3번의 요청으로 클라이언트와 서버모두 데이터를 전송할 준비가 완료되었다는 것을 보장하는 과정이다.  \n\n<img width=550 src=\"/assets/images/posts/network/tcp-3-way-handshake.png\">\n\n1. 클라이언트는 서버에게 접속 요청SYN을 한다.\n2. 서버는 클라이언트의 요청을 수락ACK하고, 클라이언트에게 접속을 요청SYN을 한다.\n3. 클라이언트는 서버의 요청을 수락ACK한다.\n   > ACK메시지와 함께 데이터를 전송할 수 있다.\n4. 데이터를 전송한다.\n\nTCP 3 way handshake를 통해 클라이언트와 서버는 논리적으로 연결된다. \n\n 2. 데이터 전달 보증\n데이터가 제대로 전송되었는지 서버에서 응답을 한다.\n\n 3. 순서 보장\n패킷의 전송 순서를 보장한다.\n\nTCP/IP 패킷에는 전송제어, 순서, 검증 정보들이 담겨있어 순서가 잘못되면 다시 요청을 하거나 서버의 내부적인 로직을 통해 순서를 보장한다.\n\n하지만 이렇게 안전한 프로토콜도 단점이 존재하는데, 3 way handshake과정과 여러 검증 데이터를 담아야 하므로 데이터의 크기가 커지고 느려진다는 단점이 존재한다.\n\n UDP - User Datagram Protocol\n\n 특징\n- PORT와 체크섬정도를 제외하면 IP와 거의 같다.\n- TCP와 다르게 연결지향적이지 않고, 데이터 전달 보증과 순서를 보장하지 않는다.\n- 그치만... 단순하여 빠르다.\n- TCP와 다르게 백지와 같은 프로토콜로 application에서 기능을 확장해볼 수 있다.",
    "tags": [
      "protocol",
      "TIL"
    ]
  },
  {
    "title": "TDD, BDD",
    "url": "/programming/2022/03/17/tdd-bdd/",
    "category": "programming",
    "date": "2022-03-17",
    "excerpt": ": 테스트 코드를 작성하고 테스트로 검증된 코드를 가지고 실제 코드를 작성하는 애자일의 대표적인 개발 방법론\n- 매우 짧은 개발 서클의 반복을 갖는 소프트웨어 개발 프로세스이다.\n- 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 케이스를 통과하면,  \n  가장 짧고 가독성이 좋고 유지보수성이 뛰어난 코드를 작성할 확률이 높다.\n- 일단 테스트를 ...",
    "content": "TDD, BDD\n TDD - Test Driven Development\n: 테스트 코드를 작성하고 테스트로 검증된 코드를 가지고 실제 코드를 작성하는 애자일의 대표적인 개발 방법론\n- 매우 짧은 개발 서클의 반복을 갖는 소프트웨어 개발 프로세스이다.\n- 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 케이스를 통과하면,  \n  가장 짧고 가독성이 좋고 유지보수성이 뛰어난 코드를 작성할 확률이 높다.\n- 일단 테스트를 통과하는 코드를 작성하고 상황에 맞게 리팩토링한다.\n- 거의 모든함수를 테스트해야한다.\n\n 진행과정\n<img src=\"/assets/images/posts/programming/how-to-tdd.png\"  width=450px>\n\n 장점\n- 리팩토링 속도 향상, 재설계의 시간 단축 \n  >끊임없이 test를 하므로 에러가 생길 가능성 사라짐\n- 테스트에 대한 문서작성의 필요가 없어진다.\n  > 테스트를 통과해야지 코드가 추가되므로\n\n 단점\n- 코드 생산성의 문재\n- 테스트 코드 작성 난이도 문제\n\n BDD - Behavior Driven Development\n: 자연스럽고 읽기 쉬운 일종의 유비쿼터스 언어로써 테스트를 작성하는 방법\n- TDD에서 파생되었다.\n- 프로그램에 기대되는 \"요구스펙\"에 가까운 형태로 자연어를 병기하며 테스트 코드를 작성한다.  \n    -> 즉, 비지니스 로직에 따른 시나리오 기반으로 테스트 코드를 작성한다.\n- 테스트 프레임워크의 메소드 이름도 자연어에 가까운 형태를 취한다.  \n  -> 사용자 위주로 작성\n- Given, When, Then 구조를 가지는 것을 기본 패턴\n\n BDD 기본 테스트 구조\n- Feature - 테스트에 대상의 기능/책임을 명시한다.\n- Scenario - 테스트 목적에 대한 상황을 설명한다.\n- Given - 시나리오 진행에 필요한 값을 설정한다.\n- When - 시나리오를 진행하는데 필요한 조건을 명시한다.\n- Then - 시나리오를 완료했을 때 보장해야 하는 결과를 명시한다.\n\n BDD의 Given-When-Then 스타일\n1. 특정 상황값이 주어지고Given\n2. 어떤 이벤트가 발생했을 때When\n3. 그에 대한 결과를 보장해야 한다Then\n> Given I am on the home page  \n> When I enter my username \"siwony_\"  \n> And I enter my password \"siwony_pw\"  \n> Then I should see my username \"siwony_\" on the dashboard\n\n\n SpringBoot BDD\nSpring Boot 에서는 BDDMockito를 사용하여 BDD를 할 수 있다.\njava\nimport static org.mockito.BDDMockito.;\n\nSeller seller = mock;\nShop shop = new Shopseller;\n\n@Test\npublic void shouldBuyBread throws Exception {\n  //given  \n  givenseller.askForBread.willReturnnew Bread;\n\n  //when\n  Goods goods = shop.buyBread;\n\n  //then\n  assertThatgoods, containBread;\n}\n\n\nreference : https://dongdd.tistory.com/165",
    "tags": [
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "WebSocket",
    "url": "/network/2022/03/17/websocket/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": ": 웹 서버와 웹 브라저간 실시간 양방향 통신환경을 제공해주는 실시간 통신 기술\n> Polling 방식요청-응답방식과 다르게 양방향으로 원할때 요청을 보낼 수 있으며 stateless한 HTTP에 비해 오버헤드가 적으므로 유용하게 사용할 수 있다.",
    "content": "WebSocket\n: 웹 서버와 웹 브라저간 실시간 양방향 통신환경을 제공해주는 실시간 통신 기술\n> Polling 방식요청-응답방식과 다르게 양방향으로 원할때 요청을 보낼 수 있으며 stateless한 HTTP에 비해 오버헤드가 적으므로 유용하게 사용할 수 있다.",
    "tags": [
      "web",
      "TIL"
    ]
  },
  {
    "title": "웹 브라우저의 요청 흐름",
    "url": "/network/2022/03/17/웹-브라우저의-요청-흐름/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "<img src=\"/assets/images/posts/network/web-browser-request-way.png\">",
    "content": "웹 브라우저의 요청 흐름\n<img src=\"/assets/images/posts/network/web-browser-request-way.png\">\n\n1. 웹 브라우저가 HTTP 메시지를 생성한다.\n2. SOCKET 라이브러리에서 OS의 TCP/IP계층에 데이터를 전달한다.\n   1. 통신할 서버의 IP와 PORT를 통해 TCP/IP를 연결한다.\n    > 3 way handshake\n   2. OS의 TCP/IP계층에 데이터를 전달한다.\n3. HTTP메시지를 포함한 TCP/IP 패킷을 생성한다.",
    "tags": [
      "web",
      "TIL"
    ]
  },
  {
    "title": "HTTP - Hyper Text Transfer Protocol",
    "url": "/network/2022/03/17/http---hyper-text-transfer-protocol/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": ": 인터넷에서 데이터를 주고받을 수 있는 프로토콜\n- 구성요소: Client, Web Server, Proxy\n- 80 PORT를 기본으로 사용한다.\n  > https는 443",
    "content": "HTTP - Hyper Text Transfer Protocol\n: 인터넷에서 데이터를 주고받을 수 있는 프로토콜\n- 구성요소: Client, Web Server, Proxy\n- 80 PORT를 기본으로 사용한다.\n  > https는 443\n\n 특징\n- HTML, XML, JSON등 컴퓨터에서 다룰 수 있는 모든 형식의 파일은 전송 가능하다.\n- 무상태 프로토콜이다. - Stateless\n  > 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다.\n- 클라이언트 서버 구조\n- 단순하며 확장 가능하다.\n\n 통신 방식\n 1. 요청request - 응답response 방식\n\n- Request Response 구조\n- 클라이언트는 서버에 요청을 보내고, 응답을 대기한다.\n- 서버가 요청에 대한 결과를 만들어 응답한다.\n\n클라이언트와 서버가 분리되었다는 것이 중요하다.  \n서버는 비즈니스 로직과 데이터에 대해 집중할 수 있고, client는 UI/UX에 집중할 수 있어 서로 독립적으로 진화할 수 있다.\n\n 2. 비상태성 - Stateless\n: HTTP는 요청하고 응답을 하면 요청을 끊어버린다.\n- 확장성이 높다.\n- 응답 서버를 쉽게 바꿀 수 있다.\n\n 2 - 1. 한계점  \n- 이전에 통신한 정보를 알 수 없다.\n  > 쿠키, 세션으로 해결한다.\n\n 3. 비 연결성 - Connectless\n- HTTP는 기본적으로 연결을 유지하지 않는 모델이다.\n- 서버 자원을 매우 효율적으로 사용할 수 있다.\n  > 매우 많은 유저가 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청을 수십개 이하로 매우 작다.\n\n 3 - 1. 한계점\n- TCP/IP 연결을 새로 맺어야 한다.\n  > 3 way handshake 시간 추가\n- HTML, JS, CSS, 추가 이미지 등 수 많은 자원이 함께 다운로드 된다.\n\n이러한 문제를 HTTP-지속-연결Persistent Connections로 문제를 해결했고, HTTP/2, HTTP/3에서 더 많은 최적화가 되었다.\n\n HTTP 메시지\n| HTTP 메시지 구조 | HTTP 메시지 예제 |\n|--------------------------|---------------|\n|<img width=400 src=\"/assets/images/posts/network/http-message-structure.png\">| <img src=\"/assets/images/posts/network/http-message-example.png\">|\n\n 1. 시작줄\n\n 1 - 1. 요청 - Request\n구조는 다음과 같다\nmd\nmethod SP공백 request-target SP HTTP-version CRLF줄바꿈\n\n 예시\nGET /search?q=hello&lang=ko HTTP/1.1\n\n method - 메서드\n서버가 수행해야 할 동작을 지정하는 역할이다.\n- 종류: GET, POST, PUT, DELETE등...\n\n request-target - 요청 대상\n- 주로 절대경로/로 시작한다.\n- 다른 방식으로 표기할 수 있다.\n\n HTTP-version\nHTTP의 버전을 나타낸다.\n\n 1 - 2 응답 - Response\n구조는 다음과 같다.\nmd\nHTTP-version SP status-code SP reason-phrase CRLF\n\n 예시\nHTTP/1,1 200 OK\n\n reason-phrase\n사람이 이해할 수 있는 짧은 상태 코드 설명 글\n\n 주요 Status Code상태코드\n> 자세히는 MDN HTTP 상태 코드https://developer.mozilla.org/ko/docs/Web/HTTP/Status 에 나와있다.\n- 1xx 조건부 응답: 요청을 받았으며 작업을 계속한다.  \n- 2xx 성공 : 클라이언트가 요청한 동작을 이해했고 승락했으며 성공적으로 처리했음을 가르킴\n- 3xx 리다이렉션 만료: 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.\n- 4xx 요청오류: 클라리언트에 오류가 있음을 나타낸다.\n- 5xx 서버오류: 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.\n\n\n 2. Header\n 2 - 1. 구조\nmd\nfield-name \":\" OWS field-value\n\n 예시\nGET /search?q=hello&lang=ko HTTP/1.1\nHost: www.google.com\n\n> OWS뛰어쓰기 허용\n- filed-name은 대소문자 구분하지 않는다.\n\n 2 - 2. 용도\nHTTP 전송에 필요한 모든 부가정보를 담는 용도\n- 인증, 브라우저 정보, 캐시 관리 정보 등...\n- 표준 헤더가 너무 많다.\n- 임의의 헤더를 추가할 수 있다.\n  > hello: hi\n\n 3. HTTP Message Body\n실제 전송할 데이터를 담고 있다. playload\n- byte로 표현 가능한 모든 데이터를 전송할 수 있다.\n  > HTML, JSON, XML, 이미지, 영상 등...\n\n다음글: 더 좋은 API를 설계하는 방법http-api-design.md",
    "tags": [
      "TIL",
      "http"
    ]
  },
  {
    "title": "IP - Internet Protocol",
    "url": "/network/2022/03/17/ip---internet-protocol/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "인터넷 통신을 하기 위한 최소한의 규칙이라고 할 수 있다.",
    "content": "IP - Internet Protocol\n인터넷 통신을 하기 위한 최소한의 규칙이라고 할 수 있다.\n\n IP의 역할\n패킷 - packet이라는 통신 단위로 데이터를 지정한 IP Address에 전달한다.\n- 호스트간의 통신만 담당 한다.\n\n IP 패킷의 정보\n- 출발지 IP주소\n- 도착지 IP주소\n- 전송할 데이터\n- etc...\n\n IP 통신의 한계\n 1. 비연결성\n패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷이 전송된다.\n  \n 2. 비신뢰성 \n데이터 전송 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다.\n\nIP는 대표적으로 이 위 두가지의 문제점을 가지고 있다. 그리고 이 문제가 해결되어도 만약 하나의 IP주소에 여러 개의 application이 요청하면 어떻게 자원을 구분할 수 있을까?\n\n이러한 문제를 해결하기 위해 TCP와 UDP가 있다.\n> UDP는 1, 2번의 문제를 해결해주지 않는다.\n\n다음글: TCP, UDPtcp-udp.md",
    "tags": [
      "protocol",
      "TIL"
    ]
  },
  {
    "title": "domain(도매인)",
    "url": "/network/2022/03/17/domain도매인/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": ": 각 ip에 이름을 부여할 수 있게 하는것",
    "content": "domain도매인\n: 각 ip에 이름을 부여할 수 있게 하는것\n 구성요소\n- opentutorials.org\n    - opentutorials : 컴퓨터 이름\n    - org : 죄상위 도메인 - 비영리단체\n- daum.co.kr\n    - daum : 컴퓨터 이름\n    - co : 국가 형태의 최상위 도메인 의미\n    - kr : 대한민국의 NIC에서 관리하는 도메인을 의미",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "API",
    "url": "/programming/2022/03/17/api/",
    "category": "programming",
    "date": "2022-03-17",
    "excerpt": "> APIApplication Programing Interface",
    "content": "API \n> APIApplication Programing Interface\n\n: 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스Interface를 뜻한다.\n\n 인터페이스? Interface\n: 서로 다른 두 물체간의 접점, 상호작용을 말한다.\n> ex. 마우스나, 키보드로 우리는 컴퓨터와 상호작용을 한다.\n\n API 특징\n- API는 다양한 형태로 존재한다.\n- API 자체는 어디까지나 사양specification만을 정의하기 때문에 구현Implementation과는 독립적이다.\n- 윈도우의 MFC나 Win32, C++의 표준 템플릿 라이브러리 STL, Java SE API 등이 이에 해당한다.\n\n 웹 API\n> 대표적으로 RESTful API가 있다.\n- API는 기본적으로 프로그래밍 인터페이스이다.  \n- 하지만, 다른 분야에 쓰일수 있도록 웹에 맞춰진 통신 인터페이스이다.\n\n 특징\n- 소스코드를 통해 결과를 입력받거나 출력받는 일반 API와 달리 웹 API는 웹을 이용하므로 거의 대부분 웹 프로토콜을 통해 주고 받는다.\n- 즉, GET/POST 등의 method형태로 필요한 인수를 전달받으면 거기에 맞는 결과값을 JSON이나 XML 형태로 전송해준다.\n  > ex GET /board 대충 게시판을 모두 가져오는 api\n\n 대표적인 웹 API 종류\n- HTTP\n- REST\n- SOAP",
    "tags": [
      "coding",
      "development",
      "TIL"
    ]
  },
  {
    "title": "동적 계획법과 분할 정복 - Dynamic Programming & Divide",
    "url": "/algorithm/2022/03/17/동적-계획법과-분할-정복---dynamic-programming-divide/",
    "category": "algorithm",
    "date": "2022-03-17",
    "excerpt": "복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방법\n- 상향식 접근법으로 가장 최하위 해답을 구하고, 공간을 할당하여 기억하고 해당 결과값을 이용해 상위 문제를 풀어간다.\n- 문제를 해결하기 위한 모든 방법을 검토하고, 그 중 최적의 풀이법을 찾아낸다.\n- ex. 피보나치 수열",
    "content": "동적 계획법과 분할 정복 - Dynamic Programming & Divide\n\n 동적 게획법\n복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방법\n- 상향식 접근법으로 가장 최하위 해답을 구하고, 공간을 할당하여 기억하고 해당 결과값을 이용해 상위 문제를 풀어간다.\n- 문제를 해결하기 위한 모든 방법을 검토하고, 그 중 최적의 풀이법을 찾아낸다.\n- ex. 피보나치 수열\n\n 방법\n1. 입력 크기가 작은 부분 문제들을 해결한다.\n2. 해당 부분 문제의 해를 활용해서 보다 큰 크기의 부분 문제를 해결한다.\n3. 최종적으로 전체 문제를 해결한다.\n\n 분할 정복 - Divide and conquer\n문제를 나눌 수 없을 때까지 나누어 다시 합병하여 문제의 답을 얻는 알고리즘\n\n- 하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식이다.\n  > 일반적으로 재귀함수로 구현한다.\n- 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않는다.\n  > 병합 정렬, 퀵 정렬 등\n\n 공통점과 차이점\n 공통점\n문제를 잘게 쪼개서 가장 작은 단위로 분할한다.\n\n 차이점\n 동적 계획법\n- 부분 문제는 중복되어, 상위 문제 해결시 재활용된ㅇ\n- Memoization 기법이 사용된다.\n\n 분할 정복\n- 부분 문제는 서로 중복되지 않는다.\n- Memoization 기법은 사용되지 않는다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "알고리즘 요약",
    "url": "/algorithm/2022/03/17/알고리즘-요약/",
    "category": "algorithm",
    "date": "2022-03-17",
    "excerpt": "문제를 해결하기 위한 방법이나 절차",
    "content": "알고리즘 요약\n\n 알고리즘\n문제를 해결하기 위한 방법이나 절차\n\n 시간/공간 복잡도\n알고리즘 성능을 분석하는 지표이며, 주로 시간 복잡도와 공간 복잡도는 반비례하는 성질을 가지고 있다.\n\n시간 복잡도 : 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다.\n\n\n 버블 정렬 - Bubble Sort\n현재 원소와 다음 원소를 비교하여 조건에 맞으면 교환하는 식의 정렬이다.\n\n- 가장 쉽다.\n- 퍼포먼스가 좋지 않아 잘 사용하지 않음\n\n\n시간 복잡도 : On²  \n공간 복잡도 : 하나의 배열만 사용하여 정렬하므로 On이다.\n\n 선택 정렬 - Selection Sort\n전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식이다.\n\n1. 전체 원소 중에서 가장 작은 원소를 찾아 선택하여 첫 번째 원소와 자리를 교환한다.\n2. 그다음 두번쨰로 작은 원소를 찾아 선택하여 두 번째 원소와 자리를 교환한다.\n3. 이과정을 반복한다.\n\n시간 복잡도 : On²  \n공간 복잡도 : O1\n\n 삽입 정렬 - Inserting Sort\n정렬되어 있는 부분집합에 정렬할 새로운 원소의 위치를 삽입하는 방법이다.\n\n1. 0번 인덱스는 건너뛴다.\n2. 0~1번 인덱스 중 1번 인덱스 값이 들어가야할 위치를 찾아서 넣는다\n3. 0~2번 인덱스 중 2번 인덱스 값이 들어가야할 위치를 찾아서 넣는다\n4. 0~n번 인덱스 중 n번 인덱스 값이 들어가야할 위치를 찾아서 넣는다.\n\n시간 복잡도 : On²  \n공간 복잡도 : On\n\n\n 병합 정렬 - Merge Sort\nn개의 원소를 가지고 있는 배열을 2로 나누어지지 않을 때까지 분할 후, 임시 배열에\n나누어진 원소를 비교하여 담은 후, 정렬된 임시배열을 원래 배열에 다시 대입함으로서 정렬하는 방법이다.\n\n- 분할정복 - Divide and Conquer\n- 최선, 최악, 최선이 모두 On log n시간 복잡도를 가진다.\n- stable하다\n  \n시간 복잡도 : On log n  \n공간 복잡도 : On\n\n 퀵 정렬 - Quick Sort\n피봇 값을 중심으로 왼쪽 부분 집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법이다.\n\n1. 가장 높은 인덱스의 값을 피벗으로 지정하고\n2. 가장 낮은 인덱스부터 증가하여 피벗보다 큰 수의 인덱스와 가장 큰 인덱스부터 증가한다.\n3. 피벗보다 작은 수의 인덱스를 구한 후 작은 인덱스와 큰 인덱스 숫자를 스왑 후\n4. 다음 작은 인덱스의 숫자를 다음 피벗으로 지정한다.\n\n- 분할정복 - Divide and Conquer\n- unstable하다\n\n시간 복잡도 : On log n 최악: On²  \n공간 복잡도 : On\n\n 기수 정렬\n낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘이다.\n\n1. 0~9 까지의 Queue 자료구조의 Bucket을 준비한다.\n2. 모든 데이터에 대하여 가장 낮은 자리수에 해당하는 Bucket에 차례대로 데이터를 둔다.\n3. 0부터 차례대로 버킷에서 데이터를 다시 가져온다.\n4. 가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2번 3번 과정을 반복한다.\n\n- 비교연산을 하지 않는다.\n- 문자열과 정수 정렬만 가능하다.\n- 자리수가 정해진 경우 빠르다 \n- 시간복잡도 : Okn\n  > k는 자리수, n은 데이터 수\n\n 알고리즘 예상 질문\n 54321 배열이 있을 때역순정렬 시, 어떤 정렬을 사용하면 좋을까요?\n선택정렬 입니다. 선택정렬은 앞에 저장되어야 하는 수를 선택하여 앞자리와 교환하여 정렬합니다.  \n반복은 최대 원소의 개수의 반만큼 ON/2일어나게 됩니다.\n\n 랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요?",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "RPC - Remote Procedure Call",
    "url": "/network/2022/03/17/rpc---remote-procedure-call/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "https://en.wikipedia.org/wiki/RemoteprocedurecallHistoryandorigins",
    "content": "RPC - Remote Procedure Call\n\n 1. 등장 배경\nhttps://en.wikipedia.org/wiki/Remote_procedure_callHistory_and_origins\n\n 2. RPC의 개념\nRPC란 프로세스간 통신을 위해 사용하는 IPC - Inter Process Communication/cs/ipc.md 방법의 한 종류이며, \n원격지의 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용한다.\n> 즉, 원격지의 프로시저를 호출하는 것이다.\n\n- RPC는 분산 컴퓨팅, client-server를 베이스로 한 앱을 위한 기술이다.\n- RPC는 일반적인 로컬 프로시저 호출을 확장하는 것을 기반으로 한다.\n- 두 프로세스들이 같은 시스템에 있거나 다른 시스템에 존재하며 네트워크가 프로세스들을 연결하는 형태로 존재한다.\n\n>  IPC란? \n> Socket, Shared Memory, Message Queue와 같이 프로세스틀이 통신하는 모든 형태를 일컷는다.\n\n<img src=\"/assets/images/posts/network/rpc-processe.png\">\n\n>  프로시저의 목적\n> 결과 값에 집중하기 보다 명령 단위가 수행하는 절차를 목적으로 한다,\n\n>  함수의 목적\n> 함수는 Input에 대비한 Output의 발생을 목적으로 한다.\n\n 2-1. RPC의 궁극적인 목표\n- client-server간 커뮤니케이션에 필요한 상세한 정보는 최대한 감춘다.\n- 클라이언트는 일반 메소드를 호출하는 것 처럼 원격지에 프로시저를 호출할 수 있다.\n\n 3. RPC의 동작 방식\n<img width=600 src=\"/assets/images/posts/network/rpc-mechanism.png\">\n\n1. client는 일반적인 방법으로 매개변수를 전달하여 client stub procedure를 호출한다.\n   > client stub은 클라이언트속 주소 공간에 있다.\n2. client stub은 매개변수를 메시지로 마샬링pack 한다. \n   > 마샬링에는 매개변수 표현을 표준 형식으로 변환하고 각 매개변수에 메시지를 복사하는 작업이 포함된다.\n3. client stub은 메시지를 원격Server Machine으로 보내는 전송 계층으로 전달한다.\n4. 서버의 transport layer은 매개변수를 디마셜링 - demarshallingunpack하고 일반 프로시저 호출 메커니즘을 사용하여 원하는 서버 루틴을 호출하는 server stub에 메시지를 전달한다.  \n5. 서버 프로시저가 완료되면 server stub으로 반환되며, 반환값을 메시지로 마샬링후 server stub은 메시지를 transport layer에 전달한다.\n6. transport layer는 결과 메시지를 client transport layer으로 다시 보내고, client의 transport layer는 메시지를 client stub으로 다시 전달한다.\n7. client stub은 반환 매개변수를 디마샬링하고, 실행 결과값은 호출자caller에게 반환된다.\n\n 3-1. IDL를 이용한 동작방식\n<img width=650 src=\"/assets/images/posts/network/rpc-use-idl.jpg\">\n\n1. IDL - Interface Definition Language을 사용하여 호출 규약을 정의한다.\n    > 함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성된다.\n2. Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현된다.\n    > 만들어진 stub코드는 클라이언트/서버에 함께 빌드한다.\n3. client에서 stub에 정의된 함수를 사용할 때,\n4. client stub은 RPC runtime을 통해 함수 호출하고\n5. server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환한다.\n\n최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있다.\n\n\n 3-2. 용어 설명\n stub\n- client stub : 마샬링함수호출에서 사용되는 파라미터의 변환과 함수 실행 후 서버에서 전달된 결과의 변환을 담당한다.\n- server stub : 언마샬링클라이언트가 전달한 매개변수의 역변환 및 함수 실행 결과의 변환을 담당한다.\n\n caller / callee\n- client / server가 필요한 비즈니스 로직을 작성하는 Layer\n- IDL - interface definition language로 작성\n\n RPC RunTime\n- Server와 Client를 바인딩하는 Layer\n- 커뮤니케이션 중 발생한 에러 처리도 함께 진행한다.\n\n 루틴\n루틴과 서브 루틴은 어떤 프로그램이 실행될 때 불려지거나 반복해서 사용되도록 만들어진 일련의 코드들을 지칭하는 용어이다.\n\n 4. RPC의 장단점\n 4-1. 장점\n- 추상화를 제공한다.\n  > 네트워크 통신의 메시지 전달 특성은 사용자에게 숨겨져 있다.\n- 성능향상을 위해 많은 프로토콜 계층을 생략할 수 있다.\n- RCP를 사용하면 로컬환경뿐만 아니라 분산환경에서도 응용 프로그램을 사용할 수 있다.\n- 프로세스 지향/쓰레드 지향모델을 지원한다.\n- 클라이언트가 high-level 언어로 프로시저 호출을 사용하여 서버와 통신할 수 있도록 돕는다.\n\n 4-2. 단점\n- 통일된 표준이 없다.\n  > 그래서 여러 벤더가 존재한다.\n- 상호작용 기반이므로 하드웨터 아키텍처와 관련하여 유연성을 제공하지 않는다.\n- 항상 많은 양의 데이터를 전송하는데 적합하지 않다.\n  > 클라이언트와 서버는 다른 실행환경을 사용할 수 있기 때문이다.\n\n\n 5. RPC의 대표적인 벤더\n- ProtocolBuffer by Googlehttps://developers.google.com/protocol-buffers/\n- Thrift by Facebookhttps://thrift.apache.org/\n- Finalge by Twitterhttps://twitter.github.io/finagle/\n\n Reference\n- https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/\n- https://velog.io/@jakeseo_me/RPC%EB%9E%80\n- https://nesoy.github.io/articles/2019-07/RPC\n- https://velog.io/@xylopeofficial/gRPC1\n- https://www.techtarget.com/searchapparchitecture/definition/Remote-Procedure-Call-RPC\n- http://www.terms.co.kr/routine.htm\n- https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460",
    "tags": [
      "protocol",
      "rpc",
      "TIL"
    ]
  },
  {
    "title": "DNS",
    "url": "/network/2022/03/17/dns/",
    "category": "network",
    "date": "2022-03-17",
    "excerpt": "> Domain Name System",
    "content": "DNS\n> Domain Name System\n\n<img width=600px src=\"/assets/images/posts/network/what-is-dns.png\">\n\n- client는 93.184.216.34같은 ip로 접속하는게 아니라  \n  example.com 이와같은 도메인으로 접속이 가능하다.\n- UDP, TCP 포트 : 53\n\n>UDP: 일반적인 DNS 조회를 할 경우 사용한다.  \n>TCP: Zone Transfer영역 전송와 512Byte를 초과하는 DNS패킷을 전송해야 할 경우이다.\n 등장배경\n1. 인터넷 표준 프로토콜은 TCP/IP이다.\n2. TCP/IP 프로토콜을 사용하는 네트워크 안에서 Host들을 식별하기 위한 목적으로 IP 주소를 사용한다.\n3. 사람의 경우 숫자보다 문자를 사용하는 것이 더 편하기 때문에 도메인 이름을 사용하여 Host들을 식별한다.\n4. 도메인 이름을 사용하는 경우에도 최종적으로 IP주소를 알고 있어야 상대방 장비와 연결이 가능하다.\n\n네트워크에서 도메인이나 호스트 이름을 숫자로 된 IP 주소로 해석해 주는 TCP/IP Network Service인 DNS가 등장하였다.\n\n DNS의 변천사\n 1. 과거\n1. 예전에는 컴퓨터마다 hosts.txt 파일을 가지고 있다.\n2. hosts 파일에는 모든 컴퓨터의 Hostname과 IP Address 정보가 저장되어있다.\n3. Client는 FTP를 이용해 접근해서 hosts 파일을 다운로드 및 적용하였다.\n4. 90년대 초반 Web 서비스 사용자가 폭발적으로 증가하면서 Internet에 연결된 Host 숫자가 크게 늘어 났다.\n5. 호스트의 수정 및 업데이트가 늦어지고 네트워크 트레픽이 증가하고 호스트 이름을 짓기가 어려워졌다.이름중복\n\n 2. 현제\n- 분산된 데이터베이스 이용한다.\n- 도메인이 워낙 많기 때문에 전 세계 모든 조직의 도메인정보를 갖고 있는 DNS 서버는 존재하지 않는다.\n- 각 조직은 자신들의 도메인 정보를 관리하는 DNS서버를 자체적으로 운영하고,  \n  이러한 수 많은 도메인의 DNS 서버들이 상호 연동되어 있는 Domain Name Space를 구성하게 된다.\n\n DNS 구성요소\n 1. 도메인 네임 스페이스Domain Name Space\n: DNS가 저장,관리하는 계층적 구조를 의미한다.   \n<img width=600px src=\"/assets/images/posts/network/dns-layer-structure.png\">\n\n- 최상위에 루트 DNS 서버가 존재하고,  \n  그 하위로 인터넷에 연결된 모든 노드가 연속해서 이어진 계층 구조로 구성되어 있다.\n- 각 레벨Top level, Second level 등의 도메인은 그 하위 도메인 에 관한 정보를 관리하는 구조이다. &rarr; 계층적 구조\n\n 2. 네임 서버Name Server\n: 숫자로 표현된 IP 주소로 변환시켜 주기 위해서는 도메인 네임 스페이스의 트리 구조 에 대한 정보를 가지고 있는 서버\n- 도메인 이름을 IP 주소로 변환하는 것을 네임 서비스라고 한다.\n- 리졸버Resolver로부터 요청 받은 도메인 이름에 대한 IP 정보를 다시 리졸버로 전달해주는 역할을 수행한다.\n\n 3. 리졸버 Resolver\n: DNS 클라이언트Ex. 웹브라우저의 요청을 네임 서버로 전달하고  \n네임 서버로부터 정보도메인 이름과 IP 주소를 받아 클라이언트에게 제공하는 기능을 수행한다.\n- 하나의 네임 서버 에게 DNS 요청을 전달하고 해당 서버에 정보가 없으면 다른 네임 서버에게 요청을 보내 정보를 받아 온다.\n- 수많은 네임 서버에 접근하여 사용자로부터 요청 받은 도메인의 IP 정보를 조회하는 기능을 수행할 수 있어야 한다.\n\n 4. 스터브 리졸버Stub Resolver\n> 리졸버의 모든 기능을 PC와 같은 클라이언트 호스트에 구현하는 것은 단말 시스템 자원의 한계와 같은 제약이 있다.\n\n- 리졸버의 대부분의 기능을 DNS 서버에 구현하고, 클라이언트 호스트에는 리졸버의 단순한 기능만을 지닌 리졸버 루틴을 구현한것이다.\n- 스터브 리졸버는 리졸버가 구현된 네임 서버의 IP 주소만 파악하면 된다.\n- 도메인에 대한 질의를 받은 스터브 리졸버는 설정된 네임 서버로 DNS 질의를 전달하고  \n  네임 서버로부터 최종 결과를 응답 받아 웹 브라우저로 전달하는 인터페이스 기능만을 수행한다.\n\n www.naver.com 을 입력하여 알아보는 DNS동작원리\n<img width=600px src=\"/assets/images/posts/network/how-to-work-dns.gif\">\n\n1 ~ 3. Root DNS 서버는 전체 FQDN 정보는 알지 못하기 때문에 자신의 하위 Domain인 COM DNS 서버의 주소를 알려준다.  \n\n4 ~ 5 이를 수신한 Local DNS 서버는 다시 Iterative Query를 사용하여 com DNS 서버에게 정보를 요청하고,  \ncom DNS 서버도 자신의 하위 레벨 Domain인 naver.com의 DNS서버 주소를 알려준다.  \n\n6 ~ 7 이를 수신한 Local DNS 서버는 다시 Iterative Query를 사용하여 naver.com DNS 서버에게 www 호스트에 대한 정보를 요청하고,  \nnaver.com DNS 서버는 www.naver.com에 대한 IP서버 주소를 알려준다.\n\n8 Local DNS 서버는 위와 같이 www.naver.com 에 대한 IP주소를 수신 후 자신의 DNS Cache에 등록하고,  \n해당 정보를 요청했던 Client에게 응답메세지로 답변한다.\n\n해당 Client는 수신한 www.naver.com의 의 IP주소를 사용하여 실제 해당 서버에 패킷을 전송하게 된다.  \n그 후 Local DNS 서버는 다른 Client에게 동일한 FQDN에 대한 DNS Query를 수신할 경우 DNS서버 Cache에 등록된 정보로 답변하는 것이 가능하다.\n\n 정규화된 도메인이름\n> FQDN Full Qualified Domain Name\n- 네트워크상에서 컴퓨터시스템을 지칭하는 하나의 완전한 이름이다.\n- DNS의 서버이름을 hostname + domain name으로 표현된다.\n\n>Host name : 실제 서버에 주어진 컴퓨터의 이름이다. www.naver  \n>Domain name : 논리적인 그룹을 표기한다. .com\n\n Zone File\n- Domain을 소유한 특정 조직의 DNS 서버는 해당 Domain에 대한 Zone 파일영역 파일을 갖는다.\n- 해당 Zone 파일에는 Resource Record라고 불리는 Domain 내부 정보가 존재하고, \n- 해당 정보 조회를 허용하여 외부 Client에게 정보를 제공할 수 있다.\n\n Resource Recode 종류\n- SOA: 해당 Domain  관리 권한 및 Zone Transfer영역 전송과 관련된 정보가 들어있다.\n- NS: NameServer의 정보를 갖고 있다.\n- AAAAA: 특정 host의 FQDN과 연결된 IP주소 정보를 갖는다.\n- CNAME: 특정 A레코드에 대한 별칭을 지정한다.\n- MX: Mail eXchange의 약자로 Mail 서비스에 관련된 정보를 갖고 있다. 해당 Domain의 Mail서버 정보\n- PTR: 역방향 조회에 사용되는 레코드, 특정 IP주소에 대한 FQDN 정보를 가지고 있다.\n- ANY: 도메인에 대한 모든 레코드 질의 시에 주로 이용된다. DNS 증폭 DRDOS 공격에 악용",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "조인 알고리즘",
    "url": "/database/2022/03/17/조인-알고리즘/",
    "category": "database",
    "date": "2022-03-17",
    "excerpt": "- Nested Roop Join - 중첩 반복 조인\n- Sort Merge Join - 정렬 병합 조인\n- Hash Join - 해시 조인",
    "content": "조인 알고리즘\n- Nested Roop Join - 중첩 반복 조인\n- Sort Merge Join - 정렬 병합 조인\n- Hash Join - 해시 조인\n\n 1. Nested Roop Join\n두개의 테이블의 행을 각각 모두 확인하여 조인하는 방법\n> 중첩 for문st\n\n 1-1. 특징\n- 한 레코드씩 순차적으로 접근한다.\n- Random Access 위주의 접근한다.\n- 주로 소량의 데이터를 조인하기 위해 사용한다.\n\n 2. Sort Merge Join\n두개의 테이블을 조인 칼럼으로 정렬하여 조인하는 방법  \n- Nested Roop Join과 수행 과정이 크게 다르지 않다.\n\n 2-2. 특징\n- 조인 컬럼으로 정렬 후 조인을 수행한다.\n- 정렬할 데이터가 많다면 부담이 크다.\n- Non-Equal Join시 자주 사용한다.\n- PGA 영역을 이용하여 정렬작업을 하기 때문에 래치 - Latch를 확득할 필요가 없어 인텍스를 통해 Table Access하는 것 보다 빠르다.\n\n 3. Hash Join\n해싱 함수 기법을 활용하여 조인을 수행하는 방식이다.\n- Sort Merge Join를 보안하기 위한 조인 방식\n- Equal Join만 가능하다.\n\n 3-1. 특징\n- Hash Join 역시 PGA 영역을 이용하기 떄문에 빠르게 결과를 얻을 수 있다.\n- Outer Table의 해시 키 칼럼에 중복값이 거의 없을 때 사용한다.\n- 대량의 데이터를 조인할 때 주로 사용한다.\n  > 소량의 데이터를 조인시 오히려 I/O성능이 나빠질 수 있다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "MongoDB",
    "url": "/database/2022/03/15/mongodb/",
    "category": "database",
    "date": "2022-03-15",
    "excerpt": "서비스 장애에도 서비스는 계속 동작\n- Replica Set 구조로 장애가 발생더라도 데이터를 유지할 수 있다.",
    "content": "MongoDB\n\n 특징\n Reliability\n서비스 장애에도 서비스는 계속 동작\n- Replica Set 구조로 장애가 발생더라도 데이터를 유지할 수 있다.\n\n Scalability\n데이터와 트래픽 증가에 따라 수평확장 - scale-out 가능\n- 서버가 중단 없이 데이터를 샤딩하여 분산할 수 있다.\n\n Flexibility\n여러가지 형태의 데이터를 손쉽게 저장\n- JSON기반의 도큐먼트 기반으로 스키마가 없어 데이터를 유연하게 저장할 수 있다.\n\n Index Support\n다양한 조건으로 빠른 데이터 검색\n\n\n 다양한 형태의 Index 제공\n- Hashed Index\n- Multikey Index\n- Partial Index\n- TTL Index\n- Geospatial Index\n\n Reference\n- https://tv.kakao.com/channel/3693125/cliplink/414072595",
    "tags": [
      "mongodb",
      "TIL"
    ]
  },
  {
    "title": "Optimizer - 옵티마이저",
    "url": "/database/2022/03/15/optimizer---옵티마이저/",
    "category": "database",
    "date": "2022-03-15",
    "excerpt": "사용자가 질의한 SQL 문에 대해 최적의 실행방법을 결정하는 역할을 수행한다.",
    "content": "Optimizer - 옵티마이저\n사용자가 질의한 SQL 문에 대해 최적의 실행방법을 결정하는 역할을 수행한다.\n\n- 옵티마이저가 최적의 실행을 결정하는 방식에 따라 규칙기반, 비용기반으로 나눠진다.\n\n 1. 규칙기반 옵티마이저\n규칙우선 순위을 가지고 실행계획을 생성한다.\n- 실행계획을 생성할 때 참조하는 정보에는 인덱스 유무, 연산자, 객체 등의 종류가 있다.\n\n 2. 비용기반 옵티마이저\nSQL 문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식이다.\n\n비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 컬럼등의 다양한 객체 통계정보와 시스템 통계정보를 이용한다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Window Function",
    "url": "/database/2022/03/02/window-function/",
    "category": "database",
    "date": "2022-03-02",
    "excerpt": ": 행과 행 간의 관계를 정의하기 위해 제공되는 함수다.",
    "content": "Window Function\n: 행과 행 간의 관계를 정의하기 위해 제공되는 함수다.\n\n- 순위, 합계, 평균, 행 위치 등을 조작할 수 있다.\n- GROUP BY 구문과 병행하여 사용할 수 없다.\n- SUM, MAX, MIN과 같은 집계 윈도우 함수를 사용할 떄 윈도우 절과 함께 사용하면 집계 대상이 되는 레코드 범위를 지정할 수 있다.\n\n 함수 종류\n 1. 순위 함수\n- RANK\n- DENSE_RANK\n- ROW_NUMBER\n\n 2. 윈도우 집계 함수\n- SUM, MAX, MIN, AVG, COUNT\n\n 3. 행 순서 함수\n- FIRST_VALUE\n- LAST_VALUE,\n- LAG\n- LEAD\n\n 4. 비율 함수\n- RATIO_TO_REPORT\n- PERCENT_RANK\n- CUME_DIST\n- NTILE\n\n 1. 구조\n\n 1-1. 윈도우 함수 구조\nsql\nSELECT WINDOW_FUNCTIONARGUMENTS\n    OVER  <PARTITION BY 컬럼> <ORDER BY 절> <WINDOWING 절> \nFROM 테이블명;\n\n-- ex\n\nSELECT JOB, SUMSAL OVER PARTITION BY JOB\n                ORDER BY SAL DESC\n                ROWS UNBOUNDED PRECEDING\n                 as SUM_SAL\nFROM EMP;\n\n> <>는 선택가능\n\n|    구조    |               설명                 |\n|-----------|-----------------------------------|\n|ARGUMENTS인수|윈도우 함수에 따라서 N개의 인수를 설정한다.|\n|PARTITION BY|전체 집합을 기준에 의해 소그룹으로 나눈다.   |\n|ORDER BY    |어떤 항목에 대해서 정렬한다.             |\n|WINDOWING   | - 행 기준 범위를 정한다. <br> - ROWS는 물리적 결과의 행 수이고 RANGE는 논리적인 값에 의한 범위이다.|\n\n 1-2. WINDOWING\n|    구조    |               설명                 |\n|-----------|-----------------------------------|\n|ROWS       |부분집합인 윈도우 크기를 물리적 단위로 행의 집합을 지정한다. 즉 행의 수를 선택한다.|\n|RANGE      |논리적 주소에 의해 행 집합을 지정한다. 즉 값의 범위를 지정한다.|\n|BETWEEN ~ AND| 윈도우의 시작과 끝 위치를 지정한다.      |\n|UNBOUNDED PRECEDING|윈도우 시작 위치가 첫 번째 행임을 의미한다.|\n|UNBOUNDED FOLLOWING|윈도우 마지막 위치가 마지막 행임을 의미한다.|\n|CURRENT ROW        |윈도우 시작 위치가 현재 행임을 의미한다.\n\n WINDOWING 예시\n전체 합계\nsql\nSELECT EMPNO, ENAME, SQL\nSUMSAL ORVERORDER BY SAL\n    ROWS BETWEEN UNBOUNDED PRECEDING\n    AND UNBOUNDED FOLLOWING AS TOTSAL\n\nFROM EMP;\n\nTOTSAL의 처음부터 마지막까지의 합계SUMSAL를 계산한 것이다.\n> AS는 생략 가능하다.\n\n누적합계\nsql\nSELECT EMPNO, ENAME, SAL\nSUMSQL OVERORDER BY SQL\n    ROWS BETWEEN UNBOUNDED PRECEDING\n    AND CURRENT ROW AS TOTSAL\nFROM EMP;\n\n- 처음부터 CURRENT ROW까지의 합계를 계산한다.\n  > 누적합계\n- 1번째 행의 값이 1, 2번째 행의 값이 2, 3번째 행의 값이 3이면 1 + 2 + 3 = 4과 같이 계산된다.\n\n 1-3. 순위 함수 - RANK FUNCTION\n: 윈도우 함수는 특정 항목과 파티션에 대해서 순위를 계산할 수 있는 함수를 제공한다.\n|  순위 함수  |               설명                 |\n|-----------|-----------------------------------|\n|RANK       | - 특정항목 및 파티션에 대해 순위를 계산한다. <br> - 동일한 순위는 동일한 값이 부여된다|\n|DENSE_RANK | - 동일한 순위를 하나의 건수로 계산하다.    |\n|ROW_NUMBER | - 동일한 순위에 대해서 고유의 순위를 부여한다.|\n\n\n RANK FUNCTION 에시\n 1. 내림차순 및 파티션\nsql\nSELECT ENAME, SAL,\n    RANK OVER ORDER BY SAL DESC AS ALL_RANK,  SAL로 등수를 계산하고, 내림차순으로 조회한다.\n    RANK OVER PARTITION BY JOB ORDER BY SAL DESC AS JOB_RANK,  JOB으로 파티션을 만들고, JOB별로 SAL 순위를 조회하게 한다.\nFROM EMP;\n\n- 동일한 순위에는 같은 순위가 부여된다.\n  > 1, 2, 2, 4, 5, 6, 6, 8\n\n 2. DENSE RANK\nsql\nSELECT ENAME, SAL,\n    RANK OVER ORDER BY SAL DESC AS ALL_RANK,\n    DENSE_RANK OVERORDER BY SAL DESC AS DENSE_RANK\nFROM EMP;\n\n- DENSE_RANK는 동일한 순위를 하나의 건수로 인식해서 조회한다.\n  > 1, 2, 2, 3, 4, 5, 5, 5, 6\n\n 3, ROW NUMBER\nsql\nSELECT ENAME, SAL,\n    RANK OVER ORDER BY SAL DESC ALL_RANK,\n    ROW_NUMBER OVER ORDER BY SAL DESC ROW_NUM\nFROM EMP;\n\n- ROW_NUMBER함수는 동일한 순위에 대해서 고유의 순위를 부여한다.\n  > DENSE_RANK기준 1, 2, 2, 4, 5가 ROW_NUMBER로 1, 2, 3, 4, 5로 조회된다.\n\n 1-4. 집계 함수 - AGGREGATE FUNCTION\n|  집계 함수  |               설명                 |\n|-----------|-----------------------------------|\n|SUM        |파티션 별로 합계를 계산한다.              |\n|AVG        |파티션 별로 평균을 계산한다.              |\n|COUNT      |파티션 별로 행 수를 계산한다.             |\n|MAX와 MIN   |파티션 별로 최댓값과 최솟값을 계산한다.     |\n\n 집계 함수 예시\n\n 1. SUM\nsql\nSELECT ENAME, SAL,\nSUMSAL OVER PARTITION BY MGR SUM_MGR\nFROM EMP;\n\n- 같은 관리자 - MGR에 파티션을 만들고 합계 - SUM를 계산한다.\n  \n 1-5. 행 순서 관련 함수\n- 행 순서 관련 함수는 상위 행 값을 하위에 출력하거나 그 반대로 출력할 수 있다.\n- 특정 위치의 행을 출력할 수 있다.\n\n|  집계 함수  |               설명                 |\n|-----------|-----------------------------------|\n|FIRST_VALUE| - 파티션에서 가장 처음에 나오는 값을 구한다.|\n|LAST_VALUE | - 파티션에서 가장 나중에 나오는 값을 구한다.|\n|LAG        | - 이전 행을 가지고 온다.           |\n|LEAD       | - 윈도우에서 특정 위치의 행을 가지고 온다. <br> - 기본값은 1이다.|\n\n 행 순서 관련 함수 예시\n 1. FIRST_VALUE\nsql\nSELECT DEPTNO, ENAME, SAL,\nFIRST VALUEENAME OVER \n    PARTITION BY DEPTNO\n    ORDER BY SAL DESC ROS UNBOUNDED PRECEDING AS DEPT_A\nFROM EMP;\n\n- 부서로 파티션을 나누고, 부서별로 급여가 가장 많은 직원의 이름을 4번째 칼럼에 배치한다.\n\n 2. LAST_VALUE\nsql\nSELECT DEPTNO, ENAME, SAL,\n    LAST_VALUEENAME OVER PARTITION BY DEPTNO\n    ORDER BY SAL DESC ROWS BETWEEN CURRENT ROW AND\n    DEPT AS A \nFROM EMP;\n\n- LAST_VALUE는 마지막행을 가지고 오고,\n- BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING은 부서 내에서 급여가 가장 적은 사람을 가지고 온다.\n\n 3. LAG\nsql\nSELECT DEPTNO, ENAME, SAL, LAGSAL, 2\n    OVER ORDER BY SAL DESC AS PRE_SAL\nFROM EMP; \n\n- 해당 행에서 2번째 이전의 값을 가지고 온다.\n\n 1-6. 비율 관련 함수\n- 누적 백분율, 순서별 백분율, 파티션을 N분으로 분할한 결과 등을 조회할 수 있다.\n\n|    집계 함수    |                 설명                   |\n|---------------|---------------------------------------|\n|CUME_DIST      | - 파티션 전체 건수에서 현재 행보다 작거나 같은 건수에 대한 누적 백분율을 조회한다. <br> - 누적 분포상에 위치를 0~1사이의 값을 가진다.\n|PERCENT_RANK   |행의 순서별 백분율을 조회한다.                |\n|NTILE          |파티션 별로 전체 건수를 ARGUMENT 값으로 N등분한 결과를 조회한다.|\n|RATIO_TO_REPORT|파티션 내에 전체 SUM칼럼에 대한 행 별 칼럼 값의 백분율을 소수점까지 조회한다.|",
    "tags": [
      "sql",
      "TIL"
    ]
  },
  {
    "title": "CASE 표현",
    "url": "/database/2022/03/02/case-표현/",
    "category": "database",
    "date": "2022-03-02",
    "excerpt": "IF-THEN-ELSE 논리와 유사한 방식으로 표현식을 작성하여 SQL의 비교 연산 기능을 보완하는 역할을 한다.\n- CASE 표현은 함수의 성질을 가지고 있어, 다른 함수처럼 중첩해서 사용할 수 있다.",
    "content": "CASE 표현\nIF-THEN-ELSE 논리와 유사한 방식으로 표현식을 작성하여 SQL의 비교 연산 기능을 보완하는 역할을 한다.\n- CASE 표현은 함수의 성질을 가지고 있어, 다른 함수처럼 중첩해서 사용할 수 있다.\n\n 간단한 예제\n일반 프로그램의 IF-THEN-ELSE-END 로직은 다음과 같다.\n\nIF  SAL > 2000\n    THEN REVISED_SALARY = SAL\n    ELSE REVISED_SALARY = 2000\nEND-IF.\n\n같은 기능을 하는 SQL CASE 표현이다.\nsql\nSELECT  ENAME,\n        CASE    WHEN    SAL > 2000\n                THEN    SAL\n                ELSE    2000\n        END     AS   REVISED_SALARY\nFROM    EMP\n\n\n 1. CASE 표현의 2가지 방법\nIF-THEN-ELSE 논리를 구현하는 CASE Expressions은 Simple Case Expression과 Searched Case Expression 두 가지 표현법 중에 하나를 선택해서 사용하게 된다.\n> Oracle의 경우 DECODE 함수를 사용할 수도 있다.\nsql\nCASE\n    SIMPLE_CASE_EXPRESSION 조건 or SEARCHED_CASE_EXPRESSION 조건\nEND\n\n\n 1-1. SIMPLE_CASE_EXPRESSION 조건\nsql\nCASE\n    EXPR WHEN COMPARISION_EXPR THEN RETURN_EXPR\n    ELSE 표현절\nEND\n\nCASE 다음에 바로 조건에 사용되는 칼럼이나 표현식을 표시하고, 다음 WHEN 절에서 앞에서 정의한 칼럼이나 표현식과 같은지 아닌지 판단하는 문장으로 EQUL - = 조건만 사용한다.\n\nSEARCHED_CASE_EXPRESSION보다 간단하게 사용할 수 있다.\n\n 예시\n부서 정보에서 부서 위치를 미국의 동부, 중부, 서부로 구분하라.\nsql\nSELECT  LOC,\n  CASE  LOC\n  WHEN  'NEW YORK'  THEN 'EAST'\n  WHEN  'BOSTON'    THEN 'EAST'\n  WHEN  'CHICAGO'   THEN 'CENTER'\n  WHEN  'DALLAS'    THEN 'CENTER'\n  ELSE  'ETC'\n  END   as  AREA\nFROM    DEPT;\n\n\n 1-2. SEARCHED_CASE_EXPRESSION 조건\nsql\nCASE\n    WHEN CONDITION THEN RETURN_EXPR\n    ELSE 표현절\nEND\n\nCASE 다음에 칼럼이나 표현식ㅇ을 표현하지 않고, 다음 WHEN절에서 EQUL - = 조건 포함 여러 조건 - >, >=, <, <=을 이용한 조건절을 사용할 수 있다.\n\nSIMPLE_CASE_EXPRESSION보다 훨씬 다양한 조건을 적용할 수 있다\n\n 예시\n사원 정보에서 급여가 3000 이상이면 상등급, 1000 이상이면 중등급, 1000 미만이면 하등급으로 분류하라\nSQL\nSELECT ENAME,\n  CASE  WHEN  SAL >= 3000  THEN  'HIGH'\n  CASE  WHEN  SAL >= 1000  THEN  'MID'\n        ELSE  'LOW'\n  END   AS    SALARY_GRADE\nFROM EMP;\n\n\n 1-3. DECODE - Oracle\nSQL\nDECODE표현식, 기준값1, 값1, 기준값2, 값2, ... , 디폴트값\n\nOracle에서만 사용되는 함수로 표현식의 값이 기준값1이면 값1을 출력하고, 기준값2이면 값2를 출력한다.  \n\n\n 에시\nSIMPLE_CASE_EXPRESSION 문을 다음과 같이 반환할 수 있다.\n\nsql\n/ SIMPLE_CASE_EXPRESSION /\nSELECT  LOC,\n  CASE  LOC\n  WHEN  'NEW YORK'  THEN 'EAST'\n  WHEN  'BOSTON'    THEN 'EAST'\n  WHEN  'CHICAGO'   THEN 'CENTER'\n  WHEN  'DALLAS'    THEN 'CENTER'\n  ELSE  'ETC'\n  END   as  AREA\nFROM    DEPT;\n\n/ USE DECODE Function /\nSELECT  LOC,\n        DECODELOC, 'NEW YORK', 'EAST', 'BOSTON', 'EAST', 'CHICAGO', 'CENTER', 'DALLAS', 'CENTER', 'ETC' as AREA\nFROM    DEPT;",
    "tags": [
      "sql",
      "TIL"
    ]
  },
  {
    "title": "제약조건",
    "url": "/database/2022/02/26/제약조건/",
    "category": "database",
    "date": "2022-02-26",
    "excerpt": "- 를 위해 사용자가 지정할 수 있는 성질\n- 모든 제약조건은 데이터 사전에 저장된다.\n  > 의미있는 이름을 부여했다면 constraint를 쉽게 참조할 수 있다.\n- 테이블 생성 당시 지정할 수 있고, 테이블 생성 후  ALTER명령어를 통해 추가 가능하다.\n- NOT NULL 제약조건은 반드시 컬럼 레벨에서만 가능하다.",
    "content": "제약조건\n- 데이터 무결성 유지를 위해 사용자가 지정할 수 있는 성질\n- 모든 제약조건은 데이터 사전에 저장된다.\n  > 의미있는 이름을 부여했다면 constraint를 쉽게 참조할 수 있다.\n- 테이블 생성 당시 지정할 수 있고, 테이블 생성 후  ALTER명령어를 통해 추가 가능하다.\n- NOT NULL 제약조건은 반드시 컬럼 레벨에서만 가능하다.\n\n 1. NOT NULL 조건\n무조건 해당 컬럼에 데이터를 입력해야 한다.\n\nsql\nCREATE TABLE STUDENT\n    stu_name VARCHAR10 NOT NULL\n\n\n혹은....\n\n\nCREATE TABLE STUDENT\n    stu_name VARCHAR10 CONSTRAINT stu_name_not_null NOT NULL\n\n\n\n 2. UNIQUE 조건\n- 데이터의 유일성을 보장한다.\n- 자동으로 인덱스가 생성된다.\n\nsql\nALTER TABLE STUDENT\n    ADD CONSTRAINT stu_uk UNIQUE stu_num\n\n> STUDENT 태이블의 stu_num속성을 UNIQUE 제약조건 생성\n\n 3. CHECK 조건\n: 컬럼의 값을 어떤 특정 범위로 제한할 수 있다.\n\nsql\nALTER TABLE STUDENT\n    ADD CONSTRAINT student_credit_ck_comm\n    CHECK credit >= 0 AND credit <= 30;\n\n\n 4. DEFAULT 지정\nsql\nCREATE TABLE STUDENT\n    ...\n    credit DEFAULT 0\n;\n\n\n 5. PRIMARY KEY 지정\n: 기본키를 지정한다.\n- UNIQUE + NOT NULL\n- 인스턴스를 식별하는 역할이며 다른 테이블에서 외래키들이 참조할 수 있는 자격을 가지고 있다.\n\nsql\nCREATE TABLE STUDENT\n    student_number NUMBER CONSTRAINT student_number_pk PRIMARY KEY\n\n\n\n 6. FOREIGN KEY 지정\n: 기본키를 참조하는 컬럼 또는 컬럼들의 집합이다.\n\nsql\nALTER TABLE STUDENT",
    "tags": [
      "sql",
      "TIL"
    ]
  },
  {
    "title": "SQL",
    "url": "/database/2022/02/24/sql/",
    "category": "database",
    "date": "2022-02-24",
    "excerpt": "|                     유형                |                 설명                   |\n|:---------------------------------------|:--------------------------------------|\n| | - 데이터의 구조를 정의하기 위한 명령어 <br> - CR...",
    "content": "SQL\n\n 1. SQL 유형\n|                     유형                |                 설명                   |\n|:---------------------------------------|:--------------------------------------|\n|데이터 정의어 - Data Definition Language | - 데이터의 구조를 정의하기 위한 명령어 <br> - CREATE, ALTER, DROP, RENAME, TRUNCATE, MODIFY|\n|데이터 조작어 DML - Data Manipulation Language | - 데이터를 검색 또는 변형하기 위한 명령어 <br> - SELECT, INSERT, UPDATE, DELETE|\n|데이터 제어어 - Data Control Language    | - 사용자에게 객체에 대한 권한을 부여/취소하기 위한 명령어 <br> - GRANT, REVOKE, \n|트랜잭션 제어어 TCL - Transaction Control Language | - 변경 내용을 확정/취소하기 위한 명령어 <br> - COMMIT, ROLLBACK",
    "tags": [
      "sql",
      "TIL"
    ]
  },
  {
    "title": "서브쿼리",
    "url": "/database/2022/02/24/서브쿼리/",
    "category": "database",
    "date": "2022-02-24",
    "excerpt": "하나의 쿼리 문장 내에 포함된 또 하나의 쿼리 문장\n- 비교연산자의 오른쪽에 기술해야 하고 반드시 괄호 안에 넣어야 함\n- 메인쿼리가 실행되기 이전에 한 번만 실행됨",
    "content": "서브쿼리\n하나의 쿼리 문장 내에 포함된 또 하나의 쿼리 문장\n- 비교연산자의 오른쪽에 기술해야 하고 반드시 괄호 안에 넣어야 함\n- 메인쿼리가 실행되기 이전에 한 번만 실행됨\n\n 서브쿼리를 사용 가능한 곳 \n- SELECT 절\n- FROM 절\n- WHERE 절\n- HAVING 절\n- ORDER BY 절\n- INSERT 문의 VALUSE 절\n- UPDATE 문의 SET 절\n\n 1. 서브쿼리의 분류\n\n 1-1. 스칼라 서브쿼리 - Scalar Subqueries\nSELECT 절 안에 서브쿼리가 들어있다.\n\n- 리턴할 수 있는 최대 데이터가 1개이다.\n  > 서브쿼리의 결과는 반드시 단일 행이나 SUM, COUNT 등의 집계 함수를 거친 단일 값으로 리턴되어야 한다.\n- 찾고자 하는 데이터가 없는 경우 NULL를 반환한다.\n- 값에 대한 캐싱이 가능하다.\n\n\n홍길동 학생의 학과를 조회한다고 가정하면 다음과 같다.\nsql\nSELECT 학생이름,\n           \n            SELECT 학과.학과이름\n            FROM 학과\n            WHERE 학과.학과ID = 학생.학생ID  AS 학과이름\nFROM 학생\nWHERE 학생이름 = '홍길동';\n\n\n 1-2. 인라인 뷰 서브쿼리 - Inline View subqueries\nFROM 절 안에 서브쿼리가 들어있다.\n\n- 서브쿼리의 결과는 반드시 하나의 테이블로 리턴되어야 한다.\n  > 서브쿼리를 끝마친 테이블 하나를 메인쿼리의 FROM 에서 테이블로 잡기 때문.\n\n수학 과목을 수강하는 학생들의 수학점수를 조회한다고 가정하면 다음과 같다.\nsql\nSELECT 학생이름, 수학점수\nFROM    \n        SELECT 학생.학생이름 AS 학생이름,\n                과목.수학점수 AS 수학점수\n        FROM 학생, 과목\n        WHERE 학생.학생이름 = 과목.학생이름\n        AND 과목.과목이름 = '수학'\n    ;\n\n\n 1-3. 중첩 서브쿼리 - Nested subqueries\nWHERE절 안에 서브쿼리가 들어있다.\n- 단일행과 복수행 둘 다 리턴이 가능하다.\n  > 서브쿼리를 끝마친 값들을 메인쿼리의 조건절을 통해 비교등을 하기 때문.\n\n수학 과목을 수강하는 학생들의 모든 정보를 조회한다고 가정하면 다음과 같다.\nsql\nSELECT \nFROM 학생\nWHERE 학생.학생이름 IN \n    SELECT 과목.학생이름\n    FROM 과목\n    WHERE 과목.과목이름 = '수학'\n;\n\n\n 1. 단일행 서브 쿼리\n- 서브쿼리의 수행결과가 오직 하나의 ROW행만을 반환한다.\n- 이 하나의 결과를 가지고 메인쿼리는 비교연산자를 통해 쿼리를 수행한다.\n- 비교연산자는 단일행 비교연산자를 사용한다.\n  > \\>, >=, <, <=, = ...\n\n사원들의 평균 급여보다 더 많은 급여를 받는 사원을 검색\nsql\nSELECT ENAME, SAL\nFROM EMP\nWHERE SAL >  \n    SELECT  AVGSAL\n    FROM  EMP\n;\n\n\n 2. 다중행 서브 쿼리\n- 서브쿼리의 수행결과가 두 건 이상의 데이터를 반환한다.\n- 비교연산자는 다중행 비교연산자를 이용한다.\n  > IN, ANY, SOME, ALL, EXISTS\n\n개발1팀 소속 사원 중 급여를 가장 많이 받는 사람의 이름과 급여를 검색\nsql\nSELECT  ENAME, SAL\nFROM  EMP\nWHERE  SAL > ALL  SELECT  SAL\n                      FROM  EMP\n                     WHERE  DEPTNAME = '개발1' ;",
    "tags": [
      "sql",
      "TIL"
    ]
  },
  {
    "title": "인덱스 - Index",
    "url": "/database/2022/02/22/인덱스---index/",
    "category": "database",
    "date": "2022-02-22",
    "excerpt": "> 핵심을 full scan을 하지 않고 인덱스 테이블을 통해 효율적으로 검색하는 것",
    "content": "인덱스 - Index\n> 핵심을 full scan을 하지 않고 인덱스 테이블을 통해 효율적으로 검색하는 것\n\n<img width=650 src=\"/assets/images/posts/database/index-structure.png\">\n\n 2. 인덱스의 특징\n- 실제 테이블을 Full Scan하지 않고 인덱스 테이블을 검색한다.\n- 지나치게 많은 인덱스 생성시 시간 및 공간이 낭비된다.\n- 인덱스된 필드의 업데이트시 시간이 증가한다.\n- 자동 생성PK or Unique / 수동 생성Create Index 구문\n- B-tree, B+tree와 같은 자료구조를 활용한다.\n\n 1. 인덱스의 스캔 구조 이해\n\n 1-1. 인덱스 스캔 방법\n- SELECT 주문단가 FROM 주문목록 WHERE 주문번호 = '1002'  \n  <img width=650 src=\"/assets/images/posts/database/index-scan-ex.png\">\n\n- Full Scan을 하지 않고 인덱스 테이블의 주문번호가 1002번인 결과값만 조회했다.\n\n만약 최초의 정렬기준이 아닌 다른 정렬기준으로 조회를 하면 어떻게 될까?\n\n- SELECT 주문단가 FROM 주문목록 WHERE 주문일자='2008.1.1'  \n  <img width=650 src=\"/assets/images/posts/database/index-scan-ex2.png\">\n  \n맨 앞에 있는 칼럼이 제외된 상태에서는 데이터를 조회 할 경우 데이터를 비교하는 범위가 매우 넓어지게 되어 성능 저하를 유발하게 된다.\n\n PK의 속성 순서대로 인덱스가 정렬된다.\n\n FK 인덱스 설정을 통한 성능 향상\n\n- ex 고객번호가 1234인 고객의 대여기록 조회\n    > 고객 테이블에 4천건, 대여 테이블에 1,000만건이 존재하는 경우\n\n<img src=\"/assets/images/posts/database/fk-index-setting.png\">\n\n출처: https://youtu.be/mjanSuhnpNw?t=632\n\n&rarr; 대여 테이블의 고객번호에 인텍스를 설정함으로 성능 향상이 가능하다.\n\n이전글: 3-2. 반정규화denormalization.md\n다음글: 3-4. 분산데이터베이스distributed-database.md",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "Oracle 11g quick start with doker",
    "url": "/database/2022/02/22/oracle-11g-quick-start-with-doker/",
    "category": "database",
    "date": "2022-02-22",
    "excerpt": "1521은 오라클DB의 기본 포드이다.",
    "content": "Oracle 11g quick start with doker\n\n 1. oracle 11g 이미지 pull\nsh\ndocker pull jaspeen/oracle-xe-11g\n\n\n 2. 이미지 실행하기 \nsh\ndocker run --name oracle11g -d -p 1521:1521 jaspeen/oracle-xe-11g\n\n1521은 오라클DB의 기본 포드이다.\n\n 3. oracle11g실행하기\n\n 3-1. sqlplus 접속\nsh\ndocker exec -it oracle11g sqlplus\n\n\n 3-2. 로그인 하기\n아이디 패스워드를 입력하여 sqlplus로 로그인한다.\n- user-name: system\n- password: oracle\n\n잘 입력했으면 아래 사진과 같이 나올 것이다.\n\n<img src=\"/assets/images/posts/database/oracle11g-sqlplus-exec-ex.png\">",
    "tags": [
      "oracle",
      "TIL"
    ]
  },
  {
    "title": "분산 데이터베이스 - distributed database",
    "url": "/database/2022/02/22/분산-데이터베이스---distributed-database/",
    "category": "database",
    "date": "2022-02-22",
    "excerpt": ": 물리적으로 분산된 데이터베이스를 하나의 논리적 시스템으로 사용",
    "content": "분산 데이터베이스 - distributed database\n: 물리적으로 분산된 데이터베이스를 하나의 논리적 시스템으로 사용\n\n 1. 분산 데이터베이스의 장단점\n|                 장점                 |                단점                  |\n|------------------------------------|--------------------------------------|\n|지역 가치성 증가, 점증적 시스템 용량 확장 가능 |소프트웨어 개발 비용 증가                   |\n|신뢰성과 가용성 증가                     |오류의 잠재성 증대                         |\n|효용성과 융통성 증가                     |처리 비용의 증대                          |\n|빠른 응답 속도, 통신비용 절감              |설계, 관리의 복잡성 및 비용 증가             |\n|데이터의 가용성과 신뢰성 증가              |불규칙한 응답 속도                         |\n|시스템 규모의 적잘한 조절 가능             |통제의 어려움                             |\n|각 지역 사용자들의 요구 수용 가능           |데이터 무결성 유지의 어려움                  |\n\n 2. 분산 데이터베이스의 적용 기법\n 2-1. 테이블 위치 분산\n: 테이블을 각각 다른 장소에 위치시킨다.\n\n 2-2. 테이블 분할 분산\n: 각 테이블을 분할하여 분산한다.\n- 수평 분할\n- 수직 분할\n\n 2-3. 테이블 복제Replication 분산\n: 동일 테이블의 복사본을 여러 서버에서 동시에 관리한다.\n\n 1. 부분 복제 - Segment Replication\n: 본사는 통합 테이블 관리, 각 지사에서는 지사에 해당된 로우만 관리한다.\n- 실제로는 지사에서 먼저 데이터가 발생한다. \n- 그 후 본사에서 전체 통합한다.\n\n 2. 광역 복제 - Broadcast Replication\n: 동일한 테이블을 여러 곳에 복제하여 관리한다.\n- 본사에서 데이터의 CUD 발생시 지사에서 이를 반영한다.\n\n 2-4. 테이블 요약Summarization 분산\n: 유사한 내용의 데이터를 서로 다른 관점/수준에서 요약하여 분산 관리한다.\n\n 1. 분석 요약 - Rollup Replication\n: 각 지사별 동일한 주제의 정보를 본사에서 통합하여 전체 요약 정보 산출\n- ex 상품A의 지사1, 지사2의\n\n 2. 통합 요약 Consolidation Replication\n: 각 지사별 상이한 주제의 정보를 본사에서 단순 취합하여 제공\n\n 3. 분산 설계 고려사항\n- 성능이 중요할 때 적용을 검토해야 한다.\n- 공통코드, 기준정보, 마스터 데이터 등에 대해 분산 구성시 성능 향상\n- 실시간 동기화가 요구되지 않을 때 바람직 하다.\n  > Near Real Time 업무의 경우도 분산 환경 구성 가능\n- 특정 서버에 집중된 부하를 분산시키기 위한 목적으로도 가능\n  > 주로 Network트레픽\n- 백업 사이트 - Disaster Recovery Site 구성 시 분산 설계의 개념을 적용할 수 있다.\n  > 재난 상황시",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "반정규화 - Denormalization",
    "url": "/database/2022/02/14/반정규화---denormalization/",
    "category": "database",
    "date": "2022-02-14",
    "excerpt": ": 정규화된 엔터티, 속성, 관계에 대해 성능 향상을 목적으로 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법이다.",
    "content": "반정규화 - Denormalization\n: 정규화된 엔터티, 속성, 관계에 대해 성능 향상을 목적으로 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법이다.\n\n<img src=\"/assets/images/posts/database/denormalization.png\">\n\n디스크 I/O량이 많아서 성능이 저하되거나 JOIN으로 인한 성능저하가 예정되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.\n\n 1. 특징\n- 테이블, 칼럼, 관계의 반정규화를 종합적으로 교려해야 한다.\n- 과도한 반정규화는 데이터 무결성을 침해하게 되어 좋지 않다.\n  > 반 정규화를 진행하면 데이터 무결성을 침해할 수 밖에 없지만 이를 해결하는 장치를 마련해야 한다.\n\n 2. 반정규화의 적용방법 - 요약\n반정규화에 대한 필요성이 결정이 되면 칼럼의 반정규화 뿐만 아니라 테이블의 반정규화와 관계의 반정규화를 종합적으로 고려하여 적용해야 한다.\n\n<img src=\"/assets/images/posts/database/denormalization-process.png\">\n\n 2-1. 반정규화 대상조사\n- 자주 사용되는 테이블에 접근하는 프로세서의 수가 많고 항상 일정한 범위만을 조회하는 경우 검토한다.\n- 테이블에 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우 검토한다.\n- 통계성 프로세서에 의해 통계 정보를 필요할 때 별도의 통계 테이블을 생성한다.\n- 테이블에 지나치게 많은 JOIN이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 검토한다.\n\n 2-2. 다른 방법유도 검토\n- 뷰 - View 생성 : 뷰 자체가 성능 향상을 가져오지 않는다. 신중하게 설계된 뷰를 재사용할 때 성능이 향상된다.\n- 클러스터링: 자주 사용되는 테이블의 데이터를 디스크의 같은 블록에 저장한다.\n- 인덱스의 조정: 인덱스 추가, 삭제 및 순서 조정\n  > 조회중심의 테이블이 아니라면 인덱스를 추가하지 않는게 좋다.\n- 응용 애플리케이션 : 데이터 처리를 위한 로직 변경 ex. 캐싱, 한방쿼리\n\n 2-3. 반정규화 적용\n반정규화를 적용하기 전 사전에 충분히 성능에 대한 고려가 이루어졌다면 반정규화를 적용해야 한다.\n\n- 테이블 반정규화\n- 속성의 반정규화\n- 관계의 반정규화\n\n이 3가지의 방법이 있고 추가, 분할, 제거할 수 있다.\n\n 3. 반정규화 기법\n 3-1. 테이블 반정규화\n<table>\n    <thead>\n        <tr>\n            <th>기법분류</th>\n            <th>기법</th>\n            <th>내용</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td rowspan=4>테이블병합</td>\n            <tr>\n                <td rowspan=1>1:1 관계 테이블병합</td>\n                <td>1:1 관계를 통합하여 성능향상</td>\n            </tr>\n            <tr>\n                <td rowspan=1>1:M 관계 테이블병합</td>\n                <td>1:M 관계를 통합하여 성능향상</td>\n            </tr>\n            <tr>\n                <td rowspan=1>슈퍼/서브타입 테이블병합</td>\n                <td>슈퍼/서브 관계를 통합하여 성능향상</td>\n            </tr>\n        </tr>\n        <tr>\n            <td rowspan=3>테이블분할</td>\n            <tr>\n                <td rowspan=1>수직분할</td>\n                <td>칼럼단위의 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능향상</td>\n            </tr>\n            <tr>\n                <td rowspan=1>수평분할</td>\n                <td>로우 단위로 집중 발생하는 트랜잭션을 분석하여 디스크 I/O및 데이터접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블을 쪼갠다.</td>\n            </tr>\n        </tr>\n        <tr>\n          <td rowspan=5>테이블 추가</td>\n          <tr>\n              <td>중복테이블 추가</td>\n              <td>다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상</td>\n          </tr>\n          <tr>\n              <td>통계테이블 추가</td>\n              <td>SUM, AVG등을 미리 수행하여 계선해 둠으로써 조회 시 성능을 향상한다.</td>\n          </tr>\n          <tr>\n              <td>이력테이블 추가</td>\n              <td>이력테이블중 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법은 반정규화의 유형</td>\n          </tr>\n          <tr>\n              <td>부분테이블 추가</td>\n              <td>하나의 테이블의 전체 컬럼 중 자주 이용하는 집중화된 컬럼들을 모아놓는 별도의 반정규화된 테이블 생성</td>\n          </tr>\n        </tr>\n    </tbody>\n</table>\n\n 1. 테이블병합\n- 1-1. 관계 테이블병합 1:1 or 1:M \n  - 두 테이블 동시 조회가 많은 경우  \n    <img width=600 src=\"/assets/images/posts/database/relation-merge.png\">\n\n    출처: https://youtu.be/pd0BzVro6zY?t=254\n\n- 1-2. 슈퍼/서브타입 모델의 변환 - Super Type / Sub Type\n  1. 개별 트랜젝션이 많을 경우 &rarr; One To One\n  2. 슈퍼타입 + 서브타입 접근 트랜잭션이 많은 경우 &rarr; Plus Type\n  3. 여러 서브타입에 대한 동시 접근이 많을 때 &rarr; All in One Type\n   \n\n  슈퍼/서브타입 모델 변환 타입의 비교  \n    |   구분   | One To One Type |    Plus Type   | Single Type |\n    |:-------|:--------------:|:---------------:|:-----------:|\n    | 특징 |  개별 테이블 유지  |슈퍼 + 서브타입 테이블|하나의 통합 테이블|\n    | 확장성|      우수함     |        보통      |     나쁨      |\n    |조인 필요 수|     많음   |       보통       |     적음      |\n    |I/O 성능저하|    양호   |        양호       |      좋음     |\n    | 관리 용의성|   나쁨     |       나쁨       |      좋음     | \n    |적합 <br>트랜잭션 유형| 개별 테이블로 접근이 많은 경우| 슈퍼 + 서브 형식 데이터 처리가 많은 경우 | 전체에 대한 일괄 처리가 많은 경우\n\n 2. 테이블분할\n- 2-1. 테이블 수직 분할\n  - 많은 컬럼을 가진 테이블에서 프로세스가 컬럼 유형마다 다르게 발생하는 경우\n  - ex. 전자출판 관련 조회, 대체제품 조회  \n    <img width=500 src=\"/assets/images/posts/database/table-column-divided-ex.png\">\n\n- 2-2. 테이블 수평 분할\n  - 테이블이 많은 양의 데이터를 가질 것으로 예상되는 경우 Partitioning을 진행한다.\n  - Range Partition: 범위로 분할\n    > 고객번호 1 ~ 1000, 1001~2001등...  \n    <img width=500 src=\"/assets/images/posts/database/table-vertical-divide-range.png\">\n\n  - List Partition: 값으로 분할\n    > 지역: 서울, 광주, 부산 등...   \n    <img width=500 src=\"/assets/images/posts/database/table-vertical-divide-value.png\">\n\n  - Hash Partition : 해쉬 함수로 분할\n    - 임이의 길이의 데이터를 짧은 길이의 데이터로 매핑하는 함수\n\n 3. 테이블추가\n- 3-1. 이력테이블 추가\n  - 가장 최근값을 중복으로 기록한 테이블을 생성한다.\n    > 가장 최근값을 중복으로 기록한 테이블 생성  \n    <img src=\"/assets/images/posts/database/table-add-tables-history.png\">\n\n  > 이력테이블 칼럼 추가와 이력테이블 추가의 차이점  \n  > 이력테이블을 값을 추가하고, 이력테이블 컬럼 추가는 여부true, false 를 추가한다.\n\n- 3-2. 부분테이블 추가\n  - 집중적으로 자주 사용되는 특정 속성들을 추출하여 별도 테이블을 구성한다.\n  - 테이블 수직 분할과 유사하지만 원본 테이블이 그대로 유지된다.\n  > ex 차량번호에 대한 차량사진 조회 질의가 많은 경우  \n  <img width=500 src=\"/assets/images/posts/database/part-table-add.png\">  \n  출처: https://youtu.be/KN586GvpZW0?t=570\n\n 3-2. 칼럼 반정규화\n|  반정규화 기법  |                               내용                       |\n|:------------:|:--------------------------------------------------------|\n|      중복컬럼 추가     |조인에 의해 처리할 떄 성능저하를 예방하기 위해 중복된 칼럼을 위치시킨다.   |\n|      파생컬럼 추가     |트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 컬럼에 보관한다. <br> > Derived Column이라고 한다.|\n|    이력테이블 칼럼추가   |대량의 이력데이터를 처리조회할 떄 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성 컬럼을 추가한다. <br> > 최근값 여부, 시작과 종료일자 등...|\n|   PK에 의한 칼럼 추가   |PK가 복합 의미를 갖는 경우 구성 요소 값의 조회 성능 향상을 위해 일반 속성을 추가한다.|\n|데이터 복구를 위한 칼럼 추가 |사용자의 실수, 응용프로그램 오류로 인해 데이터가 잘못 처리된 경우, 원래 값으로의 복구를 위해 이전 데이터를 임시적으로 보관하는 컬럼추가|\n 1. 중복칼럼 추가\n> 조인을 감소시킨다.\n- 해당 테이블에서 자주 사용하는 칼럼을 중복시킨다.\n- ex. 각 사원의 이름과 소속지점명을 조회하는 질의가 많은 경우\n  <img width=\"750\" src=\"/assets/images/posts/database/denormalization-add-duplicate-column.png\">\n\n  출처: https://youtu.be/z1AcDayMXgY?t=1169\n \n 2. 파생칼럼 추가\n- 질의가 예상되는 값을 미리 계산하여 저장한다.\n\n- 2-1. 컬럼에 의한 파생\n  - Derived Column이라고 한다.\n  - ex. 과목 점수 합계, 평균 등...\n\n- 2-2. 로우에 의한 파생\n  > 가급적 사용하지 않아야 한다.\n  - 특정 로우가 변경되면 모든 로우 값을 다시 계산하게 된다.\n  - 즉, 인스턴스의 순서에 의존성이 생기므로 사용하지 않아야 한다.\n  - ex. 공사비 누적엑셀을 생각하면 됨\n\n 3. 이력테이블 칼럼 추가\n- ex. 최근값, 종료여부 등...\n\n 4. PK의 의미적 분리를 위한 칼럼 추가\n- 차량테이블의 PK가 차량번호광주 뷁 1234와 같이 '지역' + '일련번호'로 구성된 경우 지역을 이용한 조회가 빈번한경유\n  - 지역이라는 컬럼을 생성한다.\n  - https://youtu.be/z1AcDayMXgY?t=2580\n\n\n 5. 데이터 복구를 위한 칼럼 추가\n- 사용자의 실수, 응용프로그램의 오류로 인한 데이터 손실 대비를 위해 생성한다\n- ex. 고객의 이전 주소, 고객의 이전 데이터 등...\n\n\n 3-3. 관계 반정규화\n 1. 중복관계 추가\n: 조인을 통해 정보 조회가 가능하지만, 조인 경로 단축을 위해 중복관계를 추가한다.\n\n이전글: 3-1. 정규화normalization-and-performance.md  \n다음글: 3-3. Indexindex.md\n\n\n Reference\n- SQL 전문가 가이드\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능3/6https://youtu.be/z1AcDayMXgY\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능4/6https://youtu.be/pd0BzVro6zY",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "데이터 모델링의 이해",
    "url": "/database/2022/02/06/데이터-모델링의-이해/",
    "category": "database",
    "date": "2022-02-06",
    "excerpt": "데이터 모델링은 \"복잡한 현실 세계를 추상화, 단순화하여, 일정한 표기법에 의해 명확하게 표현하는 일\" 라고 할 수 있다.\n- 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법\n- 현실 세계의 데이터What에 대해 약속된 표기법에 따라 표현하는 과정\n- DB를 구축하기 위한 분석/설계의 과정",
    "content": "데이터 모델링의 이해\n데이터 모델링은 \"복잡한 현실 세계를 추상화, 단순화하여, 일정한 표기법에 의해 명확하게 표현하는 일\" 라고 할 수 있다.\n- 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법\n- 현실 세계의 데이터What에 대해 약속된 표기법에 따라 표현하는 과정\n- DB를 구축하기 위한 분석/설계의 과정\n\n데이터 모델링은 그저 DB만을 구축하기 위한 용도가 아닌 데이터 모델링 자체로서 업무를 설명하고 분석하는 부분에도 매우 중요한 의미가 있다.\n\n좀 더 실무적으로 해석하면 업무에서 필요로 하는 데이터를 시스템 구축 방법론에 따라 분석하고 설계하여 정보시스템을 구축하는 과정으로 정의할 수 있다.\n\n그러므로 설계보다 업무 내용을 정확하게 분석하는 것이 첫 번째 단계다.\n\n 데이터 모델이 제공하는 기능 \n- 시스템을 현재 또는 원하는 모습으로 가시화하도록 도와준다.\n- 시스템의 구조와 행동을 명세화할 수 있게 한다.\n- 시스템을 구축하는 구조화된 틀을 제공한다.\n- 시스템을 구축하는 과정에서 결정한 것을 문서화한다.\n- 다양한 영역에 집중하기 위해 다른 영역의 세부 사항을 숨기는 다양한 관점을 제공한다.\n- 특정 목표에 따라 구체화된 상세 수준의 표현 방법을 제공한다.\n\n 1. 특징\n> 추상화, 단순화, 명확화\n\n 1. 추상화\n현실세계를 일정한 형식에 맞추어 표현한다.\n- 다양한 현상을 일정한 양식인 표기법에 따라 표현한다.\n\n 2. 단순화\n복잡한 현실세계를 약속된 규약에 따라 제한된 표기법언어로 표현하여 쉽게 이해할 수 있도록 하는 개념을 의미한다.\n\n 3. 명확화\n누구나 이해하기 쉽게 \"대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것\" 을 의미한다.\n\n 2. 모델링의 세 가지 관점\n모델링은 크게 세 가지 관점으로 구분하여 설명할 수 있다.\n> 데이터관점, 프로세스관점, 데이터와 프로세스의 상관관점\n\n 1. 데이터관점\n> What, Data\n\n업무가 어떤 데이터와 관련이 있는지 or 데이터간의 관계는 무엇인지 모델링하는 방법\n\n 2. 프로세스관점\n> How, Process\n\n업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야 하는지 모델링하는 방법\n\n 3. 데이터와 프로세서의 상관관점\n업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법\n\n 3. 데이터 모델링의 중요성 및 유의점\n데이터 모델링이 중요한 이유는 파급효과 - Leverage, 복잡한 정보 요구사항의 간결한 표현 - Conciseness, 데이터 품질 - Data Quality로 정리할 수 있다.\n\n 1. \"파급효과\" - Leverage \n시스템 구축이 완성되어 가는 시점에 데이터 구조의 변경으로 인한 일련의 변경 작업은 위험요소이다.  \n> 병행/통합 테스트 끝내고 에플리케이션이 완성되어가는 시점에 데이터 모델이 변경된다고 생각해보자 생각만 해도 끔찍하다.\n\n이러한 이유로 인해 시스템 구축 작업 중 다른 설계 과정보다 데이터 설계가 더 중요하다고 볼 수 있다.\n\n 2. 복잡한 정보 요구사항의 \"간결한 표현\" - Conciseness\n데이터 모델은 구축할 시스템의 정보 요구사항과 한계를 가장 명확하고 간결하게 표현할 수 있는 도구이다.\n\n 3. 데이터 품질 - Data Quality\nDB에 담겨 있는 데이터는 기업의 중요한 자산이다.  \n이 데이터는 기간이 오래될수록 활용가치가 높아지는데, 데이터 품질의 대한 문제는 초기에 데이터가 조금 쌓일 때는 모르지만 데이터가 쌓이고 쌓여서 추후 오랜시간이 지난 후 데이터를 전략적으로 활용하려고 할 때 문제가 대두된다.\n\n데이터 품질의 문제는 데이터 구조의 문제로 직결된다.\n\n 3 - 1. 데이터 모델링의 유의점\n 1 중복 - Duplication\n데이터 모델은 같은 데이터를 사용하는 사람, 시간, 장소를 파악하는 데 도움을 준다.  \n이러한 지식 응용은 DB가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.\n\n 2 비유연성 - Inflexibility\n데이터의 정의를 데이터의 사용 프로세스와 분리해야 한다.\n\n데이터 모델의 설계에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중할 수 있다.\n\n데이터의 정의를 데이터의 사용 프로세스와 분리하여 데이터 혹은 프로세스의 작은 변화로 인ㄴ 애플리케이션과 DB에 중대한 변화를 일으킬 가능성을 줄인다.\n\n 3 비일관성 - Inconsistency\n: 데이터와 데이터 간 상호 연관 관계에 대해 명확하게 정의해야한다.\n> 데이터의 중복이 없더라도 비일관성은 발생한다.\n\n사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터 모델이 업무 변경에 취약하게 만드는 단점이 된다.\n\n 4. 데이터 모델링의 3단계 진행\n> 추상적 개념적 데이터 모델링 &rarr; 논리적 데이터 모델링 &rarr; 물리적 데이터 모델링 구체적\n\n<img src=\"/assets/images/posts/database/btween-real-world-and-db-model.png\">\n\n 1. 개념적 데이터 모델링\n추상화 수준이 높고 업무중심적이고 포괄적인 수준의 모델링을 진행한다.\n- EA - Enterprise Architecture수립시 많이 이용한다.\n\n 2. 논리적 데이터 모델링\n업무의 구체적인 모습과 흐름에 따른 구체화된 업무중심의 데이터 모델을 만들어 내는 것이다.\n> 데이터 모델링이 최종적으로 완료된 상태\n- 시스템으로 구축하고자 하는 업부에 대해 Key, 속성, 관계 등을 정확하게 표현한다.\n- 재사용성이 높다.\n\n이 단계에서 중요한 또 다른 활동은 정규화이다.  \n정규화는 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들의 가장 적절한 엔티티에 배치되도록 함으로 보다 신뢰성 있는 데이터구조를 얻는데 목적이 있다.\n\n논리 데이터 모델의 상세화는 식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의 등이 있다.\n\n 3. 물리적 데이터 모델링\nDB의 저장구조에 따른 테이블스페이스 등을 고려한 방식이다.\n- DB의 성능, 저장 등 물리적인 성격을 고려햐여 설계한다.\n\n 5. 프로젝트 생명주기 - Life Cycle에서 데이터 모델링\n<img src=\"/assets/images/posts/database/project-life-cycle-data-modeling.png\">\n\n일반적으로 \n- 계획 또는 분석단계에서 개념적 데이터 모델링이 일어난다.\n- 분석단계에서는 논리적 데이터 모델링을 수행한다.\n- 설계단계에서 물리적 데이터 모델링을 수행된다.\n\n현실 프로젝트에서는 개념적 데이터 모델이 생략된 개념/논리 데이터 모델링이 분석단계 때 대부분 수행한다.\n\n 6. 데이터 모델링에서 데이터독립성의 이해\n 1. 데이터독립성의 필요성\n> 데이터독립성 &lrarr; 데이터종속성\n- 유지보수 비용증가\n- 데이터의 복잡도 증가\n- 데이터 중복성 증가\n- 요구사항 대응 저하\n\n 데이터 독립성의 이점\n- 각 view의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.\n  > 뭔가 객체지향의 loose coupling이랑 똑같은 거 같다.\n- 단계별 Schema에 따라 데이터 정의어 - DDL, 데이터 조작어 - DML가 다름을 제공한다.\n\n데이터독립성을 이해하기 위해 3단계로 표현된 ANSI 표준 모델을 살펴봐야 한다.\n\n특히 3단계인 구조, 독립성, 사상의 3가지를 이해하면 된다.\n\n 2. 데이터베이스 3단계 구조\n> 외부 스키마 &rlarr; 개념 스키마 &rlarr; 내부 스키마\n\n<img src=\"/assets/images/posts/database/data-independence.png\">\n\n외부단계는 사용자와 가까운 단계로 사용자 개개인이 보는 자료에 대한 관점과 관련이 있는부분이다.\n- 사용자가 처리하고자 하는 데이터 유형에 따라\n- 관점에 따라\n- 방법에 따라 \n\n다른 스키마 구조를 가지고 있다.\n\n개념단계는 사용자가 처리하는 데이터 유형의 공통적인 사항을 처리하는 통합된 뷰를 스키마 구조로 디자인한 형태이다.\n- 사용자가 처리하는 통합된 뷰를 설계하는 도구\n\n내부적 단계는 데이터가 물리적으로 저장된 방법에 대한 스키마 구조를 말한다.\n\n 3. 데이터독립성 요소\n 외부 스키마 - External Schema\n: 프로그래머나 사용자의 입장에서 데이터베이스의 모습으로 조직의 일부분을 정의한 것\n- View 단계 여러 개의 사용자 관점으로 구성\n  > 개인적 DB 스키마\n- DB의 개개 사용자나 응용프로그래머가 접근하는 DB정의를 의미한다.\n- 사용자관점, 접근하는 특성에 따른 스키마 구성\n\n 개념 스키마 - Conceptual Schema\n: 모든 응용 시스템과 사용자들이 필요로하는 데이터를 통합한 조직 전체의 데이터베이스 구조를 논리적으로 정의한 것.\n- 통합관점\n\n 내부 스키마 - Internal Schema\n: 전체 데이터베이스의 물리적 저장 형태를 기술하는 것.\n\n 4. 두 영역의 데이터독립성\n3단계로 나눠진 각각의 영역에 대한 독립성을 지정하는 용어는 논리적인 독립성과, 물리적인 독립성 이다.\n\n 1. 논리적 독립성\n: 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것  \n\n논리적 사상외부적/개념적 사상을 통해 논리적 독립성이 보장된다.\n\n- 논리적 구조가 변경되어도 응용 프로그램에 영향이 없다.\n- 사용자 특성에 맞는 변경이 가능하다.\n- 통합 구조 변경가능\n\n 2. 물리적 독립성\n: 내부 스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것  \n\n물리적 사상개념적/내부적 사상을 통해 물리적 독립성이 보장된다.\n- 저장장치의 구조변경은 응용프로그램과 개념스키마에 영향이 없다.\n- 물리적 구조 영향 없이 개념구조 변경가능\n- 개념구조 영향 없이 물리적인 구조 변경가능\n\n 6. 사상 - Mapping\n: 상호 독립적인 개념을 연결시켜주는 다리\n\n 외부적/개념적 사상 - 논리적 사상\n: 외부 화면이나 사용자에게 인터페이스 하기 위한 스키마 구조는 전체가 통합된 개념적 스키마와 연결된다는 것\n- 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함\n- 사용자가 접근하는 형식에 따라 다른 타입의 필드를 가질 수 있음.\n- 개념적 뷰의 필드 타입은 변화가 없음\n\n 개념적/내부적 사상 - 물리적 사상\n: 통합된 개념적 스키마 구조와 물리적으로 저장된 구조의 물리적인 테이블스페이스와 연결되는 구조\n- 개념적 뷰와 저장된 DB의 상호관련성을 정의함\n- 만약 저장된 DB구조가 바뀐다면 개념적/내부적 사상이 바뀌어야함. 그래야 개념적 스키마가 그대로 남아있게 된다.\n\n 7. 데이터 모델링의 3가지 구성 요소\n- Entity : 업무와 관련된 어떤 것\n- Attribute : 어떤 것이 갖는 성격\n- Relationship : 어떤 것 간의 관계\n\n 단수/복수 용어 구분\n<img src=\"/assets/images/posts/database/data-modeling-3-thing.png\">   \n\n출처: https://youtu.be/o4Z30OJQmZ8?t=530\n\n 8. ERD - Entity Relationship Diagram\n주로 IE/Crow's Foot표기법을 사용한다.\n\n<img src=\"/assets/images/posts/database/erd-notation.png\">\n\n 7 - 1. ERD 작성 순서\n 1. 엔터티를 그린 후 적절하게 배치한다.\n- 가장 중요한 엔터티를 왼쪽 상단에 배치하고 이것을 중심으로 다른 엔티티를 나열한다.\n  > 왼쪽 &rarr; 오른쪽, 위 &rarr; 아래 \n- 가급적 선이 꼬이지 않게 배치한다.\n\n 2. 엔터티간 관계 설정\n- 식별자 관계를 우선 설정한다.\n  > 식별자 관계: 부모로부터 상속받은 FK가 자식의 PK의 일부가 되는 관계\n- 가급적 Cycle 관계도는 발생하지 않아야 한다.\n\n 3. 관계형 기술 양 방향\n- 현재형을 사용하고 지나치게 포괄적인 단어 지양\n\n 4. 관계차수와 선택성을 표시한다.\n> 1 : N, 1 : 1 ...\n\n 9. 좋은 데이터 모델의 요소\n 1. 완정성 - Completencess\n업무에서 필요로 하는 모든 데이터가 데이터 모델에 정의되어야 한다.\n\n 2. 중복배체 - Non-Redundancy\n동일한 사실=속성은 반드시 한 번만 기록하여야 한다.\n\n 3. 업무규칙 - Business Rules\n업무규칙이 데이터 모델에 표현되어아 한다.\n> ex. 사원에는 정규직, 임시직이 있으며, 정규직만 호봉 정보를 가진다.\n\n 4. 데이터 재사용 - Data Reusbility\n회사 전체 관점에서 공통 데이터를 도출하고, 이를 전 영역에서 사용할 수 있도록 설계해야 한다.\n\n 5. 의사소통 - Communication\n데이터 분석과정에서 도출되는 많은 업무 규칙들은 데이터모델에 엔터티 서브타입, 속성, 관계 등의 형태로 최대한 자세하게 표현되어야 한다.\n- 정보시스템 운용, 관리하는 관련자들이 설계자가 정의한 업무 규칙들을 동일한 의미로 받아드리는 역할과,\n- 정보시스템을 활용할 수 있게 하는 역할을 하게 된다.\n\n 6. 통합성 - Integration\n동일한 데이터는 조직의 전체에서 한 번만 정의되고, 이를 여러 다른 영역에서 참조, 활용해야 한다.\n\n다음글: 2. 엔터티entity.md\n\n Reference\n- SQL전문가 가이드\n- 유튜브 국민대학교 김남규 교수채널 DB실무 Part2-데이터 모델링의 이해2/5https://www.youtube.com/watch?v=o4Z30OJQmZ8 동영상",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "Prometheus quick start with docker",
    "url": "/devops/2022/02/06/prometheus-quick-start-with-docker/",
    "category": "devops",
    "date": "2022-02-06",
    "excerpt": "> 이 글은 빠른 실습을 위해 Spring Boot + Spring Actuator를 기반으로 작성된 글입니다.",
    "content": "Prometheus quick start with docker\n> 이 글은 빠른 실습을 위해 Spring Boot + Spring Actuator를 기반으로 작성된 글입니다.\n\nPrometheus는 metric을 수집하고 모니터링 및 알람에 사용되는 오픈소스 애플리케이션이다.\n\n 설치 및 설정\n 1. 도커 이미지 다운로드 \nsh\ndocker pull prom/prometheus\n\n\n 2. prometheus.yml 파일 생성\nPrometheus Server는 /etc/prometheus/prometheus.yml설정 파일을 사용한다.\ndocker volume mount를 이용해 local에 만든 prometheus.yml를 mount할 것이다.\n\n 1-1. prometheus.yml 파일 생성 예시\n> Spring Boot Application을 기반으로 생성한 예제\nyaml\nglobal:\n  scrape_interval: 10s\n  evaluation_interval: 10s\n\nscrape_configs:\n  - job_name: 'spring-boot-app'\n    metrics_path: '/actuator/prometheus'  Application prometheus endpoint\n    static_configs:\n      - targets: 'host.docker.internal:8081'  application host:port\n\n\n> host.docker.internal는 docker에서 특별한 DNS name으로 사용된다. 개발용으로만 사용해야 하며, Local를 제외한 외부의 환경에서는 동작하지 않는다.\n\n 3. Docker run\nsh\ndocker run -d --name 컨테이너-이름 -p docker내부포트번호:docker외부포트번호 -v 로컬-prometheus.yml경로:/etc/prometheus/prometheus.yml prom/prometheus\n\n\n 3-1. 예시\nprometheus.yml의 경로가 ~/spring-actuator/install/prometheus/prometheus.yml 일 때 docker 외부/내부 포트를 9090으로 컨테이너를 만들고 실행하는 예시이다.\nsh\ndocker run -d --name prometheus -p 9090:9090 -v ~/spring-actuator/install/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus\n\n\n 4. 프로메테우스 접속\n3-1. 예시3-1-예시를 기준으로 실행시킨 프로메테우스 컨테이너의 http://localhost:9090 에 접속하면 다음과 같이 Prometheus 화면이 나온다.\n\n<img width=\"750\" src=\"/assets/images/posts/devops/quick-start-prometheus-main-page.png\">\n\n 4-1. Configuration 확인하기\n상단 네비게이션바에 Status &rarr; Configuration를 선택하면 다음과 같이 나타난다.\n<img width=\"750\" src=\"/assets/images/posts/devops/quick-start-prometheus-config.png\">\n\n 4-2. Application의 상태 확인하기\n상단 네비게이션바에 Status &rarr; Targets를 선택하면 application의 상태를 나타낸다. 다음은 3-1. 예시3-1-예시의 성공 예시이다.\n\n<img width=\"750\" src=\"/assets/images/posts/devops/quick-start-prometheus-targets-ex1.png\">\n\n다음은 prometheus.yml파일에 host 이름을 잘못 입력했거나 서버가 down되었을 때 나타난다.\n\n<img width=\"750\" src=\"/assets/images/posts/devops/quick-start-prometheus-targets-ex2.png\">\n\n 5. 프로메테우스 메트릭 확인하기\n메인페이지에서 페널을 하나 만들고 검색창에 확인하고 싶은 메트릭을 입력하고 Execute를 누른다. \n\n다음 예시는 http_server-requests_seconds_count 메트릭을 보여주는 예시이다.\n\n<img width=\"750\" src=\"/assets/images/posts/devops/quick-start-prometheus-metric-check.png\">\n\n 여담\n- 프로메테우스는 따로 timezone 설정이 안된다.\n  > 그래서 따로 grafana를 사용해 변경할 수 있다.\n- 프로메테우스 하나로 쓰기는 너무 구려서 그라파나 혹은 데이터독을 사용할 예정이다.\n\n Reference\n- https://jongmin92.github.io/2019/12/04/Spring/prometheus/\n- https://yjwang.tistory.com/85",
    "tags": [
      "prometheus",
      "TIL"
    ]
  },
  {
    "title": "데이터 모델과 성능",
    "url": "/database/2022/02/03/데이터-모델과-성능/",
    "category": "database",
    "date": "2022-02-03",
    "excerpt": ": DB 성능을 고려하여 데이터 모델링을 수행하는 것\n- 정규화, 반정규화, 테이블통합 및 분할, 조인 구조 PK/FK설정 등...",
    "content": "데이터 모델과 성능\n 1. 정의\n: DB 성능을 고려하여 데이터 모델링을 수행하는 것\n- 정규화, 반정규화, 테이블통합 및 분할, 조인 구조 PK/FK설정 등...\n\n 1-1. 수행 시점\n<img src=\"/assets/images/posts/database/performance-improving-graph.png\">\n\n- 빠를수록 좋다.\n  - 문석/설계 단계에서 성능 모델링 수행하면 재업무 비용이 최소화 한다.\n\n분석/설계단계에서 데이터 모델은 대충하고, 성능이 저하되는 SQL을 튜닝하고, 부족한 하드웨어 용량을 증설하는 등의 작업은 추가적인 비용을 소진하게 하는 원인이 된다.\n\n 2. 성능 데이터 모델링 고려사항\n 2-1. 성능 데이터 모델링 진행 순서\n1. 정규화를 정확하게 수행한다.\n    > 주요 관심사별로 테이블을 분산한다.\n2. 데이터베이스 용량산정 수행\n    > 각 엔터티에 어느정도의 트랜잭션이 들어오는지 파악한다.\n3. 데이터베이스에 발생되는 트랜잭션의 유형 파악\n    > CRUD 매트릭스 활용\n4. 용량과 트랜잭션의 유형에 따라 반정규화 수행\n    > 테이블, 속성, 관계 변경\n5. 이력모델의 조정, 인덱스를 고려한 PK/FK의 순서 조정, 슈퍼타입/서브타입 조정 등 수행\n6. 성능관점에서 데이터 모델을 검증한다.\n\n이전글: 2. 엔터티 - Entityentity.md\n다음글: 3-1 정규화normalization-and-performance.md\n\n Reference\n- SQL 전문가 가이드\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능1/6https://youtu.be/AAv0lT6KxyY",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "정규화와 성능",
    "url": "/database/2022/02/03/정규화와-성능/",
    "category": "database",
    "date": "2022-02-03",
    "excerpt": "- 목적: 삽입/삭제/갱신 이상현상 방지\n- 에 기반",
    "content": "정규화와 성능\n 1. 정규화 - Normalization\n- 목적: 삽입/삭제/갱신 이상현상 방지\n- 함수적 종속성 - Functional Dependency에 기반\n\n 1-1. 종류\n> 실무에서 보통은 3차 정규형까지 한다.\n\n<img src=\"/assets/images/posts/database/normalization-ex.png\">\n\n출처: https://youtu.be/vnHTZT7L-KI?t=1086\n\n 1. 1NF - 1 Normal Form\n: 모든 값이 원자값을 가짐\nComposite 혹은 Multi-valued 애트리뷰트를 제거한다.\n> 웬만하면 1정규형은 일부로 하지 않는 이상 만족한다.\n\n 2. 2NF: 부분함수종속 제거\n<img src=\"/assets/images/posts/database/2nf-ex.png\">\n\n출처: https://youtu.be/vnHTZT7L-KI?t=1369\n\n- 부분함수종속은 복합키 일 떄 발생할 확률이 크다.\n\n위 그림으로 예시를 들면 복합 식별자인 두개의 속성학번, 과목코드에 종속적인 평점을 제외한 빨간색으로 가르키는 속성들을 제거한다.\n\n하지만 2NF를 수행했지만 아직 소속학과코드는 식별자가 아니지만 학과명을 종속하고 있다 이를 3NF를 수행하여 만족시켜보자\n\n 3. 3NF: 이행함수종속 제거\n<img src=\"/assets/images/posts/database/3nf-ex.png\">\n\n기본키가 아닌 종속성을 갖는 속성을 제거한다.\n\n출처: https://youtu.be/vnHTZT7L-KI?t=1614\n\n2정규형처럼 그냥 테이블을 나누면된다.\n\n---\n\n식별자가 아닌 속성주식별자의 일부 또는 일반속성이 결정자 역할을 하는 함수 종속 제거를 하면 3정규형까지 얻을 수 있다.\n\n 1-2. 정규화의 효과\n<img width=700 src=\"/assets/images/posts/database/performing-normalization.png\">\n\n출처: https://youtu.be/vnHTZT7L-KI?t=1368\n\n- 데이터 중복 감소 &rarr; 성능 향상\n- 데이터가 관심사별로 묶임 &rarr; 성능 향상\n- 조회 질의에서 조인이 많이 발생할 시 &rarr; 성능 저하\n\n정규화를 통해 일반적으로 성능이 향상되나, 조회의 경우 처리 조건에 따라 성능이 향상되거나 저하된다.\n\n 1-3. 정규화 예시\nhttps://youtu.be/vnHTZT7L-KI?t=2286\n\n이전글: 데이터 모델과 성능data-model-and-performance.md\n다음글: 반정규화denormalization.md\n\n Reference\n- SQL 전문가 가이드 - 2절 정규화와 성능\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능2/6https://youtu.be/vnHTZT7L-KI",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "선택 정렬 - Selection Sort",
    "url": "/algorithm/2022/01/30/선택-정렬---selection-sort/",
    "category": "algorithm",
    "date": "2022-01-30",
    "excerpt": ": 해당 순서의 원소를 넣는 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.\n-  알고리즘\n- 비교 정렬\n- 불안정 정렬\n- 시간 복잡도: ON^2",
    "content": "선택 정렬 - Selection Sort\n: 해당 순서의 원소를 넣는 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.\n- 제자리 정렬 - in-place sorting 알고리즘\n- 비교 정렬\n- 불안정 정렬\n- 시간 복잡도: ON^2\n\n 정렬 방법\n1. 주어진 리스트에서 최솟값을 찾는다.\n2. 최솟값을 맨 앞 자리의 값과 교환한다.\n3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다. \n\n 예제\n<img width=500 src=\"/assets/images/posts/algorithm/selection-sort.png\">\n\n 소스코드\njava\n\n/\n  @param arrLen 배열의 크기\n  @param arr 정렬 할 배열\n/\nprivate static int solutionfinal int arrLen, final int arr {\n    for int i = 0; i < arrLen; i++ {\n        int swapIdx = i;\n        for int j = i + 1; j < arrLen; j++ {\n            if arrswapIdx > arrj swapIdx = j;\n        }\n        int temp = arri;\n        arri = arrswapIdx;\n        arrswapIdx = temp;\n    }\n    return arr;\n}\n\npublic static void mainString args {\n    Scanner sc = new ScannerSystem.in;\n    final int arrLen = sc.nextInt;\n    final int arr = new intarrLen;\n    for int i = 0; i < arrLen; i++ \n        arri = sc.nextInt;\n    \n    forint i : solutionarrLen, arr\n        System.out.printi + \" \";\n    \n}",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "버블 정렬 - Bubble Sort",
    "url": "/algorithm/2022/01/30/버블-정렬---bubble-sort/",
    "category": "algorithm",
    "date": "2022-01-30",
    "excerpt": "- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘이다.\n- 시간 복잡도 : ON^2",
    "content": "버블 정렬 - Bubble Sort\n- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘이다.\n- 시간 복잡도 : ON^2\n\n연산이 가장 많아 정렬 알고리즘 중에서 상대적으로 가장 느리고 효율성이 떨어진다.\n\n 구현 코드\njava\nprivate static int solutionfinal int arrLen, final int arr {\n    for int i = 1; i < arrLen; i++ {\n        int temp = arri, j;\n        for j = i - 1; j >= 0; j-- {\n            ifarrj > temp arrj + 1 = arrj;\n            else break;\n        }\n        arrj + 1 = temp;\n    }\n    return arr;\n}\n\npublic static void mainString args {\n    Scanner sc = new ScannerSystem.in;\n    final int arrLen = sc.nextInt;\n    final int arr = new intarrLen;\n    for int i = 0; i < arrLen; i++\n        arri = sc.nextInt;\n\n    forint i : solutionarrLen, arr\n        System.out.printi + \" \";\n}",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "엔터티 - Entity",
    "url": "/database/2022/01/30/엔터티---entity/",
    "category": "database",
    "date": "2022-01-30",
    "excerpt": "데이터 모델과 데이터 베이스에 관위자가 정의한 사항은 다음과 같다.\n- 변별할 수 있는 사물 - Peter Chen 1976\n- DB 내에서 변별 가능한 객체 - C.J Date 1986\n- 정보를 저장할 수 있는 어떤 것 - James Martin 1989\n- 정보가 저장될 수 있는 사람, 장소 물건, 사건 그리고 개념 등 - Thomas Bruce 19...",
    "content": "엔터티 - Entity\n 1. 엔터티의 정의\n데이터 모델과 데이터 베이스에 관위자가 정의한 사항은 다음과 같다.\n- 변별할 수 있는 사물 - Peter Chen 1976\n- DB 내에서 변별 가능한 객체 - C.J Date 1986\n- 정보를 저장할 수 있는 어떤 것 - James Martin 1989\n- 정보가 저장될 수 있는 사람, 장소 물건, 사건 그리고 개념 등 - Thomas Bruce 1992\n\n위 정의들의 공통점은...\n- 명사에 해당된다.\n  > 사람, 장소, 물건, 사건, 개념 등...\n- 업무상 관리가 필요한 관심사에 해당한다.\n- 저장이 되기 위한 어떤 것 이다.\n\n즉 엔터티란 \"업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것Thing\" 으로 설명할 수 있다.\n\n 2. 엔터티의 분류\n\n 2-1. 유/무형에 따른 분류\n\n 1. 유형 - Tangible 엔터티\n- 물리적인 형태가 있고 안정적이며 지속적으로 활용된다.\n- ex. 교수, 강의실, 학생 등...\n\n 2. 무형 엔터티\n  1. 개념 - Conceptual 엔터티\n     - 물리적인 형태는 존재하지 않으나 관리해야 할 개념적 정보\n     - ex. 수업, 보험상품 등...\n\n  2. 사건 - Event 엔터티\n     - 업무 수행 과정에서 발생하며 비교적 발생량이 많다.\n     - ex. 수강신청, 주문, 입금 등...\n\n 2-2. 발생시점에 따른 분류\n 1. 기본/키 엔터티 - Fundamental Entity, Key Entity\n: 업무에 원래 존재하는 정보로써 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성되는 엔터티\n- 타 엔터티의 부모의 역할을 하게된다.\n- 자신의 고유 식별자를 가지게 된다.\n- 사원, 부서, 고객, 상품 자재 등...\n\n 2. 중심엔터티 - Main Entity\n: 그 업무에 있어서 중심적인 역할을 하는 엔터티\n- 기본 엔터티로부터 발생된다.\n- 계약, 사고, 예금원장, 청구, 주문, 매출 등...\n\n 3. 행위엔터티 - Active Entity\n- 두 개 이상의 부모엔터티로부터 발생된다.\n- 자주 내용이 바뀌거나 데이터양이 증가된다.\n- 주문목록, 사원변경이력 등...\n\n 2-3. 기타\n- 스스로 생성될 수 있는지에 따라서 독립엔터티, 의존엔터티로 나뉜다.\n\n\n 3. 엔터티의 특징\n 3-1. 업무에서 필요하고 관리하고자 하는 정보\n- 관심 영역 - Business Boundary에 따라 달라진다.\n- ex. 도서관리 시스템에 환자라는 엔터티가 존재할 일이 없다.\n\n 3-2. 식별가능\n- 식별자 - Unique Identifier에 의해 식별 가능해야 한다.\n- 유일 식별자 : 해당 엔터티 인스턴스만의 고유한 이름\n\n식별자가 두 개 이상의 엔터티를 대변하면 잘못된 설계이다.\n\n만약 회원 엔터티에서 이름을 식별자로 만들어버리면 세상에는 중복되는 이름이 있으므로 이는 잘못된 식별자라고 할 수 있다.\n\n 3-3. 둘 이상의 인스턴스 집합\n하나의 엔터티는 두 개 이상의 인스턴스를 포함한다.\n\n 3-4. 업무 프로세스에 의해 이용된다.\n- 업무 프로세서에 의해 CRUD가 발생해야 한다.\n- CRUD가 발생하지 않음 &rarr; 부적절한 엔터티 도출, 또는 업무 누락\n\n 3-5. 반드시 속성을 가져야 한다.\n- 주식별자만 존재하고 일반 속성은 없는 경우도 바람직하지 않다.\n\n    - 단 연관 엔터티 - Associative Entity는 주 식별자 속성만 갖고 있어도 된다. \n        > 다음과 같은 관계에서 수강 Entity를 의미한다.\n        <img src=\"/assets/images/posts/database/associative-entity-ex.png\">\n\n 3-6. 엔터티는 최소 한 개 이상의 관계를 가져야 한다.\n관계가 없는 엔터티를 고립 엔터티 - Isolated Entity라고 하는데 고립 엔터티가 있을 경우 부적절한 엔터티 도출 및 관계 누락이 있는지 확인한다.\n\n 고립 엔터티를 인정하는 경우\n- 통계성 엔터티\n  > 읽기 효율성 또는 집계처리를 위한 엔터티\n- 코드성 엔터티\n  > ex. 에러 코드 관련 테이블단순 참조만 할 때\n- 시스템 처리용 내부 엔터티\n  > ex. 트랜잭션 로그 테이블 등...\n\n\n 4. 엔터티의 명명\n- 엔터티 생성 의미대로, 실제 업무에서 사용하는 용어를 사용한다.\n- 약어를 사용하지 않는다.\n- 단수 명사를 사용한다.\n- 이름이 동일한 엔터티가 중복으로 존재할 수 없다.\n\n 5. 관계 - Relationship\n 5-1. 관계\n- 엔터티간 논리적 연관성\n\n 5-2. 페어링 - Pairing\n- 엔터티 내 인스턴스 간의 개별적 연관성\n\n 5-3. 페어링의 집합 == 관계\n\n 5-4. 관계의 분류\n<img src=\"/assets/images/posts/database/classificationOfRelreation.png\">\n\n출처: https://youtu.be/RIe2LRc3oio?t=439\n\n관계는 사건 엔터티의 유무로 판단하면 된다.\n\n 5-5. 관계의 표기법\n 1. 관계명\n<img width=400px src=\"/assets/images/posts/database/relationship-notation.png\">\n\n- 각 관계는 두 방향의 관계명을 가진다.\n- 애매한 동사를 피한다.\n- 현재형으로 표현한다.  \n\n 2. 관계 차수 - Degree\n- 각 관계에 참여할 수 있는 인스턴스의 수 \n\n 3. 선택성\n- 필수 참여 - Mandatory Membership\n  \n- 선택 참여 - Optional Membership\n  \n관계의 양쪽이 Optional인 경우, 해당 관계는 잘못 설정되었을 가능성이 크다.\n\n 4. 관계 읽기\n<img width=600 src=\"/assets/images/posts/database/relation-read.png\">\n\n 6. 속성 - Attribute\n- 사물의 특징 또는 본질적인 성질\n- 인스턴스에 대해 의미상 더 이상 분리되지 않는 최소의 데이터 단위\n- 엔터티에 속한 인스턴스들의 성격을 구체적으로 나타낸다.\n  > 인스턴스 각각을 구분할 수 있는 기준 파악 &rarr; 이름 부여 &rarr; 속성화\n\n 엔터티 인스턴스 속성 속성값의 대응\n- 각 엔터티는 둘 이상의 인스턴스를 가진다.\n- 각 엔터티는 둘 이상의 속성을 가진다.\n- 각 속성은 하나의 속성값을 가진다.\n\n 6-1. 특징\n- 해당 업무에서 필요하고 관리해야 하는 정보\n- 모든 속성은 주식별자에 함수적으로 종속되어야 한다.\n- 하나의 속성은 한개의 값만 가져야 한다.\n  - 속성이 다중값을 가질경우 해당 속성을 별도의 엔터티로 분리한다.\n\n 6-2. 속성의 명명 권장\n- 협업에서 사용하는 이름을 부여\n- 약어 사용은 가급적 금지\n- 서술식 속성명을 피하고 명사적 속성명을 사용한다.\n- 수식어와 소유격을 피한다.\n- 속성의 이름은 가급적 전체 모델에서 유일하게 정의 권장\n\n 6-3. 속성의 표기\n<img width=800 src=\"/assets/images/posts/database/attribute-mark.png\">\n\n- 엔터티 내에 이름을 기재\n\n 6-4. 도메인 - Domain\n- 각 속성의 가질 수 있는 값의 범위\n  > ex. 학점: 0.0 ~ 4.5 사이의 실수  \n  > ex. 주소: 길이가 20자리 이내인 문자열\n- 속성에 대한 데이터 타입, 크기, 제약사항을 지정한다.\n\n 6-5 속성의 분류\n 특성에 따른 분류\n<img src=\"/assets/images/posts/database/attribute-classification.png\">\n\n- 기본 속성 - Basic Attribute\n  - 가장 일반적인 속성, 원래의 업무로부터 유래\n- 설계 속성 - Designed Attribute\n  - 데이터 모델링을 위해 새로 만든 속성 \n  > ex. PK, Idx, 코드\n- 파생 속성 - Derived Attribute\n  - 다른 속성들로 유도된 속성 주로 통계 관련\n  - 가급적 적게 정의하는 것이 좋다.\n    > 데이터의 중복과 성능에 영향을 미친다.\n  - ex. 과목점수평균\n\n 엔터티 구성 방식에 따른 분류\n- Primary Key 속성 : 엔터티의 인스턴스를 구별할 수 있는 속성\n- Foreign Key 속성 : 타 엔터티의 PK를 참조하는 속성\n- 일반 속성\n\n 분리 가능함에 따른 분류\n- 복합 속성 - Composite Attribute\n- 단순 속성 - Simple Attribute\n\n 속성값의 수에 따른 분류\n- 다중값 속성 - Multi-Valued Attribute\n- 단일값 속성 - Single-Valued Attribute\n\n 7. 식별자\n 7-1. 식별자의 분류\n<img src=\"/assets/images/posts/database/identifier-classification.png\">\n\n출처: https://youtu.be/GQpbyjjPkK8?t=39\n\n주로 주식별자, 내부식별자, 단일식별자, 본질식별자를 한번에 가지는 경우가 일반적이다.\n\n엔터티 내에서 각 인스던스를 구문할 수 있는 것 중에서 대표성 갖는 것을 주 식별자로 가지고 탈락한 것을 보조식별자로 갖는다.\n\n 7-2. 식별자의 특징\n 1. 유일성\n: 주식별자에 의해 엔터티 내의 각 인스턴스들을 모두 유일하게 구분할 수 있어야 한다.\n> ex. 각 회원들에 대해 ID가 개인별로 구요하게 부여됨\n\n 2. 최소성\n: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.\n> ID만으로 유일성이 만족되면, ID, 이름은 주식별자가 아니다.\n\n 3. 불변성\n: 주식별자가 지정되면, 그 식별자의 값은 변하지 않아야 한다.\n> 주식별자인 ID의 값이 변한다는 의미는 이전기록이 말소되고 새로운 기록이 발생했다는 의미다.\n\n 4. 존재성\n: 주식별자의 값은 null이 될 수 없다.\n> 주식별자인 ID가 없는 회원은 있을 수 없다.\n\n 7-3. 주식별자 도출 기준\n<img src=\"/assets/images/posts/database/main-identifier-derivation-criteria.png\">\n\n- 유일성을 갖는 속성 중 해당 업무에서 자주 이용되는 속성을 지정\n- 이름으로 기술되는 것은 가능하면 주식별자로 지정하지 않는다\n  > ex. 명칭, 내역과 같이 무조건 중복될 수 있으므로 code같은 것으로 주 식별자를 가진다.\n- 복합식별자를 구성할 경우 너무 많은 속성이 포함되지 않아야 함\n  > 주식별자가 너무 많이 포함되면, 인조식별자를 통해 단순화한 주식별자 속성을 만든다. ex. 회원번호, 접수번호 등...\n\n 7-4. 식별자 관계와 비식별자 관계\n<img src=\"/assets/images/posts/database/identifier-non-identifier.png\">\n\n출처: https://youtu.be/GQpbyjjPkK8?t=1558\n\n부모 엔터티의 식별자 A를 자식 엔터티의 외부식별자 AFK로 포함할 때\n 1. 식별자 관계\n위 사진에서 AFK가 주식별자에 포함된 경우를 식별자 관계라고 한다.\n- 실선으로 나타낸다.\n- 과목코드, 수강년도, 학번은 무조건 값을 가져야한다.\n  > 식별자는 null을 가지면 안된다.\n\n 2. 비식별자 관계\n위 사진에서 AFK가 비 식별자 속성으로 포함된 경우를 비식별자 관계라고 한다.\n- 부모 엔터티와 자식 엔터티의 관계가 약한경우\n  > 부모 엔터티 없이 자식 엔터티가 생성 가능\n- 점선으로 나타낸다.\n\n 7-5. 식별자 관계 - Identifier Relationship\n<img src=\"/assets/images/posts/database/identifier-relationship-ex.png\">\n\n출처: https://youtu.be/GQpbyjjPkK8?t=1834\n\n- 부모의 주식별자가 자식엔터티의 주식별자로 상속한다.\n- 반드시 부모 엔터티가 생성되어야 자식 엔터티가 생성될 수 있다.\n  - 해당 속성이 Not Null 이므로 &rarr; weak entity에 해당된다.\n- 자식 엔터티의 주식별자가 해당 속성만으로 구성되는 경우 &rarr; 1 : 1 관계\n  > 사번번호FK는 주식별자, 외부식별자, 단일식별자 에 해당된다.\n- 자식 엔터티의 주식별자가 해당 속성 + a 로 구성되는 경우 &rarr; 1 : N 관계\n  > 사원번호FK는 주식별자, 외부식별자, 복합식별자 에 해당된다.\n\n> weak entity란?  \n> 자신 혼자 식별자를 만들 수 없고 다른 엔터티의 도움을 받아 생성할 수 있는 엔터티를 의미한다.\n\n 1. 식별자 관계 남용시 문제\n- 주식별자 속성이 지속적으로 증가한다.\n\n 2. 비식별자 관계 남용시 문제\n- 조회시 JOIN횟수가 증가한다.\n\n 7-7 비식별자 관계를 고려해야 하는경우\n- 부모 엔터티와 자식 엔터티의 관계의 강도가 약한 경우\n- 자식 엔터티의 독립적인 주식별자 설정이 필요한 경우\n- PK 속성의 단순화가 필요한 경우\n  > SQL복잡도 증가로 인한 개발 생산성이 저하되는 현상을 방지한다.\n\n 식별자/비식별자 관계의 비교\n\n<img src=\"/assets/images/posts/database/identifier-vs-non-identifier.png\">\n\n출처: https://youtu.be/GQpbyjjPkK8?t=3047\n\n이전글: 1. 데이터 모델링의 이해understanding-data-modeling.md\n다음글: 3. 데이터 모델과 성능data-model-and-performance.md\n\n Refrenece\n- SQL 전문가 가이드\n- 국민대학교 김남규 교수 - DB실무 Part2-데이터 모델링의 이해3/5https://youtu.be/RIe2LRc3oio\n- 국민대학교 김남규 교수 - DB실무 Part2-데이터 모델링의 이해4/5https://youtu.be/GQpbyjjPkK8\n- 국민대학교 김남규 교수 - DB실무 Part2-데이터 모델링의 이해5/5https://youtu.be/BEzctduY9Jk",
    "tags": [
      "data-modeling",
      "TIL"
    ]
  },
  {
    "title": "트랜잭션 격리 수준 - Isolation level",
    "url": "/database/2022/01/18/트랜잭션-격리-수준---isolation-level/",
    "category": "database",
    "date": "2022-01-18",
    "excerpt": "트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다",
    "content": "트랜잭션 격리 수준 - Isolation level\n트랜잭션 격리 수준은 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것이다\n\n격리수준은 크게 4개로 나뉜다.\n- Read Uncommitted1-read-uncommitted\n- Read Committed2-read-committed\n- Repeatable Read3-repetable-read\n- Serializable4-serializable\n\n위에서 아래로 갈수록 격리수준은 높아진다.\n\n 1. 격리성 관련 문제점\n 1-1. Dirty Read\n다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것\n\n1. 트랜잭션 A가 1번 사원의 나이를 19 &rarr; 20로 변경하고 커밋하지 않았다.\n2. 트랜잭션 B는 1번 사원의 나이를 조회했더니 커밋하지 않았던 20을 조회했다.\n\n만약 트랜잭션 A가 최종커밋을 하지 않는다면, 트랜잭션 B가 가지고 있는 데이터는 꼬이게된다.\n\n 1-2. Non-Repeatable Read\n트랜잭션 내에서 같은 쿼리를 두번 수행할 때 두개의 쿼리가 다른 결과를 반환하는 현상 비 일관성\n\n1. 트랜잭션 A는 현재 1번 사원의 나이가 19인 데이터를 조회하고 있다.\n2. 트랜잭션 B가 1번 사원의 나이를 19 &rarr; 20로 변경하고 커밋한다.\n3. 그후 트랜잭션 A가 다시 해당 데이터를 조회 하면 처음 조회랑 다른 20으로 변경된 데이터를 조회하게 된다.\n\n 1-3. Phantom Read\n한 트랜잭션 안에서 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다.\n\n1. 트랜잭션 A가 특정 조건으로 데이터를 검색하여 결과를 얻었다.\n2. 트랜잭션 B가 해당 조건의 데이터를 삭제 혹은 추가 해버렸다,\n3. 다시 해당 조건으로 트랜잭션 A가 데이터를 조회하면 이전에 트랜잭션 A에서 추가/삭제된 데이터가 함께 조회/누락 된다.\n\n이 때 트랜잭션 B가 롤백하게 된다면 데이터가 꼬이게 된다.\n\n 2. 트랜잭션 격리수준\n\n 2-1. Read Uncommitted level 0\n어떤 트랜잭션의 처리중인 변경내용이 다른 트랜잭션에서 읽는 것을 허용한다.\n\n- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는다.\n- 트랜잭션에 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.\n- 데이터베이스의 일관성을 유지는 것이 불가능하다.\n\n 발생되는 문제점 \nDirty Read, Non-Repeatable Read, Phantom Read\n\n 2-2. Read Committed level 1\n어떤 트랜잭션의 변경 내용이 COMMIT 되어야만 다른 트랜잭션에서 조회할 수 있다.\n> Oracle DBMS에서 기본으로 사용된다.\n\n- Oracle, SQL Server\n\n 발생되는 문제점들\nNon-Repeatable Read, Phantom Read\n\n금융 시스템에서 입/출금 과 연관된 금전적인 처리와 연결되어 있다면 문제가 발생할 수 있다.\n\n 2-3. Repetable Read level 2\n트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리수준이다.\n> MySQL DBMS에서 기본으로 사용한다.\n\n1. A번 트랜잭션이 500000번 사원을 조회\n2. B번 트랜잭션이 500000번 사원의 이름을 변경하고 커밋\n3. A번 트랜잭션이 500000번 사원을 다시 조회\n4. 언두 - Undo 영역에 백업된 데이터 반환\n\n즉, 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된커밋된것만 보게 되는 것 이다.\n\n 발생되는 문제점\nPhantom Read\n\n 2-4. Serializable\n격리수준이 Serializable일 경우 읽기 작업에도 공유 잠금을 설정하게 되고, 이러면 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못하게 된다.\n\n- 동시처리 능력이 떨어진다.\n- 성능저하가 발생하게 된다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "SSH (Secure Shell Protocol)",
    "url": "/devops/2021/12/04/ssh-secure-shell-protocol/",
    "category": "devops",
    "date": "2021-12-04",
    "excerpt": ": 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 프로토콜",
    "content": "SSH Secure Shell Protocol\n: 네트워크 프로토콜 중 하나로 컴퓨터와 컴퓨터가 인터넷과 같은 Public Network를 통해 서로 통신을 할 때 보안적으로 안전하게 통신을 하기 위해 사용하는 프로토콜\n\n SSH의 통신 방식\n: 한 쌍의 Key를 통해 접속하려는 컴퓨터와 인증 과정을 거치며 연결이 되는프로토콜 이다.  \n\nPrivate Key\n- 공개되어도 안전한 키\n- Public Key를 통해 메시지를 전송하기 전 암호화를 하게 된다.\n- 암호화는 가능하지만 복호화는 불가능하다.\n\nPublic key\n- 절대로 공개되면 안되는 키\n- 암호화된 메시지를 복호화 할 수 있다.\n\n 사용처\n- 데이터 전송  \n    GitHub 등...\n- 원격접속  \n    AWS 등..",
    "tags": [
      "ssh",
      "TIL"
    ]
  },
  {
    "title": "01. 소프트웨어 공학 소개",
    "url": "/book/2021/08/24/01-소프트웨어-공학-소개/",
    "category": "book",
    "date": "2021-08-24",
    "excerpt": ": 프로그램 + 개발 과정에서 생성되는 모든 산출물자료구조, DB구조, 테스트 결과등...\n- 각 단계에서 만들어지는 문서와 사용자 메뉴얼 등도 포함이다.",
    "content": "01. 소프트웨어 공학 소개\n 01 - 1 소프트웨어의 이해\n 1. 소프트웨어란?\n: 프로그램 + 개발 과정에서 생성되는 모든 산출물자료구조, DB구조, 테스트 결과등...\n- 각 단계에서 만들어지는 문서와 사용자 메뉴얼 등도 포함이다.\n\n> 프로그램: 프로그래밍한 원시 코드 - source code를 말한다.\n\n 2. 소프트웨어의 분류\n 관리 소프트웨어\n: 자료를 받아들여 가공 후 정보를 제공하는 소프트웨어이다.\n- 주로 DB에 자료를 저장후 검색을 통해 사용자가 원하는 형태로 제공\n- ex. 인터넷 뱅킹, 대학 종합정보시스템 등..\n\n 제어 소프트웨어\n: 센서를 이용하거나 기기들의 동작을 제어하는 프로그램\n- ex. 교통신호 제어, 의료기기 제어 등...\n  \n 임베디드 소프트웨어\n: 장비나 기기에 내장된 형태의 소프트웨어\n- ex. 가전제품 등...\n\n 3. 소프트웨어 특징\n 제조가 아닌 개발\n- SW는 개발이 된다. \n  > 조립만 하면 끝나는 하드웨어와 다르다.\n- SW는 개발경력에 따라 생성성이 다르다.\n\n 소모가 아닌 품질 저하\n하드웨어\n- 하드웨어는 초기 실패율이 매우 높지만 오류 해결 후 큰 문제없이 오래 지속된다.\n- 마모가 되면 실패율이 높아진다.\n\n<img width=300 src=\"/assets/images/posts/book/hw-fail-curve.png\">\n\n하드웨어의 실패 곡선욕조 곡선 - bathub curve  \n\n소프트웨어\n- 하드웨어와 다르게 닳지 않는다.\n  > 오류를 해결한 후 사용기간 내 큰 문제없이 사용가능하다.\n- 하지만 사용 시작 단계부터 사용자의 요구가 계속 발생한다.\n  > 운영체제 등, 설치환경도 달라 질 수 있음\n- 변경사항이 발생하면 이로 인한 부작용 - side effect으로 인해 오류와 실패률이 올라갈 수 있다.\n\n<img width=300 src=\"/assets/images/posts/book/sw-fail-curve.png\">\n\n소프트웨어의 이상적인/실제 실패 곡선\n\n 4. 소프트웨어의 당면 문제\n 소프트웨어 개발의 느린 발전 속도\n- HW에 비하면 개발속도가 상당히 느리다.\n    > 개인용 PC성능과 SW발전 속도를 비교하면 차이가 난다.\n\n 새로운 소프트웨어에 대한 사용자 요구의 증가 \n- SW는 생산과 같이 공장에서 찍어내는게 아니라 A부터 Z까지 개발 해야 한다.\n- 새로운 SW에 대한 사용자 요구가 날로 증가하지만 발전속도는 만족을 못시키고 있다.\n- 하드웨어처럼 조립하는 방식으로 개발하기에는 표준화 등 해결해야 하는 문제가 많다.\n\n  관리 기술의 부분적 활용\n- 관리가 효율적으로 이루어져야 좋은 품질의 SW를 적기에 맞추어 납품가능하다.\n- SW를 개발할 때 주어진 예산내에서 수행할 수 있도록 비용을 관리하고,\n- 정해진 기간 내에 마칠 수 있도록 스케줄을 관리해야 한다.\n\n 5. 소프트웨어 개발의 어려움\n> 부제 - SW공학의 필요성\n 개발 과정이 복잡하다.\n- 무엇이든지 복잡하면 문제가 많이 발생한다.\n- SW공학은 개발의 복잡함을 줄이기 위한 방법과 기술을 제공한다.\n\n 참여 인력이 많다.\n- 인력이 많으면 의사소통 경로가 많아져 의사 결정 과정이 복잡할 수 있다.\n- 인력에 따른 변화가 많이 발생할 수 있다\n- SW공학은 개발에 참여하는 팀을 구성하고 관리하는 효율적인 방법을 제시한다.\n\n 개발 기간이 길다.\n- 개발 기간이 길면 진행 상황을 파학하기 쉽지 않고 개발 비용 산정이 어렵다\n- SW공학에서는 프로젝트를 효율적으로 관리하기 위한 프로젝트관리지식체계 - PMBOK를 소개한다.\n\n  01 - 2 공학과 소프트웨어 공학의 이해\n  공학\n - 정해진 기간과 주어진 비용이라는 제안이 생긴다.\n - 발전하면 문제 해결을 위한 기술이 축적된다.\n - 실무에 적용하여 문제 해결의 절차를 만든다\n - 절차의 개선으로 표준을 만들어낸다.\n\n 소프트웨어 공학\n: 품질 좋은 SW를 경제적으로 개발하기 위해 계획을 세우고, 개발하며, 유지 및 관리 하는 전 과정에서 공학, 과학 및 수학적 원리와 방법을 적용하여 필요한 이론과 기술 및 도구들에 관해 연구하는 학문이다.\n- SW개발의 어려움 해결한다.\n- 효율적인 개발을 통해 생상성을 향상시킨다.\n- 사용하자가 만족하는 고품질 SW제품을 만들기 위함이다.\n\n 소프트웨어 개발 생명주기 - SDLCSoftware Development Life Cycle\n계획 &rarr; 분석 &rarr; 설계 &rarr; 구현 &rarr; 테스트 &rarr; 유지보수",
    "tags": [
      "쉽게-배우는-소프트웨어-공학.",
      "TIL"
    ]
  },
  {
    "title": "AWS EC2",
    "url": "/devops/2021/08/12/aws-ec2/",
    "category": "devops",
    "date": "2021-08-12",
    "excerpt": ": Amazon Elastic Compute CLoud의 줄임말로써 AWS에서 제공하는 클라우드 컴퓨팅\n>Amazon EC2는 웹서비스 인터페이스를 사용해 다양한 운영 체제로 인스턴스를 시작하고, 이를 사용자 정의 애플리케이션 환경으로 로드하며, 네트워크의 엑세스 권한을 관리하고, 원하는 수의 시스템을 사용해 이미지를 실행 할 수 있는 진정한 가상 컴퓨팅 ...",
    "content": "AWS EC2\n Amazon EC2\n: Amazon Elastic Compute CLoud의 줄임말로써 AWS에서 제공하는 클라우드 컴퓨팅\n>Amazon EC2는 웹서비스 인터페이스를 사용해 다양한 운영 체제로 인스턴스를 시작하고, 이를 사용자 정의 애플리케이션 환경으로 로드하며, 네트워크의 엑세스 권한을 관리하고, 원하는 수의 시스템을 사용해 이미지를 실행 할 수 있는 진정한 가상 컴퓨팅 환경을 제공한다.\n\n 장점\n- 하드웨어 투자할 필요가 없어 빠르게 애플리케이션을 개발하고 배포할 수 있다.\n- 원하는 만큼 가상 서버를 구축\n- 보안 및 네트워크 구성과 스토리지 관리가 가능\n- 서버 트래픽 예측 필요성 줄어든다\n    >요구 사항이나 갑작스러운 인기 증대 등 변동 사항에 따라 신속하게 규모를 확장하거나 축소할 수 있음\n\n 기능 \n- 인스턴스instance: 가상 컴퓨팅 환경\n- Amazon 머신 이미지AMI: 서버에 필요한 운영체제와 여러 소프트웨어들이 적절히 구성된 상태로 제공되는 템플릿으로 인스턴스를 쉽게 만들 수 있다.\n- 인스턴스 유형: 인스턴스를 위한 CPU, 메모리, 스토리지, 네트워킹 용량의 여러 가지 구성 제공\n- 키 페어를 사용하여 인스턴스 로그인 정보 보호AWS는 퍼블릭 키를 저장하고 사용자는 개인 키를 안전한 장소에 보관하는 방식\n- 인스턴스 스토어 볼륨: 임시 데이터를 저장하는 스토리지 볼륨으로 인스턴스 중단, 최대 절전 모드로 전환 또는 종료 시 삭제됨\n- Amazon Elastic Block StoreAmazon EBS   \n    : Amazon EBS 볼륨을 사용해 영구 스토리지 볼륨에 데이터 저장\n- 인스턴스와 Amazon EBS 볼륨 등의 리소스를 다른 물리적 장소에서 액세스할 수 있는 리전 및 가용 영역\n- 보안 그룹을 사용해 인스턴스에 연결할 수 있는 프로토콜, 포트, 소스 IP 범위를 지정하는 방화벽 기능\n- 탄력적 IP 주소EIP: 동적 클라우드 컴퓨팅을 위한 고정 IPv4 주소\n- 태그: 사용자가 생성하여 Amazon EC2 리소스에 할당할 수 있는 메타데이터\n- Virtual Private CloudsVPC : AWS 클라우드에서는 논리적으로 격리되어 있지만 원할 때마다 고객의 네트워크와 간편히 연결할 수 있는 가상 네트워크\n\n 간단하게 Spring Boot 서버를 열기위한 Instance 생성하기\n> 본인은 SpringBoot로 만든 서버를 이용하여 AWS EC2 에 돌릴 예정이기때문에 SpringBoot 배포환경 기반으로 글을 작성할 것이다.\n Instance 만들기\n1. AWS Management Console 에 들어가서 EC2 에 들어간다.\n2. 인스턴스 시작을 누른다.\n<img src=./img/instanceStart.png>\n \n1. Amazon Machine ImageAMI 선택 에서   \n    Amazon Linux 2 AMI HVM, SSD Volume Type - ami-047a51fa27710816e 64비트 x86 / ami-03c5cc3d1425c6d34 64비트 Arm 를 선택한다.\n    > 본인이 원하는 것을 선택해도된다 필자는 이렇게 할것이다.\n<img src=./img/linux2-aws.png>\n\n1. 인스턴스 유형 선택 에서 원하는 인스턴스를 선택하고 인스턴스 세부 정보\u001c구성 을누른다.\n    > 간단한 Back-end서버를 열것이기 때문에 프리티어가 적용되는 t2.micro 를 사용할것이다.\n1. 3, 4, 5 단계에서 자신이 원하는 설정을 한다.\n    > 간단하게 열것이기 때문에 본인은 기본값으로 할것이다.\n1.  다음으로 6단계 보안 그룹 구성 에서 유형을 다음과 같이 추가해준다\n<img width=1000 src=\"/assets/images/posts/devops/보안그룹구성.png\">  \n\n    - 소스를 위치 무관으로 해준다. \n        >어디서나 접속을 할 것이기 때문\n    - 유형에서 HTTP를 추가해준다.\n        >HTTP통신을 이용한 back-end 서버를 추가 할 것이기 떄문\n    - 사용자 지정 TCP 를 추가한후 포트 범위를 8080으로 설정한다.\n        >본인이 8080 포트에 서버를 열것이기 때문\n7. 검토 및 시작을 누른후 확인 후 시작하기를 누른다.\n8. 그후 키페어 선택창에서 키페어가 있으면 선택하고 없으면 만든다.  \n8-1. 키페어가 없는 경우 만들어서 로컬에다가 저장한다\n    >따로 폴더에 저장하는것을 권장한다. 이 키는 남에게 넘어가면 큰일난다.\n\n Maven 기반 Spring Boot 서버 간단하게 배포하기./simple-spring-boot-aws.md\n> 이 글은 간단한 협업과, test를 하려는 목적으로 작성된 글입니다.",
    "tags": [
      "aws",
      "TIL"
    ]
  },
  {
    "title": "Elastic Stack - Elasticsearch, Logstash, Kibana + Beats",
    "url": "/devops/2021/08/12/elastic-stack---elasticsearch-logstash-kibana-beat/",
    "category": "devops",
    "date": "2021-08-12",
    "excerpt": "> ELK &rarr; Elastic StackELK Stack",
    "content": "Elastic Stack - Elasticsearch, Logstash, Kibana + Beats\n\n> ELK &rarr; Elastic StackELK Stack\n\n ELK Stack의 시작\n1. Elastic StackELK Stack의 시작은 ELK로, Elasticsearch, Logstash, Kibana의 머리글자로 이루어진 프로젝트이다. \n2. 여기에 최근 경량의 단일 목적 데이터 수집기인 Beats가 추가되면서, Elastic StackELK Stack 으로 발전하게 되었다.\n\n ELK Stack 구성요소 한눈에 보기\n<img width=\"550px\" src=\"/assets/images/posts/devops/elk-stack.png\">\n\n- Elasticsearch: JSON 기반의 분산형 검색 및 분석 엔진으로 대규모의 데이터를 손쉽게 저장, 검색, 분석할 수 있다.\n- Logstash: 확장형 플러그인 에코시스템으로 구성된 동적 데이터 수집 파이프라인\n  > 다양한 소스에서 동시에 데이터를 수집하고 변환JSON 등...하여 자주 사용하는 Stash 보관소로 보냅니다.\n- Kibana: 확장형 사용자 인터페이스로 데이터를 구체적으로 시각화할 수 있다.\n  > 데이터를 시각적으로 탐색하고 실시간으로 분석 할 수 있다.\n- Beats: 단말 장치의 데이터를 전송하는 경량 데이터 수집기 플랫폼\n  > 다소 부피가 큰 Logstash의 기능을 세분화하여, 데이터를 수집하는 원격 서버에 에이전트로 설치하는 경량화된 데이터 수집기\n\n> 에이전트: 분산 환경에서 상호 협력을 통해 작업을 수행하는 컴퓨터 프로그램\n\n ELK Stack의 구성\n 1. Elastic search\n: JSON 기반의 분산형 RESTful 검색 및 분석 엔진이다.\n- Apache Lucene을 기반으로 한 분산형 오픈 소스 검색 및 분석 엔진이다\n- 다양한 서비스에 이용가능하다.\n  - 로깅과 로그, 보안, 비즈니스, 엔터프라이즈 분석\n  - 인프라 메트릭과 컨테이너 모니터링\n  - 웹, 앱 어플리케이션 검색\n  - 애플리케이션 성능 모니터링\n- 간단한 RESTful API, 분산형 특징, 빠른 속도, 높은 확장성\n- Elastic search의 가장 큰 장점은 실시간Real-time 분석 시스템이다.\n Elasticsearch의 데이터 분석 방법\n1. 클러스터가 실행되고 있는 동안 계속해서 데이터가 입력Indexing되고,\n2. 그와 동시에 실시간에 가까운 속도로 색인된 데이터의 검색과 집계가 가능하다.\n\n이게 가능한 이유는 다음과 같다  \n역인덱스Inverted file index 데이터 구조를 사용하여 풀 텍스트Full text 검색을 할 수 있도록 설계되었기 때문이다.\n\n> 역 인덱스: 키워드를 통해 문서를 찾아내는 방식  \n> 자료구조가 Key : Value인 Map의 예시로 들면 value를 통해 key를 찾는 것이라 할 수 있다.\n\n Elasticsearch의 역할\n- Logstash를 통해 수신된 데이터를 저장소에 저장하는 역할을 담당한다.\n- 데이터를 중심부에 저장하여 예상되는 항목을 검색하고 예상치 못한 항목을 밝혀낼 수 있다.\n\n 참고\n- Lucene이 JAVA로 만들어졌기 때문에 Elasticsearch 또한 JAVA로 개발되어 있다.\n\n 2. Logstash\n: 실시간 파이프라인 기능을 가진 오픈소스 데이터 수집 엔진이다.\n- 서로 다른 소스의 데이터를 탄력적으로 통합하고, 사용자가 선택한 목적지로 데이터를 정규화할 수 있다.\n- JRuby로 되어있으며, Ruby로 개발되어 JVM위에서 돌아간다.\n\n Logstash의 역할\n- Server-side 데이터 처리 파이프라인으로 다양한 소스에서 동시에 데이터를 수집하고 통합한다.\n- 또한, 집된 데이터를 정규화하여 Elasticsearch 등의 목적지로 전송하는 역할을 한다.\n- Elastic Stack에서는 가공된 데이터를 Elasticsearch로 전달한다.\n\n 동작 원리\n1. 다양한 유형의 데이터를 입력INPUTS, 필터FILTER, 출력OUTPUTS 파이프라인을 통해 원하는 형식으로 변환\n    > \"다양한 유형의 데이터\"의 예시는 다음과 같다. &rarr; 웹 로그, 애플리케이션 로그, HTTP 요청, 센서 정보 등...  \n     > \"원하는 형식으로 변환하는 데이터\"의 예시는 다음과 같다. &rarr; 확장, 변경, 필터링, 삭제 등의 처리를 통해 가공된 데이터\n2. 원하는 데이터 저장소Stash 보관소로 전달할 수 있다.\n\n 3. Kibana\n: Elasticsearch에 색인된 데이터를 검색하고 시각화하는 오픈소스 프론트엔드 서비스이다.\n- 기본적으로 Discover, Visualize, Dashboard 메뉴와 다양한 App으로 구성되어 있으며, 플러그인을 통해 확장 가능하다.\n\n> Discover: Elasticsearch에 색인된 소스 데이터들의 검색을 위한 메뉴이다.  \n> Dashboard:  Visualize메뉴에서 만들어진 시각화 도구수집된 차트, 그래프, 메트릭, 검색 및 지도 등들을 조합하여 단일 페이지에 모아 놓고 다양한 관점에서 데이터에 요약된 인사이트를 제공한다.\n\n Kibana의 역할 \n1. Elasticserach에서 색인된 데이터를 검색하여 보고, 시각화하며 여러 차트를 생성하여 데이터를 분석한다. \n2. 브라우저를 통해 대규모 데이터에 대한 실시간 분석 보기를 제공한다.\n3. 웹 인터페이스를 통해 Elastic Stack 인스턴스를 모니터링하고 관리하며 보호한다.\n4. 통합 가시성, 보안 및 엔터프라이즈 검색 애플리케이션을 위해 Elastic Stack에서 개발된 기본 제공 솔루션에 대한 집중화된 중앙 접근 기능을 제공한다.\n\n 4. Beats\n: Beats는 다소 부피가 큰 Logstash의 기능을 세분화하여,   \n데이터를 수집하는 원격 서버에 에이전트로 설치하는 경량화된 오픈소스 데이터 수집기이다.  \n<img width=\"600px\" src=\"/assets/images/posts/devops/elk-beats.png\">\n\n- Beats를 통해 수집된 데이터는 Logstash를 통하거나, 또는 Elastcisearch로 직접 보낼 수도 있다. \n- 각 용도에 따라 다양한 Bests를 선택해 사용할 수 있다.\n\n Beats의 제품군\n- Filebeat - Real-time insight into log data\n  > 로그와 파일을 경량화된 방식으로 전달하고 중앙 집중화하여 작업을 보다 간편하게 만들어 주는 역할을 한다.\n  > - Logstash사용 이유:  \n     로그 메시지를 별도의 필드로 구문 분석하고 원하지 않는 데이터 비트를 필터링하고 다른 데이터를 보강하여 로그 메시지에 컨텍스트를 추가하는 고급 로그 향상 기능은 Logstash없이는 처리할 수 없다.\n\n- Packetbeat - Analyze network packet data\n  > Packetbeat는 데이터에 실시간으로 접근하여 내용을 분석하면 네트워크 트래픽의 흐름이 어떤지 파악할 수 있다.\n- Winlogbeat - Analyze Windows event logs.\n  >  Winlogbeat를 이용해 Windows 이벤트 로그를 Elasticsearch와 Logstash로 스트리밍할 수 있다.\n- Metricbeat - Ship and analyze metrics.\n  > CPU부터 메모리, Redis, NGINX까지 Metricbeat를 통해 다양한 시스템 서비스 통계를 가볍게 전송할 수 있다.\n- Heartbeat - Ping your Infrastructure.\n  > Heartbeat를 통해 가동 시간과 반응 시간등 활성 상태를 탐지하고 서비스가 가능한지 모니터링한다.\n- Auditbeat - Send audit data to Elasticsearch.\n  > Auditbeat는 Linux 감사 프레임워크 데이터를 수집하고 수집한 데이터를 Elastic Stack에 실시간 전송한다.\n- Functionbeat - Ship cloud data with serverless infrastructure.\n  > 클라우드 서비스의 Function-as-a-Service FaaS 플랫폼에서 기능으로 배포하여 데이터를 수집, 전송, 모니터링한다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "CI/CD",
    "url": "/devops/2021/08/12/cicd/",
    "category": "devops",
    "date": "2021-08-12",
    "excerpt": "전통적인 배포 파이프라인 단계는 다음과 같다\n1. Version control : 일반적으로 코드를 가지고 일을 하는 소프트웨어 개발자들은 코드 변경사항을 커밋한다.\n2. Acceptance tests : 미리 컴파일/빌드된 코드에 대해 테스트 묶음을 실행한다.\n3. Independent Deployment : 독립 배포는 컴파일되고 테스트된 artifac...",
    "content": "CI/CD\n 배경\n전통적인 배포 파이프라인 단계는 다음과 같다\n1. Version control : 일반적으로 코드를 가지고 일을 하는 소프트웨어 개발자들은 코드 변경사항을 커밋한다.\n2. Acceptance tests : 미리 컴파일/빌드된 코드에 대해 테스트 묶음을 실행한다.\n3. Independent Deployment : 독립 배포는 컴파일되고 테스트된 artifact 개발환경에 배포한다. 개발환경은 이상적으로 프로덕트 환경과 아주 비슷해야 한다.\n4. Producton Deployment : 일반적으로 운영팀Operations이나 DevOps팀에 의해서 다루어진다. 이것을 Independent Deployment 프로세스와 매우유사해야 하고, production 서버에 코드를 배포한다.\n5. 이러한 기존 방식으로, 휴먼에러Human error가 발생할 수 있다. 결국 잘못된 배포로 인해 영향을 미칠 수 있다.\n\n- 소프트웨어가 거대 및 복잡해지고 분업과 협업의 과정에서 코드의 Merge 과정은 까다롭고, 테스트하는데 큰 자원을 소비하는 문제를 해결하기위해 도입하게되었다.\n- 개발 브랜치가 일정 기간 이상 이용되면, 통합의 어려움은, 충돌 해결에 들어가는 시간, 오류 발생 위험이 커진다. 이러한 단점을 극복하고자 변동 내용의 반영 빈도를 늘리는 자동화가 등장\n- 빌드와 기능성을 검증하는 새로운 방법을 확보하고 기능의 개발과 배치 속도를 큰 폭으로 개선하기 시작하였다.\n\n CI/CD 정의\n지속적 통합Continuous Intergration /  \n\n지속적 전달Continuous Delivery, 지속적 배포Continuous Deployment\n<img src=\"/assets/images/posts/devops/CI-CD-model.png\">\n\n: 애플리케이션 개발 단계를 자동화 하여 보다 짧은 주기로 고객에게 제공하는 방법\n- 지속적인 통합CI, 지속적인 서비스 제공CD, 지속적인 배포CD를 가능하게 한다.\n- 새로운 코드의 통합으로 인하여 개발 및 운영팀에 발생하는 문제를 해결하는 솔루션이다.\n\n CI 지속적 통합Continuous Integration\n: 여러 개발자가 작성하거나 수정한 소스를 지속적으로 통합하고 테스트하는 것\n- Build & Packaging\n- 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 공유 레포지토리에 병합되는것\n- Build, Test를 실시하는 프로세스를 말하며 이러한 통합 프로세스를 상시로 실시하는것\n- 다수의 개발자가 동시에 애플리케이션 개발과 관련된 코드 작업을 할경우, 서로 충돌할 수 있는 문제를 해결하기 위함\n- 언제나 최신 Build를 고객에게 바로 제공 가능하게 한다.\n\n CI 적용 흐름Jenkins\n1. 개발자는 자신이 개발한 소프트웨어의 소스코드를 공통된 버전 관리시스템github 등에 저장\n2. 소스코드상에 변동이 생기면 버전 관리 시스템에서 CI툴Jenkins로 소스코드 변경을 알림\n3. CI툴에서 변경된 소스코드를 대상으로 Build, Test, Merge를 진행  \n    >이 과정들이 완료되면 슬랙, 카카오톡, 메일 등을 통해 통합 결과 알림\n\n CDContinuous Delivery, Continuous Deployment\n: 개발, 통합, 배포, 릴리즈, 테스트를 자동화하여 지속적으로 배포하는 것\n\n Continuous Delivery지속적 전달\n: 프로덕션은 수동으로 배포한다.\n\n Continuous Deployment지속적 배포\n: 프로덕션까지 자동으로 배포한다.",
    "tags": [
      "aws",
      "TIL"
    ]
  },
  {
    "title": "간단한 Spring Boot AWS Server 배포",
    "url": "/devops/2021/08/12/간단한-spring-boot-aws-server-배포/",
    "category": "devops",
    "date": "2021-08-12",
    "excerpt": "> 이글은 EC2, AWS Linux, JAVA11, Maven, macOS 기준으로 설명할 글입니다.  \n> 그리고 간단한 협업, Test 를 위한 배포입니다.",
    "content": "간단한 Spring Boot AWS Server 배포\n> 이글은 EC2, AWS Linux, JAVA11, Maven, macOS 기준으로 설명할 글입니다.  \n> 그리고 간단한 협업, Test 를 위한 배포입니다.\n\n 자신의 MAC 에서 AWS instance연결하기\n1. 자신의 터미널에서 키페어가 있는 디렉토리로 이동 한다.\n2. 터미널에서 pair key의 권한을 변경\n    > key 이름은 ~.pem 형식으로 되어있다\n    sh\n    chmod 400 키이름.pem\n    \n    > 유저가 읽기만가능하다는 권환으로 변경\n3. 자신의 AWS instance 를 선택후 연결하기 를 누른다.\n4. 그후 SSH 클라이언트 텝에 있는 예 에 적어져있는 명령어를 터미널에 입력한다.\n    >필자의 key 이름은 ~~귀찮아서~~ asdfasef 로 했다.  \n    <img width=500 src=./img/SSH-Connect.png>\n\n5. 다음과 같이 뜨면 성공이다.  \n    <img width=500 src=./img/success.png>\n\n AWS Linux 가상환경에서 배포 환경 구축하기\n> 필자는 openJDK 11 버전을 사용할 것이다.\n1. Git 설치\n    bash\n    sudo yum install git\n    \n2. JAVA8 설치 및 JAVA 11 버전 적용open JDK  \n    > JAVA11을 적용시키기 위해 먼저 JAVA8을 설치한다.\n    JAVA8 install\n    bash\n    sudo yum install -y java-1.8.0-openjdk-devel.x86_64\n    sudo yum install java-11-amazon-corretto-headless\n    \n    JAVA11 로 바꾸기\n    bash\n    sudo alternatives --config java\n    \n    설치했던 java-11-amazon-corretto 버전을 선택한다.  \n    <img width=600 src=\"/assets/images/posts/devops/java-version-switch.png\">\n\n3. Apache Maven설치\n    bash\n    sudo wget http://repos.fedorapeople.org/repos/dchen/apache-maven/epel-apache-maven.repo -O /etc/yum.repos.d/epel-apache-maven.repo\n    sudo sed -i s/\\$releasever/6/g /etc/yum.repos.d/epel-apache-maven.repo\n    sudo yum install -y apache-maven\n    \n\n 배포\n1. 자신의 SpringBoot project 받아오기  \n    ex\n    bash\n    mkdir app\n    cd ./app\n    git clone https://github.com/siwony/SpringBoot-MembershipAPI.git\n    \n\n2. 쉘스크립트를 이용해 배포  \n    vim 에디터로 쉘스크립트 작성\n    bash\n    vim deploy.sh\n    \n    bash shell script\n    bash\n    !/bin/bash\n     maven 프로젝트 폴더로 옮기기\n    cd ./SpringBoot-MembershipAPI\n    \n     프로젝트의 변경사항이 없는지 확인\n    echo \"git pull\"\n    git pull\n    \n     프로젝트 컴파일\n    echo \"프로젝트 컴파일\"\n    mvn compile\n\n     프로젝트 test\n    echo \"프로젝트 테스트\"\n    mvn test\n\n     jar 파일로 packaging\n    echo \"mvn package\"\n    mvn package\n    \n\n 서버 시작\n1. 서버 실행\n    자신의 프로젝트 폴더의 target 으로 이동\n    bash\n    cd SpringBoot-MembershipAPI/target/\n    \n    mvn packge 명령어로 만든 jar 파일 실행\n    bash\n    java -jar 자신의jar파일\n    ex java -jar membershipApi-0.0.1-SNAPSHOT.jar\n    \n    If BackGround 에서 실행하고 싶다면 java -jar 앞에 nohub 을 붙이고 명령어 끝에 & 를 입력해야된다.\n    bash\n    nohup java -jar 자신의jar파일\n    exnohub java -jar membershipApi-0.0.1-SNAPSHOT.jar &\n    \n    로그 확인하기\n    bash\n    cat nohub.out\n    \n    curl 를 이용한 서버 동작여부 test\n    bash\n    curl localhost:8080",
    "tags": [
      "aws",
      "TIL"
    ]
  },
  {
    "title": "데몬(Daemon) 프로세스",
    "url": "/os/2021/08/10/데몬daemon-프로세스/",
    "category": "os",
    "date": "2021-08-10",
    "excerpt": ": 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로세스를 말한다.\n- Init 프로세스를 부모로 두고 있고, 제어하는 터미널이 없는 프로세스를 칭한다.\n  > 맥스웰이 언급한 보이지 않는곳에서 분자들을 골라주는 유령에서 영감을 받아 이런 이름이 만들어졌다고 한다.",
    "content": "데몬Daemon 프로세스\n: 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로세스를 말한다.\n- Init 프로세스를 부모로 두고 있고, 제어하는 터미널이 없는 프로세스를 칭한다.\n  > 맥스웰이 언급한 보이지 않는곳에서 분자들을 골라주는 유령에서 영감을 받아 이런 이름이 만들어졌다고 한다.\n\n  - fork후 부모는 바로 종료되며, fork된 자식은 Init의 자식으로 입양된다. &rarr; fork off and die\n\n 특징 \n- 일반적으로 데몬을 뜻하는 ‘d’를 이름 끝에 달고있고 프로세스 방식으로 실행된다.\n  > httpd, syslogd, ftpd\n- 네트워크, 하드웨어 요청에 응답하거나 프로그램에 반응하는 기능을 한다.\n  > 대부분 시스템 관련된 작업을 하는 경우가 많아 시스템이 가동될 때 같이 실행되기도 한다.\n- 종류에는 apache, ftpd, telnet 등등이 있다.\n--- \n 일반 Daemon\n- 백그라운드에서 작동한다.\n- 평소에 메모리에 상주하지만, CPU을 할당받지 않고 idle 상태 호출될 경우에만 작동한다.\n- 사용자가 직접 제어하지 않는다.\n\n Internet Super Daemon\n: 다른 데몬들을 관리하는 데몬이다.\n- 데몬들이 항상 메모리에 상주하는것은 자원 낭비이다.\n  > 필요할떄만 메모리에 적재 할 수 없을까? 이를 위해 Internet Super Daemon이 필요하다.\n- 슈퍼 데몬에 의해 관리되는 데몬들은, 필요한 경우에만 메모리에 적재 된다.\n\n 데몬의 두가지 실행모드\n> standalone, xinetd\n\n Stand alone\n: 독립적으로 실행되는 모드이다.\n- 항상 메모리에 상주한다. &rarr; 메모리 점유로 인한 부하가 있다.\n  > 부팅할때 자동적으로 같이 실행되는 데몬 등...\n- 요청이 있을때 언제나 응답이 가능하므로, 빠른 응답이 가능하다.\n- 슈퍼 데몬도 Standalone모드이다.\n- 대표적으로는 apache데몬, mysql데몬, sendmail데몬 이 있다.\n\n XintedeXtended Internet Service Daemon\n: 슈퍼 데몬에 의해서 관리되는 방식의 모드이다.\n- 평소에 메모리에 상주해있지 않는다. &rarr; 필요한 경우에만 메모리에 적재되어 자원 낭비를 줄인다.\n- 응답속도는 상대적으로 느리다.\n- 대표적으로는 Telnet 데몬, ftp 데몬, shell 데몬이 있다.\n  > 요청이 들어오면 대기하고 있던 슈퍼데몬이 Telnet데몬을 불러와 서비스를 제공한다.",
    "tags": [
      "Linux",
      "TIL"
    ]
  },
  {
    "title": "Hypervisor(하이퍼 바이저)",
    "url": "/os/2021/07/29/hypervisor하이퍼-바이저/",
    "category": "os",
    "date": "2021-07-29",
    "excerpt": ": 호스트 컴퓨터 1대에서 다수의 운영 체제OS를 동시해 실행하기 위한 논리적 플랫폼이다.\n- 하나 이상의 가상머신VM을 실행하는 컴퓨터가 호스트HOST 가 되고, 각 가상 머신들은 게스트Guest 가 된다.",
    "content": "Hypervisor하이퍼 바이저\n: 호스트 컴퓨터 1대에서 다수의 운영 체제OS를 동시해 실행하기 위한 논리적 플랫폼이다.\n- 하나 이상의 가상머신VM을 실행하는 컴퓨터가 호스트HOST 가 되고, 각 가상 머신들은 게스트Guest 가 된다.\n\n 특징\n- 여러 개의 OS가 단일 하드웨어 호스트를 공유할 수 있도록 한다.\n\n- 각 OS는 호스트의 프로세서, 메모리 및 기타 자원들을 모두 스스로 나타낸다.\n\n- Hypervisor는 모든 문리적 장치에 액세스할 수 있다.\n\n 자료 조사후 소감\n컨테이너형 가상화 기술이 요즘 트랜드이고 앞으로 쓰일거 같다 컨테이너형 가상화에 관련된 Docker, K8n등 점진적으로 다양한 것을 배워야겠다. :",
    "tags": [
      "Virtualization",
      "TIL"
    ]
  },
  {
    "title": "퀵 정렬",
    "url": "/algorithm/2021/06/23/퀵-정렬/",
    "category": "algorithm",
    "date": "2021-06-23",
    "excerpt": "-  에 기초한 알고리즘이다.\n  > 작은 문제들로 나눠서 해결한 뒤, 해결된 작은 문제들로 큰 문제를 해결한다.",
    "content": "퀵 정렬\n- 분할 정복Divide & Conquer 에 기초한 알고리즘이다.\n  > 작은 문제들로 나눠서 해결한 뒤, 해결된 작은 문제들로 큰 문제를 해결한다.\n\n- 피봇Pivot 이라는 기준점으로 덩어리를 나누는 것으로 분할을 수행한다.\n  > Pivot 값 선정에 따라 일부 속도가 달라질 수 있다.\n\n- in-place 정렬이다.\n  >추가적인 공간을 요구하지 않고 주어진 배열 안에서 정렬을 시도한다.\n\n- 불안정 정렬UnStable Sort 이다.  \n  > 중복된 값의 경우 입력순서 보장하지 않고 무작위로 뒤섞은 상태에서 정렬 하는것을 의미한다. 참고https://3.ly/a9PWw\n\n 정의\n퀵정렬은 정렬할 전체 원소에 대해서 정렬을 수행하지 않는다.  \n1. Pivot를 하나 선정한다.\n2. Pivot를 중심으로 전체 원소들을 왼쪽 부분집합과 오른쪽 부분집합으로 분할Divide 한다.\n3. 왼쪽 부분 집합에는 기준 값보다 작은 원소들을 이동시키고,  \n   오른쪽 부분 집합에는 기준 값보다 큰 원소들을 이동시킨다.\n4. 나누어진 두 개의 작은 리스트에 대해 재귀적으로 위의 과정을 반복합니다.ㅊ\n\n\n C언어를 이용한 퀵정렬의 구현 - 오름차순\n> 여기서는 Pivot를 정렬할 리스트의 시작점으로 설정하겠습니다.\nC\ninclude <stdio.h>\n\nvoid swapint arr,int a, int b{\n    int tmp = arra;\n    arra = arrb;\n    arrb = tmp;\n}\n\nvoid qsortint arr, int start, int end{\n\t//분할된 원소가 0개이거나 1개 일때까지 함수 호출 \n\tifstart >= end return;\n\t\n\tint pivot = start;\t\n\tint left = pivot+1;\n\tint right = end;\n\tint temp;\n\t\n\twhileleft<=right{// Left Right 교차하거나 같을때 종료\n\t\twhileleft<=end && arrleft <= arrpivot //피봇 보다 큰 값 만날 때 까지\n\t\t\t++left;\n\t\twhileright>start && arrright >= arrpivot //피봇 보다 작은 값 만날 때 까지\n\t\t\t--right;\n\t\t\n\t\t//위에서 계산된 left와 right가 만나거나 엇갈리면 종료\n\t\tifleft>=right break;\n\t\t\n\t\t//두 원소 교환 \n\t\tswaparr, left, right;\n\t}\n\t\n\t//피봇 정렬 완료 \n\tswaparr, right, pivot;\n\n\tqsortarr, start, right-1;\t//피봇 중심으로 왼쪽부분 분할\n\tqsortarr, right+1, end;\t//피봇 중심으로 오른쪽부분 분할\n}\n\nint main{\n\t\n\tint i;\n\t//1~10 무작위 배열\n\tint arr7 = {5, 3, 7, 6, 2, 1, 4};\n\t\n\t//배열, 0, 6\n\tqsortarr, 0, 6;\n\t\n\t//출력 \n\tfori = 0;i < 7;++i{\n\t\tprintf\"%d \", arri;\n\t}\n\t\n\treturn 0;\n}",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "container에서 root 권한 명령어 실행",
    "url": "/devops/2021/05/29/container에서-root-권한-명령어-실행/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": "docker container에서 curl를 통해 docker을 실행하려고 했지만 예상치 못한 에러가 나왔다.  ",
    "content": "container에서 root 권한 명령어 실행\ndocker container에서 curl를 통해 docker을 실행하려고 했지만 예상치 못한 에러가 나왔다.  \nsh\nList directory /var/lib/apt/lists/partial is missing. - Acquire 13: Permission denied\n\n\n 문제원인\n- docker container에 접속을 하면 sudo 같은 명령어를 지원을 하지 않는다.\n  sh\n  > sudo\n    bash: sudo: command not found\n  \n- Docker container에 접속을 하면 user권환으로 접속이 된다.\n\n 해결방법\n접속하기전에 root 권환을 줘서 접속하면 된다.\nsh\ndocker exec -itu 0 DOCKER-CONTAINER-ID /bin/bash",
    "tags": [
      "docker",
      "TIL"
    ]
  },
  {
    "title": "컨테이너, 이미지 삭제",
    "url": "/devops/2021/05/29/컨테이너-이미지-삭제-1/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": "강제 삭제",
    "content": "컨테이너, 이미지 삭제\n 컨테이너 삭제\nsh\ndocker rm {CONTAINER_ID}\n\n 만약 컨테이너가 실행중일경우\n강제 삭제\nsh\ndocker rm -f {CONTAINER_ID}  컨테이너가 실행중일경우 강제 종료후 삭제한다.\n\n종료 후 삭제\nsh\ndocker kill {CONTAINER_ID}  container를 종료한다.\ndocker rm {CONTAINER_ID}\n\n- docker kill {CONTAINER_ID} 는 docker stop {CONTAINER_ID}로 대체 가능하다.\n- docker kill {CONTAINER_ID} {CONTAINER_ID} 다음과같이 복수개를 종료 할 수 있다.  \n  삭제도 마찬가지다.\n\n 삭제된 컨테이너 확인\nsh\ndocker ps -a\n\n\n 이미지 삭제\nsh\ndocker rmi {IMAGE_ID}\n\n\n Docker container, image 모두삭제\n 모든 docker container 삭제\nsh\ndocker stop $docker ps -a -q\ndocker rm $docker ps -a -q\n\n\n 모든 docker image 삭제\nsh\ndocker rmi $docker images -q",
    "tags": [
      "docker",
      "TIL"
    ]
  },
  {
    "title": "컨테이너, 이미지 삭제",
    "url": "/devops/2021/05/29/컨테이너-이미지-삭제/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": "강제 삭제",
    "content": "컨테이너, 이미지 삭제\n 컨테이너 삭제\nsh\ndocker rm {CONTAINER_ID}\n\n 만약 컨테이너가 실행중일경우\n강제 삭제\nsh\ndocker rm -f {CONTAINER_ID}  컨테이너가 실행중일경우 강제 종료후 삭제한다.\n\n종료 후 삭제\nsh\ndocker kill {CONTAINER_ID}  container를 종료한다.\ndocker rm {CONTAINER_ID}\n\n- docker kill {CONTAINER_ID} 는 docker stop {CONTAINER_ID}로 대체 가능하다.\n- docker kill {CONTAINER_ID} {CONTAINER_ID} 다음과같이 복수개를 종료 할 수 있다.  \n  삭제도 마찬가지다.\n\n 삭제된 컨테이너 확인\nsh\ndocker ps -a\n\n\n 이미지 삭제\nsh\ndocker rmi {IMAGE_ID}\n\n\n Docker container, image 모두삭제\n 모든 docker container 삭제\nsh\ndocker stop $docker ps -a -q\ndocker rm $docker ps -a -q\n\n\n 모든 docker image 삭제\nsh\ndocker rmi $docker images -q",
    "tags": [
      "TIL",
      "docker"
    ]
  },
  {
    "title": "docker",
    "url": "/devops/2021/05/29/docker/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": ": Go 언어로 작성된 리눅스 컨테이너 기반으로 하는 오픈소스 가상화플랫폼 이다.\n> 현재 Docker 0.9버전 부터는 직접 개발한 libcontainer 컨테이너를 사용하고 있다.  ",
    "content": "docker\n: Go 언어로 작성된 리눅스 컨테이너 기반으로 하는 오픈소스 가상화플랫폼 이다.\n> 현재 Docker 0.9버전 부터는 직접 개발한 libcontainer 컨테이너를 사용하고 있다.  \n\n 가상화 사용이유?\n향상된 컴퓨터의 성능을 더욱 효율적으로 사용하기 위해!\n1. 서버 관리자 입장에서 cpu사용량이 10% 밖에 되지않는 활용도가 낮은 서버들의 리소스 낭비일 수밖에 없다.  \n2. 그렇지만 한서버에 여러 서비스를 올린다면 안정성에 문제가 생긴다. \n\n&nbsp;&rarr; 그래서 안정성을 높이며 리소스도 최대한 활용할 수 있는 방법으로 나타난것이 서버 가상화 이다\n\n대표적인 가상화 플랫폼으로는 VM 이 있다.\n\n 컨테이너?\n: OS레벨의 가상화로 프로세스를 격리시켜 동작하는 방식으로 이루어진다.\n> 컨테이너는 가상화 기술 중 하나로 대표적으로 LXCLinux Container가 있다.\n\n한 서버의 여러 OS를 가상화 하여 사용하는 것과 컨테이너 방식으로 프로세스를 격리시켜 동작하는 방법은 어떠한 차이점이 있을까?",
    "tags": [
      "docker",
      "TIL"
    ]
  },
  {
    "title": "jenkins install",
    "url": "/devops/2021/05/29/jenkins-install/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": "- java를 설치한다.  \n  ex. \n  > 8 버전을 추천한다",
    "content": "jenkins install\n ubuntu\n apt update\nsh\nsudo apt-get update && sudo apt-get upgrade\n\n 1. Java 설치 및 확인\nsh\nsudo apt-get install openjdk-{JAVA_VERSION}-jdk\n\n- java를 설치한다.  \n  ex. sudo apt-get install openjdk-11-jdk\n  > 8 버전을 추천한다\n\n Java 버전 확인\nsh\njava --version\n\n\n 2. Jenkins 설치 \n 1. jenkins 설치를 위한 repository 추가\nsh\nwget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -\n\n\n 2. 서버의 resource.list 에 Jenkins 저장소 추가 \nsh\nwget -q -O - https://pkg.jenkins.io/debian-stable/jenkins.io.key | sudo apt-key add -\n\n\n 3. 패키지 인덱스 정보 업데이트\nsh\nsudo apt-get update\n\n\n 4. jenkins 패키지 설치\nsh\nsudo apt-get install jenkins\n\n\n 5. jenkins 실행 및 종료\nsh\nsudo systemctl start jenkins  실행\nsudo systemctl stop jenkins   종료",
    "tags": [
      "jenkins",
      "TIL"
    ]
  },
  {
    "title": "Docker install",
    "url": "/devops/2021/05/29/docker-install/",
    "category": "devops",
    "date": "2021-05-29",
    "excerpt": "",
    "content": "Docker install\n ubuntu\n docker\nsh\nsudo apt install apt-transport-https ca-certificates curl software-properties-common\n\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\nsudo add-apt-repository \"deb arch=amd64 https://download.docker.com/linux/ubuntu bionic stable\"\n\nsudo apt update\n\napt-cache policy docker-ce\n\n\n docker-compose\n 설치\nsh\nsudo curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-uname -s-uname -m -o /usr/local/bin/docker-compose\n\n 권한설정\nsh\nsudo chmod +x /usr/local/bin/docker-compose",
    "tags": [
      "docker",
      "TIL"
    ]
  },
  {
    "title": "Git Cache 삭제",
    "url": "/git/2021/05/22/git-cache-삭제/",
    "category": "git",
    "date": "2021-05-22",
    "excerpt": "실수로 ignore하지 않은 파일을 커밋한 후 ignore를 해도 계속 파일이 추적되는 경우가 있다.\n.gitignore파일에 추가하기 전에 stage에 올라간 파일들이 cache처리되어 기록에 남아버리기 떄문이다.\n이러한경우 git 캐시삭제를 한 후 다시 push하면 해결된다.",
    "content": "Git Cache 삭제\n실수로 ignore하지 않은 파일을 커밋한 후 ignore를 해도 계속 파일이 추적되는 경우가 있다.\n.gitignore파일에 추가하기 전에 stage에 올라간 파일들이 cache처리되어 기록에 남아버리기 떄문이다.\n이러한경우 git 캐시삭제를 한 후 다시 push하면 해결된다.\n\n\n 코드\nbash\ngit rm -r --cached .  모든 캐시를 삭제한다.\ngit add .  모든 변경사항 staging\ngit commit -m \"원하는 commit msg\"",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "특정 port를 사용하고 있는 프로세스 종료",
    "url": "/os/2021/05/18/특정-port를-사용하고-있는-프로세스-종료/",
    "category": "os",
    "date": "2021-05-18",
    "excerpt": "> 한번씩 서버를 열어놓고 나중에 실수로 IDE를 닫아버려서 종료를 안했을때가 있다.  ",
    "content": "특정 port를 사용하고 있는 프로세스 종료\n> 한번씩 서버를 열어놓고 나중에 실수로 IDE를 닫아버려서 종료를 안했을때가 있다.  \n\n 예시\nbash\nlsof -i TCP:PORT // ex lsof -i TCP:8080\nkill -9 PID    // ex kill -9 18234\n\n> PORT : PORT 번호  \n> PID : lsof -i TCP:PORT를 통해 구한 PID\n1. PORT번호로 실행중인 프로세스의 PID를 구한다.\n2. 위에서 PID를 통해 프로세스를 강제종료한다.\n\n 참고\n- KILL 명령어 옵션https://bigsun84.tistory.com/355",
    "tags": [
      "Linux",
      "TIL"
    ]
  },
  {
    "title": "Git 저장되지 않은 모든 변경 사항 취소 및 삭제",
    "url": "/git/2021/05/16/git-저장되지-않은-모든-변경-사항-취소-및-삭제/",
    "category": "git",
    "date": "2021-05-16",
    "excerpt": "git을 사용할때 커밋되지 않았거나 저장되지 않은 변경 사항을 삭제하고 싶을떄가 있다.\n이 떄 로컬에서 삭제하고 싶었다.",
    "content": "Git 저장되지 않은 모든 변경 사항 취소 및 삭제\ngit을 사용할때 커밋되지 않았거나 저장되지 않은 변경 사항을 삭제하고 싶을떄가 있다.\n이 떄 로컬에서 삭제하고 싶었다.\n\nbash\ngit reset  모든 staged 파일이 unstage된다.\ngit checkout .   모든 변경 사항을 취소한다.\ngit clean -fdx   추척 할 수 없는 모든 파일 제거 추적된 파일만 남는다.\n\n-x 옵션은 무시ignore 된 파일도 모두 제거한다.\n\n 신중하게 알잘딱하게 하자",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "협력하는 객체들의 공동체",
    "url": "/book/2021/04/24/협력하는-객체들의-공동체/",
    "category": "book",
    "date": "2021-04-24",
    "excerpt": ">시너지를 생각하라. 전체는 부분의 합보다 크다. - 스티븐 코비Stephen R. Covey",
    "content": "협력하는 객체들의 공동체\n>시너지를 생각하라. 전체는 부분의 합보다 크다. - 스티븐 코비Stephen R. Covey\n\n Intro\n\n 객체지향 프로그래밍?\n객체지향을 처음 접하면 다음과 같은 설명을 마주하게 된다.\n> 객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임\n\n 객체지향 프로그래밍이란..\n1. 현실속에 존재하는 사물을 최대한 유사하게 모방하여 소프트웨어 내부로 옮겨오는 작업이다.\n2. 그 결과물인 객체지향 소프트웨어는 실세계의 투영이며,  \n3. 객체란 현실 세계에 존재하는 사물에 대한 추상화 라는것이다.\n\n이와같은 설명은 객체지향 프로그래밍의 철학적인 개념을 설명하는데 적합하다.\n\n 하지만..\n- 유연하고 실용적인 관점에서 객체지향 분석, 설계를 설명하는데 적합하지 않다.  \n- 에초에 개발하면서 객체에 직접적으로 대응하는 현실의 객체를 발견확률이 낮다.\n  >발견하더라도 일반적으로 객체와 사물 간의 개념적 거리는 유사성을 찾기 어렵다.  \n  >심지어 소프트웨어가 반영해야 하는 객관적인 실세계가 존재한다는 아이디어 조차 논란의 여지가 있다.\n\n 객체지향의 목표\n: 실세계를 모방하는것이 아닌 새로운 세계를 창조하는것이다.\n> 네트워크 방화벽이 건물과 연관될 필요가 있는가?\n\n 소프트웨어 개발자의 역활\n1. 단순히 실세계를 소프트웨어 안으로 옮겨담는것이 아니다.\n2. 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는것이다.\n\n 그럼 비현실적인데 왜 실세계에 빗대어 비유를 할까?\n객체지향의 다양한 측면을 이해하고 학습하는데 매우 효과적이기 떄문이다.\n\n객체를 스스로 생각하고 스스로 결정하는 현실 세계의 생명체에 비유하는것은  \n>상태와 행위를 '캡슐화encapsulation'하는 소프트웨어 객체의 '자율성autonomous'을 설명하는데 효과적이다.\n\n사람들이 암묵적인 약속과 명시적인 계약을 기반으로 서로 협력하여 목표를 달성해 나아가는 과정은\n> '메시지message'를 주고받으며 공동의 목표를 달성하기 위해 '협력collaboration' 하는 객체들의 관계를 설명하는데 적합하다.\n\n실세계의 사물을 기반으로 소프트웨어 객체를 식별하고 구현까지 이어간다는 개념은\n> 객체지향 설계의 핵심 사상인 '연결완전성seamlessness'을 설명하는 데 적합한 틀을 제공한다.\n\n 앞으로 이책은 실세계 모방이라는 개념을 통해 객체지향의 다양한 개념을 설명할 것이다.\n\n 01. 협력하는 사람들\n 커피 공화국의 아침\n1. 손님은 커피를 주문하고\n2. 캐시어는 주문을 받고\n3. 바리스타는 커피를 제조한다.\n4. 바리스타의 제조가 끝난 커피는 다시 캐시어에 전달되고\n5. 손님에게 커피가 준비됐다는 소식을 알린다.\n\n이와같이 커피 한잔을 주문하는 이 작은 이벤트를 완성하려면 여러 사람의 조율과 조화가 필요하다.  \n모든 음료 주문은 \n1. 손님이 커피를 주문하고\n2. 캐시어가 주문을 받고\n3. 바리스타가 커피를 제조하는 과정을 거친후 완료된다\n\n결국 커피를 주문하고 제조하는 과정은 역활, 책임, 협력이라는 세 가지 개념이 조화를 이루며 만들어 낸것이다.  \n\n 카페를 통한 역활, 책임, 협력\n따뜻한 커피와 함께할 수 있는 소박한 아침 시간의 여유를 누릴 수 있는 이유는 \n- 커피를 주문하는 손님\n- 주문을 받는 캐시어\n- 커피를 제조하는 바리스타\n\n와 같은 역활이 존재하기 때문에 가능하다.\n\n 손님, 캐시어, 바리스타는 주문한 커피를 손님에게 제공하기 위해 협력하는 과정에서 자신이 맡은 바 책임을 다한다.\n\n1. 손님은 카페인을 채우기 위해 커피를 주문할 책임을 수행한다.\n2. 캐시어는 손님의 주문을 받는 책임을 수행한다.\n3. 바리스타는 주문된 커피를 제공하는 책임을 수행한다.\n4. 마지막으로 손님은 커피를 캐시어로부터 받아 카페인을 체운다\n\n이러한 과정으로 커피주문 이라는 협력관계는 끝이났다.\n\n역활, 책임, 협력은 우리가 삶을 영위하기 위해 다른 사람과 접촉하는 모든곳에 존재 한다.\n\n결국 객체지향에서 가장중한 것은 역활, 책임, 협력이다.\n\n 요청과 응답으로 구성된 협력\n> 사람들은 스스로 해결하지 못하는 문제와 마주치면 문제 해결에 필요한 지식을 알고 있거나  \n> 서비스를 제공해줄 수 있는 사람에게 도움을 요청request 한다.\n\n- 일반적으로 하나의 문제를 해결하기 위해 다수의 사람 혹은 역활이 필요하다\n- 한사람의 요청이 또 다른 사람에게 대한 요청을 유발하는 것이 일반적이다.  \n- 즉 요청은 연쇄적으로 발생한다.\n\n 커피 주문을 위해 협력하는 사람들\n<img width=450px src=\"/assets/images/posts/book/relationship-1.png\">\n\n- 커피 주문이라는 협력은 손님이 캐시어에게 원하는 커피를 주문하면서 시작된다.  \n  &rarr; 손님이 캐시어에게 주문하는 것은 커피를 재공해 줄 것을 캐시어에게 요청하는 것이다.\n\n- 주문을 받은 캐시어는 주문 내역이 기록된 컵을 전달함으로써 바리스타에게 주문된 커피를 제조해줄 것을 요청한다.\n\n요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스를 제공한다.  \n&rarr; 다른 사람의 요청에 응답response 한다.  \n\n응답 역시 요청의 방향과 반대 방향으로 연쇄적으로 전달된다.\n\n<img width=450px src=\"/assets/images/posts/book/relationship-2.png\">\n\n- 바리스타는 커피를 제조한 후 제조가 완료됐음을 캐시어에게 알려 주는 것으로 캐시어의 요청에 응답한다.\n\n- 캐시어는 진동벨을 울려 손님에게 주문된 커피가 준비됐음을 알림으로써 손님의 주문에 응답한다.\n\n요청과 응답을 통해 다른 사람과 협력collaboration 할 수 있는능력은  \n&rarr; 거대하고 복잡한 문제를 해결할 수 있는 공동체를 형성할 수 있게 만든다.\n\n협력의 성공은 특정한 역활을 맡은 각 개인이 얼마나 요청을 성실히 이행하는가에 달려있다.\n\n 역활과 책임\n\n역활: 어떤 협려에 참여하는 특정한 사람이 협력 안에서 차지하는 책임이나 의무  \n>사람들은 다른 사람과 협력하는 과정 속에서 특정한 역활role 을 부여받는다.  \n- 어떤 사람이 손님이라는 역활을 맡으면 그 사람은 커피를 주문해야 하는 임무가있다.\n- 캐시터라는 역활을 맡은 사람은 손님의로부터 주문을 받아야 하는 책임이 있다.\n\n책임 \n \n역활이라는 단어는 의미적으로 책임Responsibility 이라는 개념을 내포한다.\n> 범죄자를 검거할 책임을 거부하는 사람에게 경찰관이라는 역활을 부여하겠는가?\n\n- 역활은 특정한 책임을 암시한다.\n- 협력에 참여하며 특정한 역활을 수행하는 사람들은 역활에 적합한 책임을 수행하게된다.\n\n역활과 책임은 협력이 원활하게 진행되는 데 필요한 핵심적인 구성 요소다.\n\n- 여러 사람이 동일한 역활활을 수행할 수 있다.  \n  > 손님 입장에서 자신이 어떤 캐시어가 주문을 받는지 중요하지 않다.  \n  즉 역활에 대한 책임을 수행할 수 있으면 캐시어가 누가 주문을 받든 중요하지 않다.\n- 역활은 대체 가능성을 의미한다.\n  > 손님 입장에서 캐시어는 대체 가능substitutalbe 하다.  \n  두 명이 동일한 역활을 수행할 수 있다면 요청자 입장에서 둘 중 어떤 역활을 수행하더라도 문제가 되지 않는다.\n- 책임을 수행하는 방법은 자율적으로 선택 할 수 있다.\n  > 동일한 요청을 받더라도 바리스타의 역활을 수행하는 사람들마다 서로 다른 방식으로 요청을 처리 할 수 있다.  \n  이처럼 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 다형성polymorphism 이라고 한다.\n- 한 사람이 동시에 여러 역활을 수행할 수 있다.\n  > 한사람이 캐시어와 바리스타라는 개별적인 역활을 동시에 수행하는 것도 가능하다.  \n  즉, 한사람이 동시에 둘 이상의 역활을 수행하는 것도 가능하다.\n\n 역활, 책임, 협력\n 기능을 구현하기 위해 협력하는 객체들\n지금까지 설명한 실세계의 커피를 주문하는 과정은 객체지향의 핵심적이고 중요한 개념을 거의 대부분 포함하고 있다.\n- 사람이라는 단어를 객체로\n- 에이전트의 요청을 메시지로\n- 에이전트가 요청을 처리하는 방법을 메서드로\n\n&rarr; 위와 같이 많은 사람들이 객체지향을 설명하기위해 실세계 모방이라는 은유를 차용하는 이유이다.\n\n 역활과 책임을 수행하며 협력하는 객체들\n> \"인간은 사회적 동물이다.\" - 아리스토텔레스  \n> 인간적인 삶이란 떄로는 협력하고 때로는 반목하면서 타인과 부대끼며 살아가는 삶이다.\n\n 협력의 핵심\n1. 특정한 책임을 수행하는 역활들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다는 것이다.  \n   > 사람들은 커피 주문과 같은 특정한 목표를 이루기 위해 서로 협력한다.\n2. 일상생활에서 목표는 사람들의 협력을 통해 달성하며\n3. 목표는 더 작은 책임으로 분활되고 책임을 수행할 수 있는 적절한 역활을 가진 사람에 의해 수행된다.\n4. 협력에 참여하는 각 개인은 책임을 수행하기 위해 다른 사람에게 도움을 요청하기도 한다.\n\n이를 통해 연쇄적인 요청과 응답으로 구성되는 협력 관계가 완성된다.\n\n 객체의 세계\n> \"어떤 객체도 섬이 아니다\" - Beck 1989  \n- 사용자가 최종적으로 인식하게 되는 시스템의 기능은 객체들이 성실히 협력해서 일궈낸 결실이다.\n- 사람들은 공통의 목표를 달성하기 위해 협력하지만  \n 객체는 애플리케이션의 기능을 구현하기 위해 협력한다.\n- 시스템은 역활과 책임을 수행하는 객체로 분활된다.\n- 그리고 기능을 객체간의 연쇄적인 요청/응답의 흐름으로 구성된 협력으로 구현된다.\n\n 객체지향의 역활\n> 객체지향 설계는 객체에게 적절한 책임을 할당하는것에서 시작된다.  \n> 책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다.\n\n역활은 관련성 높은 책임의 집합이다. 객체의 역활은 사람의 역활과 유사하게 다음과 같은 특징을 가진다.\n- 여러 객체가 동일한 역활을 수행할 수 있다.\n- 역활은 대체 가능성을 의미한다.\n- 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.\n- 하나의 객체가 동시에 여러 역활을 수행할 수 있다.\n\n 협력 속에 사는 객체\n> 객체지향 애플리케이션의 윤곽을 결정하는 것은 역활, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체다.  \n\n애플리케이션의 내부에서는 쉴 새 없이 메시지를 주고받으며 협력하는 객체가 존재한다.\n\n 객체는..\n- 애플리케이션의 기능을 구현하기 위해 존재한다.\n- 아주 작은 기능조차 객체 혼자 감당기에는 복잡하고 거대하기 때문에  \n일반적으로 객체는 다른객체와 협력을 통해 기능을 구현하게 된다.\n- 협력의 품질을 결정하는 것은 객체의 품질이다.\n\n 1. 객체는 충분히 '협력적'이여야 한다.\n- 다른 객체의 요청에 충실하고 다른 객체에게 적극적인 도움을 요청할 수 있어야 한다.\n- 외부의 도움을 무시한 채 모든것을 스스로 처리하려고 하는 전지전능한 객체god object 는 내부적인 복잡도에 의해 자멸하고 만다.\n- 객체는 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다.\n- 어떤 방식으로 응답할지는 객체 스스로 판단하고 결정한다.\n- 요청에 응할지 여부도 객체 스스로 결정할 수 있다.\n\n   \n 2. 객체가 충분히 '자율적'이어야 한다.\n위에 사실로 부터 객체가 갖춰야 하는 두 번째 덕목을 알 수 있다.\n> 자율적: 자기 스스로의 원칙에 따라 어떤일을 하거나 자기 스스로를 통제하여 절제하는것\n\n\n객체의 사회도 인간의 사회와 유사하다.  \n객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로 의 결정 과 판단에 따라 행동하는 자율적이 존재이다.\n\n 상태와 행동을 함께 지닌 자율적인 객체\n흔히 객체를 상태state와 행동behavior을 함께 지닌 실체라고 정의한다.  \n이는 객체가 협력에 참여하기 위해 어떤 행동behavior을 해야 한다면 그 행동을 하는데 필요한 상태state도 함께 지니고 있어야한다.\n\n객체가 협력에 참여하는 과정속에서 자율적인 존재로 남기 위해서 필요한 행동과 상태를 함께 지니고 있어야 한다.\n\n 객체의 자율성\n> 객체의 자율성은 객체 내부와 외부를 명확하게 구분하는 것으로부터 나온다.  \n> 커피를 주문하는 협력 과정에 참여한 손님과 캐시어, 바리스타는 외부의 간섭을 받지않고 스스로 판단하고 자율적인 존재였다.\n- 객체는 행동을 위해 필요한 상태를 포함하는 동시에 특정한 행동을 수행하는 방법을 스스로 결정할 수 있어야 한다.,\n- 객체의 사적인 부분은 객체 스스로 관리하고 외부에서 일체 간섭할 수 없도록 차단해야한다.\n- 객체의 외부에서 접근이 허락된 수단을 통해서만 객체와 의사소통해야 한다.\n- 객체는 다른객체가 '무엇how'을 수행하는지 알 수 있지만, 어떻게how 수행하는지에 대해서 알 수 없다.\n\n 전통적인 개발방법과 객체지향\n> 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축 할 수 있는 가능성을 제시한다.\n\n- 과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다.  \n- 객체지향에서 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어 놓음으로써 객체의 자율성을 보장한다.",
    "tags": [
      "TIL",
      "object-orientation-facts-and-misconceptions"
    ]
  },
  {
    "title": "Agile(애자일)",
    "url": "/etc/2021/04/03/agile애자일/",
    "category": "etc",
    "date": "2021-04-03",
    "excerpt": ": 소프트웨어 개발 방법에 있어서 아무런 계획이 없는 개발 방법과 계획이 지나치게 많은 개발 방법들 사이에서 타협점을 찾고자 하는 방법론이다.\n> 지나치게 계획에 의존하고 있으며 형식적인 절차를 따르기 때문에 시간도 오래걸리고 그 효율성이 크게 저하된다는 단점이 있다.",
    "content": "Agile애자일\n: 소프트웨어 개발 방법에 있어서 아무런 계획이 없는 개발 방법과 계획이 지나치게 많은 개발 방법들 사이에서 타협점을 찾고자 하는 방법론이다.\n> 지나치게 계획에 의존하고 있으며 형식적인 절차를 따르기 때문에 시간도 오래걸리고 그 효율성이 크게 저하된다는 단점이 있다.\n\nagile : 1. 날렵한, 민첩한 2. 생각이 재빠른, 기민한\n- 짧은주기의 개발단위를 반복하여 하나의 큰 프로젝트를 완성해 나가는 방식\n- 핵심 : 협력과 피드백\n- 방법론이 아니다.  \n  >스크럽 등이 방법론에 속한다.\n\n 주의 \"애자일 방법론\"?\n> \"애자일 방법론\" 이라는 문구는 애자일이 독특한 소프트웨어 개발 방식임을 나타내기 때문에 오해의 여지가 있다.\n\n 애자일 개발 선언\n우리는 소프트웨어를 개발하고, 또 다른 사람의 개발을 도와주면서  \n소프트웨어 개발의 더 나은 방법을 찾아가고있다.  \n이 작업을 통해 우리는 다음을 가치 있게 여기게 되었다.  \n- 공정과 도구보다 개인의 상호작용을\n- 포괄적인 문서보다 작동하는 소프트웨어를\n- 계약 협상보다 고객과의 협력을\n- 계획을 따르기보다 변화에 대응하기를\n\n가치 있게 여긴다. 이말은, 왼쪽에 있는 것들도 가치가 있지만,  \n우리는 오른쪽에 있는 것들에 더 높은 가치를 둔다는 것이다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Ds_store gitignore",
    "url": "/git/2021/03/28/ds_store-gitignore/",
    "category": "git",
    "date": "2021-03-28",
    "excerpt": "> MacOs 에서 개발을 할 때 거슬리는 것은 mac의 cache file인 Dsstore가 프로젝트 폴더에 생기는 것이다.  \n> 실제로 본인은 협업 프로젝트에서 .Dsstore를 엄청 올려버렸다.. exjubjubhttps://github.com/GSM-Web-Technology/Jup-Jup-Server  \n> 이러한 상황을 미리 방지 + 앞으로 써...",
    "content": "Ds_store gitignore\n> MacOs 에서 개발을 할 때 거슬리는 것은 mac의 cache file인 Ds_store가 프로젝트 폴더에 생기는 것이다.  \n> 실제로 본인은 협업 프로젝트에서 .Ds_store를 엄청 올려버렸다.. exjubjubhttps://github.com/GSM-Web-Technology/Jup-Jup-Server  \n> 이러한 상황을 미리 방지 + 앞으로 써먹기 위해 이 md를 작성한다.\n\n다음과 같이 작성하면된다.  \n.gitignore\n\n Ds_Store ignore \n\n.DS_Store\n._.DS_Store\n/.DS_Store\n/._.DS_Store",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Payload(페이로드)",
    "url": "/back-end/2021/03/11/payload페이로드/",
    "category": "back-end",
    "date": "2021-03-11",
    "excerpt": "데이터를 전송할때, 헤더와 메타데이터, 에러 체크 비트 등과 같은 다양한 요소들을 함께 보내어 데이터 전송의 효율과 안정성을 높이게 된다.  \n이 때, 보내고자 하는 data라는 단어는 운송업에서 비롯하였는데, 지급pay해야 하는 적화물load을 의미한다.  ",
    "content": "Payload페이로드\n데이터를 전송할때, 헤더와 메타데이터, 에러 체크 비트 등과 같은 다양한 요소들을 함께 보내어 데이터 전송의 효율과 안정성을 높이게 된다.  \n이 때, 보내고자 하는 데이터 자체를 의미하는 것을 바로 payload이다.\n- \n\n 예시\njson으로 보는 실제 데이터에서 payload는 아래의 json 에서 data이다.  \n그 이외의 데이터들은 전부 통신을 하는데 있어 용이하게 해주는 부가적인 정보들이다.\njson\n{\n\t\"status\" : 200,\n\t\"from\": \"localhost\",\n\t\"to\": \"http://melonicedlatte.com/chatroom/1\",\n\t\"method\": \"GET\",\n\t\"data\":{ \"message\" : \"There is a cutty dog!\" }\n}\n\n- data는 client가 관심을 가지는 페이로드 이다.\n- 나머지 부분은, 중요하긴 하지만, 프로토콜 오버헤드이다.\n\n 번외  Payload 기원\n페이로드payload라는 단어는 운송업에서 비롯하였는데, 지급pay해야 하는 적화물load을 의미한다.  \n\n유조선 트럭이 20톤의 기름을 운반한다면 트럭의 총 무게는 차체, 운전자 등의 무게 때문에 그것보다 더 될 것이다.  \n이 모든 무게를 운송하는데 비용이 들지만, 고객은 오직 기름의 무게만을 지급pay하게 된다.  \n그래서 ‘pay-load’란 말이 나온 것이다",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "DevOps(Development + Operations)",
    "url": "/devops/2021/02/06/devopsdevelopment-operations/",
    "category": "devops",
    "date": "2021-02-06",
    "excerpt": ": SW 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화, 방식 및 도구의 조합\n> 개발자 는 계속해서 새로운것을 도입하고 싶어하지만, Ops 들은 안정성을 최우선으로 여긴다.  \n>그래서 등장한것이 DevOps이다  ",
    "content": "DevOpsDevelopment + Operations\n: SW 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화, 방식 및 도구의 조합\n> 개발자 는 계속해서 새로운것을 도입하고 싶어하지만, Ops 들은 안정성을 최우선으로 여긴다.  \n>그래서 등장한것이 DevOps이다  \n\n소프트웨어 개발 방법론 중에 하나이다.\n\n 목적\n- 제품 출시까지 걸리는 시간time to market단축\n- 새로운 판의 더 낮은 실패율\n- 픽스 간 짧아진 리드 타임상품 생산 시작부터 완성까지 걸리는 시간\n- 복구 시 더 빠른 평균 시간새로운 릴리스의 충돌 등..\n\n 특징\n Cross Functional Team\n: 각 프로세스의 개발 ~ 배포 및 테스트 담당자들을 하나의 팀으로 모으는것\n> 개발 프로세스를 하나의 팀에서 할 수 있도록 해야 한다는것\n Widely Shared Metrics\n: 팀원 모두가 알고있는 하나의 공유된 지표가 필요하다는것\n> 서비스 개발 뿐만아니라 서비스가 운영에서 잘 돌아가고 있는지, 사용자의 반응은 어떤지를 측정할 수 있는 기준이 필요하다는것\n Post Mortems\n: 장애나 이슈가 있을때 혼자만 알지 말고 팀원들과 공유해아하는것\n Regular Release\n: 짧은 주기의 정기 배포를 통해 빠르게 서비스의 기능을 개선하고 고객들의 VoC를 반영해 나가는것\n\n 이점\n- 속도\n- 신속한 제공\n- 안정성\n- 확장\n- 협력 강화\n- 보안\n\n Dev Ops 방식\n- 지속적 통합CI\n- 지속적 제공CD\n- 마이크로 서비스\n- 코드형 인프라\n- 모니터링 및 로깅\n- 커뮤니케이션 및 협업",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Component",
    "url": "/etc/2020/12/25/component/",
    "category": "etc",
    "date": "2020-12-25",
    "excerpt": "소프트웨어는 독집적으로 개발하지 않고, 독립적으로 개발하여도 다른 모듈과의 호환을 생각하지 않고 개발하여  \n결국 소프트웨어의 재사용을 어렵게 하고 유지보수 비용이 크게 증가하는 원인이 된다.  \n이러한 상황에서 소프트웨어의 재사용의 중요성을 위해 나온 기술이 컴포넌트component기술이다.",
    "content": "Component\n Component 개념 유래\n소프트웨어는 독집적으로 개발하지 않고, 독립적으로 개발하여도 다른 모듈과의 호환을 생각하지 않고 개발하여  \n결국 소프트웨어의 재사용을 어렵게 하고 유지보수 비용이 크게 증가하는 원인이 된다.  \n이러한 상황에서 소프트웨어의 재사용의 중요성을 위해 나온 기술이 컴포넌트component기술이다.\n\n 컴포넌트는 재사용이 가능한 최소 단위\n- 하드웨어처럼 독립적인 기능을 수행하고 추후에 교환될 수 있도록 해야한다.  \n- 컴포넌트의 세부사항은 겉으로 드러나선 안되는것 일부러 끄집어 내려는 시도조차 하지 말아야 한다.  \n- 필요한것은 단지 해당 컴포넌트를 쓰기 위해 제공해주는 일종의 '장치method'가 필요하다.  \n    >예를들어서, 스마트폰의 배터리 수명이 다했을 경우 배터리를 새로 구입하여,  \n    >스마트폰에서 배터리만 교체했을 것이다.  \n    >이때 스마트폰 단자와 밧데리 단자가 맞물려야 제 기능을 발휘하는데 이때 배터리 단자가 앞서 말했던 일종의 '장치'가 된다.  \n\n 객체지향 언어에서의 컴포넌트\n>객체지향 언어에서는 이러한 장치를 인터페이스interface로 제공해준다.  \n\n 인터페이스interface\n- 사용자에게 해당 소프트웨어를 쓰기위한 메서드method를 공개\n- 규격화된 메서드 환경에서 소프트웨어를 개발할 수 있는 환경을 제공해준다.\n\n 소프트웨어의 세부내용은 인터페이스를 구현받은 클래스가 작성한다.\n > 이러하여 객체지향 개념은 정보은닉개념을 수행할 수 있을 뿐더러, 각각 독립된 모듈로 소프트웨어를 만들수 있게 된다.  \n\n 결론\n컴포넌트는 재사용이 가능한 최소 단위를 뜻하며, OOP 언어등의 class등의 개념과는 다르다.  \n하나의 컴포넌트는 하나의 클래스로만 작성될 수도 있지만, 여러 개의 클래스로도 작성될 수 있기 때문이다.",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "개발 용어 정리",
    "url": "/etc/2020/12/23/개발-용어-정리/",
    "category": "etc",
    "date": "2020-12-23",
    "excerpt": "개발하면서 모르는용어를 정리하는 곳입니다.",
    "content": "개발 용어 정리\n개발하면서 모르는용어를 정리하는 곳입니다.\n\n none category\n- PoCProof of Concept : 개념증명 이라는 뜻으로 기존 시장에 없었던 신기술 및 개념을 도입하기 전에 이를 검증하기 위해 사용하는 것\n\n- 마이그레이션 migration : IT에서 마이그레이션이란 어떤 하드웨어나, 소프트웨어 또는 둘 모두가 바뀌는 환경으로 옮겨가는 것을 말한다\n- 파이프라인pipeline : 한 데이터 처리단계의 출력이 다른 단계의 입력으로 이어지는 형태로 연결된 구조를 가르킴\n- Dead Lock데드락 : '교착 상태' \n    >한정된 자원을 여러 곳에서 사용하려고 할때 발생 참고https://includestdio.tistory.com/12\n- Learning Curves러닝 커브 : 학습곡선\n    >무엇인가를 습득하는 데 드는 시간학습 비용을 말한다.  \n    >새로운 기술을 배울 때 처음에는 더디다가 어느 지점을 지나면 배움에 가속도가 붙고, 다시 더뎌지는 것을 곡선으로 표현한 것  \n    >러닝 커브는 개개인마다도 다르지만, 프로그래밍 언어별로도 다르다.\n\n web, network\n- expires : 만료\n- Load Balancing: 네트워크 또는 서버에 가해지는 부하=Load 를 분산=Balancing 해주는 기술\n- payload패이로드: 전송되는 데이터를 의미\n- backbone\n  - 개인에게 연결된 소형 회선들로부터 데이터를 모아 빠르게 전송할 수 있는 대규모 전송 회선\n  - 지역적으로는 근거리 통신망에서 광역 통신망으로 연결하기 위한 하나의 회선이나 여러 회선의 모음\n\n Srping JPA\n- Persistence Context영속성 컨텍스트 : 엔티티를 영구히 저장하는 환경\n    - Persistence영속성: 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성을 의미\n        >영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 됨\n    - Context컨텍스트 : 여기서는 '환경' 이라는 뜻을 가지고 있다.\n    \n String cecurity\n- 접근 주체Principal : 보호된 대상에 접근하는 유저\n- 인증Authenticate : 현재 유저가 누구인지 확인ex. 로그인\n    >애플리케이션의 작업을 수행할 수 있는 주체임을 증명\n- 인가Authenticate : 현재 유저가 어떤 서비스, 페이지에 접근할 수 있는 권환이 있는지 검사\n- 권한 : 인증된 주체가 애플리케이션의 동작을 수행할 수 있도록 허락되었는지 결정\n    - 권한 승인이 필요한 부분으로 접근하려면 인증 과정을 통해 주체가 증명 되어야만 한다.\n    - 권한 부여에도 두가지 영역이 존재하는데 웹 요청 권한, 메소드 호출 및 도메인 인스턴스에 대한 접근 권한 부여\n\n DevOps\n- release : 같은 제품을 새롭게 만드는것\n    - 디버그에 대한 정보x, q코드 최적화\n    - 순수한 코드 자체의 기능만 담긴 파일\n    >ex 제품에서 새로운 버전을 release함\n- deploy : 프로그램 등을 서버와 같은 기기에 설치하여 작동가능하도록 만드는 일\n- distribute : 제품을 사용자들이 사용할 수 있도록 서비스 등을 제공하는 의미\n    > ex facebook 버전 z.z가 새롭게 release 되었고 이를 서버에 deploy 하여 사용자들이 사용할수 있도록 distribute 하였다.\n- DevOps데브옵스 : 소프트웨어 개발자와 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화 개발Development과 운영Operations의 합성어\n    - 제품 출시까지 걸리는 시간time to market단축\n    - 새로운 판의 더 낮은 실패율\n    - 상품 생산 시작부터 완성까지 걸리는 시간\n    - 복구 시 더 빠른 편균시간",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "Entity relationship Diagram",
    "url": "/database/2020/12/22/entity-relationship-diagram/",
    "category": "database",
    "date": "2020-12-22",
    "excerpt": ": 개체 속성과 개체 간 관계를 도표로 표현헌것.",
    "content": "Entity relationship Diagram\n: 개체 속성과 개체 간 관계를 도표로 표현헌것.\n\n ERD 관계 표현법  \n!/assets/images/posts/database/ERD.png<img width=\"455px\" src=\"/assets/images/posts/database/ERD-line.png\">\n\n1. 1 : 1 식별관계  \n!1:1 relation/assets/images/posts/database/1:1-relation.png  \n상세 주소 테이블은 person_id를 기본키로 사용하고 있고, person_id를 통해 person 테이블을 참조 하고 있다.  \n>    >한명의 주민은 한개의 상세 주소를 가질 수 있다.  \n      상세 주소는 주민 id가 없다면 존재 할 수 없다. 식별 관계  \n      주민 주인 테이블 , 상세 주소 자식 테이블 \n2. 1 : many 참조관계  \n!1:manyreference/assets/images/posts/database/ERD-1-manyreference.png  \n부서와 회사원간의 관계를 표현한 ERD\n>    >회사원은 한개의 부서에 반드시 소속되어야 한다.  \n      한개의 부서에 여러 회사원이 소속될 수 있다.\n      한개 부서에 회사원 한명도 없을 수 있다.\n3. 1 : many 참조 Null 허용  \n!/assets/images/posts/database/ERD-1-manyreference-allow-null.png  \n부서와 회사원간의 관계를 표현한 ERD\n>    >회사원이 부서에 꼭 소속할 필요가 없다.  \n      한개의 부서에 여러 회사원이 소속될수 있다.\n      한개의 부서에 소속된 회사원이 한명도 없을 수 있다.\n\n 비 식별관계와 식별관계\n1. 식별관계Identifying Relationship  \n: 기본키에 외래키를 포함하고 있다.  \n실선으로 나타낸다.  \n!identifying-relationship-line/assets/images/posts/database/Identifying-Relationship.png  \n1. 비 식별관계None Identifying Relationship  \n: 기본키에 외래키를 미포함하고있다.  \n점선으로 나타넨다.  \n!/assets/images/posts/database/None-Identifying-Relationship-line.png",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "MySQL 명령어",
    "url": "/database/2020/12/20/mysql-명령어/",
    "category": "database",
    "date": "2020-12-20",
    "excerpt": "mysql 이라는 DB를 사용하고 user와 host 를 user 테이블에서 불러온다.",
    "content": "MySQL 명령어\n 기본적인 명령어\n DB사용\nsql\nuse DB명\n\n show\nsql\nshow databases;  --DB조회\nshow tables -- table조회\n\n create\nsql\ncreate database DB명 --DB만들기\ncreate table talbe명 --table만들기\n\n table 구조 확인\nsql\ndesc table명\n\n 유저관련 명령어\n 유저 조회\nsql\nuse mysql\nselect user, host from user\n\nmysql 이라는 DB를 사용하고 user와 host 를 user 테이블에서 불러온다.\n 유저 추가\nsql\ncreate user test@localhost IDENTIFIED by '1234'\n\n 유저 제거\nsql\ndrop user 유저이름@호스트",
    "tags": [
      "MySQL",
      "TIL"
    ]
  },
  {
    "title": "MySQL설치(mac)",
    "url": "/database/2020/12/20/mysql설치mac/",
    "category": "database",
    "date": "2020-12-20",
    "excerpt": "를하면 자동으로 설치가 될것이다.  \n설치를 확인하기 위해 버전을 확인해보자",
    "content": "MySQL설치mac\nbash\n$ brew install mysql\n\n를하면 자동으로 설치가 될것이다.  \n설치를 확인하기 위해 버전을 확인해보자\nbash\n$ mysql --version\n\n2020, 12, 17 일 기준으로 8.0.22 버전이 설치될것이다.",
    "tags": [
      "MySQL",
      "TIL"
    ]
  },
  {
    "title": "관계형 데이터베이스 - Relational database",
    "url": "/database/2020/12/20/관계형-데이터베이스---relational-database-1/",
    "category": "database",
    "date": "2020-12-20",
    "excerpt": ": table로 이루어져 있고, 이 table은 key 와 value의 관계를 나타낸다\n  이처럼 데이터의 종속성을 관계relationship로 표현하는것  \n- 1970년 영국의 수학자인 E. F. Codd 박사의 논문에서 제안\n  > 1980년에 상용화 되었다.\n- 기업의 핵심 데이터는 대부분 관계형 DB로 저장되어 있다.\n- 관계형 DB는 SQL문장에...",
    "content": "관계형 데이터베이스 - Relational database\n: table로 이루어져 있고, 이 table은 key 와 value의 관계를 나타낸다\n  이처럼 데이터의 종속성을 관계relationship로 표현하는것  \n- 1970년 영국의 수학자인 E. F. Codd 박사의 논문에서 제안\n  > 1980년에 상용화 되었다.\n- 기업의 핵심 데이터는 대부분 관계형 DB로 저장되어 있다.\n- 관계형 DB는 SQL문장에 의해 관리된다.\n\n 구성요소\n 열column\n- 각각의 열field or attribute은 유일한 이름을 가지고있다.\n- 자신만의 타입을 가지고 있다.\n 행row\n- = tuple, record\n- 관계된 데이터의 묶음 의미\n- 한 테이블의 모든 행은 같은 수의 열을 가지고 있다.\n 값value\n- 테이블은 각각의 행row 열column에 대응하는 값value를 가지고 있다.\n- 열column의 타입에 맞는 값이여야 한다.\n Key  \n: table 에서 행의 식별자로 이용되는 key or 기본 키primary key  \n즉 table에 저장된 record를 고유하게 식별하는 후보 키candidate key 중에 DB 설계자가 지정한 속성을 의미\n 관계\n1. 일대일 one-to-one 관계\n2. 일대다 one-to-many 관계\n3. 다대다 many-to-many 관계\n   > ERD로는 일대다 다대일 테이블로 관계를 나타낸다. 총 테이블 3개가 필요함\n 스키마schema\n: 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. \n> 총 3가지가 있다. 외부 스키마, 내부 스키마, 개념 스키마\n- 일반적으로 스키마는 내부 스키마를 가르킨다.\n\n 1. 외부 스키마\n: 개인의 입장, '서브스키마'라고도 한다, 사용자 뷰를 가리킨다. \n- 하나의 외부스키마는 여럿이 공유 가능하며,\n- 하나의 DB시스템에 여러 개의 외부스키마가 존재 가능\n\n 2. 내부 스키마\n: 시스템 프로그래머나 설계자의 관점에서 바라보는 스키마이다. ex. DBA\n- 데이터베이스의 물리적 구조를 가리킨다\n- 즉, 실제 저장방법을 기술하는 물리적인 저장장치와 관련되는 스키마 이다.\n- DB의 전체적인 구조로써 하나만 존재해야 함\n\n 3. 개념 스키마\n: 조직 전체의 입장, 전체적인 뷰를 가리킨다.\n- 개체간의 관계와 제약조건을 나타내고,\n- DB의 접근권한, 보안, 무결성 규칙에 대한 명세를 정의한다.\n\n key\n: DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.\n 후보키Candidate Key\n1. 기본키로 사용할 수 있는 속성을 가지고 있다.\n2. 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다.\n3. 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함.\n> 유일성: 하나의 key값으로 하나의 튜플만을 유일하게 식별할 수 있어야한다.  \n  최소성: 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성만으로 구성되어 있어야 한다.\n\n 기본키Primary Key\n: 특정 튜플을 유일하게 구별할 수 있는 속성이다.\n1. 후보키 중에서 선택한다.\n3. Null값을 가질 수 없다.\n4. 동일한 값이 중복되어 저장될 수 없다.\n\n 대체키Alternate Key\n: 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.\n\n 슈퍼키Super Key\n: 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 의미한다.\n> 예시 한 릴레이션에 속성 A와 B는 key로 나타낼 수 없지만 두개의 속성을 묶으면 유일성을 만족할 수 있는 형태\n- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.\n- 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.\n\n 외래키Foregin Key\n: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.\n> 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인상에서 정의되었을 때의 속성 A를 외래키라고 한다.\n- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.\n\n Relational Model Constraints\n 1. 도메인 제약 - Domain Constraints\n- 속성 값은 원자성 - atomicity을 가지며, 도메인에서 정의된 값이어야 한다.\n  > ex. 나이는 정수형이어야 하고, 0 ~ 150의 숫자 범위를 가진다.\n- Composite Attribute와 Multivalued Attribute는 허용되지 않는다.\n- NOT NULL이 아닌경우 NULL 값은 허용된다.\n\n 2. 키 제약 - Key Constraints\n: 릴레이션의 모든 튜플 - Tuples은 유일하게 서로 식별 가능해야 한다.\n- cf Super Key, Candidate Key, Primary Key\n\n 3. 개체 무결성 제약 - Entity Integrity Constraints\n: PK는 NOT NULL && UNIQUE이어야 한다.\n\n 4. 참조 무결성 제약 - Referential Integrity Constraints\n- 릴레이션 A가 릴레이션 B를 참조하는 경우, B의 기본키는 A의 외래키로 사용되는 경우\n  - 외래키는 NULL 이거나,\n  - NULL 이 아닌 경우 B에 실제로 존재하는 값으로 구성되어야 한다.\n\n 트랜잭션transaction?\n: DBMS에서 하나의 작업의 단위   \n트랜잭션의 기능을 제대로 수행하기 위해 네가지 특성을 만족해야한다ACID 특성 \n \n트랜잭션의 제기능 하지 못하면?  \n>예를 들어 은행에서 서로다른 ATM기기에서 2명이 동시에 A계좌1000원 들어있음의 1000원을 인출하고 가정하자.  \n>만약 거의 동시에 인출을 시도했을 때 트랜잭션이 제대로 기능하지 않으면 DB상으로 돈은 1000원 밖에 빠져나가지만 실제로는 2000원이 빠져나가게 된다.  \n>0.000001초라도 빠른 사람의 요청을 수행하고 나머지 사람에게는 지급부족으로 요청을 거절해야한다.  \n\n이러한기능을 제대로 수행하기 위한것이 트랜잭션 의 ACID 이다.\n\n ACID특성\n- 원자성Atomicity  \n    : 트랜잭션이 수행하는 연산들을 모두 정상적으로 처리 or 모두 처리하지 않아야 한다는 all-or-nothing 방식을 의미\n- 일관성Consistency  \n    : 트랜잭션이 성공적으로 수행된 이후에도 DB의 데이터는 일관된 상태를 유지해야한다.\n- 격리성Isolation  \n    : 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 간섭하지 못하도록 하여 각각의 트랜잭션이 독립적으로 수행되여야 한다.\n- 지속성Durability\n    : 트랜잭션이 성공적으로 완료된 이후 DB에 데이터들이 영구적으로 보존되어야 한다.\n\n Refrenece\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능1/6https://youtu.be/AAv0lT6KxyY",
    "tags": [
      "TIL"
    ]
  },
  {
    "title": "MySQL 기본 명령어(실행, 접속, 상태확인, 제시작, 종료)",
    "url": "/database/2020/12/20/mysql-기본-명령어실행-접속-상태확인-제시작-종료/",
    "category": "database",
    "date": "2020-12-20",
    "excerpt": "-  실행\n    bash\n    $ mysql -u root -p\n    bash\n    $ mysql.server status\n    bash\n    $ mysql.server restart\n    bash\n    $ mysql.server stop",
    "content": "MySQL 기본 명령어실행, 접속, 상태확인, 제시작, 종료\n-  실행\n    bash\n    $ mysql.server start\n-  접속\n    bash\n    $ mysql -u root -p\n    \n    비밀번호가 없으면 -p는 생략이 가능하다.\n-  상태확인\n    bash\n    $ mysql.server status\n    \n-  재시작\n    bash\n    $ mysql.server restart\n    \n-  종료\n    bash\n    $ mysql.server stop",
    "tags": [
      "MySQL",
      "TIL"
    ]
  },
  {
    "title": "관계형 데이터베이스 - Relational database",
    "url": "/database/2020/12/20/관계형-데이터베이스---relational-database/",
    "category": "database",
    "date": "2020-12-20",
    "excerpt": ": table로 이루어져 있고, 이 table은 key 와 value의 관계를 나타낸다\n  이처럼 데이터의 종속성을 관계relationship로 표현하는것  \n- 1970년 영국의 수학자인 E. F. Codd 박사의 논문에서 제안\n  > 1980년에 상용화 되었다.\n- 기업의 핵심 데이터는 대부분 관계형 DB로 저장되어 있다.\n- 관계형 DB는 SQL문장에...",
    "content": "관계형 데이터베이스 - Relational database\n: table로 이루어져 있고, 이 table은 key 와 value의 관계를 나타낸다\n  이처럼 데이터의 종속성을 관계relationship로 표현하는것  \n- 1970년 영국의 수학자인 E. F. Codd 박사의 논문에서 제안\n  > 1980년에 상용화 되었다.\n- 기업의 핵심 데이터는 대부분 관계형 DB로 저장되어 있다.\n- 관계형 DB는 SQL문장에 의해 관리된다.\n\n 구성요소\n 열column\n- 각각의 열field or attribute은 유일한 이름을 가지고있다.\n- 자신만의 타입을 가지고 있다.\n 행row\n- = tuple, record\n- 관계된 데이터의 묶음 의미\n- 한 테이블의 모든 행은 같은 수의 열을 가지고 있다.\n 값value\n- 테이블은 각각의 행row 열column에 대응하는 값value를 가지고 있다.\n- 열column의 타입에 맞는 값이여야 한다.\n Key  \n: table 에서 행의 식별자로 이용되는 key or 기본 키primary key  \n즉 table에 저장된 record를 고유하게 식별하는 후보 키candidate key 중에 DB 설계자가 지정한 속성을 의미\n 관계\n1. 일대일 one-to-one 관계\n2. 일대다 one-to-many 관계\n3. 다대다 many-to-many 관계\n   > ERD로는 일대다 다대일 테이블로 관계를 나타낸다. 총 테이블 3개가 필요함\n 스키마schema\n: 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. \n> 총 3가지가 있다. 외부 스키마, 내부 스키마, 개념 스키마\n- 일반적으로 스키마는 내부 스키마를 가르킨다.\n\n 1. 외부 스키마\n: 개인의 입장, '서브스키마'라고도 한다, 사용자 뷰를 가리킨다. \n- 하나의 외부스키마는 여럿이 공유 가능하며,\n- 하나의 DB시스템에 여러 개의 외부스키마가 존재 가능\n\n 2. 내부 스키마\n: 시스템 프로그래머나 설계자의 관점에서 바라보는 스키마이다. ex. DBA\n- 데이터베이스의 물리적 구조를 가리킨다\n- 즉, 실제 저장방법을 기술하는 물리적인 저장장치와 관련되는 스키마 이다.\n- DB의 전체적인 구조로써 하나만 존재해야 함\n\n 3. 개념 스키마\n: 조직 전체의 입장, 전체적인 뷰를 가리킨다.\n- 개체간의 관계와 제약조건을 나타내고,\n- DB의 접근권한, 보안, 무결성 규칙에 대한 명세를 정의한다.\n\n key\n: DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.\n 후보키Candidate Key\n1. 기본키로 사용할 수 있는 속성을 가지고 있다.\n2. 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재한다.\n3. 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함.\n> 유일성: 하나의 key값으로 하나의 튜플만을 유일하게 식별할 수 있어야한다.  \n  최소성: 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성만으로 구성되어 있어야 한다.\n\n 기본키Primary Key\n: 특정 튜플을 유일하게 구별할 수 있는 속성이다.\n1. 후보키 중에서 선택한다.\n3. Null값을 가질 수 없다.\n4. 동일한 값이 중복되어 저장될 수 없다.\n\n 대체키Alternate Key\n: 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.\n\n 슈퍼키Super Key\n: 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 의미한다.\n> 예시 한 릴레이션에 속성 A와 B는 key로 나타낼 수 없지만 두개의 속성을 묶으면 유일성을 만족할 수 있는 형태\n- 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.\n- 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.\n\n 외래키Foregin Key\n: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.\n> 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인상에서 정의되었을 때의 속성 A를 외래키라고 한다.\n- 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.\n\n Relational Model Constraints\n 1. 도메인 제약 - Domain Constraints\n- 속성 값은 원자성 - atomicity을 가지며, 도메인에서 정의된 값이어야 한다.\n  > ex. 나이는 정수형이어야 하고, 0 ~ 150의 숫자 범위를 가진다.\n- Composite Attribute와 Multivalued Attribute는 허용되지 않는다.\n- NOT NULL이 아닌경우 NULL 값은 허용된다.\n\n 2. 키 제약 - Key Constraints\n: 릴레이션의 모든 튜플 - Tuples은 유일하게 서로 식별 가능해야 한다.\n- cf Super Key, Candidate Key, Primary Key\n\n 3. 개체 무결성 제약 - Entity Integrity Constraints\n: PK는 NOT NULL && UNIQUE이어야 한다.\n\n 4. 참조 무결성 제약 - Referential Integrity Constraints\n- 릴레이션 A가 릴레이션 B를 참조하는 경우, B의 기본키는 A의 외래키로 사용되는 경우\n  - 외래키는 NULL 이거나,\n  - NULL 이 아닌 경우 B에 실제로 존재하는 값으로 구성되어야 한다.\n\n 트랜잭션transaction?\n: DBMS에서 하나의 작업의 단위   \n트랜잭션의 기능을 제대로 수행하기 위해 네가지 특성을 만족해야한다ACID 특성 \n \n트랜잭션의 제기능 하지 못하면?  \n>예를 들어 은행에서 서로다른 ATM기기에서 2명이 동시에 A계좌1000원 들어있음의 1000원을 인출하고 가정하자.  \n>만약 거의 동시에 인출을 시도했을 때 트랜잭션이 제대로 기능하지 않으면 DB상으로 돈은 1000원 밖에 빠져나가지만 실제로는 2000원이 빠져나가게 된다.  \n>0.000001초라도 빠른 사람의 요청을 수행하고 나머지 사람에게는 지급부족으로 요청을 거절해야한다.  \n\n이러한기능을 제대로 수행하기 위한것이 트랜잭션 의 ACID 이다.\n\n ACID특성\n- 원자성Atomicity  \n    : 트랜잭션이 수행하는 연산들을 모두 정상적으로 처리 or 모두 처리하지 않아야 한다는 all-or-nothing 방식을 의미\n- 일관성Consistency  \n    : 트랜잭션이 성공적으로 수행된 이후에도 DB의 데이터는 일관된 상태를 유지해야한다.\n- 격리성Isolation  \n    : 하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 간섭하지 못하도록 하여 각각의 트랜잭션이 독립적으로 수행되여야 한다.\n- 지속성Durability\n    : 트랜잭션이 성공적으로 완료된 이후 DB에 데이터들이 영구적으로 보존되어야 한다.\n\n Refrenece\n- 국민대학교 김남규 교수 - DB실무 Part3-데이터 모델과 성능1/6https://youtu.be/AAv0lT6KxyY",
    "tags": [
      "TIL"
    ]
  }
]