<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-07T17:20:20+09:00</updated><id>/feed.xml</id><title type="html">My Tech Blog</title><subtitle>A technical blog sharing programming insights and tutorials</subtitle><author><name>jeongcool</name></author><entry><title type="html">Prism.js Syntax Highlighting 테스트</title><link href="/programming/2024/10/07/prism-syntax-highlighting-test/" rel="alternate" type="text/html" title="Prism.js Syntax Highlighting 테스트" /><published>2024-10-07T12:00:00+09:00</published><updated>2024-10-07T12:00:00+09:00</updated><id>/programming/2024/10/07/prism-syntax-highlighting-test</id><content type="html" xml:base="/programming/2024/10/07/prism-syntax-highlighting-test/"><![CDATA[<p>이 포스트는 새로 적용된 Prism.js syntax highlighting을 테스트하기 위한 글입니다.</p>

<h2 id="javascript-예제">JavaScript 예제</h2>

<pre><code class="language-javascript">// 피보나치 수열 생성 함수
function fibonacci(n) {
    if (n &lt;= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 배열 메서드 활용
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num =&gt; num * 2);
console.log(`Original: ${numbers}`);
console.log(`Doubled: ${doubled}`);
</code></pre>

<h2 id="python-예제">Python 예제</h2>

<pre><code class="language-python"># 클래스 정의
class Calculator:
    def __init__(self):
        self.history = []
    
    def add(self, a, b):
        result = a + b
        self.history.append(f"{a} + {b} = {result}")
        return result
    
    def get_history(self):
        return self.history

# 사용 예제
calc = Calculator()
result = calc.add(10, 20)
print(f"결과: {result}")

# 리스트 컴프리헨션
squares = [x**2 for x in range(10) if x % 2 == 0]
print(f"짝수의 제곱: {squares}")
</code></pre>

<h2 id="css-예제">CSS 예제</h2>

<pre><code class="language-css">/* 반응형 그리드 레이아웃 */
.grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
    padding: 2rem;
}

.card {
    background: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    transition: transform 0.3s ease;
}

.card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}
</code></pre>

<h2 id="html-예제">HTML 예제</h2>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;샘플 페이지&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header class="header"&gt;
        &lt;nav class="nav"&gt;
            &lt;ul class="nav-list"&gt;
                &lt;li&gt;&lt;a href="#home"&gt;홈&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#about"&gt;소개&lt;/a&gt;&lt;/li&gt;
                &lt;li&gt;&lt;a href="#contact"&gt;연락처&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/nav&gt;
    &lt;/header&gt;
    
    &lt;main class="main-content"&gt;
        &lt;section id="hero"&gt;
            &lt;h1&gt;환영합니다!&lt;/h1&gt;
            &lt;p&gt;이것은 샘플 HTML 코드입니다.&lt;/p&gt;
        &lt;/section&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="java-예제">Java 예제</h2>

<pre><code class="language-java">// 제네릭 클래스
public class Stack&lt;T&gt; {
    private ArrayList&lt;T&gt; items;
    
    public Stack() {
        this.items = new ArrayList&lt;&gt;();
    }
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
    
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    public int size() {
        return items.size();
    }
}

// 사용 예제
Stack&lt;String&gt; stringStack = new Stack&lt;&gt;();
stringStack.push("Hello");
stringStack.push("World");
System.out.println(stringStack.pop()); // "World"
</code></pre>

<h2 id="inline-코드-테스트">Inline 코드 테스트</h2>

<p>여기서 <code>console.log()</code>는 JavaScript의 출력 함수이고, <code>print()</code>는 Python의 출력 함수입니다. 
CSS에서는 <code>display: flex;</code>를 사용하여 플렉스 레이아웃을 만들 수 있습니다.</p>

<h2 id="기능-테스트">기능 테스트</h2>

<p>Prism.js의 주요 기능들:</p>
<ul>
  <li>✅ 자동 언어 감지</li>
  <li>✅ 라인 번호 표시</li>
  <li>✅ 코드 복사 기능</li>
  <li>✅ 언어 표시</li>
  <li>✅ 문법 하이라이팅</li>
</ul>

<p>코드 블록 위에 마우스를 올려보시면 복사 버튼이 나타납니다!</p>]]></content><author><name>jeongcool</name></author><category term="programming" /><category term="javascript" /><category term="python" /><category term="java" /><category term="prism" /><category term="syntax-highlighting" /><summary type="html"><![CDATA[이 포스트는 새로 적용된 Prism.js syntax highlighting을 테스트하기 위한 글입니다.]]></summary></entry><entry><title type="html">VO 사실과 오해</title><link href="/programming/2024/02/18/vo-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4/" rel="alternate" type="text/html" title="VO 사실과 오해" /><published>2024-02-18T00:00:00+09:00</published><updated>2024-02-18T00:00:00+09:00</updated><id>/programming/2024/02/18/vo-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4</id><content type="html" xml:base="/programming/2024/02/18/vo-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4/"><![CDATA[<h1 id="vo-사실과-오해">VO 사실과 오해</h1>
<blockquote>
  <p>2022.10.19(수) 사내에서 발표한 내용</p>
</blockquote>

<p><img src="/assets/images/posts/programming/VO사실과_오해_img_1.png" alt="" /><em>https://woogienote.tistory.com/m/88</em></p>

<p><img src="/assets/images/posts/programming/VO사실과_오해_img_2.png" alt="" /><em>https://kkminseok.github.io/posts/Spring_semina/</em></p>

<p>위 2개의 사진에 나와있는 블로그는 VO는 객체의 속성과 getter, setter를 가지고 있다고하고, 다른 하나는 불변이라 readOnly의 특징을 가진다고 나와있습니다.</p>

<p>둘 다 계층간 데이터 교환을 위한 객체라고 설명하고 있습니다.</p>

<p>근데 위 한국 블로그 2개랑 마틴 파울러의 VO가 다르네?!</p>

<h2 id="마틴-파울러의-vo">마틴 파울러의 VO</h2>

<p>Martin Fowler의 글에 의하면</p>

<blockquote>
  <p>I find it useful to think of two classes of object: value objects and reference objects, depending on how I tell them apart</p>

  <p>나는 구별하는 방법에 따라 값 객체와 참조 객체,두 가지 클래스의 객체를 고려하는 것이 유용하다는 것을 알게되었다.</p>
</blockquote>

<blockquote>
  <p>When programming, I often find it’s useful to represent things as a compound.A 2D coordinate consists of an x value and y value.An amount of money consists of a number and a currency.A date range consists of start and end dates,which themselves can be compounds of year, month, and day.</p>

  <p>프로그래밍을 할 때, 사물을 복합물로 표현하는 것이 유용할 경우가 종종 있다.예를 들어, 2차원 좌표는 x, y로 이루어져 있고,돈이나 통화 같은 경우 숫자로 이루어져 있다.날짜의 범위는 시작 날짜와 종료날짜로 구성될 수 있고,연도와 월, 일의 복합물일 수 도 있다.</p>
</blockquote>

<p>예시. Point(x = 1, y = 2), Date(month = 1, day = 4)</p>

<p>즉 VO란, 한개 이상의 속성들을 묶어 특정 값을 나타내는 객체를 말하고,</p>

<p>VO는 도메인 객체의 일종이며, 보통 기본키로 식별 값을 갖는 Entity와 구별해서 사용된다.</p>

<h2 id="마틴-파울러의-vo를-다음과-같이-구분해서-설명하고-있다">마틴 파울러의 VO를 다음과 같이 구분해서 설명하고 있다.</h2>

<ol>
  <li>equals &amp; hash code 메서드 재정의</li>
</ol>

<p>기본적으로 객체를 === 비교(동일성)비교를 하면 객체의 참조 주소를 비교하고 == (동등성)비교를 하면 객체의 값(프로퍼티)를 기반으로 비교를 하게 된다.</p>

<p>RGB(0,0,0) == RGB(0,0,0) // false? 하얀색과 하얀색이 다르다?</p>

<p>equals &amp; hash code 메서드를 재정의 한다면 속성값이 같은 객체를 보장할 수 있다.</p>

<ol>
  <li>수정자(Setter)가 없는 불변(Immutable) 객체</li>
</ol>

<p>Entity와 같은 경우 별도의 식별 값을 가지고 있기 때문에내부 속성 값이 변경된다고 하더라도 같은 객체로 계속 인식하고 추적할 수 있습니다.<br />
하지만 속성 값 자체가 식별 값인 VO는 속성 값이 바뀌게 되면 식별 값도 바뀌게 되어 추적이 불가능하고,복사 될 때는 의도치 않은 객체들이 함께 변경되는 문제를 유발합니다.</p>

<p>따라서 VO는 값을 변경할 수 없는 불변 객체로 만들어야합니다.</p>

<pre><code class="language-kotlin">class RGB(var r : Int, var g : Int, var b : Int){
  overried fun toString() : String
}

val color = RGB(0,0,0)
val blackFont = FontStyle(color)

color.r = 180
color.g = 85
color.b = 162

val purpleFont = FontStyle(color)

print(blackFont.color) // Color(180, 85, 162) 출력
print(purpleFont.color) // Color(180, 85, 162) 출력
</code></pre>

<p>근데 왜 데이터 이동을 위한 객체도 VO라고 부르는걸까?</p>

<p>이는 해당 글의 Further Reading 부분에서 확인할 수 있다.</p>

<blockquote>
  <p>One source of terminological confusion is that around the turn of the century some J2EE literature used “value object” for Data Transfer Object. That usage has mostly disappeared by now, but you might run into it.</p>

  <p>용어 혼란의 한 가지 원인은 세기가 바뀔 무렵 일부 J2EE 문헌에서 Data Transfer Object 에 “Value Object”를 사용했다는 것 입니다. 그 사용법은 지금은 대부분 사라졌지만, 아마 이것을 우연히 만날 수 있다.</p>
</blockquote>

<p>즉 J2EE문헌에서 데이터 전달에 사용하는 객체를 VO라고 했었던 것이다.</p>

<h2 id="j2ee에서의-vo">J2EE에서의 VO</h2>

<p>Core J2EE Patterns에서 VO는 데이터를 전송하기 위한 객체에 대한 패턴을 의미한다.</p>

<p>내부적으로 Java Beans spec을 따라야 한다.</p>

<p>자바빈즈 JavaBeans 클래스 규약</p>

<ol>
  <li>
    <p>private 접근제한자로 필드를 선언한다. (필수)</p>
  </li>
  <li>
    <p>getter 메소드와 setter 메소드를 갖는다. (필수)</p>
  </li>
  <li>
    <p>기본 생성자가 반드시 존재해야 된다. (필수)</p>
  </li>
  <li>
    <p>implements Serializable (선택)</p>
  </li>
</ol>

<p>하지만 이는 혼동의 여지가 있어 Core J2EE Patterns 2판에서 VO를 TO(Transfer Object)라고 변경했다.</p>

<p>TO에 대해 자세히 알고싶다면 oracle 참조. https://www.oracle.com/java/technologies/transfer-object.html</p>

<p><img src="/assets/images/posts/programming/VO사실과_오해_img_3.png" alt="" /></p>

<h2 id="그럼-vo는-어떻게-써야할까">그럼 VO는 어떻게 써야할까?</h2>

<p>VO 정확히 말하면 VO Pattern에서의 VO객체는 TO(Transfer Object)로 변경되었다.</p>

<p>데이터 전달을 위한 VO를 사용하고 싶다면 확실하게 Value Object 패턴 이라고 말해줄 필요가 있다.</p>

<p>하지만 J2EE pattern에 나와있듯이 VO는 오해에 소지가 있어 TO로 변경되었으니 TO를 사용하는게 좋지 않을까?</p>

<p>마지막으로 KSUG에서의 Toby님의 대화를 첨부한다.
<img src="/assets/images/posts/programming/VO사실과_오해_img_4.png" alt="" /></p>

<h2 id="결론">결론</h2>

<p>내가 생각하기에 저 2개의 블로그가 VO를 다르게 설명하게 된 원인은 VO Pattern과 DDD에서의 Value Object를 구분하지 못하여 생기는 문제가 아닐까 라고 생각이 든다.</p>

<p>만약 VO Pattern에 대해 말하고 싶다면 Pattern을 명확하게 알려줘야 하고 애초에 VO를 J2EE core patterns에서는 TO라고 부르고 있다.</p>

<p>데이터 전달을 위한 객체는 VO보다 DTO로 부르는게 더 적절하므로 DTO를 사용하자</p>

<h2 id="references">References</h2>
<ul>
  <li>https://github.com/benelog/blog/issues/27</li>
  <li>https://groups.google.com/g/ksug/c/M3l6ZqKpaQ4/m/4rcCbgS_CXUJ</li>
  <li>https://martinfowler.com/bliki/ValueObject.html</li>
  <li>https://d2.naver.com/news/3435170</li>
</ul>]]></content><author><name>jeongcool</name></author><category term="programming" /><category term="coding" /><category term="development" /><category term="TIL" /><summary type="html"><![CDATA[VO 사실과 오해 2022.10.19(수) 사내에서 발표한 내용]]></summary></entry><entry><title type="html">Test Post 1</title><link href="/test/2024/01/01/test-post-1/" rel="alternate" type="text/html" title="Test Post 1" /><published>2024-01-01T10:00:00+09:00</published><updated>2024-01-01T10:00:00+09:00</updated><id>/test/2024/01/01/test-post-1</id><content type="html" xml:base="/test/2024/01/01/test-post-1/"><![CDATA[<p>This is autogenerated test post #1.</p>

<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer nec odio. Praesent libero. Sed cursus ante dapibus diam.</p>

<h2 id="example-code">Example Code</h2>

<pre><code class="language-ruby"># Sample code block for Test Post 1
puts "Hello from Test Post 1"
</code></pre>

<p>More sample content…</p>]]></content><author><name>jeongcool</name></author><category term="test" /><category term="test" /><category term="sample" /><summary type="html"><![CDATA[Sample excerpt for Test Post 1.]]></summary></entry><entry><title type="html">Welcome to My Tech Blog</title><link href="/general/2024/01/01/welcome-to-my-blog/" rel="alternate" type="text/html" title="Welcome to My Tech Blog" /><published>2024-01-01T10:00:00+09:00</published><updated>2024-01-01T10:00:00+09:00</updated><id>/general/2024/01/01/welcome-to-my-blog</id><content type="html" xml:base="/general/2024/01/01/welcome-to-my-blog/"><![CDATA[<p>안녕하세요! 제 기술 블로그에 오신 것을 환영합니다.</p>

<p>이 블로그에서는 다음과 같은 내용을 다룰 예정입니다:</p>

<ul>
  <li>프로그래밍 튜토리얼</li>
  <li>기술 트렌드 분석</li>
  <li>개발 경험 공유</li>
</ul>

<p>앞으로 유용한 콘텐츠로 찾아뵙겠습니다!</p>]]></content><author><name>jeongcool</name></author><category term="general" /><category term="welcome" /><category term="introduction" /><category term="blog" /><summary type="html"><![CDATA[안녕하세요! 제 기술 블로그에 오신 것을 환영합니다.]]></summary></entry><entry><title type="html">Plan Archive</title><link href="/back-end/2023/07/26/plan-archive/" rel="alternate" type="text/html" title="Plan Archive" /><published>2023-07-26T00:00:00+09:00</published><updated>2023-07-26T00:00:00+09:00</updated><id>/back-end/2023/07/26/plan-archive</id><content type="html" xml:base="/back-end/2023/07/26/plan-archive/"><![CDATA[<h1 id="plan-archive">Plan Archive</h1>

<ul>
  <li><code>-plan</code> 이 붙은 jar 파일이며</li>
  <li>에플리케이션 실행에 필요한 모든 의존성이 포함되지 않는 파일이며</li>
  <li>소스코드와 리소스 파일만 포함된다.</li>
  <li>이런 jar 파일을 thin.jar, standard.jar로 불리기도 한다.</li>
</ul>

<h2 id="springboot-애플리케이션에서-생성하지-않는-방법">SpringBoot 애플리케이션에서 생성하지 않는 방법</h2>

<ul>
  <li>reference: https://docs.spring.io/spring-boot/docs/2.5.1/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives</li>
</ul>

<p>Spring Boot 2.5.x 버전부터 build시 자동으로 생성된다 만약 생성을 원하지 않을 경우 classifier를 사용하거나</p>

<pre><code class="language-kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
	classifier = "boot"
}

tasks.getByName&lt;Jar&gt;("jar") {
	classifier = ""
}
</code></pre>

<p>plan archive를 완전히 build하고 싶지 않을경우 아래와 같이 build.gradle.kts에 추가하면 된다.</p>

<pre><code class="language-kotlin">tasks.getByName&lt;Jar&gt;("jar") {
	enabled = false
}
</code></pre>

<h2 id="executable-jar">Executable-Jar</h2>

<p>반대로 Excutable Jar는 그 즉시 실행할 수 있는 jar 파일을 의미한다,</p>

<ul>
  <li>애플리케이션 실행에 필요한 모든 의존성이 포함된다.</li>
</ul>

<h2 id="해당-글을-작성하는-이유">해당 글을 작성하는 이유</h2>

<p>토이프로젝트 진행 중 간단하게 AWS ec2환경에서 Github Action + code deploy 를 활용해서 ci/cd를 진행해야 하는 일이 있었다.<br />
그 중 deploy하는 bash script를 작성하는데 빌드 디렉토리 하위에 <code>*.jar</code> 표현식을 가진 파일을 실행하라는 스크립트를 작성했었다.<br />
그랬더니 plan jar 파일을 실행시켜 cd과정에서 실패했고 이 과정에서 궁금해서 쓰개 됨</p>]]></content><author><name>jeongcool</name></author><category term="back-end" /><category term="TIL" /><category term="gradle" /><category term="build-tool" /><summary type="html"><![CDATA[Plan Archive]]></summary></entry><entry><title type="html">4. 컴포넌트 원칙</title><link href="/book/2023/04/30/4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9B%90%EC%B9%99/" rel="alternate" type="text/html" title="4. 컴포넌트 원칙" /><published>2023-04-30T00:00:00+09:00</published><updated>2023-04-30T00:00:00+09:00</updated><id>/book/2023/04/30/4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9B%90%EC%B9%99</id><content type="html" xml:base="/book/2023/04/30/4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%9B%90%EC%B9%99/"><![CDATA[<h1 id="4-컴포넌트-원칙">4. 컴포넌트 원칙</h1>
<h2 id="컴포넌트란">컴포넌트란</h2>
<p>컴포는트는 배포 단위이며 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.</p>

<p><strong>예시</strong></p>
<ol>
  <li>Java의 jar, war</li>
  <li>루비의 gem</li>
  <li>.Net에서 DLL</li>
</ol>

<p>잘 설계된 컴포넌트라면 반드시 독립적으로 배포(개발) 가능한 능력을 갖춰야 한다.</p>

<h2 id="컴포넌트의-역사">컴포넌트의 역사</h2>
<h3 id="1-소프트웨어-개발-초창기에-메모리에서-프로그램-위치와-레이아웃을-프로그래머가-직접-제어했다">1. 소프트웨어 개발 초창기에 메모리에서 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.</h3>
<ul>
  <li>이 떄 당시 라이브러리는 바이너리가 아닌 소스코드 형태로 존재했다.</li>
  <li>하지만 이 방식은 컴파일 시 매우 느린 단점이 있다.
    <h3 id="2-컴파일-시간을-단축시키기-위해-함수-라이브러리-소스코드를-애플리케이션-코드로부터-분리했다">2. 컴파일 시간을 단축시키기 위해 함수 라이브러리 소스코드를 애플리케이션 코드로부터 분리했다.</h3>
  </li>
  <li>하지만 라이브러리가 점점 커졌고 할당된 메모리 주소를 넘거가게 되는데
    <h3 id="3-재배치가-가능한-바이너리relocatable-bineary">3. 재배치가 가능한 바이너리(<code>relocatable bineary</code>)</h3>
  </li>
  <li>지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일을 수정하자는 개념</li>
  <li>로더는 재배치 코드가 자리할 위치 정보를 전달받음 -&gt; 재배치 코드에는 로드한 데이터의 변경 부분을 주소에 로드할 수 있는지 알려주는 플래그 삽입</li>
  <li>이제 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었음</li>
  <li>실제로 로더는 바이너리를 입력받은 후 단순히 하나씩 차례로 메모리로 로드하며 재배치하는 작업을 처리
    <ul>
      <li>이를 통해 프로그래머는 오직 필요한 함수만 로드 할 수 있게 됨</li>
    </ul>
  </li>
  <li>또한 컴파일러는 재배치 가능한 바이너리 안에 함수 이름을 메타데이터 형태로 생성하도록 수정
    <ul>
      <li>만약 프로그램이 라이브러리 함수를 호출한다면 라이브러리 함수 이름을 외부 참조(<code>external reference</code>)로 생성</li>
      <li>반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의(<code>external definition</code>)로 생성</li>
      <li>이렇게 하여 외부 정의 에 링크시킬 수 있게 됨</li>
      <li>이렇게 링킹 로더(<code>linking loader</code>)가 탄생</li>
    </ul>
  </li>
</ul>

<h3 id="4-링커">4. 링커</h3>
<ul>
  <li>링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.</li>
  <li>하지만, 프로그램은 훨씬 커지게 되며 링킹 로더가 너무 느려졌다.
    <blockquote>
      <p>링킹 로더가 프로그램 하나를 로드하는 데만 한 시간 이상 걸리게 되었다. (자기테이프 사용)</p>
    </blockquote>
  </li>
  <li>마침내 로드와 링크가 두 단계로 분리
    <ul>
      <li>프로그래머가 느린 부분 즉, 링크 과정을 맡음</li>
      <li>링커 라는 별도의 애플리케이션으로 해당 작업을 처리하도록 만듦</li>
      <li>링커는 링크가 완료된 재배치 코드를 만들어 주어 로더의 로딩 과정이 아주 빨라짐</li>
      <li>한번 만들어둔 실행 파일은 언제라도 빠르게 로드 할 수 있게 되었다.</li>
    </ul>
  </li>
</ul>

<h3 id="5-무어의-법칙">5. 무어의 법칙</h3>
<ol>
  <li>1980년대 소스 모듈은 .c파일에서 .o파일로 컴파일 후 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐</li>
  <li>각 모듈을 컴파일 하는 시간은 상대적으로 빠르지만 전체 모듈을 컴파일하는 일은 꽤 시간이 걸림</li>
  <li>1980년대 후반에 들어서자 디스크는 작아졌으며 RAM의 용량은 커졌다. 컴퓨터 메모리는 저렴해짐</li>
  <li>1990년대 후반이 되자, 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는게 더 빨라지기 시작함.</li>
  <li>이렇게 Active X와 공유 라이브러리 시대가 열리고 .jar파일 등장</li>
</ol>

<h3 id="결론-이-책에서의-컴포넌트">결론: 이 책에서의 컴포넌트</h3>
<p>런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일</p>

<h2 id="컴포넌트-응집성">컴포넌트 응집성</h2>
<blockquote>
  <p>이 클래스를 어느 컴포넌트에 포함시켜야 할까?</p>
</blockquote>

<p>해당 장에서는 컴포넌트 응집성과 관련된 세 가지 원칙을 논의한다.</p>

<ul>
  <li>REP(<code>Reuse/Release Equivalence Principle</code>): 재사용/릴리스 등가 원칙</li>
  <li>CCP(<code>Common Closure Principle</code>): 공통 폐쇄 원칙</li>
  <li>CRP(<code>Common Reuse Principle</code>): 공통 재사용 원칙</li>
</ul>

<h3 id="1-rep-재사용릴리즈-등가-원칙">1. REP: 재사용/릴리즈 등가 원칙</h3>
<blockquote>
  <p>재사용 단위는 릴리즈 단위와 같다.
<!-- TODO --></p>
</blockquote>

<h3 id="2-ccp-공통-폐쇄-원칙">2. CCP: 공통 폐쇄 원칙</h3>
<blockquote>
  <p>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라
<!-- TODO --></p>
</blockquote>

<h3 id="3-crp-공통-재사용-원칙">3. CRP: 공통 재사용 원칙</h3>
<blockquote>
  <p>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
<!-- TODO --></p>
  <h2 id="컴포넌트-결합">컴포넌트 결합</h2>
  <!-- TODO -->
</blockquote>]]></content><author><name>jeongcool</name></author><category term="book" /><category term="클린아키텍처" /><category term="TIL" /><summary type="html"><![CDATA[4. 컴포넌트 원칙 컴포넌트란 컴포는트는 배포 단위이며 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.]]></summary></entry><entry><title type="html">8. 통합 테스트를 하는 이유</title><link href="/book/2023/03/19/8-%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/" rel="alternate" type="text/html" title="8. 통합 테스트를 하는 이유" /><published>2023-03-19T00:00:00+09:00</published><updated>2023-03-19T00:00:00+09:00</updated><id>/book/2023/03/19/8-%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0</id><content type="html" xml:base="/book/2023/03/19/8-%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/"><![CDATA[<h1 id="8-통합-테스트를-하는-이유">8. 통합 테스트를 하는 이유</h1>

<h2 id="통합-테스트는-무엇인가">통합 테스트는 무엇인가</h2>
<p>통합 테스트란 시스템이 프로세스 외부 의존성과 어떻게 통합하는지 검증한다.</p>

<p>단위 테스트의 세 가지 사항을 하나라도 충족하지 못하는 테스트는 통합테스트의 범주에 속한다.</p>

<blockquote>
  <ul>
    <li>단일 동작 단위를 검증</li>
    <li>빠르게 수행</li>
    <li>다른 테스트와 별도로 처리</li>
  </ul>
</blockquote>

<p>통합 테스트는 대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증한다.</p>

<ul>
  <li>단위 테스트는 도메인 모델을 다룬다.</li>
  <li>통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다.</li>
</ul>

<p><img src="/assets/images/posts/book/통합테스트_단위테스트_사사분면.jpeg" /></p>

<p>통합 테스트는 <code>주요 흐름(happy path)</code>,과 단위 테스트가 다루지 못한 <code>기타 예외 상황(edge case)</code> 를 다룬다.</p>

<blockquote>
  <h4 id="주요-흐름happy-apth">주요 흐름(happy apth)</h4>
  <p>시나리오의 성공적인 실행이다.</p>
  <h4 id="예외-상황edge-case">예외 상황(edge case)</h4>
  <p>비즈니스 시나리오 수행 중 오류가 발생하는 경우</p>
</blockquote>

<p>하지만 통합 테스트는 유지비가 많이 든다.</p>
<ul>
  <li>프로세스 외부 의존성 운영이 필요한</li>
  <li>관련된 협력자가 많아 테스트가 비대해진다.</li>
</ul>

<p>대부분의 통합테스트를 단위테스트로 변환하면 유지비를 절감할 수 있지만, 중요한 통합 테스트가 비즈니스 시나리오당 하나 또는 두 개 있으면 시스템 전체의 정확도를 보장할 수 있다.</p>

<p><img src="/assets/images/posts/book/테스트%20피라미드.jpeg" /></p>

<h3 id="통합-테스트와-빠른-실패">통합 테스트와 빠른 실패</h3>
<p>어떠한 예외 상황에 잘못 실행돼 전체 애플리케이션이 즉시 실패하면 해당 예외 상황은 테스트할 필요 없다.</p>

<pre><code class="language-kotlin">// User
fun changeEmail(newEmail: String, company: Company) {
    require(canChangeEmail())
    
    ...나머지
}

// UserController
fun changeEmail(userId: Int, newEmail: String){
    val user = userRepository.findByIdOrNull(userId)!!

    val error = user.canChageEmail()
    if(error != null)
        return error

    ...나머지
}
</code></pre>
<p>컨트롤러는 <code>canChangeEmail()</code>를 호출하고 해당 메서드가 오류를 반환하면 연산을 중단한다.</p>

<p>컨트롤러가 <code>canChangeEmail()</code>를 참조하지 않고 이메일을 변경하려고 하면</p>
<ul>
  <li>예외가 던져질 것이고</li>
  <li><code>changeEmail()</code>매서드의 실행만으로 버그가 들어나므로 쉽게 알아차리고 고칠 수 있다.</li>
  <li>데이터의 손상으로 이어지지 않는다.</li>
</ul>

<p>이러한 테스트는 단위 테스트로 하는 것이 더 낫고 통합 테스트를 통해 검증할 필요가 없는 케이스다.</p>

<p>버그를 빨리 나타나게 하는 것을 <code>빠른 실패 원칙(Fast Fail principle)</code>이라 하며 통합테스트에서 할 수 이 있는 대안이다.</p>

<h4 id="빠른-실패-원칙">빠른 실패 원칙</h4>
<p>예기칙 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 의미한다.</p>

<p>이 원칙은 다음을 통해 애플리케이션의 안정성을 높인다.</p>
<ul>
  <li>피드백 루프 단축: 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다.
-&gt; 이미 운영 환경으로 넘어온 버그는 개발 중에 발견된 버그보다 수정 비용이 훨씬 더 크다.</li>
  <li>지속성 상태 보호: 버그는 애플리케이션 상태를 손상시킨다. -&gt; 손상된 상태가 DB로 침투하면, 고치기가 훨씬 어려워진다. 빨리 실패하면 손상이 확산되는 것을 막을 수 있다.</li>
</ul>

<h2 id="어떤-프로레스-외부-의존성을-직접-테스트해야-하는가">어떤 프로레스 외부 의존성을 직접 테스트해야 하는가?</h2>
<h3 id="프로세스-외부-의존성의-두-가지-유형">프로세스 외부 의존성의 두 가지 유형</h3>
<h4 id="관리-의존성">관리 의존성</h4>
<ul>
  <li>애플리케이션을 통해서만 접근할 수 있으며, 해당 의존성과 상호 작용은 외부 환경에서 볼 수 없다.</li>
  <li>관리 의존성과 통신은 구현 세부 사항이다.
    <ul>
      <li>외부 클라이언트는 DB의 구성을 신경 쓰지 않는다.</li>
      <li>중요한 것은 시스템의 최종 상태이다.</li>
    </ul>
  </li>
  <li>ex. DB</li>
</ul>

<h4 id="비관리-의존성">비관리 의존성</h4>
<ul>
  <li>해당 의존성과의 상호작용을 외부에서 볼 수 있다.</li>
  <li>비관리 의존성의 통신은 식별할 수 있는 동작이다.</li>
  <li>ex. SMTP, Message Bus</li>
</ul>

<h3 id="관리-의존성이며-비관리-의존성인-프로세스">관리 의존성이며 비관리 의존성인 프로세스</h3>
<p>관리 의존성과 비 관리 의존성 모두의 속성을 나타내는 프로세스 외부 의존성이 있을 수 있다.
<img src="/assets/images/posts/book/관리의존성이며_외부의존성인경우_유.jpeg" /></p>

<ul>
  <li>다른 애플리케이션에서 볼 수 있는 테이블을 비관리 의존성으로 취급한다.</li>
</ul>

<blockquote>
  <p>시스템 간 통합을 구현하는 데 DB보다는 동기식/비동기식 통신을 사용하는 것이 낫다.</p>
</blockquote>

<h3 id="통합-테스트에서-실제-db를-사용할-수-없는경우">통합 테스트에서 실제 DB를 사용할 수 없는경우</h3>
<p>DB를 그대로 테스트할 수 없다면 통합테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하자</p>

<p>가치가 충분하지 않은 테스트는 테스트 스위트에 있어서는 안된다.</p>

<h2 id="잘못된-내외부-의존성을-위한-인터페이스-사용">잘못된 내/외부 의존성을 위한 인터페이스 사용</h2>
<pre><code class="language-kotlin">interface UserRepository
class UserRepositoryImpl: UserRepository
</code></pre>
<p>이렇게 인터페이스를 사용하는 일반적인 이유는 인터페이스가</p>
<ul>
  <li>프로세스 외부 의존성을 추상화해 느슨한 결합을 달성하고,</li>
  <li>기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP를 지키기 떄문이다.</li>
</ul>

<p>이 두 가지 이유 모두 오해이다.</p>

<h3 id="1프로세스-외부-의존성을-추상화해-느슨한-결합을-달성한다">1.프로세스 외부 의존성을 추상화해 느슨한 결합을 달성한다.</h3>
<p>단일 구현을 위한 인터페이스는 추상화가 아니며 해당 인터페이스를 구현하는 클래스보다 결합도가 낮지 않다.</p>

<blockquote>
  <p>진정한 추상화는 발견하는 것이지. 발명하는 것이 아니다.</p>
</blockquote>

<h3 id="2-인터페이스는-기존-코드를-변경하지-않고-새로운-기능을-추가해-ocp을-준수한다">2. 인터페이스는 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP을 준수한다.</h3>
<p>YANGI는 현재 필요하지않은 기능에 시간을 들여서는 안되는 원칙을 말하며, 이는 기회 비용을 낭비하거나 프로젝트 코드의 경량화를 방해한다.</p>

<h2 id="통합-테스트-모범-사례">통합 테스트 모범 사례</h2>
<p>통합 테스트를 최대한 활용하는 데 도움이 되는 지침</p>
<ol>
  <li>도메인 모델 경계 명시</li>
  <li>애플리케이션 내 계층 줄이기</li>
  <li>순환 의존성 제거</li>
</ol>

<h3 id="1-도메인-모델-경계-명시">1. 도메인 모델 경계 명시</h3>
<p>항상 도메인 모델을 코드베이스에 명시적이고 잘 알려진 위치에 두도록 하라.</p>

<ul>
  <li>도메인 클래스와 컨트롤러 사이의 명확한 경계로 단위테스트와 통합 테스트의 차리점을 쉽게 구별할 수 있다.</li>
</ul>

<h3 id="2-계층-수-줄이기">2. 계층 수 줄이기</h3>
<blockquote>
  <p>컴퓨터 과학의 모든 문제는 또 다른 간접 계층으로 해결할 수 있다. 간접 계층이 너무 많아서 문제가 생기지 않는다면 말이다.
추상화가 지나치게 많으면 단위 테스트와 통합 테스트에도 도움이 되지 않는다.</p>
  <ul>
    <li>간접 계층이 많은 코드 베이스는 컨트롤러와 도메인 모델 사이에 명확한 경계가 없는 편이다.</li>
    <li>각 계층을 따로 검증하는 경향이 훨씬 강하다.</li>
    <li>이러한 경향으로 통합테스트는 가치가 떨어지며</li>
    <li>특정 계층의 코드만 실행하고 하위 계층은 목으로 처리한다.</li>
    <li>최종 결과는 항상 똑같이 낮은 리팩터링 내성과 불충분한 회귀 방지다.</li>
  </ul>
</blockquote>

<h3 id="3-순환-의존성-제거하기">3. 순환 의존성 제거하기</h3>
<p>순환 의존성의 대표적인 예는 call back이다.</p>
<pre><code class="language-kotlin">class CheckOutService {
    fun checkOut(orderId: Int) {
        val service = ReportGenerationService();
        service.generateReport(orderId, this)
        ... 생략
    }
}

class ReportGenerationService {
    fun generationService(orderId: Int, checkOutService: CheckOutService) {
        ...생략
    }
}
</code></pre>

<ul>
  <li>순환 의존성은 테스트를 방해한다.
    <ul>
      <li>클래스 그래프를 나눠서 동작 단위를 하나 분리하려면 목으로 처리해야 하는 경우가 많음</li>
    </ul>
  </li>
  <li>인터페이스를 사용해 해결(?)
    <ul>
      <li><code>ReportGenerationService</code>를 구체 클래스 대신 인터페이스에 의존하는 경우 컴파일 타임의 순환 참조를 해결할 수 있으나</li>
      <li>여전히 런타임에 순환이 있다.</li>
      <li>추가로 코드를 알아야 하는데 부담이 늘어난다.</li>
    </ul>
  </li>
</ul>

<pre><code class="language-kotlin">class CheckOutService {
    fun checkOut(orderId: Int) {
        val service = ReportGenerationService();
        val report: Report = service.generateReport(orderId)
        ... 생략
    }
}

class ReportGenerationService {
    fun generationService(
        orderId: Int, 
        checkOutService: CheckOutService
    ): Report {
        ...생략
    }
}
</code></pre>
<p><code>ReportGenerationService</code>가 CheckOutService를 호출하는 대신 작업 결과를 리턴하게 하자.</p>

<h3 id="테스트에서-다중-실행-구절-사용">테스트에서 다중 실행 구절 사용</h3>
<p>테스트 내에서 두개 이상의 준비/실행/검증 구절을 두는 것은 권장되지않는다.</p>

<p>이는 테스트가 여러 가지 동작 단위를 확인한다는 신호로 유지보수성을 저해한다는 신호이기 때문이다.</p>

<p>예를 들어 사용자의 등록과 삭제를 하나의 통합 테스트에서 확인하려고 하는 경우 아래와 같은 구조를 가질 수 있다.</p>

<ul>
  <li>준비 : 사용자 등록에 필요한 데이터 준비</li>
  <li>실행 : UserController.RegisterUser() 호출</li>
  <li>검증 : 등록 동작의 성공 여부를 확인하기 위해 데이터베이스 조회</li>
  <li>실행 : UserController.DeleteUser() 호출</li>
  <li>검증 : 삭제 동작의 성공 여부를 확인하기 위해 데이터 베이스 조회
이러한 방식은 사용자의 상태가 자연스럽게 흐르기 때문에 어느정도 설득력이 있어보인다.</li>
</ul>

<p>문제는 이러한 테스트 구조는 어떤 것을 검증하려는 것인지 모호해지면서 규모가 순식간에 커질 수 있다는 점이다.</p>

<p>따라서 각 실행을 고유의 테스트로 추출해 각각 테스트하는 것이 좋다.</p>

<p>다만 예외적으로 원하는 상태로 만들기가 까다로운 프로세스 외부 의존성인 경우 여러 동작을 하나루 묶어서 처리해야 한다.</p>

<p>이 방법은 프로세스 외부 의존성과의 상호 작용 횟수를 줄이는 효과가 있으므로 어느 정도 타당하다고 볼 수 있다.</p>]]></content><author><name>jeongcool</name></author><category term="book" /><category term="유닛테스트" /><category term="TIL" /><summary type="html"><![CDATA[8. 통합 테스트를 하는 이유]]></summary></entry><entry><title type="html">단위테스트 스타일</title><link href="/book/2023/03/11/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC/" rel="alternate" type="text/html" title="단위테스트 스타일" /><published>2023-03-11T00:00:00+09:00</published><updated>2023-03-11T00:00:00+09:00</updated><id>/book/2023/03/11/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC</id><content type="html" xml:base="/book/2023/03/11/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC/"><![CDATA[<h1 id="단위테스트-스타일">단위테스트 스타일</h1>
<h2 id="요약">요약</h2>
<p>단위테스트의 스타일은 3가지로 나뉜다.</p>
<ol>
  <li>상태 기반</li>
  <li>출력 기반</li>
  <li>통신 기반</li>
</ol>

<p>여기서 출력 기반 스타일의 테스트는 가장 품질이 좋지만 모든 코드에 적용할 수 없고 순수 함수 방식으로만 작성된 코드에 사용할 수 있다.</p>

<p>통신 기반 테스트는 간혈적으로 사용해야 한다.</p>

<h2 id="단위-테스트의-세-가지-스타일">단위 테스트의 세 가지 스타일</h2>
<h3 id="1-출력-기반-테스트">1. 출력 기반 테스트</h3>
<p><img src="/assets/images/posts/book/출력_기반_테스트.jpeg" /></p>

<p>SUT에 입력을 넣고 생성되는 출력을 검증하는 방식이다.</p>
<ul>
  <li>전역 상태나 내부 상태를 변경하지 않는 코드에만 적용된다.</li>
  <li>함수형(functional)이라고 한다.
    <ul>
      <li>함수형 프로그래밍 에 뿌리를 두고 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="2-상태-기반-스타일-정의">2. 상태 기반 스타일 정의</h3>
<p><img src="/assets/images/posts/book/상태_기반_테스트.jpeg" /></p>

<p>작업이 완료된 후 시스템 상태를 확인하는 것이다.</p>

<p>상태 기반 스타일에서 상태란 SUT나 협력자 중 하나, 또는 DB나 파일시스템과 같은 프로세스 외부 의존성의 상태를 의미할 수 있다.</p>

<h4 id="예제">예제</h4>
<pre><code class="language-kotlin">class Order{
    private val _products: MutableList&lt;Product&gt; = mutableListOf()
    private val products: List&lt;Product&gt;
        get() = _products

    fun addProduct(product: Product){
        _products.add(product)
    }
}

@Test
fun `Adding a product to an order`(){
    val product = Product("Hand wash")
    val sut = Order();

    sut.addProduct(product);

    Assertions.assertEquals(1, sut.products.count())
    Assertions.assertEquals(product, sut.products[0])
}
</code></pre>
<p>addProduct를 검증하는게 아닌 Order의 상태값인 products를 검증했다.</p>

<h3 id="3-통신-기반-스타일-정의">3. 통신 기반 스타일 정의</h3>
<p>목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.</p>

<pre><code class="language-kotlin">@Test
fun `Sending a greetings eamil`(){
    val emailGatewayMock: EmailGateWay = mockk()
    val sut = new Controller(emailGatewayMock)
    val email = "user@email.com"
    every{
        emailGatewayMock.sendGreetingsEmail(email)
    } just run

    sut.greetUser(email)

    verify(exactly = 1){
        emailGatewayMock.sendGreetingsEmail(email)
    }
}
</code></pre>

<h2 id="단위테스트-스타일-비교">단위테스트 스타일 비교</h2>
<p>|                             | 출력 기반 | 상태 기반 |통신 기반|
|—————————–|———|———|——|
|리펙터링 내성을 지키기 위해 필요한 노력|   낮음   |   중간   |  중간 |
|유지비                         |   낮음   |   중간   |  높음 |</p>

<h3 id="결론">결론</h3>
<p>출력 기반 테스트를 선호하자.</p>
<ul>
  <li>코드를 순수함수로 바꾸면 출력 기반 테스트로 변경할 수 있다.
    <ul>
      <li>하지만 모든 코드를 순수 함수로 바꿀 수 없다.</li>
    </ul>
  </li>
</ul>

<h2 id="함수형-아키텍처">함수형 아키텍처</h2>
<p><img src="/assets/images/posts/book/함수형_아키텍처.png" /></p>

<p>함수형 프로그래밍은 수학적 함수(mathematial function)혹은 순수 함수(pure function)이라고 불리우는 함수를 사용하는 프로그래밍이다.</p>

<ul>
  <li>하나의 입력과 하나의 출력이 있으며 둘 다 메서드 시그니처에 명시되어 있다.</li>
  <li>숨은 입출력이 없는 메서드이다.</li>
</ul>

<pre><code class="language-kotlin">fun decimal calculatorDiscount(products: Array&lt;Product&gt;){
    val discount: BigDecimal = products.length * 0.01
    return Math.min(discount, 0.2)
}
</code></pre>

<h3 id="비즈니스-로직과-부수효과를-분리하는-방법">비즈니스 로직과 부수효과를 분리하는 방법</h3>
<p>두 가지 코드 유형을 구분하여 분리할 수 있다,.</p>
<ul>
  <li>결정을 내리는 코드: 해당 코드는 부작용이 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
    <ul>
      <li>함수형 코어</li>
    </ul>
  </li>
  <li>해당 결정에 따라 작용하는 코드: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.
    <ul>
      <li>가변 셸</li>
    </ul>
  </li>
</ul>]]></content><author><name>jeongcool</name></author><category term="book" /><category term="유닛테스트" /><category term="TIL" /><summary type="html"><![CDATA[단위테스트 스타일 요약 단위테스트의 스타일은 3가지로 나뉜다. 상태 기반 출력 기반 통신 기반]]></summary></entry><entry><title type="html">4. 좋은 단위 테스트의 4대요소</title><link href="/book/2023/03/05/4-%EC%A2%8B%EC%9D%80-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-4%EB%8C%80%EC%9A%94%EC%86%8C/" rel="alternate" type="text/html" title="4. 좋은 단위 테스트의 4대요소" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T00:00:00+09:00</updated><id>/book/2023/03/05/4-%EC%A2%8B%EC%9D%80-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-4%EB%8C%80%EC%9A%94%EC%86%8C</id><content type="html" xml:base="/book/2023/03/05/4-%EC%A2%8B%EC%9D%80-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-4%EB%8C%80%EC%9A%94%EC%86%8C/"><![CDATA[<h1 id="4-좋은-단위-테스트의-4대요소">4. 좋은 단위 테스트의 4대요소</h1>
<h2 id="요약">요약</h2>
<p>좋은 단위테스트의 네 가지 특성은 다음과 같다.</p>
<ol>
  <li>회귀 방지</li>
  <li>리팩터링 내성</li>
  <li>빠른 피드백</li>
  <li>유지 보수성</li>
</ol>

<p>이상적인 테스트는 4가지를 모두 만족하는 것이지만 <code>회귀 방지</code>, <code>리팩터링 내성</code>, <code>빠른 피드백</code>은 상호 배타적이므로 달성할 수 없다.</p>

<p>하지만 특정 특성에 집중하고 다른 특성을 버릴 수 없다. 이러한 테스트는 가치가 없다.</p>

<h2 id="1-회귀-방지">1. 회귀 방지</h2>
<p>코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우를 의미한다.</p>

<p>코드베이스가 커질수록 잠재적인 버그에 더 많이 노출되므로 회귀에 대해 효과적인 보호를 개발하는게 중요하다.</p>

<h3 id="회귀-방지-지표에-대한-평가-사항">회귀 방지 지표에 대한 평가 사항</h3>
<ul>
  <li><code>테스트 중 실행되는 코드의 양</code>
    <ul>
      <li>일반적으로 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.</li>
    </ul>
  </li>
  <li><code>코드 복잡도</code> 및 <code>코드의 도메인 유의성</code>
    <ul>
      <li>복잡한 비즈니스 로직을 나타내는 코드가 <code>보일러플레이트 코드(boilerplate code)</code>보다 훨씬 더 중요하다</li>
      <li>비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입힌다.</li>
    </ul>
  </li>
</ul>

<h3 id="etc">ETC</h3>
<ul>
  <li>단순한 코드를 테스트 하는 것은 가치가 거의없다.
    <ul>
      <li>ex. getter, setter</li>
    </ul>
  </li>
  <li>코드 외에 작성하지 않는 코드(라이브러리, 프레임워크, 외부 시스템)를 테스트 하는것도 중요하다.</li>
</ul>

<blockquote>
  <p>회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.</p>
</blockquote>

<h2 id="2-리팩터링-내성">2. 리팩터링 내성</h2>
<p>테스트를 실패로 바꾸지 않고 기본 애플리케이션 코드를 피개터링할 수 있는지에 대한 척도이다.</p>

<h3 id="리팩터링-내성에-대한-평가-사항">리팩터링 내성에 대한 평가 사항</h3>
<ul>
  <li>거짓 양성의 빈도수(적을수록 좋다.)</li>
</ul>

<p>테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가하는 것 인데 여기에 대한 장점은 2가지가 있다.</p>
<ul>
  <li>기존 기능이 고장났을 때 테스트가 조기 경고를 제공한다.
    <ul>
      <li>조기 경고로 결함이 있는 코드가 운영 환경에 배포되기 전에 문제를 해결할 수 있다.</li>
    </ul>
  </li>
  <li>코드 변경이 회귀로 이어지지 않을 것 이라고 확신하게 된다.
    <ul>
      <li>확신이 없다면 리팩터링을 주저하게 되고 코드베이스가 나빠질 가능성이 훨씬 높아진다.</li>
    </ul>
  </li>
</ul>

<p>하지만 거짓 양성은 이 두 가지 이점을 모두 방해한다.</p>
<ul>
  <li>테스트가 타당한 이유 없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희적된다.
    <ul>
      <li>실패에 익숙 -&gt; 신경 X -&gt; 타당한 실패도 무시</li>
    </ul>
  </li>
  <li>거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 떨어져 더 이상 믿을 만한 안정망으로 인식하지 않는다.
    <ul>
      <li>신뢰가 줄어듦 -&gt; 리팩토링이 줄어듦 -&gt; 회귀를 피하려 코드 변경을 최소화</li>
    </ul>
  </li>
</ul>

<h3 id="거짓-양성의-원인">거짓 양성의 원인</h3>
<ul>
  <li>테스트와 SUT의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.</li>
  <li>거짓 양성을 줄이는 방법 : 테스트와 구현 세부 상황을 분리한다.</li>
</ul>

<h3 id="리팩터링-내성를-높이는-방법">리팩터링 내성를 높이는 방법</h3>
<ul>
  <li>코드의 내부 작업과 테스트 사이를 가능 한 멀리 떨어뜨리고 최종 결과를 목표로 한다.</li>
</ul>]]></content><author><name>jeongcool</name></author><category term="book" /><category term="유닛테스트" /><category term="TIL" /><summary type="html"><![CDATA[4. 좋은 단위 테스트의 4대요소 요약 좋은 단위테스트의 네 가지 특성은 다음과 같다. 회귀 방지 리팩터링 내성 빠른 피드백 유지 보수성]]></summary></entry><entry><title type="html">3 단위테스트 구조</title><link href="/book/2023/03/02/3-%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="3 단위테스트 구조" /><published>2023-03-02T00:00:00+09:00</published><updated>2023-03-02T00:00:00+09:00</updated><id>/book/2023/03/02/3-%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="/book/2023/03/02/3-%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%EC%A1%B0/"><![CDATA[<h1 id="3-단위테스트-구조">3 단위테스트 구조</h1>

<h2 id="요약">요약</h2>
<p>해당 장에서는</p>
<ul>
  <li>단위테스트 구조(AAA패턴)</li>
  <li>좋은 단위테스트 명명법</li>
  <li>매개변수화된 테스트(Parameterized Test)</li>
</ul>

<p>과 같은 내용을 배운다.</p>

<p>단위테스트 구조 AAA패턴은 우리가 일반적으로 테스트를 작성하는 Given-When-Then 구조인 BDD와 굉장히 유사하다.</p>

<p>좋은 단위테스트 명명법은 기초적인 문법을 준수해야 하며 개발자가 아닌 다른 사람이 읽어도 이해할 수 있게 짓어야 한다.</p>

<p>그리고 매개변수화된 테스트를 통해 유사하게 작성된 테스트를 여러 개로 묶을 수 있는 기능을 제공한다.</p>

<h2 id="1-단위테스트를-구성하는-방법">1. 단위테스트를 구성하는 방법</h2>
<h3 id="aaaarrange-act-assert-패턴-사용">AAA(Arrange, Act, Assert) 패턴 사용</h3>
<p>AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 부분으로 나눈다.</p>
<ol>
  <li>준비 구절에서 SUT과 해당 의존성을 원하는 상태로 만든다.</li>
  <li>실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며
(출력이 있다면) 출력값을 캡처한다.</li>
  <li>검증 구절에서는 결과를 검증한다.<br />
결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.</li>
</ol>

<pre><code class="language-kotlin">class Calculator{
    fun sum(first: Double, second: Double): Double 
        = second + second
}

internal class CalculatorTests{

    @Test
    fun void `Sum of two numbers`(){
        // 준비(Arrange)
        val first = 10
        val second = 20
        val calculator = Calculator()

        // 실행(Act)
        val result = calculator.sum(first, second)

        // 검증(Assert)
        Assertions.assertEquals(30, result)
    }
}
</code></pre>

<p>AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다. -&gt;결국 전체 테스트 스위트의 유지 보수 비용이 줄어든다.</p>

<h3 id="피해야-할-것">피해야 할 것</h3>
<h4 id="1-여러-개의-준비-실행-검증-구절-피하기">1. 여러 개의 준비, 실행, 검증 구절 피하기</h4>
<p>여러 개의 동작 단위를 검증하는 테스트를 의미하게 되고 이러한 테스트는 더 이상 단위 테스트가 아니라 통합테스트이다.</p>

<p>실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고 간단하고, 빠르며, 이해하기 쉽다.</p>

<h4 id="2-테스트-내-if-문-피하기">2. 테스트 내 if 문 피하기</h4>
<p>if 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 즉, 테스트를 여러 개로 나눌 수 있다.</p>

<p>통합테스트에도 분기가 늘어나 얻는 이점이 없다.</p>

<h3 id="aaa패턴의-각-구절의-크기">AAA패턴의 각 구절의 크기</h3>
<ul>
  <li>일반적으로 준비 구절이 가장 크다.
    <ul>
      <li>훨씬 크면 테스트 내 비공개 메서드 or 별도의 팩토리 클래스로 도출하는 게 좋다.
        <ul>
          <li>Object Mother, Test Data Builder</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>실행 구절은 보통 코드 한줄이다.
    <ul>
      <li>실행 구절이 두 줄 이상이라면 SUT의 공개 API에 문제가 있을 수 있다.</li>
    </ul>
  </li>
  <li>단일 동작 단위는 여러 결과를 낼 수 있어 하나의 테스트로 그 모든 결과를 평가해도 좋다
    <ul>
      <li>하지만, 검증 구절이 너무 커지는 것은 제품 코드에서 추상화가 누락될 수 있다는 의미다.</li>
    </ul>
  </li>
</ul>

<h3 id="sut-구별하기">SUT 구별하기</h3>
<p>SUT는 애플리케이션에서 호출하고 하는 동작에 대한 진입점을 제공한다.</p>

<p>그러나 진입점은 오직 하나만 존재할 수 있다.</p>

<p>그러므로 SUT를 의존성과 구분하는 것이 중요하다.</p>

<pre><code class="language-kotlin">internal class CalculatorTests{

    @Test
    fun void `Sum of two numbers`(){
        // 준비(Arrange)
        val first = 10
        val second = 20
        val sut = Calculator()

        // 실행(Act)
        val result = sut.sum(first, second)

        // 검증(Assert)
        Assertions.assertEquals(30, result)sut
    }
}
</code></pre>
<p>이처럼 테스트 내 SUT 변수명을 sut로 구분하면 자연스럽게 구분이 된다.</p>

<h3 id="추가로">추가로</h3>
<ul>
  <li>테스트 시 준비 구절부터 시작하는게 아닌 검증 구절부터 시작하는 방법도 있다. (TDD를 실천할 때)</li>
  <li>AAA패턴은 <code>Given-When-Then</code>패턴과 차이는 없지만, 프로그래머가 아닌 사람에게 더 읽기 쉬운 구조이다.</li>
</ul>

<h2 id="2-테스트-간-테스트-픽스처-재사용">2. 테스트 간 테스트 픽스처 재사용</h2>
<p>테스트 픽스처는 테스트 실행 대상 객체다.</p>
<ul>
  <li>DB나 하드 디스크의 파일일 수 있다.</li>
  <li>이러한 객체는 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다.</li>
</ul>

<h3 id="올바르지-않은-테스트-간-테스트-픽스처-재사용">올바르지 않은 테스트 간 테스트 픽스처 재사용</h3>
<h4 id="테스트-간-높은-결합도는-안티패턴">테스트 간 높은 결합도는 안티패턴</h4>
<p>준비 구절을 테스트 간 공유하게 된다면 모든 테스트가 서로 결합되고 만약 테스트의 준비 로직을 수정하면 클래스 속 모든 테스트에 영향을 미친다.</p>

<h4 id="테스트-가독성을-떨어뜨리는-생성자-사용">테스트 가독성을 떨어뜨리는 생성자 사용</h4>
<p>준비 코드를 생성자로 추출할 때 단점은 테스트 가독성을 떨어뜨리는 것이다.</p>
<ul>
  <li>테스트가 무엇을 하는지 이해하려면 클래스의 다른 부분을 봐야한다.</li>
</ul>

<h3 id="더-나은-테스트-픽스처-재사용법">더 나은 테스트 픽스처 재사용법</h3>
<ul>
  <li>비공개 팩토리 메서드</li>
</ul>

<h2 id="3-단위-테스트-명명법">3. 단위 테스트 명명법</h2>
<ul>
  <li>엄격한 명명 정책을 따르지 않는다.</li>
  <li>문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자</li>
  <li>단어를 밑줄(_) 표시로 구분한다.
    <ul>
      <li>Kotlin에서는 백틱(`)으로 함수 이름을 감싸면 띄어쓰기를 사용할 수 있다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>테스트 클래스 이름을 지을 때 <code>[클래스명]Tests</code> 패턴을 사용하지만 테스트가 해당 클래스만 검증하는 것으로 제한하는게 아니다.
단위 테스트에서 단위는 동작의 단위지 클래스의 단위가 아니다.</p>
</blockquote>

<h3 id="테스트-이름-명명시-피해야-하는-사항">테스트 이름 명명시 피해야 하는 사항</h3>
<ul>
  <li>테스트 이름에 SUT의 매서드 이름을 포함하지 않는다.</li>
  <li>사실을 서술할 때 소망이나 욕구가 들어가지 않는다. (ex. should be 문구)</li>
</ul>

<h2 id="4-매개변수화된-테스트">4. 매개변수화된 테스트</h2>
<p>보통 테스트 하나로는 동작 단위를 완전하게 설명하기 충분하지 않다.</p>

<p>동작이 충분히 복잡하면 이를 설명하는 데 테스트 수가 급격히 증가할 수 있으며 관리하기 어려워질 수 있다.</p>

<p>대부분의 단위 테스트 프레임워크는 유사한 테스트를 묶을 수 있는 매개변수화된 테스트 기능을 제공한다.</p>

<h3 id="예시">예시</h3>
<p>아래와 같이 가장 빠른 배송일이 오늘로부터 이틀 후가 되도록 작동하는 배송기능이 있다면</p>
<pre><code class="language-kotlin">fun `Deliverty for today is invalid`()
fun `Deliverty for tomorrow is invalid`()
fun `The soonest delivery date is two days from now`()
</code></pre>

<pre><code class="language-kotlin">@ParameterizedTest
@CsvSource(
    "HECTO_FINANCIAL,CARD,1000",
    "NONE,MAINTENANCE_FEE,2000",
    "NONE,ZERO,0",
)
fun `Can detect an invalid delivery date`(
    daysFromNow: Int,
    expected: Boolean
)
</code></pre>]]></content><author><name>jeongcool</name></author><category term="book" /><category term="유닛테스트" /><category term="TIL" /><summary type="html"><![CDATA[3 단위테스트 구조]]></summary></entry></feed>