<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>4. 컴포넌트 원칙</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">4. 컴포넌트 원칙</h1><post-metadata layout="inline" categories='["book"]' tags='["클린아키텍처","TIL"]' date="April 30, 2023" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="4-컴포넌트-원칙">4. 컴포넌트 원칙</h1><h2 id="컴포넌트란">컴포넌트란</h2><p>컴포는트는 배포 단위이며 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.</p><p><strong>예시</strong></p><ol><li>Java의 jar, war</li><li>루비의 gem</li><li>.Net에서 DLL</li></ol><p>잘 설계된 컴포넌트라면 반드시 독립적으로 배포(개발) 가능한 능력을 갖춰야 한다.</p><h2 id="컴포넌트의-역사">컴포넌트의 역사</h2><h3 id="1-소프트웨어-개발-초창기에-메모리에서-프로그램-위치와-레이아웃을-프로그래머가-직접-제어했다">1. 소프트웨어 개발 초창기에 메모리에서 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.</h3><ul><li>이 떄 당시 라이브러리는 바이너리가 아닌 소스코드 형태로 존재했다.</li><li>하지만 이 방식은 컴파일 시 매우 느린 단점이 있다.<h3 id="2-컴파일-시간을-단축시키기-위해-함수-라이브러리-소스코드를-애플리케이션-코드로부터-분리했다">2. 컴파일 시간을 단축시키기 위해 함수 라이브러리 소스코드를 애플리케이션 코드로부터 분리했다.</h3></li><li>하지만 라이브러리가 점점 커졌고 할당된 메모리 주소를 넘거가게 되는데<h3 id="3-재배치가-가능한-바이너리relocatable-bineary">3. 재배치가 가능한 바이너리(<code>relocatable bineary</code>)</h3></li><li>지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일을 수정하자는 개념</li><li>로더는 재배치 코드가 자리할 위치 정보를 전달받음 -&gt; 재배치 코드에는 로드한 데이터의 변경 부분을 주소에 로드할 수 있는지 알려주는 플래그 삽입</li><li>이제 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었음</li><li>실제로 로더는 바이너리를 입력받은 후 단순히 하나씩 차례로 메모리로 로드하며 재배치하는 작업을 처리<ul><li>이를 통해 프로그래머는 오직 필요한 함수만 로드 할 수 있게 됨</li></ul></li><li>또한 컴파일러는 재배치 가능한 바이너리 안에 함수 이름을 메타데이터 형태로 생성하도록 수정<ul><li>만약 프로그램이 라이브러리 함수를 호출한다면 라이브러리 함수 이름을 외부 참조(<code>external reference</code>)로 생성</li><li>반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의(<code>external definition</code>)로 생성</li><li>이렇게 하여 외부 정의 에 링크시킬 수 있게 됨</li><li>이렇게 링킹 로더(<code>linking loader</code>)가 탄생</li></ul></li></ul><h3 id="4-링커">4. 링커</h3><ul><li>링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.</li><li>하지만, 프로그램은 훨씬 커지게 되며 링킹 로더가 너무 느려졌다.<blockquote><p>링킹 로더가 프로그램 하나를 로드하는 데만 한 시간 이상 걸리게 되었다. (자기테이프 사용)</p></blockquote></li><li>마침내 로드와 링크가 두 단계로 분리<ul><li>프로그래머가 느린 부분 즉, 링크 과정을 맡음</li><li>링커 라는 별도의 애플리케이션으로 해당 작업을 처리하도록 만듦</li><li>링커는 링크가 완료된 재배치 코드를 만들어 주어 로더의 로딩 과정이 아주 빨라짐</li><li>한번 만들어둔 실행 파일은 언제라도 빠르게 로드 할 수 있게 되었다.</li></ul></li></ul><h3 id="5-무어의-법칙">5. 무어의 법칙</h3><ol><li>1980년대 소스 모듈은 .c파일에서 .o파일로 컴파일 후 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어짐</li><li>각 모듈을 컴파일 하는 시간은 상대적으로 빠르지만 전체 모듈을 컴파일하는 일은 꽤 시간이 걸림</li><li>1980년대 후반에 들어서자 디스크는 작아졌으며 RAM의 용량은 커졌다. 컴퓨터 메모리는 저렴해짐</li><li>1990년대 후반이 되자, 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는게 더 빨라지기 시작함.</li><li>이렇게 Active X와 공유 라이브러리 시대가 열리고 .jar파일 등장</li></ol><h3 id="결론-이-책에서의-컴포넌트">결론: 이 책에서의 컴포넌트</h3><p>런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일</p><h2 id="컴포넌트-응집성">컴포넌트 응집성</h2><blockquote><p>이 클래스를 어느 컴포넌트에 포함시켜야 할까?</p></blockquote><p>해당 장에서는 컴포넌트 응집성과 관련된 세 가지 원칙을 논의한다.</p><ul><li>REP(<code>Reuse/Release Equivalence Principle</code>): 재사용/릴리스 등가 원칙</li><li>CCP(<code>Common Closure Principle</code>): 공통 폐쇄 원칙</li><li>CRP(<code>Common Reuse Principle</code>): 공통 재사용 원칙</li></ul><h3 id="1-rep-재사용릴리즈-등가-원칙">1. REP: 재사용/릴리즈 등가 원칙</h3><blockquote><p>재사용 단위는 릴리즈 단위와 같다.</p></blockquote><h3 id="2-ccp-공통-폐쇄-원칙">2. CCP: 공통 폐쇄 원칙</h3><blockquote><p>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라</p></blockquote><h3 id="3-crp-공통-재사용-원칙">3. CRP: 공통 재사용 원칙</h3><blockquote><p>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라</p><h2 id="컴포넌트-결합">컴포넌트 결합</h2></blockquote></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/book/2023/03/19/8-%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/" class="nav-link">8. 통합 테스트를 하는 이유</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2023/07/26/plan-archive/" class="nav-link">Plan Archive</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>