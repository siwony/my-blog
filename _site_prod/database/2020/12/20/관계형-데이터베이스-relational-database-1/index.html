<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>관계형 데이터베이스 - Relational database</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">관계형 데이터베이스 - Relational database</h1><post-metadata layout="inline" categories='["database"]' tags='["TIL"]' date="December 20, 2020" reading-time="4" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="관계형-데이터베이스---relational-database">관계형 데이터베이스 - Relational database</h1><p>: table로 이루어져 있고, 이 table은 key 와 value의 관계를 나타낸다 이처럼 데이터의 종속성을 관계(relationship)로 표현하는것</p><ul><li>1970년 영국의 수학자인 E. F. Codd 박사의 논문에서 제안<blockquote><p>1980년에 상용화 되었다.</p></blockquote></li><li>기업의 핵심 데이터는 대부분 관계형 DB로 저장되어 있다.</li><li>관계형 DB는 SQL문장에 의해 관리된다.</li></ul><h2 id="구성요소">구성요소</h2><h3 id="열column">열(column)</h3><ul><li>각각의 열(field or attribute)은 유일한 이름을 가지고있다.</li><li>자신만의 타입을 가지고 있다.<h3 id="행row">행(row)</h3></li><li>= tuple, record</li><li>관계된 데이터의 묶음 의미</li><li>한 테이블의 모든 행은 같은 수의 열을 가지고 있다.<h3 id="값value">값(value)</h3></li><li>테이블은 각각의 행(row) 열(column)에 대응하는 값(value)를 가지고 있다.</li><li>열(column)의 타입에 맞는 값이여야 한다.<h3 id="key">Key</h3><p>: table 에서 행의 식별자로 이용되는 key or 기본 키(primary key)<br>즉 table에 저장된 record를 고유하게 식별하는 후보 키(candidate key) 중에 DB 설계자가 지정한 속성을 의미</p><h3 id="관계">관계</h3><ol><li>일대일 (one-to-one) 관계</li><li>일대다 (one-to-many) 관계</li><li>다대다 (many-to-many) 관계<blockquote><p>ERD로는 일대다 다대일 테이블로 관계를 나타낸다. (총 테이블 3개가 필요함)</p><h3 id="스키마schema">스키마(schema)</h3><p>: 데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. 총 3가지가 있다. (외부 스키마, 내부 스키마, 개념 스키마)</p></blockquote></li></ol></li><li>일반적으로 스키마는 <strong>내부 스키마를 가르킨다.</strong></li></ul><h4 id="1-외부-스키마">1. 외부 스키마</h4><p>: 개인의 입장, ‘서브스키마’라고도 한다, 사용자 뷰를 가리킨다.</p><ul><li>하나의 외부스키마는 여럿이 공유 가능하며,</li><li>하나의 DB시스템에 여러 개의 외부스키마가 존재 가능</li></ul><h4 id="2-내부-스키마">2. 내부 스키마</h4><p>: 시스템 프로그래머나 설계자의 관점에서 바라보는 스키마이다. (ex. DBA)</p><ul><li>데이터베이스의 물리적 구조를 가리킨다</li><li>즉, <strong>실제 저장방법을 기술하는 물리적인 저장장치와 관련되는 스키마 이다.</strong></li><li>DB의 전체적인 구조로써 하나만 존재해야 함</li></ul><h4 id="3-개념-스키마">3. 개념 스키마</h4><p>: 조직 전체의 입장, 전체적인 뷰를 가리킨다.</p><ul><li>개체간의 관계와 제약조건을 나타내고,</li><li>DB의 <code>접근권한</code>, <code>보안</code>, <code>무결성</code> 규칙에 대한 명세를 정의한다.</li></ul><h2 id="key-1">key</h2><p>: DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다.</p><h3 id="후보키candidate-key"><strong>후보키(Candidate Key)</strong></h3><ol><li><strong>기본키로 사용할 수 있는 속성을 가지고 있다.</strong></li><li>모든 릴레이션에는 <strong>반드시 하나 이상의 후보키가 존재한다.</strong></li><li>릴레이션에 있는 모든 튜플에 대해서 <strong>유일성</strong>과 <strong>최소성</strong>을 만족시켜야 함.<blockquote><p>유일성: 하나의 key값으로 하나의 튜플만을 유일하게 식별할 수 있어야한다.<br>최소성: 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성만으로 구성되어 있어야 한다.</p></blockquote></li></ol><h3 id="기본키primary-key">기본키(Primary Key)</h3><p>: 특정 튜플을 유일하게 구별할 수 있는 속성이다.</p><ol><li>후보키 중에서 선택한다.</li><li><strong>Null값을 가질 수 없다</strong>.</li><li>동일한 값이 <strong>중복되어 저장될 수 없다.</strong></li></ol><h3 id="대체키alternate-key">대체키(Alternate Key)</h3><p>: 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다.</p><h3 id="슈퍼키super-key">슈퍼키(Super Key)</h3><p>: 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 의미한다.</p><blockquote><p>예시) 한 릴레이션에 속성 A와 B는 key로 나타낼 수 없지만 두개의 속성을 묶으면 유일성을 만족할 수 있는 형태</p><ul><li>릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.</li><li>슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.</li></ul></blockquote><h3 id="외래키foregin-key">외래키(Foregin Key)</h3><p>: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합이다.</p><blockquote><p>한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인상에서 정의되었을 때의 속성 A를 외래키라고 한다.</p><ul><li>외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.</li></ul></blockquote><h2 id="relational-model-constraints">Relational Model Constraints</h2><h3 id="1-도메인-제약---domain-constraints">1. 도메인 제약 - Domain Constraints</h3><ul><li>속성 값은 <code>원자성 - atomicity</code>을 가지며, 도메인에서 정의된 값이어야 한다.<blockquote><p>ex. 나이는 정수형이어야 하고, 0 ~ 150의 숫자 범위를 가진다.</p></blockquote></li><li><code>Composite Attribute</code>와 <code>Multivalued Attribute</code>는 허용되지 않는다.</li><li>NOT NULL이 아닌경우 NULL 값은 허용된다.</li></ul><h3 id="2-키-제약---key-constraints">2. 키 제약 - Key Constraints</h3><p>: 릴레이션의 모든 <code>튜플 - Tuples</code>은 유일하게 서로 <strong>식별 가능</strong>해야 한다.</p><ul><li>cf) Super Key, Candidate Key, Primary Key</li></ul><h3 id="3-개체-무결성-제약---entity-integrity-constraints">3. 개체 무결성 제약 - Entity Integrity Constraints</h3><p>: PK는 <strong>NOT NULL &amp;&amp; UNIQUE</strong>이어야 한다.</p><h3 id="4-참조-무결성-제약---referential-integrity-constraints">4. 참조 무결성 제약 - Referential Integrity Constraints</h3><ul><li>릴레이션 A가 릴레이션 B를 참조하는 경우, B의 기본키는 A의 외래키로 사용되는 경우<ul><li>외래키는 NULL 이거나,</li><li>NULL 이 아닌 경우 B에 실제로 존재하는 값으로 구성되어야 한다.</li></ul></li></ul><h2 id="트랜잭션transaction">트랜잭션(transaction)?</h2><p>: DBMS에서 하나의 작업의 단위<br>트랜잭션의 기능을 제대로 수행하기 위해 네가지 특성을 만족해야한다(ACID 특성)</p><p><strong>트랜잭션의 제기능 하지 못하면?</strong></p><blockquote><p>예를 들어 은행에서 서로다른 ATM기기에서 2명이 동시에 A계좌(1000원 들어있음)의 1000원을 인출하고 가정하자.<br>만약 거의 동시에 인출을 시도했을 때 트랜잭션이 제대로 기능하지 않으면 DB상으로 돈은 1000원 밖에 빠져나가지만 실제로는 2000원이 빠져나가게 된다.<br>0.000001초라도 빠른 사람의 요청을 수행하고 나머지 사람에게는 지급부족으로 요청을 거절해야한다.</p></blockquote><p>이러한기능을 제대로 수행하기 위한것이 <strong>트랜잭션 의 ACID</strong> 이다.</p><h3 id="acid특성">ACID특성</h3><ul><li><dl><dt><strong>원자성(Atomicity)</strong></dt><dd>트랜잭션이 수행하는 연산들을 모두 정상적으로 처리 or 모두 처리하지 않아야 한다는 all-or-nothing 방식을 의미</dd></dl></li><li><dl><dt><strong>일관성(Consistency)</strong></dt><dd>트랜잭션이 성공적으로 수행된 이후에도 <strong>DB의 데이터는 일관된 상태를 유지해야한다.</strong></dd></dl></li><li><dl><dt><strong>격리성(Isolation)</strong></dt><dd>하나의 트랜잭션이 완료될 때까지 다른 트랜잭션이 간섭하지 못하도록 하여 <strong>각각의 트랜잭션이 독립적으로 수행되여야 한다.</strong></dd></dl></li><li><dl><dt><strong>지속성(Durability)</strong></dt><dd>트랜잭션이 성공적으로 완료된 이후 DB에 <strong>데이터들이 영구적으로 보존되어야 한다.</strong></dd></dl></li></ul><h4 id="refrenece">Refrenece</h4><ul><li><a href="https://youtu.be/AAv0lT6KxyY">국민대학교 김남규 교수 - (DB실무) Part3-데이터 모델과 성능(1/6)</a></li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/database/2020/12/20/mysql%EC%84%A4%EC%B9%98mac/" class="nav-link">MySQL설치(mac)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/database/2020/12/20/%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-relational-database/" class="nav-link">관계형 데이터베이스 - Relational database</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>