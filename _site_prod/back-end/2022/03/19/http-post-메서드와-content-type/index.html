<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HTTP POST 메서드와 Content-Type</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">HTTP POST 메서드와 Content-Type</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring-mvc","spring","TIL"]' date="March 19, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="http-post-메서드와-content-type">HTTP POST 메서드와 Content-Type</h1><p>Spring Boot를 사용해 API서버를 만들면 POST메서드를 통해 요청을 받을 때 body에 JSON형태로 통신한다는 전제로 개발을 하게 된다.</p><p>하지만, JSON 형태가 아닌 다른 형식으로 클라이언트에서 요청을 보내야 할 때가 있다.<br>파일을 전송하거나 파일과 데이터를 함께 전송하고 싶으면 <code>multipart/form-data</code> 형식으로 요청하고,<br>POST 형식에서 QueryString 형태로 body에 값을 전송하고 싶다면 <code>application/x-www-form-urlencoded</code> 형식으로 요청한다.</p><h4 id="multipartform-data">multipart/form-data</h4><p>각각의 데이터를 구분하는 boundary와 데이터를 구분하는 boundary 사이에 데이터와 데이터를 구분하는 Content-Type이 필수적으로 있는 요청 방식</p><p><strong>요청 예시</strong></p><pre><code class="language-http">POST /foo HTTP/1.1
Content-Length: 68137
Content-Type: multipart/form-data; boundary=---------------------------974767299852498929531610575
Content-Disposition: form-data; name="description"
---------------------------974767299852498929531610575

some text

---------------------------974767299852498929531610575
Content-Disposition: form-data; name="myFile"; filename="foo.txt"
Content-Type: text/plain

(content of the uploaded file foo.txt)

---------------------------974767299852498929531610575--
</code></pre><h4 id="applicationx-www-form-urlencoded">application/x-www-form-urlencoded</h4><p><code>&amp;</code>로 분리되고, <code>=</code> 기호로 키와 값을 연결하는 key-value tuple로 인코딩되는 형식의 요청 방식</p><p>예시</p><pre><code class="language-http">POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&amp;to=Mom
</code></pre><h3 id="이-문서를-정리하게-된-동기">이 문서를 정리하게 된 동기</h3><p><code>@RequestBody</code>를 통해 특정 API에서 데이터를 받을 때 Content-Type이 <code>application/x-www-form-urlencoded</code>인 요청받았다면 다음과 같은 에러가 발생한다.</p><pre><code class="language-json">{
    "timestamp": "2021-11-30T14:01:38.862+00:00",
    "status": 415,
    "error": "Unsupported Media Type",
    "trace": "org.springframework.web.HttpMediaTypeNotSupportedException: Content type 'multipart/form-data;boundary=--------------------------626757645175388487558235;charset=UTF-8' not supported\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:206)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:160) ...",
    "message": "Content type 'multipart/form-data;boundary=--------------------------626757645175388487558235;charset=UTF-8' not supported",
    "path": "/board/write"
}
</code></pre><p>이 문서는 위와 같은 에러를 겪고 Content-Type의 개념과 Content-Type 별 요청을 어떻게 처리해야 하는지 궁금하게 되었고 이를 공부한 후 작성한 글이다.</p><h2 id="applicationx-www-form-urlencoded-content-type의-데이터를-받는-방법">applicationx-www-form-urlencoded Content-Type의 데이터를 받는 방법</h2><h3 id="1-requestparam">1. @RequestParam</h3><blockquote><p>지저분한 방법이라 3번을 사용하는 것을 추천한다. ```java @PostMapping(value = “signup”) public String upload(@RequestParam String email, @RequestParam String password) {</p></blockquote><pre><code>return "응애"; } ```
</code></pre><h3 id="2-requestbody-multivaluemapk-v">2. <code>@RequestBody MultiValueMap&lt;K, V&gt;</code></h3><p><code>MultiValueMap과</code> 함께 <code>@RequestBody</code>를 사용하면 <code>AnnotationMethodHandlerAdapter</code>에 의해 <code>FormHttpMessageConverter</code>가 등록하게 된다.</p><pre><code class="language-java">@PostMapping("signup")
public String upload(@RequestBody MultiValueMap&lt;String, String&gt; data) { 
    log.info("MultiValueMap&lt;String, String&gt;: {}", data);
    return data.toString();
}
</code></pre><p>Content-Type은 <code>application/x-www-form-urlencoded</code>이고 <code>/signup</code>에 <code>name=siwony&amp;password=1234</code> 이렇게 요청을 보내면 다음과 같이 로깅이 되어 출력된다.</p><pre><code class="language-sh">MultiValueMap&lt;String, String&gt;: {email=[siwon103305@gmail.com], password=[siwon]}
</code></pre><p><code>MultiValueMap</code>은 <code>Map&lt;K, List&lt;V&gt;&gt;</code>을 상속받고 있다. 이유는</p><h3 id="3-modelattribute">3. @ModelAttribute</h3><p><a href="command-object.md"><strong>커맨드 객체</strong></a>와 함께 <code>@ModelAttribute</code>를 사용하면 2번과 같이 <code>FormHttpMessageConverter</code>가 등록되어 해당 객체로 바인딩 할 수 있다.</p><ul><li><code>@ModelAttribute</code>는 생략 가능하다. ```java @PostMapping(“signup”) public String upload(@ModelAttribute MemberDto memberDto) { log.info(“MultiValueMap&lt;String, String&gt;: {}”, memberDto); return data.toString(); }</li></ul><p>// MemberDto @Getter @NoArgsConstructor // Getter와 기본생성자는 무조건 존재해야 한다. public class MemberDto{ private String email; private String password; }</p><pre><code>
## multipart/form-data의 데이터를 받는 방법

### 1. @RequestParam
지저분한 방법이라 2번을 사용하는 것을 추천한다.

**예시**
```java
@PostMapping(value = "signup")
public String upload(@RequestParam String email,
                    @RequestParam String password,
                    @RequestParam Multipart img) {
    return "응 그래";
}
</code></pre><h3 id="2-modelattribute">2. @ModelAttribute</h3><p><code>applicationx-www-form-urlencoded Content-Type</code>의 데이터를 받는 방법이랑 똑같이 인자에<br><em><code>@ModelAttribute</code> + 커맨드객체</em> 와 같은 방법으로 사용한다.<br><strong>하지만 요청시 데이터를 받아 바운딩 할 객체에는 다음 예시와 같이 <code>MultipartFile</code>객체가 존재해야된다.</strong></p><h4 id="올바른-예시">올바른 예시</h4><pre><code class="language-java">// controller
@PostMapping("signup")
public String login(@ModelAttribute MemberDto memberDto) { 
    log.info("MultiValueMap&lt;String, String&gt;: {}", memberDto);
    return data.toString();
}

============================================================

// MemberDto
@Getter @NoArgsConstructor  // Getter와 기본생성자는 무조건 존재해야 한다.
public class MemberDto{
    private String email;
    private String password;
    private MultipartFile img;
}
</code></pre><p>만약 위 예시의 <code>MultipartFile</code>타입의 <code>img</code>맴버 변수가 없을 경우 해당 요청의 Content-Type은 applicationx-www-form-urlencoded로 판단하고 415에러가 발생한다.</p><p>이는 <code>@PostMapping</code>의 consumes속성에 <code>application/x-www-form-urlencoded</code>를 지정하면 된다.</p><blockquote><p>하지만 구지 file데이터를 받지 않는데 <code>multipart/form-data</code>를 사용해야 하는 이유가 있을까?</p></blockquote><h4 id="consumes속성을-바꾼-예시">consumes속성을 바꾼 예시</h4><pre><code class="language-java">import org.springframework.http.MediaType;

// class 선언 생략

@PostMapping(value = "signup", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public String login(@ModelAttribute MemberDto memberDto) {
    log.info("MemberDto: {}", memberDto);
    return memberDto.toString();
}
</code></pre></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/network/2022/03/19/grpc-google-remote-procedure-call/" class="nav-link">gRPC - google Remote Procedure Call</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/cs/2022/03/19/ipc-inter-process-comunication/" class="nav-link">IPC - Inter Process Comunication</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>