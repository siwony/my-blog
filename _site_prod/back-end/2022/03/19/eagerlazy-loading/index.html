<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Eager/LAZY loading</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Eager/LAZY loading</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="eagerlazy-loading">Eager/LAZY loading</h1><h3 id="과연-member만-조회할-때-team도-조회해야-할까">과연 Member만 조회할 때 Team도 조회해야 할까?</h3><p>&lt;img width=400px src=./img/when-member-get-team.png&gt;</p><ul><li>단순히 Member만 조회하는 로직에서는 굉장히 비효율적이다.</li><li>Member를 조회하는데 Team을 조회하는 비효율적인 상황이 일어난다.</li></ul><p><strong>→ LAZY(지연) loading을 이용하여 이 부분을 해결할 수 있다.</strong></p><h3 id="lazy">LAZY</h3><p>: 연관된 엔티티를 <code>즉시(Eager)</code>로 가져오는 것이 아닌 <code>Proxy(대리자) 객체</code>를 통해 필요할 때만 연관된 엔티티를 가져오는것<br><code>fetch = FetchType.LAZY</code></p><blockquote><p>비즈니스 로직에서 연관된 엔티티를 조회하는 경우가 별로 없는 경우</p></blockquote><p>&lt;img width=450px src=./img/lazy-loading.png&gt;</p><pre><code class="language-java">@Entity
public class Member {

@Id @GeneratedValue 
private Long id;

@Column(name = "USERNAME")
private String name; 

@ManyToOne(fetch = FetchType.EAGER) //** @JoinColumn(name = "TEAM_ID")
private Team team;
//etc....
}
</code></pre><ul><li>실제로 LAZY를 통해 조회를하면 Team의 Proxy 객체를 조회한다.<br>→ Proxy 객체는 아무값도 없다.</li></ul><h3 id="1-lazy를-사용한-프록시를-통한-조회">1. LAZY를 사용한 프록시를 통한 조회</h3><p>&lt;img width=450px src=./img/lazy-proxy-find.png&gt;</p><pre><code class="language-java">Team team = member.getTeam(); // 프록시 객체
team.getTeam // 실제 Team을 사용하는 시점에서 초기화 -&gt; 이때 쿼리를 날린다.
</code></pre><ul><li>Member 단독으로 조회할 때는 <code>LAZY</code>가 효율적이다.</li><li>Member가 90%정도 단독으로 사용한다면 <code>LAZY</code>가 효율적이다.</li><li>하지만 Member와 Team을 동시에 조회해야 할 경우가 엄청 많은 경우 <code>EAGER(즉시)</code> loading이 이득이다.</li></ul><h3 id="eager">EAGER</h3><p>: 한방쿼리를 날려 연관된 엔티티를 한꺼번에 조회한다. → Proxy가 필요 없다.<br><code>fetch = FetchType.EAGER</code></p><blockquote><p>비즈니스 로직에서 연관된 엔티티를 조회하는 경우가 많은 경우</p></blockquote><p>&lt;img width=450px src=./img/eager-loading.png&gt;</p><h3 id="1-eager를-사용한-조회">1. EAGER를 사용한 조회</h3><p>&lt;img width=400px src=./img/eager-find.png&gt;</p><ul><li>JPA 구현체는 가능하면 조인을 사용하여 SQL을 한 번에 함께 조회한다.</li></ul><h3 id="2-eager-주의-사항---실무경험-공유">2. EAGER 주의 사항 - 실무경험 공유</h3><ul><li><strong>가급적 지연 로딩만 사용하자(특히 실무에서)</strong></li><li>즉시로딩을 적용하면 예상치 못한 SQL이 발생한다.<blockquote><p>연관된 테이블이 10개 이상이라고 생각해보자 끔찍하다.</p></blockquote></li><li><strong>즉시로딩은 JPQL에서 N + 1 문제를 발생한다.</strong> → 그냥 <code>LAZY</code>로 설정하고 <code>FETCH JOIN</code>을 사용하자.<ol><li>만약 <code>select m from Member m</code> 라는 JPQL을 사용하면 → 대충 쿼리가 <code>select * from member</code> 이런 식으로 나간다..</li><li>Member를 조회했지만 연관된 엔티티가 EAGER로 되어있다.</li><li>그러면 다시 한번 연관된 엔티티를 조회하기 위해 query가 또나온다.<blockquote><p>N + 1: (1)처음 쿼리를 날리면 (N)개의 쿼리가 따라온다.</p></blockquote></li></ol></li><li><code>@OneToMany</code>, <code>@ManyToMany</code>는 기본이 지연로딩이다.</li></ul><h2 id="마무리---실무">마무리 - 실무</h2><h4 id="모든-연관관계에-지연-로딩을-사용해라">모든 연관관계에 지연 로딩을 사용해라</h4><h4 id="실무에서-즉시-로딩을-사용하지-마라--상상치-못한-쿼리가-나간다">실무에서 즉시 로딩을 사용하지 마라 → 상상치 못한 쿼리가 나간다.</h4><h4 id="jpql-fetch-join이나-엔티티-그래프-기능을-사용해라"><code>JPQL fetch join</code>이나, <code>엔티티 그래프 기능</code>을 사용해라</h4></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/didependency-injection-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85/" class="nav-link">DI(Dependency Injection, 의존성 주입)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/entity/" class="nav-link">Entity</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>