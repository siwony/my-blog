<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>프로젝션</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">프로젝션</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","JPQL","TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="프로젝션">프로젝션</h1><p>: SELECT 절에 조회할 대상을 지정하는것</p><ul><li>프로잭션으로 관리되는 Entity는 모두다 영속성 컨텍스트에 관리된다.<h3 id="프로젝션-대상">프로젝션 대상</h3><h3 id="1-엔티티">1. 엔티티</h3><h4 id="select-m-from-member-m"><strong><code>SELECT m FROM Member m</code></strong></h4><p>```java List<member>result = em .createQuery("SELECT m FROM Member m", Member.class).getResulteList();</member></p></li></ul><p>Member findMember = result.get(0); findMember.setAge(20) //업데이트 쿼리가 나간다 즉 영속성 컨텍스트에 관리가 된다.</p><pre><code>&gt; JPQL에서 조회한 Member는 영속성 컨텍스트에 관리된다.  
&gt; &amp;rarr; Age를 변경했더니 업데이트 쿼리가 나갔다.

#### `SELECT m.team FROM Member m`
&gt; Memeber에서 Team을 가져오려면 결국 Member와 Team을 join해야한다.
```java
//List&lt;Team&gt; result = em .createQuery("SELECT m.team FROM Member m", Team.class).getResulteList(); // 명시적조인
//
List&lt;Team&gt; result = 
  em .createQuery("SELECT t FROM Member m join m.team t", Team.class).getResulteList();
</code></pre><ul><li><code>SELECT m.team FROM Member m</code>과 같이 <strong>묵시적 조인</strong>을 하지 않는게 좋다.<blockquote><p>나중에 운영하면서 쿼리를 튜닝해야 할떄가 생긴다.</p></blockquote></li><li><code>SELECT t FROM Member m join m.team t</code> 와 같이 <strong>명시적 조인</strong>을 하자</li></ul><h3 id="2-임베디드">2. 임베디드</h3><h4 id="select-maddress-from-member-m"><code>SELECT m.address FROM Member m</code></h4><blockquote><p>address는 city, street, zipcode를 가지고 있는 임베디드 타입이다.</p><ul><li><code>select address from Address a</code> 와 같이 사용할 수 없다 <strong>어디에 소속되어 있는지 명시 줘야한다.</strong></li></ul></blockquote><h3 id="3-스칼라-타입">3. 스칼라 타입</h3><h4 id="select-musername-mage-from-member-m"><code>SELECT m.username, m.age FROM Member m</code></h4><ul><li>DISTINCT로 중복 제거 → 중복된 데이터 제거<pre><code class="language-java">em.createQuery("select distinct m.username, m.age from Member").getResultList();
</code></pre></li></ul><h3 id="여러-값-조회">여러 값 조회</h3><p><code>SELECT m.username, m.age FROM Member m</code></p><h4 id="1-query-타입으로-조회">1. Query 타입으로 조회</h4><blockquote><p>가장 권장하지 않는다. 너무 귀찮다. ```java List resultList = em.createQuery(“SELECT m.username, m.age FROM Member m”).getResultList();</p></blockquote><p>Object o = resultList.get(0); Object [] result = (Obejct[]) o; System.out.println(“username = “ + result[0]) // username = 조회된_유저이름 System.out.println(“age = “ + result[1]) // username = 조회된_유저나이</p><pre><code>#### 2. Object[] 타입으로 조회
&gt; 이것도 권장하지 않는다.
```java
List&lt;Obejct[]&gt; resultList = 
  em.createQuery("SELECT m.username, m.age FROM Member m").getResultList();

Object[] result = resultList.get(0);
System.out.println("username = " + result[0]) // username = 조회된_유저이름
System.out.println("age = " + result[1]) // username = 조회된_유저나이
</code></pre><h4 id="3-new-명령어로-조회">3. new 명령어로 조회</h4><blockquote><p>제일 간단하다.<br><code>SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m</code></p><ul><li>패키지 명을 포함한 전체 클래스 명을 입력해야한다. → 문자열이기 때문에 무조건 클래스명을 명시해야 한다.</li><li>순서와 타입이 일치하는 생성자 필요하다. <strong>MemberDto</strong> ```java @Getter @Setter public class MemberDto{ private String username; private int age;</li></ul></blockquote><p>public MemberDto(String username; int age){ this.username = username; this.age = age; } }</p><pre><code>**결과**
```java
List resultList = 
  em.createQuery("SELECT new foo.MemberDto(m.username, m.age) FROM Member m").getResultList();

MemberDto memberDto = result.get(0);

System.out.println("username = " + memberDto.getUsername()) // username = 조회된_유저이름
System.out.println("age = " + memberDto.getAge()) // username = 조회된_유저나이
</code></pre></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/cs/2022/03/19/%ED%8A%B8%EB%A6%AC-tree/" class="nav-link">트리 - Tree</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/%ED%94%8C%EB%9F%AC%EC%8B%9Cflush/" class="nav-link">플러시(flush)</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>