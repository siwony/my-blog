<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Executor Framework</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Executor Framework</h1><post-metadata layout="inline" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="executor-framework">Executor Framework</h1><p>: 고수준 (High-Level) Concurrency 프로그래밍를 지원하는 Framework</p><ul><li>Executor에 스레드를 만들고 관리하는 작업을 위임한다.</li><li><code>Executor</code>, <code>ExecutorService</code>, <code>ScheduledExecutorService</code><blockquote><p>주로 <code>Executor</code>를 사용하는 것 보다 <code>Executor</code>를 상속받은 <code>ExecutorService</code>를 사용한다.</p></blockquote></li><li>Executors를 통해 <code>Executor</code>, <code>ExecutorService</code>, <code>ScheduledExecutorService</code>를 생성할 수 있다.</li><li>JDK5 부터 지원한다.<blockquote><p>JDK5이전에는 개발자가 직접 Thread Pool를 만들어 관리했다.</p></blockquote></li></ul><h3 id="하는-역할">하는 역할</h3><ul><li>스레드 생성<blockquote><p>애플리케이션이 사용할 스레드 풀을 만들어 관리한다.</p></blockquote></li><li>스레드 관리<blockquote><p>스레드의 생명주기를 관리한다.</p></blockquote></li><li>작업처리 및 실행<blockquote><p>스레드로 실행할 작업(task)을 언제든지 실행할 수 있게 한다.</p></blockquote></li></ul><h2 id="간단한-사용-예시">간단한 사용 예시</h2><h3 id="executorservice-생성"><code>ExecutorService</code> 생성</h3><p><code>Executors</code>를 통해 <code>ExecurotService</code>를 생성할 수 있다.</p><blockquote><p>다음 메소드를 제공하여 스레드 풀을 개수 및 종류를 정할 수 있다.</p><ul><li><code>Executors.newFixedThreadPool(int)</code> 인자 개수만큼 고정된 스레드 풀을 만든다.</li><li><code>Executors.newCachedThreadPool()</code> 필요한 만큼 스레드 풀을 생성한다.</li><li><code>Executors.newSingleThreadExecutor()</code> 스레드가 한개인 <code>ExecutortService</code>객체를 생성한다.</li></ul></blockquote><p>예시 - 10개의 Thread Pool 생성</p><pre><code class="language-java">ExecutorService executorService = Executors.newFixedThreadPool(10);
</code></pre><h3 id="executorservice에-task-할당하기">ExecutorService에 task 할당하기</h3><p><code>ExecutorService</code>는 <code>Runnable</code>과 <code>Callable</code> task를 실행할 수 있다.</p><ul><li>결과가 없는 task는 <code>execute(Runnable)</code>를 사용한다.</li><li>결과가 있는 task는 <code>Future</code>를 반환하는<br><code>submit(Runnable)</code>, <code>submit(Runnable, T resulte)</code>, <code>submit(Callable&lt;T&gt;)</code>를 사용한다.</li></ul><p>예시 - Runnable</p><pre><code>executorService.execute(
  () -&gt; System.out.println("Hello world!")
)
executorService.execute(
  () -&gt; System.out.println("Hello thread!")
)
</code></pre><p>예시 - Callable</p><pre><code class="language-java">Callable&lt;String&gt; callable = () -&gt; {
    StringBuilder sb = new StringBuilder();
    for(int i = 0; i &lt; 10; i++)
        sb.append(i);

    return sb.toString();
};

Future&lt;String&gt; submit = executorService.submit(callable);
System.out.println(submit.get()); // 출력 0123456789 
</code></pre><ul><li><code>Future.get</code><ul><li>해당 스레드의 작업 결과를 가져온다.</li><li><code>InterruptedException</code>에 대한 예외처리가 필요하다.</li></ul></li></ul><h3 id="executorservice-종료하기">ExecutorService 종료하기</h3><p><code>ExecutorService</code>는 <code>ExecutorService</code>를 종료하기 위한 두가지 매서드를 제공한다.</p><h4 id="shutdown">shutdown</h4><blockquote><p>Graceful Shutdown</p></blockquote><p>: 이 method가 실행될 때, 새로운 task가 할당되는 것을 막고 이미 전에 제출된 task가 실행되는 것을 기다린 후 종료한다.</p><ul><li>shutdown를 실행한 후 task를 실행하면 <code>RejectedExecutionException</code>이 발생한다.</li></ul><p>예시 코드</p><pre><code class="language-java">executorService.execute(() -&gt; {
    try {
        Thread.sleep(1000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("before shutdown");
});
executorService.shutdown();
executorService.execute(() -&gt; System.out.println("after shutdown")); 
</code></pre><p>예시 출력결과</p><pre><code class="language-sh">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task TestMain$$Lambda$16/0x0000000800066040@2133c8f8 rejected from java.util.concurrent.ThreadPoolExecutor@43a25848[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at TestMain.main(TestMain.java:25)
before shutdown
</code></pre><h4 id="shutdownnow">shutdownNow</h4><p>: 모든 활성된 task을 즉시 종료하려 시도하고 새로운 task가 할당되는 것을 막는다.</p><p>예시 코드</p><pre><code class="language-java">executorService.execute(() -&gt; {
    try {
        Thread.sleep(1000L);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("Hello World");
});
executorService.shutdown();
executorService.execute(() -&gt; System.out.println("Hello World")); 
</code></pre><p>예시 출력결과</p><pre><code class="language-sh">java.lang.InterruptedException: sleep interrupted
	at java.base/java.lang.Thread.sleep(Native Method)
	at TestMain.lambda$main$1(TestMain.java:18)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:829)
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task TestMain$$Lambda$16/0x0000000800066040@2133c8f8 rejected from java.util.concurrent.ThreadPoolExecutor@43a25848[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at TestMain.main(TestMain.java:25)
before shutdown
</code></pre><ul><li><code>InterruptedException</code>가 발생한 것을 통해 곧바로 task를 종료하려 시도한 것을 알 수 있다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/exception-%EC%98%88%EC%99%B8/" class="nav-link">Exception (예외)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/facade-pattern/" class="nav-link">Facade Pattern</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>