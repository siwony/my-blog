<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Callable과 Future</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Callable과 Future</h1><post-metadata layout="inline" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="callable과-future">Callable과 Future</h1><p><code>Callable</code>은 <code>Runnable</code>과 다르게 작업(task)의 결과를 받을 수 있다.<br>그리고 <code>ExecutorService</code>를 이용해 <code>Callable</code>의 작업물을 <code>Future</code>객체로 감싸서 받을 수 있다.</p><h3 id="callable">Callable</h3><ul><li>인자가 없고 리턴 타입의 객체를 리턴한다.</li><li><code>ExecutorService</code>의 <code>submit</code>매서드를 사용하여 Task를 실행할 수 있다.</li></ul><h3 id="future">Future</h3><ul><li>비동기적인 작업의 현재 상태를 조회하거나 결과를 가저 올 수 있다.</li><li>블로킹 콜을 이용해 최종 결과를 얻는다.<blockquote><p>작업이 완료될 때 까지 기다린다.</p></blockquote></li><li><code>지연 완료 - pending Completion</code> 객체라고도 한다</li></ul><h4 id="get---결과를-가져온다">get() - 결과를 가져온다.</h4><p>오버로딩된 두가지 메서드를 제공한다.</p><ul><li>계산이 완료될 때까지 기다린 다음에 결과를 검색한다.<pre><code class="language-java">V get() throws InterruptedException, ExecutionException;
</code></pre></li><li>최대 지정된 시간까지 기다렸다가 사용 가능한 경우 객체를 검색한다.<pre><code class="language-java">V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException,TimeoutException;
</code></pre></li></ul><p>예시</p><pre><code class="language-java">ExecutorService executorService = Executors.newFixedThreadPool(10);

Callable&lt;String&gt; callable = () -&gt; {
    Thread.sleep(2000L);
    return "Callable done";
};

Future&lt;String&gt; future = executorService.submit(callable);
System.out.println("Get result"); // blocking call - 약 2초 후 결과를 가져온다.
String result = future.get();
System.out.println(result);

executorService.shutdown();
</code></pre><ul><li>“Get result”가 출력된 후 약 2초후 Future에서 반환한 “Callable done”가 출력된다.</li></ul><h4 id="isdone-iscancelled---작업-상태-확인하기">isDone(), isCancelled() - 작업 상태 확인하기</h4><ul><li><code>isDone</code>은 작업이 안료되면 true를 반환 그렇지 않으면 false<pre><code class="language-java">boolean isDone();
</code></pre></li><li><code>isCancelled</code> 착업이 완료된 경우 true를 반환하고, 작업이 정상적으로 종료되거나 예외 또는 취소된 경우도 true를 반환한다.<pre><code class="language-java">boolean isCancelled();
</code></pre></li></ul><h4 id="cancelboolean-mayinterruptifrunning---작업취소하기">cancel(boolean mayInterruptIfRunning) - 작업취소하기</h4><p>: 해당 작업을 취소하려 할 떄 사용한다.</p><pre><code class="language-java">boolean cancel(boolean mayInterruptIfRunning);
</code></pre><ul><li>작업이 완료되었거나, 취소할 수 없는 경우에 false를 반환한다.</li><li>성공적으로 취소했으면, true 아니면 false을 반환한다.</li><li>작업이 이미 완료되었거나, 취소되었거나, 다른 이유로 취소할 수 없는 경우에는 false를 반환한다.</li></ul><h2 id="executerservice의-invokeall과-invokeany">ExecuterService의 invokeAll과 invokeAny</h2><blockquote><p>여러개의 동시 Callable작업에 대한 처리를 담당하지만 어떤 차이점이 있을까?</p><h3 id="invokeall---모든-future목록을-반환한다">invokeAll() - 모든 Future목록을 반환한다.</h3><p>: 태스크를 실행하고 모두 완료되거나 시간 초과가 만료될 때, 상태 및 결과를 저장하고 있는 <code>Future</code>목록을 반환한다. ```java</p></blockquote><t>List&lt;Future<t>&gt; invokeAll(Collection&lt;? extends Callable<t>&gt; tasks) throws InterruptedException;<t>List&lt;Future<t>&gt; invokeAll(Collection&lt;? extends Callable<t>&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; ``` - 이 작업이 진행되는 동안 현재 컬렉션이 수정되면 메서드의 결과가 정의되지 않는다. - 동시에 실행한 작업중에 가장 오래걸리는 작업만큼 시간이 소요된다. 예시 ```java ExecutorService executorService = Executors.newFixedThreadPool(10); Callable<string>callable1 = () -&gt; { Thread.sleep(1000L); return "Java"; }; Callable<string>callable2 = () -&gt; { Thread.sleep(2000L); return "Spring"; }; Callable<string>callable3 = () -&gt; { Thread.sleep(1500L); return "JPA"; }; List&lt;Future<string>&gt; futures = executorService.invokeAll(Arrays.asList(callable1, callable2, callable3)); for(Future<string>f : futures){ System.out.println(f.get()); } executorService.shutdown(); ``` - 약 2초를 기다린 후 가장 작업이 빨리 끝난 순서대로 "Java", "JPA", "Spring"이 출력 되었다. ### invokeAny : 가장 먼저 완료된 작업의 결과를 바로 반환한다. ```java<t>T invokeAny(Collection&lt;? extends Callable<t>&gt; tasks)throws InterruptedException, ExecutionException;<t>T invokeAny(Collection&lt;? extends Callable<t>&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; ``` - 이 작업이 진행되는 동안 지정된 컬렉션이 수정되면 이 메서드의 결과가 정의되지 않는다. - 동시에 실행한 작업중에 제일 짧게 걸리는 작업만큼 시간이 걸린다. - 이 또한 블록킹 콜 에시 ```java ExecutorService executorService = Executors.newFixedThreadPool(10); Callable<string>callable1 = () -&gt; { Thread.sleep(1000L); return "Java"; }; Callable<string>callable2 = () -&gt; { Thread.sleep(2000L); return "Spring"; }; Callable<string>callable3 = () -&gt; { Thread.sleep(1500L); return "JPA"; }; String future = executorService.invokeAny(Arrays.asList(callable1, callable2, callable3)); System.out.println(future); executorService.shutdown(); ``` - 대략 1초를 기다리고 가장 먼저 완료된 작업의 결과("Java")가 바로 반환된다.</string></string></string></t></t></t></t></string></string></string></string></string></t></t></t></t></t></t></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/atomic/" class="nav-link">Atomic</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/class-loader-system-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94-%EC%8B%9C%EC%8A%A4%ED%85%9C/" class="nav-link">Class Loader System - 클래스 로더 시스템</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>