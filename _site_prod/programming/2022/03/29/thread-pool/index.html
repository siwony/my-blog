<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Thread Pool</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Thread Pool</h1><post-metadata layout="inline" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="1" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="thread-pool">Thread Pool</h1><p>: 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것</p><h3 id="java의-스레드의-특성">Java의 스레드의 특성</h3><ul><li>Java의 스레드는 <strong>CPU를 최대한 사용해서 많은 업무를 동시에 처리</strong>할 수 있게 도와준다.</li><li>스레드를 생성하려면 <strong>약간의 시간과 메모리가 필요</strong>하다.</li><li><strong>JVM은 스레드의 생성 개수에 대한 제약이 없다.</strong><blockquote><p>→ 지속적으로 생성한다면 성능저하 및 메모리 고갈의 문제가 생길 수 있다.</p></blockquote></li></ul><h3 id="thread-pool의-필요성">Thread Pool의 필요성</h3><ul><li>JVM의 옵션등으로 스레드의 생성을 제어를 할 수 없다.</li><li>무제한적인 스레드의 생성을 막기위한 스레드 관리 방식이 필요하다.</li><li>Thread Pool은 어플리케이션이 선택적으로 사용할 수 있는 스레드 관리 방식이다.</li></ul><h4 id="thread-pool방식을-사용하는-소프트웨어">Thread Pool방식을 사용하는 소프트웨어</h4><p>대표적으로 Tomcat과 같은 웹서버가 있다.</p><ul><li>웹서버는 엄청 많은 요청이 들어올 수 있는데 <strong>요청마다 스레드를 생성하는 것은 JVM의 메모리를 급격하게 소비시키며 성능에도 저하가 발생할 수 있다.</strong></li><li>이럴 때 최대 스레드 개수를 지정해 놓으면 지정한 스레드 개수 이상의 HTTP 요청에 대해서 처리하지 않고 기다리다가</li><li>유휴상태의 스레드가 생기면 그 때 사용하지 않는 스레드를 재사용하여 HTTP요청을 처리한다.</li></ul><h3 id="thread-pool의-구조">Thread Pool의 구조</h3><p><img src="/assets/images/posts/programming/thread-pool.png"></p><ol><li>Thread Pool은 작업처리에 사용되는 스레드를 제한된 개수만큼 정한다.</li><li><code>작업큐 - Queue</code>에 들어오는 <code>작업 - Task</code>들을 하나씩 스레드가 맡아 처리한다.</li><li>그 후 스레드에서 Task가 끝나면 Application에 반환한다.</li></ol></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C-%EA%B2%BD%EC%9F%81%EC%83%81%ED%83%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/" class="nav-link">Synchronized 키워드 - 경쟁상태를 해결하는 방법</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/volatile-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/" class="nav-link">Volatile - 메모리 가시성을 해결하는 방법</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>