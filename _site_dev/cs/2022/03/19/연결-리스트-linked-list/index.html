<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>연결 리스트 - Linked List</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">연결 리스트 - Linked List</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["cs"]'
          tags='["data-structure","linear","list","TIL"]'
          date="March 19, 2022"
          reading-time="5"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="연결-리스트---linked-list">연결 리스트 - Linked List</h1>
<p>: 연결 리스트는 노드(node)들로 이어진 리스트를 말한다.</p>
<h4 id="연결리스트의-예---단일-연결-리스트">연결리스트의 예 - 단일 연결 리스트</h4>
<p><img width="600" src="/assets/images/posts/cs/linked-list-ex.png" /></p>

<ul>
  <li>노드는 보통 데이터를 저장하는 부분과, 다음 노드를 가르키는 부분으로 구성된다.</li>
  <li><code>연결 리스트</code>는 처음과 끝을 가르키는 포인터들을 이용해 리스트를 관리한다.</li>
  <li><code>단일 연결리스트</code>, <code>원형 연결 리스트</code>, <code>이중 연결 리스트</code>가 있다.</li>
</ul>

<h4 id="노드의-구조-예---단일-연결-리스트">노드의 구조 예 - 단일 연결 리스트</h4>
<p><img width="150" src="/assets/images/posts/cs/linked-list-node-structure.png" /></p>

<ul>
  <li>노드는 데이터를 갖고있는 데이터 필드와 리스트의 다음 원소를 가리키는, 링크필드(포인터)로 구성된다.</li>
</ul>

<h3 id="연결-리스트-특징">연결 리스트 특징</h3>
<ul>
  <li>포인터로 연결한다.
    <blockquote>
      <p>원소들이 메모리 내 어느 위치에도 가능</p>
    </blockquote>
  </li>
  <li>크기가 가변적이다.
    <blockquote>
      <p>메모리가 허용하는 만큼 커질 수 있음</p>
    </blockquote>
  </li>
  <li>원소의 순서 유지되고, 순차 접근을 한다.
    <blockquote>
      <p>원소의 순서는 링크를 이용하여 유지시켜 준다, 탐색시 순차적으로 접근해야 하므로 시간복잡도 <code>O(N)</code>을 가진다.</p>
    </blockquote>
  </li>
  <li>선형 리스트에 비해 구현이 어렵다.
    <blockquote>
      <p>포인터의 저장 필요에 저장공간이 조금더 많이 소요되나, 빈공간을 거의 없게 할 수 있다.</p>
    </blockquote>
  </li>
  <li>다른 자료구조(추상자료형, ADT)의 기반이 된다.
    <blockquote>
      <p>큐, 스택, 해시 테이블 등</p>
    </blockquote>
  </li>
</ul>

<h3 id="연결-리스트-단점">연결 리스트 단점</h3>
<h4 id="1-캐싱에-적합하지-않은-구조">1. 캐싱에 적합하지 않은 구조</h4>
<blockquote>
  <p>탐식시 연결 리스트보다 배열(순차 리스트)가 연결 리스트를 압도한다 이유가 무엇일까?</p>
</blockquote>

<p><img src="/assets/images/posts/cs/cpu-cache.jpeg" /></p>

<p>결론은 <strong>컴퓨터에 있는 캐시(Cache)라는 저장 공간이 그 이유다.</strong></p>
<ol>
  <li><code>CPU</code>는 메인메모리에 적재(load)된 소스코드를 한줄씩 읽어서 처리하는데 <br />
  <code>메인메모리(RAM)</code>의 경우 <code>CPU</code>에 비해 데이터 처리 속도가 압도적으로 느리다.</li>
  <li>때문에 <code>CPU</code>에서 작업을 완료해도 <code>RAM</code>에 있는 데이터나 소스코드가 전송되지 않아서 <code>CPU</code>가 오랜시간 대기하는 경우가 생긴다.</li>
  <li>이러한 문제를 해결하기 위해 이 둘 사이에 <code>캐시라는 저장공간</code>을 만들고 RAM에 적재된 정보 중 일부를 캐시에 미리 적재한다.
    <blockquote>
      <p>캐시는 <code>SRAM기반</code>으로 <code>DRAM기반</code>의 <code>RAM</code>보다 훨씬 빠르다.</p>
    </blockquote>
  </li>
  <li><code>CPU</code>는 <code>RAM</code>이 아닌 <code>캐시</code>에서 정보들을 가져오게 되고 이러한 <code>캐싱 방식</code>을 이용하면 <code>CPU</code>가 쉬는 시간을 극도로 줄일 수 있다.</li>
</ol>

<p>왜 <code>연결 리스트</code>는 캐싱에 적합하지 않을까?</p>
<ul>
  <li><code>배열</code>: 같은 타입의 데이터들이 <strong>연속된 메모리에 저장</strong>되어 있어 이 데이터들을 한번에 캐시로 넘길 수 있다.</li>
  <li><code>연결 리스트</code>: 데이터를 메모리 곳곳에 저장한 뒤, 이들을 주소로만 연결한 구조이기 때문에 데이터가 캐시로 한번에 넘어 올 수 없다.</li>
</ul>

<h4 id="2-복잡한-연산에-따른-오버헤드">2. 복잡한 연산에 따른 오버헤드</h4>
<p>: 일반적으로 배열리스트의 연산들보다 연결리스트의 연산들이 훨씬 복잡하다.</p>
<ul>
  <li>모든 연산을 수행할 때 더 많은 명령어가 필요하고 때문에 더 많은 오버헤드가 발생하게 된다.</li>
  <li>알고리즘의 시간 복잡도 이외에도 추가적인 시간들이 소모된다.</li>
</ul>

<h4 id="3-주소-저장으로-인한-공간-낭비">3. 주소 저장으로 인한 공간 낭비</h4>
<p>: 데이터 이외에도 주소에 대한 정보를 반드시 가지고 있어야하기 때문에 주소에 대한 용량이 소모된다.</p>
<ul>
  <li>정수형 리스트의 경우 데이터(integer), 주소(integer)를 저장하기 때문에 배열리스트와 비교하여 2배의 용량이 필요하다.</li>
  <li>하지만 빈 값을 허용하지 않는다.</li>
</ul>

<h2 id="1-단일-연결-리스트---singly-linked-list">1. 단일 연결 리스트 - Singly Linked List</h2>
<p>: 포인터를 통해 단방향으로 다음 노드를 가르키는 자료구조이다.<br />
<img src="/assets/images/posts/cs/single-linked-list.png" /></p>

<ul>
  <li>모든 원소가 데이터, 링크 쌍으로 이루어져 있다.</li>
  <li>원소의 삽입과, 삭제가 용이하다.</li>
</ul>

<h3 id="삽입--삭제-연산">삽입 / 삭제 연산</h3>
<blockquote>
  <p>일반적으로 삽입/삭제 연산은 상수, <code>O(1)</code> 시간복잡도를 갖는다.<br />
하지만 현실적인 삽입/삭제 연산은 탐색이 포함되므로 결국 <code>O(1 + n)</code>즉, <code>O(n)</code>의 시간복잡도를 가진다.</p>
</blockquote>

<h4 id="1-맨-앞에-노드-삽입">1. 맨 앞에 노드 삽입</h4>
<blockquote>
  <p>Head만 있으면 되므로 <code>O(1)</code>의 시간복잡도를 갖는다.
<img width="700px" src="/assets/images/posts/cs/singly-list-head-insert.png" /></p>
</blockquote>

<ol>
  <li><code>새로운 노드</code>를 생성한다.</li>
  <li><code>새로운 노드</code>의 <code>링크</code>를 <code>헤더</code> 다음으로 가리키도록 한다.</li>
  <li><code>헤더의 링크</code>는 <code>새로운 노드</code>를 가르키게 한다.</li>
</ol>

<h4 id="2-맨-뒤에-노드-삽입">2. 맨 뒤에 노드 삽입</h4>
<blockquote>
  <p>O<code>(n)</code>의 시간복잡도를 가진다.
<img width="700px" src="/assets/images/posts/cs/마지막_노드_추가.png" /></p>
</blockquote>

<ol>
  <li><code>새로운 노드</code>를 생성한다.</li>
  <li><code>마지막 노드</code>를 찾는다.</li>
  <li><code>마지막 노드</code>는 <code>새로운 노드</code>를 가르키게 한다</li>
</ol>

<h4 id="3-원하는-곳index에-노드-삽입">3. 원하는 곳(index)에 노드 삽입</h4>
<blockquote>
  <p>원하는 노드를 탐색 후 삽입하므로 시간복잡도 <code>O(n + 1)</code>즉, <code>O(n)</code>를 갖는다.</p>
</blockquote>

<p><img width="700px" src="/assets/images/posts/cs/인덱스_노드_추가.png" /></p>

<ol>
  <li><code>새로운 노드</code>를 생성한다.</li>
  <li><code>특정 인덱스의 노드(cru)</code>와 그 <code>이전 노드(prev)</code>를 찾는다.</li>
  <li><code>prev</code>가 새로운 노드를 가르키고, <code>새로운 노드</code>가 <code>cur</code>를 가리키도록 한다.</li>
</ol>

<h4 id="4-특정-노드-삭제">4. 특정 노드 삭제</h4>
<blockquote>
  <p>원하는 노드를 탐색 후 삭제하므로 시간복잡도 <code>O(n + 1)</code>즉. <code>O(n)</code>를 갖는다.
<img src="/assets/images/posts/cs/인덱스_노드_삭제.png" /></p>
</blockquote>

<ol>
  <li><code>삭제할 노드</code>를 없앤다.</li>
  <li><code>삭제할 노드</code>의 <code>이전 노드의 포인터</code>를 <code>삭제할 노드</code>의 <code>다음 노드</code>로 지정해주면 된다.</li>
</ol>

<h3 id="단일-연결-리스트의-단점">단일 연결 리스트의 단점</h3>
<ul>
  <li>이전 리스트의 값을 확인하려면 다시한번 탐색을 해야 한다.</li>
</ul>

<h2 id="2-원형-연결-리스트---circular-linked-list">2. 원형 연결 리스트 - Circular Linked List</h2>
<p>: 리스트의 마지막 노드(헤드)의 링크가 첫 번째 노드를 가리키는 연결 리스트이다.<br />
<img width="600" src="/assets/images/posts/cs/circular-linked-list.png" /></p>

<ul>
  <li><code>헤드</code>의 <code>링크(link)</code>는 리스트의 <code>첫 번째 노드</code>를 가르킨다.
    <blockquote>
      <p>리스트의 처음이나 마지막에 노드를 삽입하는 연산이 편리해진다.</p>
    </blockquote>
  </li>
</ul>

<h3 id="삽입-연산">삽입 연산</h3>
<h4 id="1-앞부분-삽입-연산---head다음-위치에-삽입">1. 앞부분 삽입 연산 - <code>Head</code>다음 위치에 삽입</h4>
<blockquote>
  <p>시간복잡도는 <code>Head</code>만 알고 있으면 되므로 탐색이 필요하지 않아 <code>O(1)</code>이다.</p>
</blockquote>

<p><img width="400" src="/assets/images/posts/cs/circular-linked-front-insert.png" /></p>

<ol>
  <li>새로 삽입할 <code>node</code>의 <code>link</code>를 <code>head</code>의 <code>link</code>로 할당
    <blockquote>
      <p><code>head</code>는 리스트의 삽입 이전 첫번째 노드의 포인터를 가지고 있기 때문</p>
    </blockquote>
  </li>
  <li><code>head</code>의 <code>link</code>를 <code>node</code>로 할당</li>
</ol>

<p><strong>순서가 변경되면 안된다. 만약 2를 먼저 실행하면 새로 삽입할 <code>node</code>의 <code>link</code>를 지정할 주소를 알지 못한다.</strong></p>

<h4 id="2-뒷부분-삽입-연산">2. 뒷부분 삽입 연산</h4>
<p><img width="400" src="/assets/images/posts/cs/circular-linked-back-insert.png" /></p>

<ol>
  <li><code>node</code>의 <code>link</code>를 <code>head</code>의 <code>link</code>로 할당</li>
  <li><code>head</code>의 <code>link</code>를 <code>node</code>로 할당
    <blockquote>
      <p><code>head</code>는 리스트의 제일 마지막 노드를 의미하므로</p>
    </blockquote>
  </li>
  <li><code>head</code>를 <code>node</code>로 변경</li>
</ol>

<p><strong>순서가 변경되면 안된다. 2과정이 먼저 일어나면 지정할 주소를 잃어버리게 된다.</strong></p>

<h4 id="3-원하는-곳index에-노드-삽입-1">3. 원하는 곳(index)에 노드 삽입</h4>
<p><a href="#3-원하는-곳index에-노드-삽입">단일 연결리스트의 3번 삽입 연산과 같다.</a>
다만 head가 맞는지 아닌지 예외처리를… 해야 할 것이다(뇌피셜)</p>

<h3 id="삭제-연산">삭제 연산</h3>
<p><a href="#4-특정-노드-삭제">단일 연결리스트의 4번 삭제 연산과 같다.</a></p>

<h2 id="3-이중-연결-리스트---doubly-linked-list">3. 이중 연결 리스트 - Doubly Linked List</h2>
<p>: 각 노드가 선행 노드와 후속 노드에 대한 링크를 가지는 리스트이다.
<img src="/assets/images/posts/cs/doubly-linked-list.png" /></p>

<ul>
  <li>노드의 <code>왼쪽 링크(left link)</code>는 <code>현제 노드</code>의 <code>왼쪽 노드</code>를 가르킨다.</li>
  <li>노드의 <code>오른쪽 링크(right link)</code>는 <code>현재 노드</code>의 <code>오른쪽 노드</code>를 가르킨다.</li>
  <li><code>헤드노드</code>도 노드로 이루어져 있다.</li>
  <li>노드가 양방향으로 연결되어 있으므로 <strong>탐색도 양방향이 가능하다.</strong></li>
  <li>하지만 <strong>노드의 포인터는 단일 연결 리스트에 비해 1개 더 늘어난다.</strong></li>
</ul>

<blockquote>
  <p>참고. <code>right link</code> == <code>previous link</code>, <code>left link</code> == <code>next link</code></p>
</blockquote>

<h4 id="헤드노드---head-node">헤드노드 - head Node</h4>
<p>: 데이터를 가지지 않고 오로지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드이다.</p>
<ul>
  <li>헤드 포인터만의 구별이 필요하다. → <code>헤드노드</code>에는 데이터가 없다.</li>
  <li>리스트가 공백상태라면 <code>헤드노드</code>만 존재하는 상태이다.</li>
  <li><code>왼쪽 링크(left link)</code>: 리스트의 마지막 노드를 가리킨다</li>
  <li><code>오른쪽 링크(right link)</code>: 리스트의 맨 첫번째 노드를 가리킨다.</li>
</ul>

<h3 id="삽입-연산-1">삽입 연산</h3>
<blockquote>
  <p><code>new_node</code>를 <code>before</code>의 앞쪽에 삽입하는 연산<br />
시간 복잡도: 특정노드의 위치를 정확하게 알면 <code>O(1)</code>, 탐색이 필요하면 <code>O(n + 1)</code> 즉, <code>O(n)</code></p>
</blockquote>

<p><img src="/assets/images/posts/cs/doubly-insert-ops.png" /></p>

<blockquote>
  <p>이상적인 순서는 1 → 2 → 3 → 4 이지만 순서마다 차이가 날 수 있다.</p>
  <ol>
    <li><code>new_node</code>의 <code>left link</code>가 <code>before</code>를 가리킨다.</li>
    <li><code>new_node</code>의 <code>right link</code>가 <code>before</code>의 <code>rlink</code>를 가리킨다.</li>
    <li><code>before</code>의 <code>right link</code>의 <code>left link</code>가 <code>new_node</code>를 가르킨다.</li>
    <li><code>before</code>의 <code>right link</code>는 <code>now_node</code>를 가르킨다.</li>
  </ol>
</blockquote>

<p><strong>2, 3번은 무조건 4번 앞에 수행되어야 한다.</strong></p>

<p>필요한 예외 처리 - 선행자를 찾을 수 없을때 즉, 해당 리스트가 없을 때(초기화 x)</p>

<h3 id="삭제-연산-1">삭제 연산</h3>
<blockquote>
  <p>삭제하려는 노드를 <code>removed</code>변수로 받아서 삭제 연산을 수행한다.<br />
시간 복잡도: 특정노드의 위치를 정확하게 알면 <code>O(1)</code>, 탐색이 필요하면 <code>O(n + 1)</code> 즉, <code>O(n)</code></p>
</blockquote>

<p><img src="/assets/images/posts/cs/doubly-delete-ops.png" /></p>

<blockquote>
  <p>순서는 상관 없다.</p>
  <ol>
    <li><code>removed</code>의 <code>left link</code>는 <code>removed</code>의 <code>right link</code>를 가르킨다.
삭제할 노드의 이전 노드가 없을 때</li>
    <li><code>removed</code>의 <code>right link</code>는 <code>removed</code>의 <code>left link</code>를 가르킨다.
삭제할 노드의 다음 노드가 없을 때</li>
  </ol>
</blockquote>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/cs/2022/03/19/%EC%88%9C%EC%B0%A8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-sequential-list/" class="nav-link">순차 리스트 - Sequential List</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/" class="nav-link">연관관계 관리</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
