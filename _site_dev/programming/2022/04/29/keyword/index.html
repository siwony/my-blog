<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyword</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Keyword</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["kotlin","coding","development","TIL"]'
          date="April 29, 2022"
          reading-time="4"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="keyword">Keyword</h1>
<h2 id="1-hard-keywords">1. Hard Keywords</h2>
<p>식별자로 사용할 수 없는 키워드를 의미한다.</p>

<h3 id="1-1-as">1-1. as</h3>
<p><code>as</code>키워드는 <strong>타입 캐스팅</strong>과 <strong>별칭 기능</strong>의 두 가지 역할을 한다.</p>

<h4 id="타입-캐스팅">타입 캐스팅</h4>
<pre><code class="language-kotlin">val x: String = y as String
</code></pre>
<p>위 코드는 <code>y</code>를 String으로 캐스팅하여 <code>x</code>에 대입하는 코드이다.<br />
컴파일 오류는 발생하지 않지만, <strong>런타임 시 캐스팅이 불가능한 타입일 경우 Exception이 발생한다.</strong>
→ 이를 Unsafe 캐스팅이라고 한다.</p>

<pre><code class="language-kotlin">val x: String? = y as String?
</code></pre>
<p><code>Nullable</code> 한 값을 캐스팅 해야 하는 경우 ?연산자를 이용하여 y가 null일 경우 캐스팅을 하지 않고 x에 null를 대입하게 된다.</p>

<p>as를 통한 타입 캐스팅은 런타임시에 캐스팅이 실패 할 경우 Exception이 발생하는데 Exception이 발생하지 않고, null를 대압하고 싶다면 <code>as?</code>키워드를 사용할 수 있다.</p>
<pre><code class="language-kotlin">val x: String? = y as? String
</code></pre>
<p>물론 null를 허용해야 하므로 타입뒤에 <code>?</code>를 사용해야 한다.</p>

<h4 id="alias">alias</h4>
<p>as는 import 구문에서 alias의 역할을 맡고있다.</p>

<p>예시로 Animal.Info와 Human.Info 클래스를 import 한다고 하면, 둘다 동일한 Info라는 이름을 가지기 때문에 충돌이 일어난다.
자바는 이럴 경우 해당 클래스를 접근 할 때 한쪽클래스는 패키지명까지 모두 작성해야 한다.</p>

<p>하지만 코틀린에서는 as키워드를 사용해 alias를 지정할 수 있다.</p>
<pre><code class="language-kotlin">import Animal.Info
import Human.Info as humnInfo
</code></pre>

<h3 id="1-2-fun">1-2. fun</h3>
<p>함수임을 나타내는 키워드다.</p>

<pre><code class="language-kotlin">fun 함수명(args...): 반환타입{
    ...
}

//예시
fun add(a:Int, b:Int): Int{
    return a + b;
}
</code></pre>

<h3 id="1-3-in">1-3. in</h3>
<p><code>for loop</code>, <code>range expressions</code>, <code>when expressions</code>, <code>generic</code> 등에 쓰일 수 있다.</p>

<h4 id="for-loop">for loop</h4>
<pre><code class="language-kotlin">val items: Array&lt;Int&gt; = arrayOf(1, 2, 3)
for (i: Int in items)
    println("i = " + i)  
</code></pre>
<p>Java의 <code>for each(enhanced for loop)</code>와 동일하게 동작하며 1, 2, 3를 출력한다.</p>

<h4 id="range-expressions">range expressions</h4>
<p>in 키워드는 다음과 같이 조건식으로도 사용이 가능하다.</p>
<pre><code class="language-kotlin">val items: Array&lt;Int&gt; = arrayOf(1, 2, 3)
val hasOne: Boolean = 1 in items
println(hsaOne)
</code></pre>
<blockquote>
  <p>true 출력</p>
</blockquote>

<p>Java에서 Collection에 있는 원소를 찾으려면 <code>items.contains(1)</code>와 같이 contains연산을 해야 한다.</p>

<h4 id="when-expressions">when expressions</h4>
<p>Java의 switch처럼 동작한다.</p>

<pre><code class="language-kotlin">when(a) {
    a in 1..10 -&gt; println("a is in 1 ~ 10")
}
</code></pre>

<h4 id="generic">generic</h4>
<p>제네릭에서 in연산을 통해 반공변성을 사용할 수 있지만 길어지므로 다른 글에 적도록 하겠다.</p>

<h4 id="in">!in</h4>
<p>in 앞에 부정연산자를 붙은 키워드이고 in의 반대를 나타낸다.<br />
<code>range expressions</code>, <code>when expressions</code>와 같은 조건식에서만 사용할 수 있다.</p>

<h3 id="1-4-is">1-4. is</h3>
<p>타입캐스팅과 관련된 키워드이다.</p>

<p>Java에서는 타입캐스팅과 관련된 코드를 작성하려면 아래와 같이 Boilerplate한 code를 작성할 수 밖에 없다.</p>
<pre><code class="language-java">Object hello = "hello";
if(hello instanceof String)
    System.out.println(((String)hello).length());
</code></pre>

<p>하지만 Kotlin은 컴파일러가 is로 체크하는 부분을 추적하여 자동으로 캐스팅해준다.</p>
<blockquote>
  <p>이를 Smart Cast라고 한다.</p>
  <pre><code class="language-kotlin">Any hello = "hello";
if(hello is String)
    System.out.println(hello.length());
</code></pre>
</blockquote>

<h4 id="when-expression">when expression</h4>
<p>is 키워드는 <code>when expression</code>에서 사용할 때 가장 강력한 기능인 거 같다.</p>
<pre><code class="language-kotlin">when (a) {
    is Int -&gt; print(a)
    is String -&gt; print(a.length)
    is IntArray -&gt; print(x.size)
}
</code></pre>

<h4 id="is">!is</h4>
<ul>
  <li>is에 부정연산자 <code>!</code>가 붙은 연산자이다.</li>
  <li><code>in</code>, <code>!in</code>과 같이 반대의 관계이다.</li>
  <li><code>is</code>연산자가 사용되는 모든 곳에 사용할 수 있다.</li>
</ul>

<h3 id="1-5-this">1-5. this</h3>
<p>// TODO implicit label에 대해 공부하기 및 <code>extendsion function</code>에 대해 공부하기<br />
공식홈페이지의 코드가 너무 어렵다 공부하고 적어야겠다.</p>

<h3 id="1-6-throw">1-6. throw</h3>
<p>java와 같이 <code>Exception</code>을 발생시키는 키워드이다.</p>

<p>추가적으로 Kotlin은 Java와 다르게 CheckedException의 예외 처리를 강제하지 않는다.</p>

<h3 id="1-7-type-aliases">1-7. type aliases</h3>
<p>말 그대로 타입에 별칭을 줄 수 있다.</p>

<ul>
  <li><code>generic</code>, <code>function</code>, <code>class</code> 등 여러곳에 사용할 수 있다.</li>
  <li>class, method 블럭 외부에 선언해야 한다.</li>
</ul>

<pre><code class="language-kotlin">typealias FileTable&lt;K&gt; = MutableMap&lt;K, MutableList&lt;File&gt;&gt;
typealias NodeSet = Set&lt;Network.Node&gt;

fun main() {
    var fileTable: FileTable&lt;Int&gt; = HashMap()
    var nodeSet: NodeSet = HashSet()
}
</code></pre>
<p>이와 같이 generic선언이 긴 경우 커스텀한 타입으로 선언 할 수 있고</p>

<p>함수도 Java의 functional interface와 비슷하게 커스텀한 타입으로 선언할 수 있다.</p>
<pre><code class="language-kotlin">typealias MyHandler = (Int, String, Any) -&gt; Unit
typealias Predicate&lt;T&gt; = (T) -&gt; Boolean

fun function(handler: MyHandler, predicate: Predicate&lt;Int&gt;) {
    handler.invoke(10, "20", 30)
    if(predicate.invoke(10))
        println("predicate is true");
}

fun main() {
    function(
        {a, b, c -&gt; println("$a $b $c")},
        {a -&gt; a == 10}
    )
}
</code></pre>
<p>출력결과</p>
<pre><code>10 20 30
predicate is true
</code></pre>

<p>클래스도 커스텀한 별명을 만들어낼 수 있다.</p>
<pre><code class="language-kotlin">class A {
    class Inner
}

typealias AInner =  A.Inner
typealias Password = String
typealias Username = String

fun main() {
    val node: AInner = AInner()
    val userPassword : Password = "password"
    val username: Username = "siwony"
}
</code></pre>

<h3 id="1-8-val-var">1-8. val, var</h3>
<ul>
  <li>val은 immutable한 값을 갖는다. java에서 final 키워드와 같다.</li>
  <li>var은 mutable한 값을 갖는다. 즉 값이 변할 수 있다.</li>
</ul>

<h3 id="1-9-when-expression">1-9. when expression</h3>
<p><code>when expression</code>은 Java의 switch와 비슷하다.</p>

<pre><code class="language-java">switch (x) {
    case 1 : 
        System.out.println("1");
        break;
    
    case 2 : 
        System.out.println("2");
        break;
    
    default : 
        System.out.println("not found");
        System.out.println("go back!");
}
</code></pre>
<p>이 코드는 충분히 볼만하지만 만약 개발중에 <code>break</code>를 빼먹게 된다면 프로그램의 정합성을 해치게 된다.
그리고 여러 사람들이 느끼기에는 default가 의미적으로 안맞다고 하는 사람도 있다.</p>

<p>반면 코틀린 코드를 보면</p>
<pre><code class="language-kotlin">when (x) {
  1 -&gt; println("1")
  2 -&gt; println("2")
  else -&gt; {
        println("not found")
        println("go back!")
    }
}
</code></pre>
<p>break를 신경쓰지 않아도 되고 if else조건식을 사용하는 느낌을 준다.</p>

<p>그럼 만약 여러 케이스에 대해 동일하게 처리해야 하면 어떻게 해야 할까?</p>
<pre><code class="language-kotlin">when (x) {
  1, 2, 3, 4 -&gt; println("1 or 2 or 3 or 4")
  5 -&gt; println("2")
  else -&gt; {
        println("not found")
        println("go back!")
    }
}
</code></pre>
<p>그냥 한줄에 콤마(<code>,</code>)로 구분하여 적을 수 있다!</p>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://medium.com/@joongwon/kotlin-kotlin-키워드-및-연산자-해부-1-hard-keywords-3062f5fe2d11</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/04/26/%EC%A7%81%EB%A0%AC%ED%99%94-serializable/" class="nav-link">직렬화 - Serializable</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/04/29/kotlin/" class="nav-link">Kotlin</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
