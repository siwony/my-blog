<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스레드 로컬 - Thread Local</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">스레드 로컬 - Thread Local</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["concurrent","TIL","coding","development","java"]'
          date="March 29, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="스레드-로컬---thread-local">스레드 로컬 - Thread Local</h1>
<h3 id="reference">Reference</h3>
<ul>
  <li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8">김영한 인프런 핵심 원리 - 고급편</a></li>
</ul>

<h2 id="스레드-로컬">스레드 로컬</h2>
<p>: 스레드 단위로 로컬 변수를 할당하는 기능을 제공하는 클래스이다</p>
<ul>
  <li>JDK1.2 부터 지원하고 java.lang패키지에 있다.</li>
</ul>

<h3 id="thread-local의-동작-원리">Thread Local의 동작 원리</h3>
<h4 id="값-저장">값 저장</h4>
<p>스레드 로컬를 사용하면 각 스레드마다 별도의 내부 저장소를 생성한다.</p>
<blockquote>
  <p>같은 인스턴스 스레드 로컬 필드에 접근해도 동시성 이슈가 발생하지 않는다.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Thread-A</th>
      <th style="text-align: center">Thread-B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="/assets/images/posts/programming/thread-local-save1.png" alt="" /></td>
      <td style="text-align: center"><img src="/assets/images/posts/programming/thread-local-save2.png" alt="" /></td>
    </tr>
  </tbody>
</table>

<h4 id="값-조회">값 조회</h4>
<p>스레드 로컬을 통해 데이터를 조회해도 해당 Thread가 저장한 값을 알맞게 반환해준다.
<img width="650" src="/assets/images/posts/programming/thread-local-lock-up.png" /></p>

<h2 id="사용-예시">사용 예시</h2>
<h4 id="threadlocal의-method">ThreadLocal의 method</h4>
<ul>
  <li><code>ThreadLocal.set()</code>: 스레드 로컬에 값 설정</li>
  <li><code>ThreadLocal.get()</code>: 스레드 로컬에 값 얻기</li>
  <li><code>ThreadLocal.remove()</code>: 스레드 로컬에 값 제거</li>
</ul>

<h3 id="예시">예시</h3>
<p>값을 저장하고 조회하는 간단한 서비스(<code>ThreadLocalService</code>)를 만들었다.</p>
<pre><code class="language-java">@Slf4j
public class ThreadLocalService {

    private final ThreadLocal&lt;String&gt; nameStore = new ThreadLocal&lt;&gt;();

    public String logic(String name)  {
        log.info("저장 name={} -&gt; nameStore={}", name, nameStore.get());
        nameStore.set(name);
        sleep(1000); // 대충 저장을 하면 1초가 걸림
        log.info("조회 nameStore={}", nameStore.get());
        return nameStore.get();
    }

    public void removeValueInThreadLocal(){
        this.nameStore.remove();
    }

    public String lockUpValue(){
        return nameStore.get();
    }

    private void sleep(long time){
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<ul>
  <li>일부로 동시성 이슈를 만들어 내려고 logic매서드 속에 해당 Thread를 1초동안 sleep하게 만들었다.</li>
  <li>하지만 ThreadLocal를 통해 값을 nameStore값을 받으므로 동시성 이슈가 발생하지 않는다.</li>
</ul>

<p>이제 태스트 코드로 확인해보자</p>
<pre><code class="language-java">@Slf4j
public class FieldServiceTest {

    private ThreadLocalService service = new ThreadLocalService();

    @Test
    void field(){
        log.info("main start");
        Runnable userA = () -&gt; {
            service.logic("userA");
            service.removeValueInThreadLocal();
            log.info("ThreadLocal 값 제거 후 조회 -&gt; {}", service.lockUpValue());
        };

        Runnable userB = () -&gt; {
            service.logic("userB");
            service.removeValueInThreadLocal();
            log.info("ThreadLocal 값 제거 후 조회 -&gt; {}", service.lockUpValue());
        };

        Thread threadA = new Thread(userA);
        threadA.setName("thread-A");

        Thread threadB = new Thread(userB);
        threadB.setName("thread-B");

        threadA.start();
        threadB.start();

        sleep(3000); // Main Thread가 바로 종료되지 않도록한다.
        log.info("main exit");
    }

    private void sleep(long time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p><strong>출력 예시</strong></p>
<blockquote>
  <p>상황에 따라 스레드가 실행되는 시점이 다를 수 있다.</p>
  <pre><code class="language-sh">14:55:05.535 [main] INFO com.siwony.ifl_spring_advanced.trace.FieldServiceTest - main start
14:55:05.539 [thread-B] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 저장 name=userB -&gt; nameStore=null
14:55:05.538 [thread-A] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 저장 name=userA -&gt; nameStore=null
14:55:06.546 [thread-A] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=userA
14:55:06.546 [thread-B] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=userB
14:55:06.546 [thread-A] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=null
14:55:06.546 [thread-B] INFO com.siwony.ifl_spring_advanced.trace.thread_local.code.ThreadLocalService - 조회 nameStore=null
14:55:08.541 [main] INFO com.siwony.ifl_spring_advanced.trace.FieldServiceTest - main exit
</code></pre>
  <ul>
    <li>ThreadLocal를 사용해서 Thread가 ThreadLocalService의 똑같은 객체를 접근해 같은 ThreadLocal를 사용했지만 동시성 이슈가 발생하지 않았다.</li>
    <li>A-Thread는 A-Thread가 저장한 값인 userA를 제대로 저장 후 값을 가져왔다.</li>
    <li>B-Thread는 B-Thread가 저장한 값인 userB를 제대로 저장 후 값을 가져왔다.</li>
    <li>A-Thread, B-Thread는 <code>ThreadLocalService.remove</code>를 통해 <code>ThreadLocalService</code>속 ThreadLocal의 값을 remove해서 삭제 후 <code>lockUpValue()</code>매서드로 조회 했더니 null이 출력되었다.</li>
  </ul>
</blockquote>

<h3 id="threadlocal의-주의사항">ThreadLocal의 주의사항</h3>
<p>여기서 한 가지 의문이 드는 점이 있는데,<br />
“어차피 Thread가 종료되면 Thread에 따라 <code>ThreadLocal</code>도 제거될 텐데 왜 <code>ThreadLocal.remove()</code>를 통해 스레드 저장소의 저장된 값을 지우는 거지?”라는 의문이 들 수 있다.</p>

<p>하지만 이는 나중에 얘기치 못한 상황을 불러 올 수 있는데 특히 Thread Pool를 사용하는 Tomcat과 같은 시스템에서 문제가 발생할 수 있다.</p>

<p>사용자 A의 요청                |  사용자 A의 요청에 대한 응답
:————————-:|:————————-:
<img src="/assets/images/posts/programming/thread-local-issue-ex1.png" alt="" />  |  <img src="/assets/images/posts/programming/thread-local-issue-ex2.png" alt="" /></p>
<ul>
  <li>사용자A는 WAS에 요청하여 Thread-A를 사용해 사용자 A를 저장후 사용자A에게 HTTP응답을 했다.</li>
  <li>사용자A는 요청이 끝나 사용자A가 요청한 로직을 처리한 Thread-A는 Thread Pool에 반환되었다.</li>
  <li>Thread-A가 파괴되지 않았으므로 Thread-A는 스레드 로컬에는 사용자A의 데이터가 남아있다.</li>
</ul>

<p>여기서 사용자B가 사용자B 즉, 자신의 정보를 조회하는 로직을 요청했는데, 하필 Thread-A를 사용하면 어떻게 될까?</p>

<p><img src="/assets/images/posts/programming/thread-local-issue-ex3.png" /></p>

<ol>
  <li>사용자B는 조회를 위한 HTTP요청을 한다.</li>
  <li>WAS는 스레드 풀에서 스레드를 하나 조회한다.</li>
  <li>근데 하필 thread-A 가 할당되었다.</li>
  <li>Thread-A는 스레드 로컬에서 데이터를 조회한다.</li>
  <li>스레드 로컬은 thread-A 전용 보관소에 있는 사용자A 값을 반환한다.</li>
  <li>결과적으로 사용자A 값이 반환된다.</li>
  <li><strong>사용자B는 사용자A의 정보를 조회하게 된다.</strong></li>
</ol>

<p>이렇게 사용자B가 사용자A를 조회하는 치명적인 문제가 발생할 수 있다.</p>

<p>이러한 문제가 발생할 수 있으므로 <strong>스레드 로컬의 값을 <code>ThreadLocal.remove()</code> 를 통해서 꼭 제거해야 한다.</strong></p>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/03/29/%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91/" class="nav-link">바이트 코드 조작</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/03/29/%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-annotation-processor/" class="nav-link">어노테이션 프로세서 - Annotation Processor</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
