<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>템플릿 메서드 패턴 - Template Method Pattern</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">템플릿 메서드 패턴 - Template Method Pattern</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["TIL","coding","development","Design-pattern","java"]'
          date="March 29, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="템플릿-메서드-패턴---template-method-pattern">템플릿 메서드 패턴 - Template Method Pattern</h1>
<h4 id="참고자료">참고자료</h4>
<ul>
  <li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8">김영한 인프런 핵심 원리 - 고급편</a></li>
  <li><a href="https://github.com/siwony/spring-core-principle-advanced/tree/main/src/test/java/com/siwony/ifl_spring_advanced/trace/template">예제 코드</a></li>
</ul>

<h4 id="변하는-것과-변하지-않는-것을-분리">변하는 것과 변하지 않는 것을 분리</h4>
<p>GOF의 디자인 패턴에서는 템플릿 메서드 패턴을 다음과 같이 정의한다.</p>
<blockquote>
  <p>작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기한다.<br />
템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있다.</p>
</blockquote>

<p align="center"> <img align="center" width="200" src="/assets/images/posts/programming/tamplate-method-pattern.png" /></p>

<p>이를 풀어서 설명하면<br />
부모 클래스에 골격인 알고리즘의 골격인 <strong>템플릿을 정의하고</strong>, 일부분만 자식 클래스에 정의하는 것이다. 이렇게 템플릿 메서드 패턴을 사용하면 <strong>특정 부분만 변경</strong>할 수 있다.</p>

<h2 id="예제---비즈니스-로직의-수행-속도를-측정하여-로깅하기">예제 - 비즈니스 로직의 수행 속도를 측정하여 로깅하기</h2>
<blockquote>
  <p>실습환경: SpringBoot + lombok + junit5
다음과 같이 비즈니스 로직을 실행하는 메서드가 2개( <code>logic1()</code>, <code>logic2()</code> )가 있다.
```java
@Test
public void executeLogic(){
    logic1();
    logic2();
}</p>
</blockquote>

<p>private void logic1() {
    // 비즈니스 로직 실행
    log.info(“비즈니스 로직1 실행”);
    // 비즈니스 로직 종료
}</p>

<p>private void logic2() {
    // 비즈니스 로직 실행
    log.info(“비즈니스 로직2 실행”);
    // 비즈니스 로직 종료
}</p>
<pre><code>위와 같이 비즈니스 로직를 실행하는 `logic1`, `logic2`가 있다. 이 2개의 메서드에 비즈니스 로식의 수행속도를 측정하고 싶다면 코드를 다음과 같이 추가하면 된다.
```java
@Test
public void executeLogic(){ ... }

private void logic1() {
    long startTime = System.currentTimeMillis();
    // 비즈니스 로직 실행
    log.info("비즈니스 로직1 실행");
    // 비즈니스 로직 종료
    long endTime = System.currentTimeMillis();
    long resultTime = endTime - startTime;
    log.info("resultTime={}", resultTime);
}

private void logic2() {
    long startTime = System.currentTimeMillis();
    // 비즈니스 로직 실행
    log.info("비즈니스 로직2 실행");
    // 비즈니스 로직 종료
    long endTime = System.currentTimeMillis();
    long resultTime = endTime - startTime;
    log.info("resultTime={}", resultTime);
}
</code></pre>
<p><strong>출력 예시</strong></p>
<pre><code class="language-sh">23:10:25.701 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직1 실행
23:10:25.703 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - resultTime=3
23:10:25.705 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직2 실행
23:10:25.705 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - resultTime=0
</code></pre>
<p>끝났다 우리는 비즈니스 로직에 대한 수행시간을 측정할 수 있게 되었다.</p>

<p>하지만 위에 작성한 코드는 다음과 같은 문제를 가지고 있다.</p>
<ul>
  <li>메서드에 순수 비즈니스 로직과 부가적인 로직이 섞여 <strong>단일-책임-원칙(SRP)에 위반된다.</strong></li>
  <li>비즈니스 로직을 제외한 <strong>수행시간을 측정하는 로직은 계속 중복</strong>되고 있다.
    <blockquote>
      <p>중간에 끼어있는 비즈니스 로직으로 인해 따로 함수화하기도 힘들다.</p>
    </blockquote>
  </li>
</ul>

<p>이러한 문제를 해결하기 위해 템플릿 메서드 패턴을 사용해 보자</p>

<h4 id="비즈니스-로직의-시간을-측정하는-템플릿-추상-클래스-생성">비즈니스 로직의 시간을 측정하는 템플릿 추상 클래스 생성</h4>
<pre><code class="language-java">@Slf4j
public abstract class TimeMeasurementTemplate&lt;T&gt; {

    public void execute(){
        long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        T result = call();
        // 비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }

    protected abstract T call();
}
</code></pre>
<p><code>execute()</code>에서는 변하지 않는 로직 즉, 우리가 중복을 없애고 싶었던 시간 측정을 로직을 템플릿으로 정의하고,<br />
<code>call()</code>에서는 변하는 로직 즉, 함수화를 번거롭게 만들었던 비즈니스 로직을 구현한다.</p>

<pre><code class="language-java">@Test
void executeLogic(){
    TimeMeasurementTemplate&lt;Void&gt; template1 = new TimeMeasurementTemplate&lt;&gt;() {
        @Override
        protected Void call() {
            log.info("비즈니스 로직1 실행");
            return null;
        }
    };
    template1.execute();


    TimeMeasurementTemplate&lt;Void&gt; template2 = new TimeMeasurementTemplate&lt;&gt;() {
        @Override
        protected Void call() {
            log.info("비즈니스 로직2 실행");
            return null;
        }
    };
    template2.execute();
}
</code></pre>
<p><strong>출력 결과</strong></p>
<pre><code class="language-sh">23:46:35.475 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직1 실행
23:46:35.477 [main] INFO com.siwony.ifl_spring_advanced.trace.template.code.TimeMeasurementTemplate - resultTime=3
23:46:35.479 [main] INFO com.siwony.ifl_spring_advanced.trace.template.TemplateMethodTest - 비즈니스 로직2 실행
23:46:35.479 [main] INFO com.siwony.ifl_spring_advanced.trace.template.code.TimeMeasurementTemplate - resultTime=0
</code></pre>
<ul>
  <li>이렇게 템플릿 메서드 패턴을 이용해 <em>시간을 측정하는 로직</em>과, <em>비즈니스 로직</em>를 분리하여 <strong>SRP를 충족했다.</strong></li>
  <li>그리고 반복되는 코드가 사라짐으로 <strong>코드의 응집력이 높아졌다.</strong></li>
</ul>

<h4 id="하지만-템플릿-메서드-패턴은-상속이-가진-단점을-그대로-가져간다">하지만, 템플릿 메서드 패턴은 상속이 가진 단점을 그대로 가져간다.</h4>
<ul>
  <li>자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합된다.
    <blockquote>
      <p>자식 입장에서는 부모 클래스의 기능을 전혀 사용하지 않는다.<br />
“자식 클래스에서 부모 클래스의 기능을 사용한 것이 있나?”</p>
    </blockquote>
  </li>
  <li>상속 구조를 사용하기 때문에 별도의 <code>클래스</code>/<code>익명 내부 클래스</code>를 만들어야 해서 구조가 복잡하다.</li>
</ul>

<p>템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴은 <a href="Strategy-Pattern.md">전략-패턴(Strategy Pattern)</a>이다.</p>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/03/29/%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95/" class="nav-link">클래스 기반의 프록시 생성 방법</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/03/29/%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4-template-callback-pettern/" class="nav-link">템플릿 콜백 패턴 - Template Callback Pettern</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
