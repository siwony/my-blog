<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpringMVC는 어떻게 데이터를 반환할까?</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">SpringMVC는 어떻게 데이터를 반환할까?</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring-mvc","spring","TIL"]'
          date="April 20, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="springmvc는-어떻게-데이터를-반환할까">SpringMVC는 어떻게 데이터를 반환할까?</h1>
<blockquote>
  <p>부제: <code>ViewResolver</code>와 <code>MessageConverter</code></p>
</blockquote>

<h3 id="해당-글을-적게-된-동기">해당 글을 적게 된 동기</h3>
<p>Spring은 MVC2를 따르기 위해 모든 요청에 대한 응답을 <code>DispacherServlet</code>에서 모두 담당하는 것이 아닌 JSP, HTML과 같이 view만을 반환하는 <code>ViewResolver</code>를 통해 view를 반환한다. 그렇다면, <strong>“JSON혹은 XML과 같은 데이터를 받고 비즈니스 로직을 처리 후 다시 JSON이나 XML과 같은 데이터는 어떻게 데이터를 반환하여 클라이언트에 전달하는지”</strong> 의문을 가지게 되었는데…</p>

<p>SpringMVC 요청 흐름을 검색하면 다음과 같이 간략한 다이어그램을 볼 수 있다.
<img width="750" src="/assets/images/posts/back-end/spring-mvc-request-stream.png" /></p>

<p>View는 <code>ViewResolver</code>를 통해 View를 전달받는데, XML이나 JSON같은 데이터는 어떤식으로 반환하는지에 대한 정보를 찾기도 힘들고 제대로 된 다이어그램도 찾을 수 없어 직접 디버깅과 구글링을 통해 탐구할 것이다.</p>

<p>부분적으로 생략된 부분이 있기 때문에 디버깅을 같이 따라해보면 좋겠다.</p>

<h3 id="responsebody">@ResponseBody</h3>
<p><code>@ResponseBody</code> 어노테이션을 사용한 Controller는 <code>ViewResolver</code>가 아닌 <code>MessageConverter</code>를 통해 사용자에게 데이터를 반환한다.</p>
<blockquote>
  <p>+<code>@RestController</code>속에 <code>@ResponseBody</code> 어노테이션이 있다.</p>
</blockquote>

<h2 id="1-요청응답-과정을-핥아보자">1. 요청/응답 과정을 핥아보자</h2>
<p>앞으로 살펴볼 클래스들의 UML이다.</p>
<blockquote>
  <p>누락된 부분 있을 수 있으므로 제보 부탁드려요 :)</p>
</blockquote>

<p><img src="/assets/images/posts/back-end/DispatcherServlet-UML.png" /></p>

<h3 id="1-1-사전작업">1-1. 사전작업</h3>
<ol>
  <li><code>DispatcherServlect</code>클래스 내부에 들어간다.</li>
  <li><code>DispatcherServlect#doService</code>를 찾는다.</li>
  <li>메서드의 첫번 째 줄인 <code>this.logRequest(request);</code>에 breaking point를 건다.</li>
</ol>

<p><img src="/assets/images/posts/back-end/dispatherServlet-pre-ready.png" /></p>

<p>이후 아무 <code>@RestController</code>를 만들어서 해당 컨트롤러를 실행할 예정이다.</p>

<p>필자는 다음과 같은 컨트롤러를 만들었다.</p>

<pre><code class="language-java">@RestController
public class HelloController {

    @GetMapping("/hello")
    private String hello(){
        return "hello";
    }
}
</code></pre>

<h3 id="1-2-디버깅을-해보자">1-2. 디버깅을 해보자</h3>

<h4 id="1-컨트롤러헨들러를-가져와-실행할-수-있는-상태를-만드는-과정">1. 컨트롤러(헨들러)를 가져와 실행할 수 있는 상태를 만드는 과정</h4>
<p><code>doService</code> 메서드에서 계속 Step Over를 하다보면 <code>doDispatch(request, response)</code>를 찾을 수 있다.</p>

<p><img width="800" src="/assets/images/posts/back-end/find-doDispatch.png" /></p>

<p><code>doDispathc(request, response)</code> 내부로 들어가기 위해 디버거의 Step Into를 사용하면 <code>doDispatch</code>메서드로 들어가진다 그 후,
<code>mappedHandler = this.getHandler(processedRequest);</code>구분이 나올때까지 Step Over를 한다.</p>

<p><img width="800" src="/assets/images/posts/back-end/find-handler-mapping.png" /></p>

<p>그 후 계속 Step Over를 하다보면 HandlerMapping부분을 찾을 수 있는데 <code>getHandler(processedRequest)</code>부분에서 다시 한번 Step Into를 하면</p>

<p><img width="800" src="/assets/images/posts/back-end/getHandler.png" /></p>

<ol>
  <li><code>handlerMappings</code>변수에 5개의 HandlerMapping이 존재하는 것을 확인할 수 있고</li>
  <li>핸들러들을 순회하면서</li>
  <li><code>RequestMappingHandler</code>를 찾은 다음</li>
  <li><code>RequestMappingHandler</code>가 <a href="#1-1-사전작업">사전작업 파트</a>에서 필자가 만든 <code>HelloController#hello</code>를 <code>hander</code>가 가지고 있는것을 볼 수 있다.</li>
</ol>

<p>이렇게 HandlerMapping을 통해 controller(handler) Bean객체를 <code>DispatcherServlet</code>에게 전달한 후,
<code>getHandler</code>를 통해 얻은 <code>HandlerAdapter</code>를 얻어오는 것을 볼 수 있다.</p>
<blockquote>
  <p>HandlerAdapter로 handler를 실행할 수 있다.</p>
</blockquote>

<p><img width="800" src="/assets/images/posts/back-end/find-handlerAdapter.png" /></p>

<p><code>getHandlerAdapter</code>내부로 들어가면 이번에는 for문을 통해 사용할 HandlerAdapter를 찾는 과정이 진행된다.<br />
HandlerAdapter는 사진과 같이 4개가 존재한다.
<img width="800" src="/assets/images/posts/back-end/get-handler-adapter-inside.png" /></p>

<p>디버깅을 계속 진행하다보면 <code>RequestMappingHandlerAdapter</code>가 선택되는 것을 확인할 수 있다. 이제 hendler를 실행할 수 있는 HandlerAdapter를 찾았고 handler를 실행할 단계만 남아있다.</p>

<h4 id="2-handler-실행하기">2. Handler 실행하기</h4>
<p>getHandlerAdapter에서 빠져나온 후 Step Over를 통해 이동하다보면 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>를 볼 수 있는데 이 코드는 
handlerAdapter를 통해 handler를 실행한다. handle매서드를 속을 살펴보면<br />
<img width="800" src="/assets/images/posts/back-end/invoke-handler.png" /></p>

<p>아래와 같이 <code>handleInternal</code> 매서드가 있는 것을 볼 수 있는데 <br />
<img width="800" src="/assets/images/posts/back-end/exec-handle-method.png" /></p>

<p>한번 더 내부코드에 들어가면</p>

<p><img width="800" src="/assets/images/posts/back-end/handleInternal.png" /></p>

<ol>
  <li><code>handlerMethod</code>를 인수로 가지고 있고,</li>
  <li><code>invokeHandlerMethod</code> 메서드에서 리플렉션으로 <code>handlerMethod</code>를 실행한다.
    <blockquote>
      <p>필자 기준 <code>HelloController#hello()</code>가 실행된다.</p>
    </blockquote>
  </li>
</ol>

<p>더 자세히 알기 위해 <code>invokeHandlerMethod</code>를 살펴보면</p>

<p><img src="/assets/images/posts/back-end/invoke-handler1.png" /></p>

<p>거의 끝나간다. <code>invokeHandlerMethod</code>속 <code>invocableMethod.invokeAndHandle(webRequest, mavContainer)</code>를 통해 handler가 실행되고 그에 대한 반환결과를 얻을 수 있다!</p>

<p>해당 사진에 나와있는 코드이외에 여러 코드가 많지만 <code>invocableMethod.invokeAndHandle(webRequest, mavContainer)</code>부분만 알면된다 그 이외의 코드는 view관련 코드인듯 하다.</p>

<p><code>invokeAndHandle(webRequest, mavContainer)</code>의 내부를 들어가보자</p>

<p><img src="/assets/images/posts/back-end/invoke-handler2.png" /></p>

<ol>
  <li>handler를 리플렉션으로 실행한다.</li>
  <li><code>returnValue</code> 에 <code>hello</code>값이 저장되있는 것을 확인 할 수 있다.</li>
</ol>

<p>그 이후 Step Over를 계속 하다 보면, <code>StringHttpMessageConverter</code>를 확인할 수 있다!
<img src="/assets/images/posts/back-end/StringHttpMessageConverter.png" /></p>

<p>드디어 찾았다. HelloController는 단순하게 <code>"hello"</code>를 반환하므로 <code>StringHttpMessageConverter</code>를 통해 메시지를 반환하지만 객체를 반환하게 된다면 Jackson라이브러리에서 제공하는 <code>appingJackson2HttpMessageConverter</code>를 사용하게 된다.</p>

<h2 id="결론">결론</h2>
<p>결과적으로 XML, JSON과 같은 view를 제외한 데이터는 ViewResolver를 거치지 않고, MessageConverter를 거쳐 데이터를 반환한다.</p>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://devlog-wjdrbs96.tistory.com/409</li>
  <li>https://velog.io/@prayme/Spring은-Http-Message-Body를-어떻게-Java의-객체로-역직렬화할까</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/04/19/%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%A0%95%EC%A0%81-%EB%A7%A4%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4%EB%9D%BC/" class="nav-link">생성자 대신 정적 매소드 사용을 고려해라</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/04/20/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%88%9C%ED%9A%8C%EC%A4%91-%EB%A7%8C%EB%82%9C-concurrentmodificationexception/" class="nav-link">리스트 순회중 만난 ConcurrentModificationException</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
