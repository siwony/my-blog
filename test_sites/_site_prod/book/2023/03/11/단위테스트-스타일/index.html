<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>단위테스트 스타일</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">단위테스트 스타일</h1><post-metadata layout="inline" categories='["book"]' tags='["유닛테스트","TIL"]' date="March 11, 2023" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="단위테스트-스타일">단위테스트 스타일</h1><h2 id="요약">요약</h2><p>단위테스트의 스타일은 3가지로 나뉜다.</p><ol><li>상태 기반</li><li>출력 기반</li><li>통신 기반</li></ol><p>여기서 출력 기반 스타일의 테스트는 가장 품질이 좋지만 모든 코드에 적용할 수 없고 순수 함수 방식으로만 작성된 코드에 사용할 수 있다.</p><p>통신 기반 테스트는 간혈적으로 사용해야 한다.</p><h2 id="단위-테스트의-세-가지-스타일">단위 테스트의 세 가지 스타일</h2><h3 id="1-출력-기반-테스트">1. 출력 기반 테스트</h3><p><img src="/assets/images/posts/book/출력_기반_테스트.jpeg"></p><p>SUT에 입력을 넣고 생성되는 출력을 검증하는 방식이다.</p><ul><li>전역 상태나 내부 상태를 변경하지 않는 코드에만 적용된다.</li><li>함수형(functional)이라고 한다.<ul><li>함수형 프로그래밍 에 뿌리를 두고 있다.</li></ul></li></ul><h3 id="2-상태-기반-스타일-정의">2. 상태 기반 스타일 정의</h3><p><img src="/assets/images/posts/book/상태_기반_테스트.jpeg"></p><p>작업이 완료된 후 시스템 상태를 확인하는 것이다.</p><p>상태 기반 스타일에서 상태란 SUT나 협력자 중 하나, 또는 DB나 파일시스템과 같은 프로세스 외부 의존성의 상태를 의미할 수 있다.</p><h4 id="예제">예제</h4><pre><code class="language-kotlin">class Order{
    private val _products: MutableList&lt;Product&gt; = mutableListOf()
    private val products: List&lt;Product&gt;
        get() = _products

    fun addProduct(product: Product){
        _products.add(product)
    }
}

@Test
fun `Adding a product to an order`(){
    val product = Product("Hand wash")
    val sut = Order();

    sut.addProduct(product);

    Assertions.assertEquals(1, sut.products.count())
    Assertions.assertEquals(product, sut.products[0])
}
</code></pre><p>addProduct를 검증하는게 아닌 Order의 상태값인 products를 검증했다.</p><h3 id="3-통신-기반-스타일-정의">3. 통신 기반 스타일 정의</h3><p>목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증한다.</p><pre><code class="language-kotlin">@Test
fun `Sending a greetings eamil`(){
    val emailGatewayMock: EmailGateWay = mockk()
    val sut = new Controller(emailGatewayMock)
    val email = "user@email.com"
    every{
        emailGatewayMock.sendGreetingsEmail(email)
    } just run

    sut.greetUser(email)

    verify(exactly = 1){
        emailGatewayMock.sendGreetingsEmail(email)
    }
}
</code></pre><h2 id="단위테스트-스타일-비교">단위테스트 스타일 비교</h2><p>| | 출력 기반 | 상태 기반 |통신 기반| |—————————–|———|———|——| |리펙터링 내성을 지키기 위해 필요한 노력| 낮음 | 중간 | 중간 | |유지비 | 낮음 | 중간 | 높음 |</p><h3 id="결론">결론</h3><p>출력 기반 테스트를 선호하자.</p><ul><li>코드를 순수함수로 바꾸면 출력 기반 테스트로 변경할 수 있다.<ul><li>하지만 모든 코드를 순수 함수로 바꿀 수 없다.</li></ul></li></ul><h2 id="함수형-아키텍처">함수형 아키텍처</h2><p><img src="/assets/images/posts/book/함수형_아키텍처.png"></p><p>함수형 프로그래밍은 수학적 함수(mathematial function)혹은 순수 함수(pure function)이라고 불리우는 함수를 사용하는 프로그래밍이다.</p><ul><li>하나의 입력과 하나의 출력이 있으며 둘 다 메서드 시그니처에 명시되어 있다.</li><li>숨은 입출력이 없는 메서드이다.</li></ul><pre><code class="language-kotlin">fun decimal calculatorDiscount(products: Array&lt;Product&gt;){
    val discount: BigDecimal = products.length * 0.01
    return Math.min(discount, 0.2)
}
</code></pre><h3 id="비즈니스-로직과-부수효과를-분리하는-방법">비즈니스 로직과 부수효과를 분리하는 방법</h3><p>두 가지 코드 유형을 구분하여 분리할 수 있다,.</p><ul><li>결정을 내리는 코드: 해당 코드는 부작용이 없기 때문에 수학적 함수를 사용해 작성할 수 있다.<ul><li>함수형 코어</li></ul></li><li>해당 결정에 따라 작용하는 코드: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환한다.<ul><li>가변 셸</li></ul></li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/book/2023/03/05/4-%EC%A2%8B%EC%9D%80-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%9D%98-4%EB%8C%80%EC%9A%94%EC%86%8C/" class="nav-link">4. 좋은 단위 테스트의 4대요소</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/book/2023/03/19/8-%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/" class="nav-link">8. 통합 테스트를 하는 이유</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>