<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>소프트웨어 테스트</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">소프트웨어 테스트</h1><post-metadata layout="inline" categories='["cs"]' tags='["TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="소프트웨어-테스트">소프트웨어 테스트</h1><ul><li>소프트웨어 테스트는 소프트웨어가 문제가 없다를 보이는 것이 아니라 문제가 있다를 밝히는 과정이다.</li><li>즉, 문제를 밝혀 그 문제를 해결하고 소프트웨어의 신뢰성을 높이는 일련의 과정이다.</li><li>SWLC(소프트웨어 생명주기)의 프로세스중에 테스트에 해당된다.</li></ul><blockquote><p>*SWLC(소프트웨어 생명주기) :<br>요구사항 분석 → 시스템 명세 단계 → 설계 → 구현 → 테스트 → 유지보수</p></blockquote><h3 id="정의">정의</h3><ul><li>노출되지 않은 숨어있는 결함(Fault)을 찾기 위해 소프트웨어를 작동시키는 일련의 행위와 절차</li><li>오류 발견을 목적으로 프로그램을 실행하여 품질을 평가하는 과정</li><li>품질을 개선하기 위한 일련의 활동</li><li>일반적으로 테스트 케이스에 따라 SW를 동적으로 실행시켜 예상결과치와 비교 분석</li><li>SW의 동작과 성능, 안정성이 요구되는 수준을 만족하는지 확인하기 위한 결함을 발견하는 메커니즘</li></ul><h3 id="목적">목적</h3><ul><li>프로그램에 잠재된 오류의 발견</li><li>기술적인 기능 및 성능의 확인</li><li>사용자 만족도 향상</li><li>제품 신뢰도 향상</li></ul><h3 id="테스트의-일반적인-원리">테스트의 일반적인 원리</h3><p>|원리|내용|원인| |–|–|–| |<strong>결함발견</strong>|- 결함 제거가 아닌 결함의 발견을 목적 | 테스트 본연의 역활| |<strong>불완정성</strong>|- 완전한 테스트는 불가능하다.<br>- 무한경로, 무한 입력 값, 무한 타이핑 불가능| 자원의 한계| |<strong>초기 집중</strong><br>(*요르돈 법칙)|- 개발 설계 시 부터 테스트 고려<br>- 결함의 조기 발견 및 재유입 방지|품질 비용 감소| |<strong>결함 집중</strong>|- 결함의 80%는 20%의 특정 모듈에 집중된다.|파레토 법칙| |<strong>살충제 패러독스</strong>|- 동일한 테스트 전략, 기법을 적용 할 시 내성이 생긴다.<br>(더이상 새로운 결함을 찾아 내지 못한다.)|테스트에 특화된 코딩| |<strong>정황 의존적</strong>|- 테스트는 주변 환경에 영향을 받음|외부요소, 심리 요소| |<strong>오류-부재의 궤변</strong>|- 요구 사항을 충족시키지 못한다면,<br>결함을 발견하고 모두 제거하여도 좋은 테스트라 볼 수 없다.|테스터의 수동적 자세|</p><blockquote><p>*요르돈 법칙 :<br>Snowball Effect, 눈덩이 법칙, 결함 증폭 모델<br>소프트웨어 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게되어 비용이 커진다는 법칙</p></blockquote><h2 id="소프트웨어-테스트의-종류">소프트웨어 테스트의 종류</h2><p><img width="500px" src="/assets/images/posts/cs/kinds-of-test.jpg"></p><h3 id="back-box-testing---블렉-박스테스팅">Back Box Testing - 블렉 박스테스팅</h3><p>: 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 동작을 검사하는 방식이다.</p><ul><li>올바른 입력과 올바르지 않은 입력을 입력하여 올바른 출력이 나오는지 테스트하는 기법이다.</li><li>사용자 관점의 테스트 방법이라 볼 수 있다.</li></ul><h3 id="whilte-box-testing---화이트-박스-테스팅">Whilte Box Testing - 화이트 박스 테스팅</h3><p>: 시스템의 내부 설계를 고려한 테스팅으로서 시스템의 코드 내부의 로직에 대한 지식을 기반으로 수행된다.</p><ul><li>응용 프로그램의 내부 구조, 동작, 내부 소스 코드 검사하는 테스트 방식이다.</li><li>커버리지(Coverage)를 통하여 테스팅된다.</li><li>개발자 관점의 테스트 방법이라 볼 수 있다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91%EC%8B%A4%EC%A0%84/" class="nav-link">상속관계 매핑(실전)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/cs/2022/03/19/%EC%88%9C%EC%B0%A8-%EB%A6%AC%EC%8A%A4%ED%8A%B8-sequential-list/" class="nav-link">순차 리스트 - Sequential List</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>