<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>동적 계획법과 분할 정복 - Dynamic Programming & Divide</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">동적 계획법과 분할 정복 - Dynamic Programming & Divide</h1><post-metadata layout="inline" categories='["algorithm"]' tags='["TIL"]' date="March 17, 2022" reading-time="1" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="동적-계획법과-분할-정복---dynamic-programming--divide">동적 계획법과 분할 정복 - Dynamic Programming &amp; Divide</h1><h2 id="동적-게획법">동적 게획법</h2><p>복잡한 문제를 간단한 여러개의 문제로 나누어 푸는 방법</p><ul><li>상향식 접근법으로 가장 최하위 해답을 구하고, 공간을 할당하여 기억하고 해당 결과값을 이용해 상위 문제를 풀어간다.</li><li>문제를 해결하기 위한 모든 방법을 검토하고, 그 중 최적의 풀이법을 찾아낸다.</li><li>ex. 피보나치 수열</li></ul><h3 id="방법">방법</h3><ol><li>입력 크기가 작은 부분 문제들을 해결한다.</li><li>해당 부분 문제의 해를 활용해서 보다 큰 크기의 부분 문제를 해결한다.</li><li>최종적으로 전체 문제를 해결한다.</li></ol><h2 id="분할-정복---divide-and-conquer">분할 정복 - Divide and conquer</h2><p>문제를 나눌 수 없을 때까지 나누어 다시 합병하여 문제의 답을 얻는 알고리즘</p><ul><li>하향식 접근법으로, 상위의 해답을 구하기 위해, 아래로 내려가면서 하위의 해답을 구하는 방식이다.<blockquote><p>일반적으로 재귀함수로 구현한다.</p></blockquote></li><li>문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않는다.<blockquote><p>병합 정렬, 퀵 정렬 등</p></blockquote></li></ul><h2 id="공통점과-차이점">공통점과 차이점</h2><h3 id="공통점">공통점</h3><p>문제를 잘게 쪼개서 가장 작은 단위로 분할한다.</p><h3 id="차이점">차이점</h3><h4 id="동적-계획법">동적 계획법</h4><ul><li>부분 문제는 중복되어, 상위 문제 해결시 재활용된ㅇ</li><li>Memoization 기법이 사용된다.</li></ul><h4 id="분할-정복">분할 정복</h4><ul><li>부분 문제는 서로 중복되지 않는다.</li><li>Memoization 기법은 사용되지 않는다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/network/2022/03/17/%EB%8D%94-%EB%82%98%EC%9D%80-uri-api%EB%A5%BC-%EC%84%A4%EA%B3%84-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95%EA%B3%BC-http-method/" class="nav-link">더 나은 URI API를 설계 하는 방법과 HTTP method</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/network/2022/03/17/%EC%84%9C%EB%B2%84%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%ED%86%A0%ED%81%B0%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D/" class="nav-link">서버기반 인증, 토큰기반 인증</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>