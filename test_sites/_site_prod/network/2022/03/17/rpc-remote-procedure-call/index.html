<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RPC - Remote Procedure Call</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">RPC - Remote Procedure Call</h1><post-metadata layout="inline" categories='["network"]' tags='["protocol","rpc","TIL"]' date="March 17, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="rpc---remote-procedure-call">RPC - Remote Procedure Call</h1><h2 id="1-등장-배경">1. 등장 배경</h2><p>https://en.wikipedia.org/wiki/Remote_procedure_call#History_and_origins</p><h2 id="2-rpc의-개념">2. RPC의 개념</h2><p>RPC란 프로세스간 통신을 위해 사용하는 <a href="/cs/ipc.md"><code>IPC - Inter Process Communication</code></a> 방법의 한 종류이며, <strong>원격지의 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용한다.</strong></p><blockquote><p>즉, 원격지의 프로시저를 호출하는 것이다.</p></blockquote><ul><li>RPC는 <code>분산 컴퓨팅</code>, <code>client-server</code>를 베이스로 한 앱을 위한 기술이다.</li><li>RPC는 일반적인 로컬 프로시저 호출을 확장하는 것을 기반으로 한다.</li><li>두 프로세스들이 같은 시스템에 있거나 다른 시스템에 존재하며 네트워크가 프로세스들을 연결하는 형태로 존재한다.</li></ul><blockquote><h4 id="ipc란">IPC란?</h4><p>Socket, Shared Memory, Message Queue와 같이 프로세스틀이 통신하는 모든 형태를 일컷는다.</p></blockquote><p><img src="/assets/images/posts/network/rpc-processe.png"></p><blockquote><h4 id="프로시저의-목적">프로시저의 목적</h4><p>결과 값에 집중하기 보다 <strong>명령 단위가 수행하는 절차를 목적</strong>으로 한다,</p></blockquote><blockquote><h4 id="함수의-목적">함수의 목적</h4><p>함수는 <strong>Input에 대비한 Output의 발생을 목적</strong>으로 한다.</p></blockquote><h3 id="2-1-rpc의-궁극적인-목표">2-1. RPC의 궁극적인 목표</h3><ul><li>client-server간 커뮤니케이션에 필요한 상세한 정보는 최대한 감춘다.</li><li>클라이언트는 <code>일반 메소드를 호출하는 것</code> 처럼 원격지에 프로시저를 호출할 수 있다.</li></ul><h2 id="3-rpc의-동작-방식">3. RPC의 동작 방식</h2><p><img width="600" src="/assets/images/posts/network/rpc-mechanism.png"></p><ol><li><code>client</code>는 일반적인 방법으로 매개변수를 전달하여 <strong><code>client stub procedure</code>를 호출한다.</strong><blockquote><p><code>client stub</code>은 클라이언트속 주소 공간에 있다.</p></blockquote></li><li><strong><code>client stub</code>은 매개변수를 메시지로 마샬링(pack)</strong> 한다.<blockquote><p>마샬링에는 매개변수 표현을 표준 형식으로 변환하고 각 매개변수에 메시지를 복사하는 작업이 포함된다.</p></blockquote></li><li><code>client stub</code>은 메시지를 원격<code>Server Machine</code>으로 보내는 전송 계층으로 전달한다.</li><li>서버의 <code>transport layer</code>은 매개변수를 <code>디마셜링 - demarshalling</code>(unpack)하고 일반 프로시저 호출 메커니즘을 사용하여 원하는 서버 루틴을 호출하는 <code>server stub</code>에 메시지를 전달한다.</li><li>서버 프로시저가 완료되면 <code>server stub</code>으로 반환되며, 반환값을 메시지로 마샬링후 <code>server stub</code>은 메시지를 <code>transport layer</code>에 전달한다.</li><li><code>transport layer</code>는 결과 메시지를 client <code>transport layer</code>으로 다시 보내고, <code>client</code>의 <code>transport layer</code>는 메시지를 <code>client stub</code>으로 다시 전달한다.</li><li><code>client stub</code>은 반환 매개변수를 디마샬링하고, 실행 결과값은 호출자(caller)에게 반환된다.</li></ol><h3 id="3-1-idl를-이용한-동작방식">3-1. IDL를 이용한 동작방식</h3><p><img width="650" src="/assets/images/posts/network/rpc-use-idl.jpg"></p><ol><li><code>IDL - Interface Definition Language</code>을 사용하여 호출 규약을 정의한다.<blockquote><p>함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen으로 컴파일하면 stub code가 자동으로 생성된다.</p></blockquote></li><li>Stub Code에 명시된 함수는 원시코드의 형태로, 상세 기능은 server에서 구현된다.<blockquote><p>만들어진 stub코드는 클라이언트/서버에 함께 빌드한다.</p></blockquote></li><li>client에서 stub에 정의된 함수를 사용할 때,</li><li>client stub은 RPC runtime을 통해 함수 호출하고</li><li>server는 수신된 procedure 호출에 대한 처리 후 결과 값을 반환한다.</li></ol><p>최종적으로 Client는 Server의 결과 값을 반환받고, 함수를 Local에 있는 것 처럼 사용할 수 있다.</p><h3 id="3-2-용어-설명">3-2. 용어 설명</h3><h4 id="stub">stub</h4><ul><li>client stub : 마샬링(함수호출에서 사용되는 파라미터의 변환)과 함수 실행 후 서버에서 전달된 결과의 변환을 담당한다.</li><li>server stub : 언마샬링(클라이언트가 전달한 매개변수의 역변환) 및 함수 실행 결과의 변환을 담당한다.</li></ul><h4 id="caller--callee">caller / callee</h4><ul><li>client / server가 필요한 비즈니스 로직을 작성하는 Layer</li><li><code>IDL - interface definition language</code>로 작성</li></ul><h4 id="rpc-runtime">RPC RunTime</h4><ul><li>Server와 Client를 바인딩하는 Layer</li><li>커뮤니케이션 중 발생한 에러 처리도 함께 진행한다.</li></ul><h4 id="루틴">루틴</h4><p>루틴과 서브 루틴은 어떤 프로그램이 실행될 때 불려지거나 반복해서 사용되도록 만들어진 일련의 코드들을 지칭하는 용어이다.</p><h2 id="4-rpc의-장단점">4. RPC의 장단점</h2><h3 id="4-1-장점">4-1. 장점</h3><ul><li>추상화를 제공한다.<blockquote><p>네트워크 통신의 메시지 전달 특성은 사용자에게 숨겨져 있다.</p></blockquote></li><li>성능향상을 위해 많은 프로토콜 계층을 생략할 수 있다.</li><li>RCP를 사용하면 <strong>로컬환경뿐만 아니라 분산환경에서도 응용 프로그램을 사용할 수 있다.</strong></li><li><code>프로세스 지향</code>/<code>쓰레드 지향</code>모델을 지원한다.</li><li>클라이언트가 high-level 언어로 프로시저 호출을 사용하여 서버와 통신할 수 있도록 돕는다.</li></ul><h3 id="4-2-단점">4-2. 단점</h3><ul><li>통일된 표준이 없다.<blockquote><p>그래서 여러 벤더가 존재한다.</p></blockquote></li><li>상호작용 기반이므로 하드웨터 아키텍처와 관련하여 유연성을 제공하지 않는다.</li><li>항상 많은 양의 데이터를 전송하는데 적합하지 않다.<blockquote><p>클라이언트와 서버는 다른 실행환경을 사용할 수 있기 때문이다.</p></blockquote></li></ul><h2 id="5-rpc의-대표적인-벤더">5. RPC의 대표적인 벤더</h2><ul><li><a href="https://developers.google.com/protocol-buffers/">ProtocolBuffer by Google</a></li><li><a href="https://thrift.apache.org/">Thrift by Facebook</a></li><li><a href="https://twitter.github.io/finagle/">Finalge by Twitter</a></li></ul><h2 id="reference">Reference</h2><ul><li>https://www.geeksforgeeks.org/remote-procedure-call-rpc-in-operating-system/</li><li>https://velog.io/@jakeseo_me/RPC%EB%9E%80</li><li>https://nesoy.github.io/articles/2019-07/RPC</li><li>https://velog.io/@xylopeofficial/gRPC1</li><li>https://www.techtarget.com/searchapparchitecture/definition/Remote-Procedure-Call-RPC</li><li>http://www.terms.co.kr/routine.htm</li><li>https://medium.com/naver-cloud-platform/nbp-기술-경험-시대의-흐름-grpc-깊게-파고들기-1-39e97cb3460</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/network/2022/03/17/rest-api-rest-api/" class="nav-link">REST, API, REST API</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/network/2022/03/17/socket/" class="nav-link">Socket</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>