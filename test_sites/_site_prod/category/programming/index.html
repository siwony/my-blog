<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Programming Posts</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><div class="category-page"><header class="category-header"><h1>Programming Posts</h1><p class="category-description">75 posts in this category</p></header><div class="category-content"><div class="post-list"><article class="post-preview"><h3><a href="/programming/2024/10/07/prism-syntax-highlighting-test/">Prism.js Syntax Highlighting 테스트</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["javascript","python","java","prism","syntax-highlighting"]' date="October 07, 2024" reading-time="2"></post-metadata><p>이 포스트는 새로 적용된 Prism.js syntax highlighting을 테스트하기 위한 글입니다.</p></article><article class="post-preview"><h3><a href="/programming/2024/02/18/vo-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4/">VO 사실과 오해</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["coding","development","TIL"]' date="February 18, 2024" reading-time="4"></post-metadata><p>VO 사실과 오해 2022.10.19(수) 사내에서 발표한 내용</p></article><article class="post-preview"><h3><a href="/programming/2022/09/25/equals/">equals</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="September 25, 2022" reading-time="1"></post-metadata><p>equals</p></article><article class="post-preview"><h3><a href="/programming/2022/09/24/%EC%8B%9Dexpression%EA%B3%BC-%EB%AC%B8statement/">식(expression)과 문(statement)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="September 24, 2022" reading-time="1"></post-metadata><p>식(expression)과 문(statement) Java에서 볼 수 없던 특징이라 정리하게 됨</p></article><article class="post-preview"><h3><a href="/programming/2022/06/28/weakhashmap/">WeakHashMap</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","memory","development","java"]' date="June 28, 2022" reading-time="1"></post-metadata><p>WeakHashMap 더 이상 사용하지 않는 객체를 GC할 때 자동으로 삭제해주는 Map Key가 더 이상 강하게 레퍼런스(strong reference)되는 곳이 없다면 해당...</p></article><article class="post-preview"><h3><a href="/programming/2022/06/28/java-reference%EC%99%80-gc/">Java Reference와 GC</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","memory","development","java"]' date="June 28, 2022" reading-time="4"></post-metadata><p>Java Reference와 GC 최초의 Java에서는 GC작업에 애플리케이션의 사용자 코드가 관여하지 않도록 구현되어 있었지만 GC작업에서 좀 더 다양한 방법으로 객체를 처리하기...</p></article><article class="post-preview"><h3><a href="/programming/2022/06/26/pojoplain-old-java-object/">POJO(Plain Old JAVA Object)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="June 26, 2022" reading-time="2"></post-metadata><p>POJO(Plain Old JAVA Object) : 오래된 방식의 간단한 자바 오브젝트 “특정 '기술'에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말한다.”...</p></article><article class="post-preview"><h3><a href="/programming/2022/05/16/try-with-resource-%EA%B5%AC%EB%AC%B8%EA%B3%BC-use%ED%95%A8%EC%88%98/">try-with-resource 구문과 use함수</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="May 16, 2022" reading-time="1"></post-metadata><p>try-with-resource 구문과 use함수 Java에서는 자원을 close를 해야 할 떄 try-with-resources문으로 자원이 일을 한 후 자동으로 close()를 호출해주는 구문이 있다.</p></article><article class="post-preview"><h3><a href="/programming/2022/05/13/%EC%97%98%EB%B9%84%EC%8A%A4-%EC%97%B0%EC%82%B0%EC%9E%90-elvis-operation/">엘비스 연산자 - Elvis Operation</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="May 13, 2022" reading-time="1"></post-metadata><p>엘비스 연산자 - Elvis Operation 엘비스 연산자는 ?:로 표현된다. 왼쪽 객체가 non-null이면 그 객체의 값으 리턴되고, null이면 ?:의 오른쪽 값을...</p></article><article class="post-preview"><h3><a href="/programming/2022/05/02/%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98-varages/">가변인수 - varages</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="May 02, 2022" reading-time="1"></post-metadata><p>가변인수 - varages // todo heap pollution</p></article><article class="post-preview"><h3><a href="/programming/2022/05/02/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EB%8A%94-%EB%B0%A9%EB%B2%95/">인스턴스화를 막는 방법</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="May 02, 2022" reading-time="1"></post-metadata><p>인스턴스화를 막는 방법 객체지향에서 객체를 만드는 인스턴스화를 막는다니 이게 뭔소리인가 싶지만, 주로 유틸리티성 클래스같이 정적 메소드로만 이루어져 있는 클래스들은 객체를...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/29/kotlin/">Kotlin</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="April 29, 2022" reading-time="1"></post-metadata><p>Kotlin JetBrains에서 2011년에 공개한 오픈 소스 프로그래밍 언어 Java에 비해 상당히 간결한 문법을 가지고 있다. 근데 뭔가 많이 간결해서 Java...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/29/keyword/">Keyword</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="April 29, 2022" reading-time="4"></post-metadata><p>Keyword 1. Hard Keywords 식별자로 사용할 수 없는 키워드를 의미한다.</p></article><article class="post-preview"><h3><a href="/programming/2022/04/29/kotlin%EC%9D%98-%EB%B3%80%EC%88%98/">Kotlin의 변수</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["kotlin","coding","development","TIL"]' date="April 29, 2022" reading-time="2"></post-metadata><p>Kotlin의 변수 이글의 예제 코드는 Main 함수에서 진행되었으며, Main함수를 생략했습니다. 특징 var와 val이라는 키워드로 변수를 만든다. Non-null과 Nullable이 존재한다. ?...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/26/%EC%A7%81%EB%A0%AC%ED%99%94-serializable/">직렬화 - Serializable</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="April 26, 2022" reading-time="1"></post-metadata><p>직렬화 - Serializable Java Object Serialization Spec</p></article><article class="post-preview"><h3><a href="/programming/2022/04/20/%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%88%9C%ED%9A%8C%EC%A4%91-%EB%A7%8C%EB%82%9C-concurrentmodificationexception/">리스트 순회중 만난 ConcurrentModificationException</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","java-collection-framework"]' date="April 20, 2022" reading-time="3"></post-metadata><p>리스트 순회중 만난 ConcurrentModificationException 1. 문제의 발생과 배경 알고리즘을 풀다가 리스트를 enhanced for loop(for each)를 통해 순회하며 List.remove()연산을 해야 하는...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/20/%ED%96%A5%EC%83%81%EB%90%9C-for-%EB%A3%A8%ED%94%84-enhanced-for-loop/">향상된 for 루프 - Enhanced for loop</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","grammar","coding","development","java"]' date="April 20, 2022" reading-time="1"></post-metadata><p>향상된 for 루프 - Enhanced for loop 주로 for each한다. JDK5부터 추가되었다. 배열 뿐만 아니라 Iterable를 구현한 클래스에 사용할 수...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/19/%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%A0%95%EC%A0%81-%EB%A7%A4%EC%86%8C%EB%93%9C-%EC%82%AC%EC%9A%A9%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4%EB%9D%BC/">생성자 대신 정적 매소드 사용을 고려해라</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","effective-java","development","java"]' date="April 19, 2022" reading-time="1"></post-metadata><p>생성자 대신 정적 매소드 사용을 고려해라</p></article><article class="post-preview"><h3><a href="/programming/2022/04/16/junit5/">Junit5</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["junit","TIL","coding","development","java"]' date="April 16, 2022" reading-time="1"></post-metadata><p>Junit5 Java의 대표적인 단위 테스트 코두 Java8+ 대체제: TestNG, Spock Junit5부터 class, method에 public를 붙여주지 않아도 된다.</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/enum%EC%97%B4%EA%B1%B0%ED%98%95/">enum(열거형)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>enum(열거형) 열거타입을 이용하면 변수를 선언할 때 변수타입으로 사용가능 특정 값만 가져야 한다면 열거형 사용 상수를 열거형 대신해서 사용했던것</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/java-data-type/">JAVA Data Type</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>JAVA Data Type</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/java/">JAVA</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>JAVA 특징 1. 객체 지향 프로그래밍(OOP) JAVA는 상속, 캡슐화(은닉성), 다형성, 추상화를 제공한다. OOP참고</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/package/">Package</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>Package 서로 연관됨 클래스 또는 인터페이스들을 묶어 놓은 묶음 클래스들이 필요할 때만 사용될 수 있도록 함 클래스를 패키지 이름 과...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/try-with-resources/">Try-with-resources</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="2"></post-metadata><p>Try-with-resources 해당 문법은 try(...)에서 선언된 객체들에 대해 try가 종료될 떄 자동으로 자원을 해제해주는 기능히다. try에서 선언된 객체가 AutoCloseable을 구현하면 Java는...</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/%EB%B3%80%EC%88%98%EC%9D%98-scope-static/">변수의 scope, static</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>변수의 scope, static scope 프로그램상에서 사용되는 변수의 사용가능한 범위 ```java public class ValableScopeExam{</p></article><article class="post-preview"><h3><a href="/programming/2022/04/05/array/">Array</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["legacy","TIL","grammar","coding","development","java"]' date="April 05, 2022" reading-time="1"></post-metadata><p>Array 배열 선언 ```java ///////////1차원/////////// int[] arr1 = new int[100]; int[] arr2 = new int[]{1, 2, 3, 4}; int[] arr3...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/stream/">Stream</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","api","java8"]' date="March 29, 2022" reading-time="3"></post-metadata><p>먼저 숙지해야 하는 것 숙지하지 않아도 사용할 수 있지만, Stream은 여러 메서드에서 함수형 인터페이스를 사용하므로 숙지하는게 좋다. 람다 표현식 메서드...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/string-class/">String class</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","api"]' date="March 29, 2022" reading-time="3"></post-metadata><p>String class Java를 만든 사람들은 객체지향 언어를 설계할 때 모든 것을 객체로 만들지 않고 원시형 - Primitive Type를 보유하여 성능을...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C-%EA%B2%BD%EC%9F%81%EC%83%81%ED%83%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/">Synchronized 키워드 - 경쟁상태를 해결하는 방법</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Synchronized 키워드 - 경쟁상태를 해결하는 방법 synchronized 키워드는 Multi-Thread 환경에서 여러개의 쓰래드가 하나의 공유 변수에 동시에 접근할 때 경쟁상태 -...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/thread-pool/">Thread Pool</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Thread Pool : 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/volatile-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%80%EC%8B%9C%EC%84%B1%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/">Volatile - 메모리 가시성을 해결하는 방법</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Volatile - 메모리 가시성을 해결하는 방법 volatile 키워드는 Java "변수를 Main Memory에 저장하겠다"라는 것을 명시하는 것이다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/wrapper-class/">Wrapper class</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Wrapper class</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9D%EC%8B%9C-dynamic-proxy/">다이나믹 프록시 - Dynamic Proxy</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>다이나믹 프록시 - Dynamic Proxy 런타임에 특정 인터페이스들을 구현하는 클래스 또는 인스턴스를 만드는 기술 공식문서</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/">디자인 패턴</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>디자인 패턴 : 자주 사용하는 설계 패턴을 정형화하여 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계 알고리즘과...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D/">람다 표현식</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","grammar","coding","development","java","java8"]' date="March 29, 2022" reading-time="2"></post-metadata><p>람다 표현식 : 간단히 메소드를 하나의 식으로 표현한 것이다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-reflection/">리플렉션 - Reflection</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="4"></post-metadata><p>리플렉션 - Reflection</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%A9%94%EC%86%8C%EB%93%9C-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-method-reference/">메소드 레퍼런스 - Method Reference</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","grammar","coding","development","java","java8"]' date="March 29, 2022" reading-time="2"></post-metadata><p>메소드 레퍼런스 - Method Reference : Lambda 표현식을 더 간단하게 표현하는 방법입니다. 메소드 레퍼런스를 이해 하려면 Lambda를 먼저 이해해야 한다....</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91/">바이트 코드 조작</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","JVM","development","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>바이트 코드 조작</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%A1%9C%EC%BB%AC-thread-local/">스레드 로컬 - Thread Local</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>스레드 로컬 - Thread Local Reference 김영한 인프런 핵심 원리 - 고급편</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-annotation-processor/">어노테이션 프로세서 - Annotation Processor</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>어노테이션 프로세서 - Annotation Processor Oracle 공식문서</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95/">클래스 기반의 프록시 생성 방법</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>클래스 기반의 프록시 생성 방법 ByteBuddy와 CGlib로 class기반 생성을 할 수 있다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4-template-method-pattern/">템플릿 메서드 패턴 - Template Method Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>템플릿 메서드 패턴 - Template Method Pattern 참고자료 김영한 인프런 핵심 원리 - 고급편 예제 코드</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4-template-callback-pettern/">템플릿 콜백 패턴 - Template Callback Pettern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>템플릿 콜백 패턴 - Template Callback Pettern</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/%ED%95%A8%EC%88%98%ED%98%95-interface/">함수형 interface</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","grammar","coding","development","java","java8"]' date="March 29, 2022" reading-time="3"></post-metadata><p>함수형 interface 추상 메서드가 1개만 있으면 모두 함수형 interface이다. 정적(static) 메서드, 디폴트(default) 메서드가 있을 수 있다. SAM(Single Abstract Method) @FunctionalInterface...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/adepter-pattern/">Adepter Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Adepter Pattern : 서로 다른 인터페이스를 가진 두 클래스를 어댑터 클래스로 인터페이스를 통일 시켜 사용하는 방법이다. 관계가 없는 인터페이스를 같이...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/annotation/">Annotation</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Annotation Annotation은 그자체로 주석이라는 의미를 가진다. 하지만 일반 주석이랑 다르다! JDK5 버전부터 사용할 수 있다. @를 붙여서 사용한다. Reflection을 이용해...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/atomic/">Atomic</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Atomic java.util.concurrent.atomic에 정의 되어 있고 멀티 쓰레드 환경에서 동기화에 의존하지 않고, 원자성을 보장하게 해주는 Atomic API에 대해 소개하려고 한다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/callable%EA%B3%BC-future/">Callable과 Future</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Callable과 Future Callable은 Runnable과 다르게 작업(task)의 결과를 받을 수 있다. 그리고 ExecutorService를 이용해 Callable의 작업물을 Future객체로 감싸서 받을 수 있다....</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/class-loader-system-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94-%EC%8B%9C%EC%8A%A4%ED%85%9C/">Class Loader System - 클래스 로더 시스템</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","JVM","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Class Loader System - 클래스 로더 시스템 로딩 → 링크 → 초기화</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/concurrent-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/">Concurrent 프로그래밍</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Concurrent 프로그래밍 동시에 여러 작업을 진행할 수 있는 프로그래밍 ex. 유튜브 보면서 코딩 자바에서 지원하는 Concurrent 프로그래밍 멀티 프로세싱 (ProcessBuilder)...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/decorator-pattern/">Decorator Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Decorator Pattern : 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴 기본 뼈대(클래스)는 유지하되, 이후...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/enumeration-%EC%99%80-iterator/">Enumeration 와 Iterator</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","api"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Enumeration 와 Iterator Enumeration 와 Iterator는 서로 동작하는 것이 비슷하다. 먼저 이 두 개를 알기 전에 Fila-Fast 방식에 대해 알아야...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/exception-%EC%98%88%EC%99%B8/">Exception (예외)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Exception (예외) 오류(Error)와 예외(Exception) 오류(Error) : 시스템에 비정상적인 상황이 생겼을 때 발생한다. 시스템 수준에서 발생한다. → 심각한 수준의 오류 개발자가...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/executor-framework/">Executor Framework</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Executor Framework : 고수준 (High-Level) Concurrency 프로그래밍를 지원하는 Framework</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/facade-pattern/">Facade Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Facade Pattern : 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. &lt;img width=550px src=./img/facade-diagram.png&gt;</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/google-guava/">Google Guava</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Google Guava 배경 FCM를 통해 push 알람로직을 작성하는 중 관련 API의 코드를 뜯어보는 중 Guava에 대한 언급이 있어 찾아보게 되었다....</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/interface/">Interface</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="6"></post-metadata><p>Interface : Java Programing 언어에서 class들이 구현해야 하는 동작을 지정하는데 사용하는 추상 자료형이다. interface라는 키워드를 사용하여 선언한다. 메소드 시그니처(Method sigature),...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/java-beans/">Java Beans</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Java Beans EJB(Enterprise Java Beans)와 전혀 다르다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/java-install/">Java install</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Java install openJDK 설치 필자는 open jdk 11버전을 선택했다. sudo apt install openjdk-11-jdk</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/java-version-%EB%B3%80%EA%B2%BD/">Java version 변경</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="1"></post-metadata><p>Java version 변경</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/java%EC%9D%98-%EB%82%A0%EC%A7%9C%EC%8B%9C%EA%B0%84%EC%9D%84-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94-api/">Java의 날짜/시간을 나타내는 API</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","api","java8"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Java의 날짜/시간을 나타내는 API Java8 이전 Date, Calendar, SimpleDateFormet등… 문제점 1. 객체명이 직관적이지 않다. Data객체가 날짜와 시간을 제공한다. → 객체명이...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/jcf-java-collection-framework/">JCF - Java Collection Framework</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","java-collection-framework"]' date="March 29, 2022" reading-time="3"></post-metadata><p>JCF - Java Collection Framework Java Collection Framework는 공통적으로 재사용 가능한 수집 데이터 구조를 구현하는 클래스 및 인터페이스의 집합이다.</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/jvm-jdk-jre/">JVM, JDK, JRE</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["java","coding","development","TIL"]' date="March 29, 2022" reading-time="1"></post-metadata><p>JVM, JDK, JRE JVM - Java Virtual Machine WORA - Write Once Run Anywhere JVM으로 Java byte code(.class파일)를 OS 특화된...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/jvm-%EA%B5%AC%EC%A1%B0/">JVM 구조</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","JVM","development","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>JVM 구조</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/jvm/">JVM</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","JVM","development","java"]' date="March 29, 2022" reading-time="8"></post-metadata><p>JVM 이 md는 Java7버전 기준으로 작성되었어요… Permanent Generation이 삭제가 되어버리네…?? 그와중에 블로그들 왜 다 java7버전 기준으로 정리함 어이없음 ㅋㅋㅋㅋㅋ 역시...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/observer-pattern/">Observer Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Observer Pattern : 변화가 일어 났을때, 미리 등록된 다른 클래스에 통보해주는 패턴 객체 사이에 일 대 다의 의존 관계를 정의해...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/optional/">Optional</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","java","api","java8"]' date="March 29, 2022" reading-time="4"></post-metadata><p>Optional 등장 배경 null에 대한 문제점 지속적인 NPE - NullPointException 방어가 필요하다. NPE를 방어할 코드를 지속적으로 추가해야 하므로 비즈니스 로직이...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/proxy-pattern/">Proxy Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Proxy Pattern</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/singleton-pattern/">Singleton Pattern</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="2"></post-metadata><p>Singleton Pattern : 어떠한 클래스(객체)가 유일하게 1개만 존재해야 할때 사용하는 패턴 즉, 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/strategy-pattern%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4/">Strategy Pattern(전략 패턴)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="3"></post-metadata><p>Strategy Pattern(전략 패턴) 이전글: 템플릿 메서드 패턴</p></article><article class="post-preview"><h3><a href="/programming/2022/03/29/completablefuture/">CompletableFuture</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="6"></post-metadata><p>CompletableFuture 비동기 - Asynchronous 프로그래밍에 대한 여러 기능을 제공하는 인터페이스. 공식 문서</p></article><article class="post-preview"><h3><a href="/programming/2022/03/17/tdd-bdd/">TDD, BDD</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["coding","development","TIL"]' date="March 17, 2022" reading-time="2"></post-metadata><p>TDD, BDD TDD - Test Driven Development : 테스트 코드를 작성하고 테스트로 검증된 코드를 가지고 실제 코드를 작성하는 애자일의 대표적인...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/17/ddddomain-driven-design/">DDD(Domain Driven Design)</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["coding","development","TIL"]' date="March 17, 2022" reading-time="1"></post-metadata><p>DDD(Domain Driven Design) : 도메인을 중심으로 하는 개발 방식이다. → 도메인에 관련된 문제를 해결하는것. 복잡한 도메인을 해결하는 것을 높은 우선순위로...</p></article><article class="post-preview"><h3><a href="/programming/2022/03/17/api/">API</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["coding","development","TIL"]' date="March 17, 2022" reading-time="1"></post-metadata><p>API API(Application Programing Interface)</p></article><article class="post-preview"><h3><a href="/programming/2022/03/17/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9D%98-3%EA%B0%9C%EC%9D%98-key%EC%9B%90%EC%B9%99/">소프트웨어 개발의 3개의 KEY원칙</a></h3><post-metadata layout="badge" categories='["programming"]' tags='["coding","development","TIL"]' date="March 17, 2022" reading-time="1"></post-metadata><p>소프트웨어 개발의 3개의 KEY원칙 DRY- Don’t Repeat Yourself 같은 코드를 반복하지마라.</p></article></div></div><nav class="category-navigation-bottom"><a href="/" class="nav-link">← Back to Home</a> <a href="/blog/" class="nav-link">All Posts →</a></nav></div></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>