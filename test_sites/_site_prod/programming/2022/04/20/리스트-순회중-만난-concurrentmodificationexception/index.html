<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>리스트 순회중 만난 ConcurrentModificationException</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">리스트 순회중 만난 ConcurrentModificationException</h1><post-metadata layout="inline" categories='["programming"]' tags='["TIL","coding","development","java","java-collection-framework"]' date="April 20, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="리스트-순회중-만난-concurrentmodificationexception">리스트 순회중 만난 ConcurrentModificationException</h1><h3 id="1-문제의-발생과-배경">1. 문제의 발생과 배경</h3><p>알고리즘을 풀다가 리스트를 <code>enhanced for loop(for each)</code>를 통해 순회하며 <code>List.remove()</code>연산을 해야 하는 상황이 있었다. 필자는 아무렇지 않게 순회중 <code>List.remove()</code> 연산을 하게 되었는데 <code>ConcurrentModificationException</code>가 발생하였다.</p><p>처음에는 <code>ConcurrentModificationException</code>라는 이름을 보고 동시성 관련 예외라고 잠깐 생각했지만 싱글스레드 환경에서 발생했으므로 다른 원인이 있다는 것을 짐작하여 구글링을 하게 되었다. 그리고 나중에 이러한 일을 겪지 않으려 이 글을 작성한다.</p><p><code>ConcurrentModificationException</code>이 발생한 코드의 예시는 다음과 같다.</p><pre><code class="language-java">private static boolean solution(String[] phone_book) {
    final LinkedList&lt;String&gt; phone_books = Arrays.stream(phone_book)
            .collect(LinkedList::new, LinkedList::add, LinkedList::addAll);
    ...

    for (String s : phone_books) {  // 이 부분!
        ...
        phone_books.remove(s);
        ...
    }
}
</code></pre><h3 id="concurrentmodificationexception란">ConcurrentModificationException란?</h3><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ConcurrentModificationException.html"><code>ConcurrentModificationException</code>의 공식문서</a>를 살펴보면 첫번째 문단에 다음과 같이 나와있다.</p><blockquote><p>This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.</p></blockquote><p>이 문장을 번역해보면<br><strong>“이 예외는 객체의 동시 수정이 허용되지 않는경우 동시 수정을 감지한 메서드에서 thorw될 수 있다.”</strong> 즉, 동시성 관련하여 예외가 발생할 수 있다. 하지만, 3번째 문단은 다음과 같이 나와있다.</p><blockquote><p>Note that this exception does not always indicate that an object has been concurrently modified by a different thread. If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception. For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception.</p></blockquote><p>대충 번역을 해보면 “이 예외는 항상 다른 스레드에 의해 동시에 수정됨을 나타내는 것이 아니고, 단일 스레드가 객체의 계약을 위반하는 메서드 호출 시퀀스를 실행하는 경우 발생할 수 있다. 예를 들어 <strong>fail-fast iterator로 컬렉션을 반복하는 동안 컬렉션을 수정하는 경우 iterator는 이 예외를 thorw한다.</strong>”</p><p>위에서 <a href="#1-문제의-발생과-배경">1. 문제의 발생과 배경</a>부분에 첨부한 코드를 다시한번 살펴보면 Linked List가 <code>enhanced for loop</code>를 통해 순회하며 <code>List.remove</code>를 한 부분에서 <code>ConcurrentModificationException</code>이 발생했다.</p><p>이정도까지 왔으면 짐작이 될 것이다. <strong><code>LinkedList</code>는 fail-fast <code>Iterator</code>를 사용한다.</strong></p><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html"><code>LinkedList</code>의 공식 문서</a>를 살펴보면 4문단에 다음과 같이 나와있다.</p><blockquote><p>The iterators returned by <strong>this class’s iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator’s own remove or add methods, the iterator will throw a ConcurrentModificationException.</strong> Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.</p></blockquote><p>볼드 처리한 부분만 해석하면 해당 문제 “<strong>이 클래스의 iterator와 listIterator 메서드는 fail-fast이고, 구조적으로 수정되는 경우 반복자의 자체 제거 또는 추가 메서드를 통하지 않는 경우를 제외하고 반복자는 <code>ConcurrentModificationException</code>을 throw합니다.</strong>”</p><h2 id="해결방법">해결방법</h2><h3 id="1-listremove가-아닌-iteratorremove를-사용한다">1. List.remove()가 아닌 Iterator.remove()를 사용한다.</h3><p><code>List.remove()</code>가 아닌 Iterator를 삭제하는 방법인 <code>iterator.remove()</code>를 사용하면 된다.</p><pre><code class="language-java">private static boolean solution(String[] phone_book) {
    final LinkedList&lt;String&gt; phone_books = Arrays.stream(phone_book)
            .collect(LinkedList::new, LinkedList::add, LinkedList::addAll);
    ...

    Iterator&lt;String&gt; iterator = phone_books.iterator()
    while(iterator.hasNext()){
        ...
        iterator.remove();
        ...
    }
}
</code></pre><p>이 방법은 스레드 환경에 안전하지 않다.<br>하지만 필자는 싱글스레드 환경인 알고리즘 풀이에서 발생한 예외라 이렇게 해결했다.</p><h3 id="2-javautilconcurrent-패키지의-copyonwirtearraylist를-활용하자">2. java.util.concurrent 패키지의 CopyOnWirteArrayList를 활용하자</h3></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/04/20/springmvc%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C/" class="nav-link">SpringMVC는 어떻게 데이터를 반환할까?</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/04/20/%EB%B2%8C%ED%81%AC-%EC%97%B0%EC%82%B0-bulk-opertation/" class="nav-link">벌크 연산 - Bulk Opertation</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>