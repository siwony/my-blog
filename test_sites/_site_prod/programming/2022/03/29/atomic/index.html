<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Atomic</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Atomic</h1><post-metadata layout="inline" categories='["programming"]' tags='["concurrent","TIL","coding","development","java"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="atomic">Atomic</h1><p><code>java.util.concurrent.atomic</code>에 정의 되어 있고 멀티 쓰레드 환경에서 동기화에 의존하지 않고, 원자성을 보장하게 해주는 Atomic API에 대해 소개하려고 한다.</p><h3 id="atomic-access">Atomic Access</h3><p>API소개전 Atomic Access의 개념을 알아보자</p><p>Oracle 자바 레퍼런스에 나와있는 Atomic Access의 정의는 다음과 같다.</p><blockquote><p>In programming, an atomic action is one that effectively happens all at once.<br>An atomic action cannot stop in the middle: it either happens completely, or it doesn’t happen at all. No side effects of an atomic action are visible until the action is complete.</p></blockquote><p>글을 요약하자면 처음부터 끝까지 완전히 수행되거나, 아예 아무것도 수행되지 않아야 하는 Action이라고 한다.</p><h4 id="왜-끝가지-수행되거나-아예-아무것도-수행되지-않아야-할까">왜 끝가지 수행되거나, 아예 아무것도 수행되지 않아야 할까</h4><p>티켓 구매 서비스에서 유명한 연예인의 콘서트에 예매하는데 티켓이 1개 남은 상황에서 여러명이 동시적으로 구매하려고 하는 경우를 생각해보면</p><ol><li>1번 회원 결제 성공</li><li>티켓 수량 업데이트가 끝나지 않은 상황에서 2번 회원도 결제에 성공했다.</li><li>티켓 수량이 0 으로 변경되었지만 2번 회원은 이미 돈을 지급한 상태이다.</li><li>서비스 장애가 발생했다!</li></ol><p>티켓 구매라는 작업이 정상적으로 수행되려면 1번 회원의 결제 결과가 재고 수량에 반영되기 전 2번 회원의 결제 시도는 잠시 미뤄야 한다.</p><p>하나의 스레드가 모든 작업을 차례대로 처리한다면, 작업 간 공유하는 데이터의 일관성이 깨지는 일은 생기지 않을 것이다. 하지만, 수많은 요청을 빠르게 처리하려면 멀티스레드가 필연적으로 사용된다.</p><p>여러 개의 작업이 쪼개서 번갈아 가며 실행하는 멀티스레드 환경에 <code>비 원자 연산</code>이 수행되면 위와 같은 문제가 발생할 수 있으므로 <code>Atomic 연산</code>이 필요하다.</p><h4 id="atomic-action의-특징">Atomic Action의 특징</h4><ul><li><code>인터러브 - Interleave</code> 하지 않는다.</li><li>스레드 간섭에 대한 걱정을 하지 않고 사용할 수 있다.</li><li>메모리 <code>일관성 - consistency</code> 오류가 발생할 수 있으므로 동기화해야 하는 필요성을 제거하지 않는다.</li></ul><h2 id="atomic-type">Atomic Type</h2><p>Atomic Type은 단일 변수에 대해 <code>Atomic Operations</code>를 지원한다.</p><ul><li>Wrapping 클래스의 일종<blockquote><p>참조타입, 원시타입 두 종류의 변수에 모두 적용가능함</p></blockquote></li><li>사용시 내부적으로 <code>CAS - Compare And Swap</code> 알고리즘을 사용해 lock없이 동기화 처리를 한다.<blockquote><p>non-blocking으로 원자성을 보장한다</p></blockquote></li></ul><h4 id="주요-class">주요 Class</h4><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li><li>AtomicReference</li><li>AtomicIntegerArray</li><li>AtomicDoubleArray</li><li>AtomicReferenceArrays</li></ul><h4 id="주요-method">주요 Method</h4><ul><li><code>get()</code> : 현재 값을 반환한다.</li><li><code>set(newValue)</code> : newValue로 값을 변경한다.</li><li><code>getAndSet(newValue)</code> : 원자적으로 값을 업데이트하고 원래의 값을 반환한다.</li><li><code>compareAndSet(expect, update)</code> : 원자적으로 값을 업데이터 하고 원래의 값을 반환한다.</li><li>숫자형 Atomic Type의 경우 증감연산을 할 수 있는 메서드를 추가적으로 제공한다.</li></ul><h3 id="atomic-vs-synchronized-키워드">Atomic VS synchronized 키워드</h3><h4 id="synchronized-키워드">synchronized 키워드</h4><p>특정 Thread가 해당 블럭 전체를 lock하기 떄문에 bloking이 발생한다.</p><h4 id="atomic-1">Atomic</h4><p>CAS 알고리즘을 통해 <code>Non-Blocking</code> 상태로 동기화 문제를 해결할 수 있다.</p><h3 id="atomic-class의-내부">Atomic class의 내부</h3><blockquote><p>Java11 기준 ```java public class AtomicBoolean implements java.io.Serializable {</p></blockquote><pre><code>private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
private volatile int value;

생략...

public final int getAndSet(int newValue) {
    return U.getAndSetInt(this, VALUE, newValue);
}

생략... } ``` `getAndSet` method에서 `U.getAndSetInt`를 사용하는데 이것이 CAS 알고리즘이다.
</code></pre><p><code>jdk.internal.misc.Unsafe#getAndSetInt</code>의 구현을 보면</p><pre><code class="language-java">    @HotSpotIntrinsicCandidate
    public final int getAndSetInt(Object o, long offset, int newValue) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!weakCompareAndSetInt(o, offset, v, newValue));
        return v;
    }
</code></pre><p><code>compareAndSwapInt</code>를 호출해 메모리에 저장된 값과 현재 CPU에 캐시 된 expect 값을 비교해 같은 경우만 update를 실행한다.</p><p>자세히 설명하면, 현재 연산에서 기대하는 값과 메모리상에서의 값이 일치하지 않는다면 중간에 다른 스레드가 관여한 것으로 판단하여 write를 실패시키고 재시도를 한다. <code>lock-free</code> 방식으로 루프를 돌기 때문에 <code>block</code>, <code>unblock</code> 상태 변경 처리에 드는 비용이 발생하지 않는다.</p><blockquote><p><strong>lock-free</strong><br>멀티스레드 환경에서 동시에 호출해도 정확한 결과를 만들어주는 알고리즘</p><ul><li>여러개의 스레드에서 동시에 작업이 호출되었을 경우 정해진 시간마다 적어도 한개의 작업이 호출되는 알고리즘이다.</li></ul></blockquote><p><code>getIntVolatile</code>는 native로 구현되어 볼 수 없다.</p><h2 id="reference">Reference</h2><ul><li>https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html</li><li>https://zion830.tistory.com/58</li><li>https://n1tjrgns.tistory.com/244</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/annotation/" class="nav-link">Annotation</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/callable%EA%B3%BC-future/" class="nav-link">Callable과 Future</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>