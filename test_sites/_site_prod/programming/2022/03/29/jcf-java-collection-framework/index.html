<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JCF - Java Collection Framework</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">JCF - Java Collection Framework</h1><post-metadata layout="inline" categories='["programming"]' tags='["TIL","coding","development","java","java-collection-framework"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="jcf---java-collection-framework">JCF - Java Collection Framework</h1><p>Java Collection Framework는 공통적으로 재사용 가능한 수집 데이터 구조를 구현하는 클래스 및 인터페이스의 집합이다.</p><h3 id="jfc-상속-구조">JFC 상속 구조</h3><p><img src="/assets/images/posts/programming/collection-framework-structure.jpeg"></p><h3 id="컬렉션-프레임워크-구성요소">컬렉션 프레임워크 구성요소</h3><ul><li>컬렉션 인터페이스 : 모든 컬렉션 인터페이스 <code>java.util</code>패키지에 있다.</li><li>컬렉션 클래스 : 모든 컬렉션 클래스는 <code>java.util</code>, <code>java.util.concurrent</code> 패키지에 있다.</li><li>컬렉션 알고리즘 : 검색, 정렬, 셔플과 같은 기능을 제공한다.</li></ul><h2 id="1-컬렉션-인터페이스---collection-interface">1. 컬렉션 인터페이스 - Collection Interface</h2><ul><li>공식문서 : https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html<h4 id="컬렉션-프레임워크-대표적인-인터페이스">컬렉션 프레임워크 대표적인 인터페이스</h4></li><li><code>List&lt;E&gt;</code></li><li><code>Set&lt;E&gt;</code></li><li><code>Map&lt;K, V&gt;</code></li></ul><h3 id="1-1-collection-인터페이스">1-1. Collection 인터페이스</h3><p><code>Collection</code>인터페이스는 직접적인 구현은 제공하지 않으며 모든 컬렉션 클래스가 구현해야 하는 메서드를 포함하고 있다.</p><h3 id="1-2-list">1-2. List</h3><ul><li>순서 있는 데이터의 집합으로 데이터의 중복을 허용한다.</li><li>Random access를 허용한다.</li><li><code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, <code>Stack</code></li></ul><h3 id="1-3-set-인터페이스">1-3. Set 인터페이스</h3><ul><li>중복 요소를 포함할 수 있다.</li><li>Random access를 허용하지 않는다.<blockquote><p><code>LinkedHashSet</code> 제외</p></blockquote></li><li><code>HashSet</code>, <code>TreeSet</code>, <code>LinkedHashSet</code></li></ul><h3 id="1-4-sortedset-인터페이스">1-4. SortedSet 인터페이스</h3><p>요소를 오름차순으로 유지하는 Set이다.</p><ul><li>구현체는 <code>TreeSet</code>이 있다.</li></ul><h3 id="1-5-queue-인터페이스">1-5. Queue 인터페이스</h3><p>Queue 인터페이스는 처리하기 전에 요소를 보유하는 데 사용된다.</p><ul><li>기본 컬렉션 작업 이외에 삽입, 추출 및 검사 작업을 제공한다.</li><li>일반적으로 Queue 요소를 FIFO 방식으로 정렬하며 예외에는 <code>우선순위 큐 - PriorityQueue</code>가 있다.</li></ul><h3 id="1-6-deque">1-6. Deque</h3><p>양쪽 긑에 요소 삽입 및 제거를 지원한다.</p><ul><li>구현된 글래스는 ArrayDeque가 있다.</li></ul><h2 id="2-map-인터페이스">2. Map 인터페이스</h2><ul><li>Key-Value</li><li>중복 Key가 존재할 수 없다.</li><li>각 키는 하나의 값만 매핑할 수 있다.</li><li><code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>, <code>Hashtable</code>, <code>Properties</code></li></ul><h3 id="2-1-sortedmap">2-1 SortedMap</h3><p>매핑을 오름차순의 키 순서로 유지하는 Map이다.</p><ul><li>구현체는 <code>TreeMap</code>이 있다.</li></ul><h2 id="3-기타-인터페이스-그룹">3. 기타 인터페이스 그룹</h2><h3 id="3-1-iterator-인터페이스">3-1. Iterator 인터페이스</h3><p>Iterator 인터페이스는 어떤 컬렉션이든 반복적으로 수행하기 위한 메서드를 제공한다.</p><ul><li>컬렉션 프레임워크에서는 <code>Enumeration</code>대신 <code>Iterator</code>를 사용한다.</li><li>Iterator 디자인 패턴을 구현한다.</li><li><code>iterator()</code>를 통해 컬렉션으로 부터 Iterator instance를 가져올 수 있고 컬렉션을 순회하는 도중에 엘리먼트를 삭제할 수 있다.</li></ul><h3 id="3-2-listiterator-인터페이스">3-2. ListIterator 인터페이스</h3><ul><li>어느 방향이든 목록을 탐색하고 반복하면서 목록을 수정하고, 목록에서 반복자의 현재 위치를 가져올 수 있다</li><li>커서 위치는 <code>previous()</code>, <code>next()</code>에 대한 호출에 의해 반환될 요소 사이에 위치한다.</li></ul><h3 id="3-3-concurrent-인터페이스-그룹">3-3. Concurrent 인터페이스 그룹</h3><ul><li><code>BlockingQueue</code></li><li><code>TransferQueue</code></li><li><code>BlockingDeque</code></li><li><code>ConcurrentMap</code></li><li><code>ConcurrentNavigableMap</code></li></ul><h2 id="4-컬렉션-클래스---collection-class">4. 컬렉션 클래스 - Collection Class</h2><p><code>ArrayList</code>, <code>LinkedList</code>, <code>HashSet</code>, <code>TreeSet</code>, <code>PriorityQueue</code>, <code>ArrayDeque</code>, <code>HashMap</code>, <code>TreeMap</code>, <code>LinkedHashMap</code>, <code>Vector</code>, <code>Stack</code>, <code>Dictionary</code>, <code>Hashtable</code>, <code>Properties</code></p><h4 id="concurrent-클래스">Concurrent 클래스</h4><p><code>CopyOnWriteArrayList</code>, <code>CopyOnWriteArraySet</code>, <code>ConcurrentHashMap</code></p><h4 id="abstract-클래스">Abstract 클래스</h4><p><code>AbstractList</code>, <code>AbstractSequenctailList</code>, <code>AbstractSet</code>, <code>AbstractQueue</code></p><h3 id="4-1-arraylist-클래스">4-1. ArrayList 클래스</h3><ul><li>resizable-array이면서 비동기이다.<blockquote><p>동기화가 필요하면 <code>Collections.synchronizeList()</code>를 통해 동기화가 보장되는 List를 반환받아 사용한다.</p></blockquote></li><li><code>ArrayList</code>는 내부적으로 배열을 이용하여 요소를 저장한다.</li><li>thread-safe하지 않다.</li></ul><h3 id="4-2-linkedlist-클래스">4-2. LinkedList 클래스</h3><ul><li><code>Queue</code>, <code>Deque</code> 속성 메서드를 가지고 있다.</li><li><code>Queue</code>, <code>Deque</code>의 메서를 포함하고 있따.</li><li>내부적으로 연결 리스트를 이용한다.</li><li>thread-safe하지 않다.</li></ul><h3 id="4-3-hashset-클래스">4-3. HashSet 클래스</h3><p><code>HashMap</code>에 의해 지원되는 Set 인터페이스의 구현체이다.</p><ul><li>요소의 순서를 보장하지 않는다.</li><li>null를 허용한다</li><li><ul><li>thread-safe하지 않다.</li></ul></li></ul><h3 id="4-4-treeset-클래스">4-4. TreeSet 클래스</h3><p><code>TreeMap</code>의 근본이 되는 <code>NavigableSet</code> 구현이다.</p><ul><li>thread-safe하지 않다.</li></ul><h3 id="4-5-priorityqueue-클래스">4-5. PriorityQueue 클래스</h3><p>우선순위 큐</p><ul><li>thread-safe하지 않다.</li></ul><h3 id="4-6-arraydeque">4-6. ArrayDeque</h3><p><code>Deque</code>인터페이스의 동적 배열 구현체 이다.</p><ul><li>thread-safe하지 않다.</li></ul><h2 id="5-map-인터페이스-그룹의-클래스">5. Map 인터페이스 그룹의 클래스</h2><h3 id="5-1-hashmap-클래스">5-1. HashMap 클래스</h3><ul><li>threa-safe하지 않다.</li><li>null를 허용하지 않는다.</li><li>앨리먼트의 순서를 보장하지 않는다.</li></ul><h3 id="5-2-treemap-클래스">5-2. TreeMap 클래스</h3><ul><li>Red-Baclk 트리 기반 <code>NavigableMap</code>의 구현체다.</li><li>thread-safe하지 않다.</li></ul><h3 id="5-3-linkedhashmap-클래스">5-3. LinkedHashMap 클래스</h3><ul><li><code>LinkedHashMap</code></li><li>null를 허용한다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/java%EC%9D%98-%EB%82%A0%EC%A7%9C%EC%8B%9C%EA%B0%84%EC%9D%84-%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94-api/" class="nav-link">Java의 날짜/시간을 나타내는 API</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/jvm-jdk-jre/" class="nav-link">JVM, JDK, JRE</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>