<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Annotation</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Annotation</h1><post-metadata layout="inline" categories='["programming"]' tags='["TIL","byte-code-controller-way","coding","development","java"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="annotation">Annotation</h1><p>Annotation은 그자체로 주석이라는 의미를 가진다. 하지만 일반 주석이랑 다르다!</p><ul><li>JDK5 버전부터 사용할 수 있다.</li><li><code>@</code>를 붙여서 사용한다.</li><li>Reflection을 이용해 Class의 Annotation을 조회할 수 있다.</li><li>Annotatino은 interface에 해당된다.</li></ul><h3 id="annotation의-용도">Annotation의 용도</h3><blockquote><p>대부분 사용되는 용도는 다음과 같다.</p><h4 id="1-컴파일러에게-코드-작성-문법-에러를-체크하도록-정보를-제공">1. 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공</h4><p>대표적으로 Java에서 제공하는 <code>@Override</code>가 있다.</p></blockquote><p>다음은 equals를 Override하는 예시이다.</p><pre><code class="language-java">@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Book)) return false;
    Book book = (Book) o;
    return a == book.a &amp;&amp; Objects.equals(b, book.b);
}
</code></pre><p>다음과 같이 파라미터가 다르면 <code>@Override</code>에서 에러가 발생하는 것을 볼 수 있다 <img width="450" src="/assets/images/posts/programming/annotation-override-error.png"></p><p>에러 메시지</p><pre><code class="language-sh">파일경로/Book.java:10:5
java: method does not override or implement a method from a supertype
</code></pre><h4 id="2-소프트웨어-개발툴이-빌드나-배치시-코드를-자동으로-생성할-수-있도록-정보-제공">2. 소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공</h4><p>대표적인 예시로 Querydsl의 Q타입 Entity를 생성하는 것이 있다. 이를 가능하게 하는 기능을 annotation processor라고 한다.</p><h4 id="3-실행시런타임시특정-기능을-실행하도록-정보를-제공">3. 실행시(런타임시)특정 기능을 실행하도록 정보를 제공</h4><p>annotation은 클래스, 메서드, 필드등에 대한 메타데이터를 가질 수 있다. 대표적인 예로 SpringBoot의 <code>@Component</code>가 있는데 이 annotation이 붙여진 class는 Spring의 관리대상에 포함된다.</p><p>.<br>.<br>. ETC…</p><h3 id="use-case">Use Case</h3><ul><li>컴파일러를 위한 정보제공 : <code>@FunctionalInterface</code> ,<code>@supresswarnings</code></li><li>자동 문서 작성 : Jenkins, Jira, Teamcity 등…</li><li>코드 자동 생성 : Querydsl, lombok, JAXB 등…<blockquote><p>annotation processor</p></blockquote></li><li>런타임 프로세싱 : Junit, DI(Spring), logging(Log4J), DA(Hibernate) 등…</li></ul><h2 id="annotation의-구성">Annotation의 구성</h2><p>다음은 Annotation의 예시이다.</p><pre><code class="language-java">@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation {
}
</code></pre><h3 id="targetelementtype">@Target(ElementType[])</h3><p>: Annotation이 적용할 위치를 나타낸다. |위치|Element Type| |—|————| |패키지| <code>ElementType.PACKAGE</code>| |클래스, 인터페이스, enum, record|<code>ElementType.TYPE</code>| |Annotation 타입| <code>ElementType.ANNOTATION_TYPE</code>| |생성자|<code>ElementType.CONSTRUCTOR</code>| |맴버 변수|<code>ElementType.FIELD</code>| |지역 변수|<code>ElementType.LOCAL_VARIABLE</code>| |메서드| <code>ElementType.METHOD</code>| |Record component | <code>ElementType.RECORD_COMPONENT</code> | |매개변수|<code>ElementType.PARAMETER</code>| |파라미터 타입|<code>ElementType.TYPE_PARAMETER</code>| |타입|<code>ElementType.TYPE_USE</code>|</p><h3 id="retentionretentionpolicy"><code>@Retention(RetentionPolicy)</code></h3><p>: Annotation 의 Scope를 제한한다.</p><ul><li><strong><code>SOURCE</code></strong><br>어노테이션 정보가 컴파일시 사라진다. 즉, 바이트코드에 존재하지 않는다.<blockquote><p>ex. <code>@Override</code>, <code>@SuppressWarnings</code>, lombok의 <code>getter/setter</code></p></blockquote></li><li><strong><code>CLASS</code></strong> 클래스 파일에 존재하고 컴파일러에 의해 사용가능, 가상머신(런타임)에서는 사라진다.</li><li><strong><code>RUNTIME</code></strong> 실행시 어노테이션 정보가 가상 머신에 의해서 참조 가능. reflection에 의해 사용될 수 있다.</li></ul><h4 id="class는-왜-사용될까">CLASS는 왜 사용될까?</h4><blockquote><p>참고: https://stackoverflow.com/questions/38975073/retention-of-java-type-checker-annotations</p></blockquote><p>CLASS 정책은 Maven과 Gradle로 다운받은 라이브러리와 jar파일은 소스코드(<code>.java</code>)가 아닌 바이트코드(<code>.class</code>)만 남겨진다.</p><p><code>.class</code> 파일만 존재하는 라이브러리 같은 경우에도 타입체커, IDE 부가기능 등을 사용할수 있으려면 CLASS 정책이 필요하다.<br>SOURCE 정책으로 사용한다면 컴파일된 라이브러리의 jar 파일에는 어노테이션 정보가 남아있지 않기 때문에 위와 같은 기능을 사용할 수 없다.</p><h3 id="추가적인-구성요소">추가적인 구성요소</h3><h4 id="inherited"><code>@Inherited</code></h4><p>슈퍼클래스를 상속한 서브 클래스에서도 해당 Annotation을 갖도록 한다.</p><pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation {}

@Annotation
public class SuperClass{}

public class DownClass extends SuperClass{}
</code></pre><p>리플렉션을 이용해 DownClass의 Annotation가져오기</p><pre><code class="language-java">public static void main(String[] args) {
    Class&lt;DownClass&gt; downClassClass = DownClass.class;
    Arrays.stream(downClassClass.getAnnotations()).forEach(System.out::println);
}
</code></pre><p>출력 결과 예시</p><pre><code class="language-sh">@패키지_이름.Annotation()
</code></pre><h4 id="documented"><code>@Documented</code></h4><p><code>@Documented</code> 어노테이션이 지정된 대상의 JavaDoc 에 이 어노테이션의 존재를 표기하도록 지정한다.</p><h3 id="변수">변수</h3><p>annotation은 변수를 사용할 수 있다. 변수의 형식은 다음과 같다.</p><pre><code class="language-java">[public] 타입 변수명();
[public] 타입 변수명() default 기본값;
</code></pre><ul><li><code>final</code>과 <code>abstract</code>, <code>private</code> 를 사용할 수 없다.</li><li>public은 기본적으로 생략이 된다.</li><li>기본값에 null이 들어갈 수 없다.</li><li>변수의 타입은 기본형 혹은 <code>java.lang.String</code>형만 올 수 있다.</li></ul><p>만약 annotation의 변수명이 value면 annotation를 다음과 같이 사용할 수 있다.</p><pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Annotation {
    String value();

    String a() default "";
}

@Annotation("hello")
public class ExClass1 { }

@Annotation(value = "hello", a = "a")
public class ExClass2 { }
</code></pre></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/adepter-pattern/" class="nav-link">Adepter Pattern</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/atomic/" class="nav-link">Atomic</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>