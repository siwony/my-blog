<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Proxy Pattern</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Proxy Pattern</h1><post-metadata layout="inline" categories='["programming"]' tags='["TIL","coding","development","Design-pattern","java"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="proxy-pattern">Proxy Pattern</h1><dl><dt><img width="650" src="/assets/images/posts/programming/proxy-simple.png"></dt><dd><p>Proxy Class를 통해 대신 전달 하는 형태로 설계되며, 실제 Client는 접근하려는 객체(Real Subject)를 바로 접근하는게 아닌 Proxy로 부터 결과를 받는다.</p><blockquote><p>Proxy: 대리인 이라는 뜻, 뭔가를 대신하여 처리하는것</p></blockquote></dd></dl><p>주로 logging, 혹은 부가적인 기능을 추가할 때 사용한다. DataJPA Repository, Hibernate Entity 등… 다양한 곳에서 사용한다.</p><p>이런 부가적인 기능을 메서드에 직접 코드를 수정해서 추가하는게 어닌 원래 매서드의 코드를 수정하지 않고 부가적인 기능을 추가할 수 있게 하는 패턴이다.</p><h3 id="특징">특징</h3><h4 id="장점">장점</h4><ul><li>기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다.<blockquote><p>OCP - Open-Close Principle</p></blockquote></li><li>기존 코드가 해야 하는 일만 유지할 수 있다.<blockquote><p>SRP - Single Responsibility Principle</p></blockquote></li><li>기능 추가 및 초기화 지연 등으로 다양하게 활용할 수 있다.<blockquote><p>자원이 큰 객체를 늦게 초기화 하던지 혹은 로깅, 캐싱등 여러가지로 활용할 수 있다.</p><h4 id="단점">단점</h4></blockquote></li><li>코드의 복잡도가 증가한다.</li></ul><h2 id="proxy-패턴-구현-예제">Proxy 패턴 구현 예제</h2><h3 id="1-상속을-이용한-proxy---인터페이스가-없는-경우">1. 상속을 이용한 Proxy - 인터페이스가 없는 경우</h3><p>메서드 Overried를 이용해 프록시 패턴을 구현한다. - 상속성</p><p><img width="550" src="/assets/images/posts/programming/proxy-uml-extend.png"></p><ul><li>Proxy는 RealSubject를 상속받는다.</li><li>Proxy는 RealSubject의 메서드를 overried한다.</li></ul><h4 id="구현">구현</h4><ol><li><code>GameService</code>와 <code>GameService</code>의 Proxy객체인 <code>GameServiceProxy</code>가 있다.</li><li><code>GameService</code>는 start라는 매서드를 가진다.</li><li>원래 메서드(<code>GameService.start()</code>)의 코드를 수정하지 않고 해당 메서드의 수행속도를 측정하고 싶다.</li><li><code>GameServiceProxy</code>가 <code>GameService</code>를 상속받고 부모의 <code>start()</code>의 수행속도를 측정한다.</li></ol><pre><code class="language-java">// GameService(Real Subject)
public class GameService{
  public void start() throws InterrubtedException{
    System.out.println("Game Start!!")
  }
}

// GameServiceProxy(Proxy)
public class GameServiceProxy extends GameService {

  @Overried
  public void start() throws InterrubtedException{
    long before = System.currentTimeMillis();
    System.out.println("이 자리에 오신 여러분을 진심으로 환영합니다.");
    Thread.sleep(1000L);
  }
}

public class Client {
  public static void main(String[] args){
    GameService gameService = new GameServiceProxy();
    gameService.start();
  }
}
</code></pre><p>출력 결과</p><pre><code class="language-sh">Game Start!!
1000
</code></pre><h4 id="사용하는-이유">사용하는 이유</h4><ul><li>Real Subject(ex. <code>GameService</code>)를 고칠 수 없는 경우 상속으로 해결한다.</li><li>인터페이스를 이용한 Proxy구조보다 비교적 단순하다.</li></ul><p>하지만 가급적으로 인터페이스를 활용하는게 좋다.</p><h3 id="2-인터페이스를-이용한-proxy">2. 인터페이스를 이용한 Proxy</h3><p>인터페이스를 이용해 프록시 패턴을 구현한다. - 다형성</p><p><img width="550px" src="/assets/images/posts/programming/proxy-uml-interface.png"></p><ul><li>Proxy와 RealSubject는 interface인 Subject를 구현한다.</li><li>Proxy는 RealSubject를 가지고 있는다.</li><li>Proxy객체는 RealSubject의 메서드를 대신 실행한다.</li></ul><h4 id="구현-1">구현</h4><ol><li><code>GameService</code> 인터페이스와 그를 구현한 <code>DefaultGameService</code>, <code>ProxyGameService</code>가 있다.</li><li><code>DefaultGameService</code>의 proxy는 <code>ProxyGameService</code>이고 DefaultGameService를 필드로 가지고 있다.</li><li>원래 메서드(<code>DefaultGameService.start()</code>)의 코드를 수정하지 않고 해당 메서드의 수행속도를 측정하고 싶다.</li><li><code>GameServiceProxy</code>는 <code>DefaultGameService</code>의 메서드를 대신 실행해 <code>start()</code>의 수행속도를 측정한다.</li></ol><pre><code class="language-java">// DefaultGameService(RealSubject)와  ProxyGameService(Proxy)의 Subject 인터페이스
public interface GameService {
    void start() throws InterruptedException;
}

// DefaultGameService(Real Subject)
public class DefaultGameService implements GameService{

    @Override
    public void start() throws InterruptedException {
        System.out.println("Game Start!!!");
        Thread.sleep(1000L);
    }
}

// GameServiceProxy(Proxy)
public class GameServiceProxy implements GameService{

    private final GameService gameService; // proxy를 적용할 RealSubject

    public GameServiceProxy(GameService gameService) {
        this.gameService = gameService;
    }

    @Override
    public void start() throws InterruptedException {
        long before = System.currentTimeMillis();
        gameService.start();
        System.out.println(System.currentTimeMillis() - before);
    }
}

// Client
public class Client {
    public static void main(String[] args) throws InterruptedException {
        GameService gameService = new GameServiceProxy(new DefaultGameService());
        gameService.start();
    }
}
</code></pre><p>출력 결과</p><pre><code class="language-sh">Game Start!!
1000
</code></pre><h4 id="사용하는-이유-1">사용하는 이유</h4><ul><li>사용범위가 넓다. ex. 늦은초기화<pre><code class="language-java">public class GameServiceProxy implements GameService{

  private final GameService gameService; // proxy를 적용할 RealSubject

  @Override
  public void start() throws InterruptedException {
      long before = System.currentTimeMillis();
      if(gameService == null){
        gameService = new DefaultGameService(); // 야매지만 늦은 초기화를 수행했다.
      }
      gameService.start();
      System.out.println(System.currentTimeMillis() - before);
  }
}
</code></pre></li><li>상속을 이용한 방법보다 조금 더 복잡하다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/optional/" class="nav-link">Optional</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/29/repository/" class="nav-link">Repository</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>