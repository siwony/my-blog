<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Optional</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">Optional</h1><post-metadata layout="inline" categories='["programming"]' tags='["TIL","coding","development","java","api","java8"]' date="March 29, 2022" reading-time="4" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="optional">Optional</h1><h3 id="등장-배경">등장 배경</h3><h4 id="null에-대한-문제점">null에 대한 문제점</h4><ul><li>지속적인 <code>NPE - NullPointException</code> 방어가 필요하다.</li><li>NPE를 방어할 코드를 지속적으로 추가해야 하므로 비즈니스 로직이 복잡해진다.</li></ul><h4 id="java8-이전에-메서드에서-존재하지-않는값null을-리턴할-수-있을-때-처리하는-방법">JAVA8 이전에 메서드에서 존재하지 않는값(null)을 리턴할 수 있을 때 처리하는 방법</h4><ul><li>예외를 던진다. → 비용이 발생한다.<ul><li>stack trace를 출력한다.</li><li>만약 다른 예외로 throw시 추가적인 로직을 작성해야 한다.</li></ul></li><li>null을 리턴한다. → 비용 문제가 없지만 그 코드를 사용하는 개발자는 주의해야 한다.(ex. NPE)</li></ul><h4 id="함수형-프로그래밍에서-영감을-얻다">함수형 프로그래밍에서 영감을 얻다.</h4><p>Java는 <code>존재하지 않는 값</code>을 표현하기위해 null을 사용한다면,<br>Scala나 Haskell같은 함수형 언어들은 <code>존재할지 안 할지 모르는 값</code>을 표현할 수 있는 별개의 타입을 가지고 있다.<br>→ 이를 보고 영감을 받아 <code>Optional</code>이 탄생했다.</p><p><strong><code>Optional</code>은 <code>존재할지 안 할지 모르는 값</code>을 다룰 수 있는 여러가지 기능들을 제공한다.</strong></p><h2 id="optional-1">Optional</h2><p>: <code>"null이 될 수도 있는 객체”</code>을 감싸고 있는 일종의 Wrapper Class이다.</p><ul><li>NPE를 유발할 수 있는 null을 직접 다루지 않아도 된다.</li><li>명시적으로 해당 변수가 null일 수도 있다는 가능성을 표현할 수 있다.<blockquote><p>null에 대한 처리를 강제할 수 있다.</p></blockquote></li></ul><h3 id="기본적인-사용-방법">기본적인 사용 방법</h3><h4 id="optional-변수">Optional 변수</h4><ul><li>제네릭을 지원하기 때문에 선언시 명시한 타입 파라미터에 따라 감쌀 수 있다.<pre><code class="language-java">Optional&lt;Member&gt; optMember;  // Member타입을 감싸는 Optional
OptionalInt maybeInteager;  // int타입의 Optional
</code></pre></li></ul><h3 id="주의할-점">주의할 점</h3><h4 id="1-리턴값으로만-사용하는-것을-권장한다">1. 리턴값으로만 사용하는 것을 권장한다.</h4><blockquote><p>메소드 매개변수 타입, 맵의 키 타입, 인스턴스 필드타입으로 사용하지 말자.</p></blockquote><h4 id="2-optional을-리턴하는-메소드에서-null을-리턴하지-말자">2. Optional을 리턴하는 메소드에서 null을 리턴하지 말자.</h4><ul><li><code>Optional</code>자체가 해당 값이 <code>"존재할지 안 할지 모르는 값"</code>이므로 Null를 반환하면 안된다.<blockquote><p>개발에 큰 혼선을 야기한다. → Optional이 제공하는 기능을 사용하하면 NPE가 발생한다.</p><h4 id="3-기본타입primitive-type용-optional이-따로-존재하므로-기본타입을-사용하고-싶으면-사용한다">3. 기본타입(primitive type)용 Optional이 따로 존재하므로 기본타입을 사용하고 싶으면 사용한다.</h4></blockquote></li><li><code>OptionalInt</code>, <code>OptionalLong</code> 등…<blockquote><p>그냥 <code>Optional</code>를 사용하면 내부적으로 Auto boxing/unboxing이 일어나므로 오버해드가 발생한다.</p><h4 id="4-collection-map-stream-array-optional은-opiontal로-감싸지-말자">4. <code>Collection</code>, <code>Map</code>, <code>Stream Array</code>, <code>Optional</code>은 Opiontal로 감싸지 말자.</h4></blockquote></li><li>값이 비어있다는 것을 표현할 수 있는 객체이므로 <code>Optional</code>를 사용할 필요가 없다.</li></ul><h3 id="optional-api-사용-방법">Optional API 사용 방법</h3><h4 id="optional-만들기">Optional 만들기</h4><ul><li><code>Optional.of(T type)</code></li><li><code>Optional.ofNullable(T type)</code></li><li><code>Optional.empty(T type)</code></li></ul><h4 id="optional속-값의-유무">Optional속 값의 유무</h4><ul><li><code>isPresent()</code></li><li><code>isEmpty() (Java11 부터 추가)</code></li></ul><p>예시</p><pre><code class="language-java">Member member = null;
Optional&lt;Member&gt; optMember = Optional.of(member);
System.out.println(optMember.isPresent()); // false
System.out.println(optMember.isEmpty()); // true
</code></pre><h4 id="optional에-있는-값-가져오기">Optional에 있는 값 가져오기</h4><ul><li><code>get()</code><blockquote><p>만약 해당 값이 비어있다면 <code>NoSuchElementException</code>이 발생한다.<br>하지만 <code>get()</code>으로 바로 꺼내는 방식보다 앞으로 나올 방식으로 값을 꺼내 사용하는 것을 지양해야 한다.</p></blockquote></li></ul><p>예시</p><pre><code class="language-java">Member getMember1 = Optional.of(new Member).get();

Member member = new null();
Member getMember2 = Optional.ofNullable(member).get(); //NoSuchElementException
Member getMember3 = Optional.of(member).get(); // NullPointException
</code></pre><h4 id="optional에-값이-있는-경우에-해당-식을-실행하기">Optional에 값이 있는 경우에 해당 식을 실행하기</h4><ul><li><code>ifPresent(Consumer)</code></li></ul><p>예시</p><pre><code class="language-java">Optional&lt;Member&gt; optMember = Optional.of(new Member("siwony"));
Member nullMember = null;
Optional&lt;Member&gt; optNullmember = Optional.ofNullalbe(nullMember);

optMember.ifPresent(member -&gt; System.out.println(member.getName)) // siwony출력
optNullmember.ifPresent(member -&gt; System.out.println(member.getName) // 아무것도 출력되지 않음
</code></pre><h4 id="optional에-값이-있으면-가져오고-없는-경우에-t를-리턴하라">Optional에 값이 있으면 가져오고 없는 경우에 T를 리턴하라.</h4><ul><li><code>orElse(T)</code></li></ul><p>예시</p><pre><code class="language-java">Member nullMember = null;
Optional&lt;Member&gt; optNullmember = Optional.ofNullalbe(nullMember);
Member newMember = optNullmember.orElse(new Member("siwony"));
System.out.println(newMember.getName()) // siwony 출력
</code></pre><ul><li><code>orElse</code>에 넘겨준 인수는 어쩃든 어떠한 연산을 무조건한다. (임의의 값을 넘겨주기 때문)</li><li>상수의 값을 넘겨줄 때 사용한다.<blockquote><p>동적으로 어떠한 작업을 통해 값을 반환하기 원하면 <code>orElseGet</code>를 사용하는게 좋다.</p></blockquote></li></ul><h4 id="optional에-값이-있으면-가져오고-없는-경우에-해당-supplier를-실행후-어떤-값을-리턴해라">Optional에 값이 있으면 가져오고 없는 경우에 해당 Supplier를 실행후 어떤 값을 리턴해라</h4><ul><li><code>orElseGet(Supplier)</code></li></ul><p>예시</p><pre><code class="language-java">Optional&lt;Config&gt; optConfig = Optional.of(new Config("start"));
// 만약 config가 null이라면 status가 ready인 config 객체를 반환한다.
Config config = optConfig.orElseGet(() -&gt; new Config("ready")); 
System.out.println(config.status); // start반환
</code></pre><ul><li>어떠한 값을 동적으로 처리한 후 값을 반환하고 싶을 때 사용한다.</li></ul><h4 id="optional에-값이-있으면-가져오고-없는-경우에-해당-exception을-throw해라">Optional에 값이 있으면 가져오고 없는 경우에 해당 Exception을 throw해라</h4><ul><li><code>orElseThrow(Supplier)</code></li></ul><p>예시</p><pre><code class="language-java">Optional&lt;Member&gt; optMember = memberRepository.findByUsername("siwony");
//만약 member가 조회가 되지 않으면 MemberNotFound라는 Exceptionn(사용자 지정 Exception)을 던진다
Member member = optMember.orElseThrow(() -&gt; new MemberNotFoundException()); 
//만약 Exception을 인수로 넘겨주지 않으면 NoSuchElementException가 발생한다.
Member member = optMember.orElseThrow();  
</code></pre><ul><li>기본값은 <code>NoSuchElementException</code></li></ul><h4 id="optional에-들어있는-값-걸러내기">Optional에 들어있는 값 걸러내기</h4><ul><li><code>filter(Predicate)</code></li></ul><p>예시</p><pre><code class="language-java">Optional&lt;Member&gt; optMember = memberRepository.findByUsername("siwony");
//member의 getAge()의 반환값이 18이 아니면 emtpy Optionl를 반환한다.
Optional&lt;Member&gt; member = optMember.filter(mmeber -&gt; member.getAge() != 18);
</code></pre><ul><li>filter를 사용할 Optional은(optMember) 해당 객체(member)가 비어있지 않다는 가정하여 사용한다.</li></ul><h4 id="optional에-들어있는-값-변환하기">Optional에 들어있는 값 변환하기</h4><ul><li>무조건 Optional타입을 반환한다.</li><li>특정 element를 다른 형식으로 반환한다.<ol><li><code>map(Function)</code></li></ol></li></ul><p>예시</p><pre><code class="language-java">Optional&lt;Member&gt; optMember = memberRepository.findByUsername("siwony");
//member의 getAge()의 반환값이 18이 아니면 emtpy Optionl를 반환한다.
Optional&lt;Integer&gt; member = optMember.map(meber -&gt; member.getAge());
</code></pre><ol><li><code>flatMap(Function)</code><blockquote><p>Optional 안에 들어있는 인스턴스가 Optional인 경우에 사용한다.</p></blockquote></li></ol><p>예시</p><pre><code class="language-java">Optional&lt;Member&gt; optMember = memberRepository.findByUsername("siwony");

// map을 사용하는 경우
Optional&lt;Optional&lt;Plan&gt;&gt; member = optMember.map(meber -&gt; member.getPlan());

// flatMap을 사용하는 경우
Optional&lt;Plan&gt; member = optMember.flatMap(meber -&gt; member.getPlan());
</code></pre></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/observer-pattern/" class="nav-link">Observer Pattern</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/proxy-pattern/" class="nav-link">Proxy Pattern</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>