<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>IoC(Inversion Of Control) - 제어의 역전</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">IoC(Inversion Of Control) - 제어의 역전</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","spring-triangle","TIL"]' date="June 05, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="iocinversion-of-control---제어의-역전">IoC(Inversion Of Control) - 제어의 역전</h1><p>: 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미한다.</p><ul><li>컴포넌트 의존관계 결정 (Component dependency resolution), 설정(configuration) 및 생명주기(lifecycle)를 해결하기 위한 디자인 패턴(Design Pattern)<blockquote><p>어떤 객체가 사용할 객체(의존관계인 객체)를 직접 선언하여 사용하는 것이 아니라,<br>어떤 방법을 사용하여(ex.생성자 등..)사용하여 주입 받아 사용것 을 IoC의 일부라고 표현 할 수 있다.</p></blockquote></li></ul><p><strong>일번적인 제어권</strong>: 자기가 사용할 의존성은 자기가 만들어서 사용</p><pre><code class="language-java">@Service
public class CarService {
	private CarRepository carRepository = new CarRepository();
}
</code></pre><h2 id="ioc-분류">IoC 분류</h2><h4 id="dl---dependency-lookup">DL - Dependency Lookup</h4><p>: 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 Lookup하는 것 이다.</p><h4 id="di---dependency-injection">DI - Dependency Injection</h4><p>: 각 클래스간의 의존관계를 빈 설정(Bean Definition)정보를 바탕으로 컨테이너가 자동으로 연결해 주는 것 이다.</p><p>DI의 분류</p><ul><li>Setter Injection</li><li>Constructor Injection</li><li>Method Injection</li></ul><p>&lt;img width=500px src=./img/DI-DL.png&gt;</p><h3 id="dependency-injection를-통한-ioc">Dependency Injection를 통한 IoC</h3><pre><code class="language-java">@Service
public class CarService {
	
    // CarRepository를 사용은 하지만 만들지는 않는다.
	private CarRepository carRepository;
    /*
    생성자를 통해서 받아온다.
    따라서 의존성을 관리하는 일은 CarService가 하는 일이아니다. 누군가 밖에서 해주는 것이다.
    */
    //생성자를 통한 의존성 주입 
    public CarService(CarRepository carRepository){
    	this.carRepository = carRepository;
    }
}
</code></pre><h3 id="di는-ioc를-구현하는-방법의-한-종류">“DI는 IoC를 구현하는 방법의 한 종류”</h3><p><strong>게임을 예시로 들어보자</strong></p><ol><li>플레이어가 게임 캐릭터를 조종한다.</li><li>게임 캐릭터가 해야 할 일(퀘스트 등..)을 플레이어가 직접적으로 관여해 조종한다.</li><li>게임 캐릭터의 제어권은 플레이어(외부)에게 넘어감 -&gt; 제어권이 위임되었다 -&gt; 제어의 역전(IoC)</li></ol><h2 id="ioc-container">IoC Container</h2><p>: Spring Framework는 <strong>객체에 대한 생성 및 생명주기를 관리</strong> 할 수 있는 기능을 제공한다.</p><ul><li>객체의 생성을 책임지고, 의존성을 관리</li><li>POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다</li><li>객체 생성에 대한 제어권을 IoC Container에 넘긴다.</li></ul><h3 id="구성요소">구성요소</h3><h4 id="1-beanfactory">1. BeanFactory</h4><ul><li><strong>Bean 등록, 생성, 조회, 반환 관리</strong></li><li>IoC Container의 최상단에 interface로 존재한다.</li><li><strong>보통 BeanFactory를 바로 사용하지 않고, 이를 확장한 <code>ApplicationContext</code>를 사용한다.</strong></li></ul><h4 id="2-applicationcontext">2. ApplicationContext</h4><ul><li><code>BeanFactory</code>와 Bean을 등록, 생성, 조회, 반환 을 관리하는 기능은 같다.</li><li><code>BeanFactory</code>의 서브 인터페이스인 <code>ListableBeanFactory</code>, <code>HierachicalBeanFactory</code>라는 인터페이스를 상속하여 <code>BeanFactory</code>를 상속하고 있다.</li><li>Spring의 각종 부가 서비스를 추가로 제공한다.<ul><li><code>ResourceLoaderAware</code>의 <code>ResourceLoader</code> (편리한 리소스 조회)<blockquote><p>로컬, 개발, 운영등을 구분해서</p></blockquote></li><li><code>ApplicationEventPublisherAware</code>의 <code>ApllicationEventPublicher</code> (이벤트발행/구독 모델 지원)</li><li><code>MessageSourceAware</code>의 <code>MessageSource</code> (메시지소스를 활용한 국제화(i18n) 기능)</li><li><code>ApllicatonContextAware</code>의 <code>ApllicationContext</code></li><li><code>EnviornmentCapable</code> (환경변수)<blockquote><p>로컬 개발, 운영등을 구분해서 처리 <code>Profile</code></p></blockquote></li></ul></li><li>Spring이 제공하는 <code>ApplicationContext</code> 구현 클래스가 여러 종류가 있다.</li></ul><h2 id="ioc의-핵심은">IoC의 핵심은?</h2><p>개발자가 Bean을 직접 만들지 않고 xml, annotation과 같은 메타데이터를 제공하면 프로그램(Spring framework)이 해당 메타데이터를 사용해 Bean객체를 제어한다.</p><p><strong>즉, <code>IoC Container</code>는 <code>Spring Framework</code>이라고 할 수 있고, 이는 Spring Framwork를 사용하는 이유이자 핵심 \기능이다.</strong></p></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/06/05/aspect-oriented-programming%EA%B4%80%EC%A0%90-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/" class="nav-link">Aspect Oriented Programming(관점 지향 프로그래밍)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/06/05/psa-portable-service-abstraction/" class="nav-link">PSA - Portable Service Abstraction</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>