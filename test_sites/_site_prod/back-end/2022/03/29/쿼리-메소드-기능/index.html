<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>쿼리 메소드 기능</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">쿼리 메소드 기능</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","data-jpa","TIL"]' date="March 29, 2022" reading-time="3" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="쿼리-메소드-기능">쿼리 메소드 기능</h1><blockquote><p>만약 findByUsername같이 Entity 종속적인 기능을 사용하려면 어떻게 해야 할까? Spring JPA는 쿼리 메소드라는것을 제공한다.</p><h4 id="쿼리-메소드-기능-3가지">쿼리 메소드 기능 3가지</h4><ul><li>메소드 이름으로 쿼리 생성</li><li>메소드 이름으로 JPA NamedQuery 호출</li><li><code>@Query</code> 어노테이션을 사용해서 리파지토리 인터페이스에 쿼리 직접 정의</li></ul></blockquote><h3 id="메소드-이름으로-쿼리-생성">메소드 이름으로 쿼리 생성</h3><p>: 메소드 이름을 분석하여 JPQL 쿼리를 실행한다.</p><p>이름과 나이를 기준으로 회원을 조회하려면?</p><h4 id="순수-jpa-repository-코드">순수 JPA Repository 코드</h4><pre><code class="language-java"> public List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age) {
      return em.createQuery("select m from Member m where m.username = :username
  and m.age &gt; :age")
              .setParameter("username", username)
              .setParameter("age", age)
              .getResultList();
}
</code></pre><h4 id="spring-data-jpa">Spring Data JPA</h4><pre><code class="language-java">public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {
    List&lt;Member&gt; findByUsernameAndAgeGreaterThan(String username, int age);
}
</code></pre><ul><li>쿼리 메소드 필터 조건: <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation">공식문서 참고</a></li><li>조회: find…By, read…By, get…By<blockquote><p>findHelloBy 처럼 …에 식별하기 위한 내용(설명)이 들어가도 된다.<br>자세한건 공식문서</p></blockquote></li><li><code>COUNT</code>: count…By 반환타입 <code>long</code></li><li><code>EXISTS</code>: exists…By 반환타입 <code>boolean</code></li><li>삭제: delete…By, remove…By 반환타입 <code>long</code></li><li><code>DISTINCT</code>: <code>findDistinct</code>, <code>findMemberDistinctBy</code></li><li><code>LIMIT</code>: <code>findFirst3</code>, <code>findFirst</code>, <code>findTop</code>, <code>findTop3</code></li></ul><blockquote><p>참고: 필드명이 변경되면 인터페이스에서도 똑같이 변경해줘야 한다.<br>그렇지 않으면 애플리케이션 시작 시점에 에러가 나온다.<br>이러한점이 JPA큰 장점이다.</p></blockquote><h3 id="메소드-이름으로-jpa-namedquery-호출">메소드 이름으로 JPA NamedQuery 호출</h3><p>: JPA의 NamedQuery를 호출할 수 있다.</p><blockquote><p>실무에서 사용할 일이 별로 없다.<br>대신 <code>@Query</code>를 사용하여 Repository 메소드에 쿼리를 직접 정의한다.</p></blockquote><h4 id="namedquery-어노테이션으로-named-쿼리-정의"><code>@NamedQuery</code> 어노테이션으로 Named 쿼리 정의</h4><pre><code class="language-java">@Entity
@NamedQuery(
    name="Member.findByUsername",
    query="select m from Member m where m.username = :username"
)
public class Member{
    ...
}
</code></pre><h4 id="jpa를-직접-사용해서-named-쿼리-호출">JPA를 직접 사용해서 Named 쿼리 호출</h4><pre><code class="language-java">public class MemberRepository {
    public List&lt;Member&gt; findByUsername(String username) {
        ...
        List&lt;Member&gt; resultList = 
        em.createNamedQuery("Member.findByUsername", Member.class)
                .setParameter("username", username)
                .getResultList();
    }
}
</code></pre><h4 id="data-jpa를-사용하여-named-쿼리-호출">DATA JPA를 사용하여 Named 쿼리 호출</h4><pre><code class="language-java">@Repository
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {
//    @Query(name = "Member.findByUsername") //생략가능하다. 알아서 위에 선언된 Member를 찾아간다.
    List&lt;Member&gt; findByUsername(@Param("username") String username);
}
</code></pre><ul><li>Spring Data JPA는 선언한 “도메인 클래스 + . + 메서드 이름’ 으로 Named 쿼리를 찾아서 실행한다.</li><li>실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략을 사용한다.</li><li>필요하면 전략을 변경 가능하지만 권장x<blockquote><p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-lookup-strategies">참고</a></p></blockquote></li></ul><h3 id="query를-사용하여-repository-매서드에-쿼리-정의하기">@Query를 사용하여 Repository 매서드에 쿼리 정의하기</h3><blockquote><p>가장 권장하는 방식이다.<br>메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다.<br><strong>복잡하면 주로 <code>@Query</code>를 통해 실무에서 많이 사용한다.</strong></p></blockquote><h4 id="메서드에-jpql-쿼리-작성">메서드에 JPQL 쿼리 작성</h4><pre><code class="language-java">public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {
    @Query("select m from Member m where m.username= :username and m.age = :age")
    List&lt;Member&gt; findUser(@Param("username") String username, @Param("age") int
    age);
}
</code></pre><ul><li><code>@org.springframework.data.jpa.repository.Query</code> 어노테이션을 사용한다.</li><li>실행할 메서드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있음</li><li><strong>JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있다!</strong></li></ul><h3 id="dto-조회하기">DTO 조회하기</h3><p>예제 DTO</p><pre><code class="language-java">@Data
  public class MemberDto {
      private Long id;
      private String username;
      private String teamName;
      public MemberDto(Long id, String username, String teamName) {
          this.id = id;
          this.username = username;
          this.teamName = teamName;
      }
}
</code></pre><p>예제 Repository</p><pre><code class="language-java">    @Query("select new com.study.datajpa.dto.MemberDto(m.id, m.username, t.name) from Member m join m.team t")
    List&lt;MemberDto&gt; findMemberDto();
</code></pre><ul><li>JPA <code>new</code> 명령어를 사용하고, 생성자가 맞는 DTO가 필요하다.<br>→ JPA와 사용방식이 동일하다.</li></ul><h3 id="파라미터-바인딩">파라미터 바인딩</h3><h4 id="위치기반">위치기반</h4><blockquote><p>실무에서 사용하지 않는다. 가독성및 유지보수성이 매우 떨어진다.</p><pre><code class="language-sql">select m from Member m where m.username = ?0
</code></pre></blockquote><h4 id="이름기반">이름기반</h4><pre><code class="language-sql">select m from Member m where m.username = :name
</code></pre><p>파라미터 파인딩</p><pre><code class="language-java">public interface MemberRepository extends JpaRepository&lt;Member, Long&gt;{

    @Query("select m from Member m where m.username = :name")
    Member findMembers(@Param("name") String username);
}
</code></pre><h4 id="컬렉션-파라미터-바인딩">컬렉션 파라미터 바인딩</h4><p><code>Collection</code> 타입으로 in절을 지원한다.</p><pre><code class="language-java">    @Query("select m from Member m where m.username in :names")
    List&lt;Member&gt; findByNames (@Param("names") Collection&lt;String&gt; names);
</code></pre><h3 id="반환타입">반환타입</h3><blockquote><p>Spring Data JPA는 여러 반환타입을 지원한다.</p><pre><code class="language-java">List&lt;Member&gt; findListByUsername(String username); //컬렉션
Member findMemberByUsername(String username) //단건
Optional&lt;Member&gt; findOptionalMemberByUsername;
</code></pre></blockquote><h4 id="컬렉션">컬렉션</h4><blockquote><p>List 등…</p></blockquote><ul><li>결과가 없을떄는 빈 빈 컬렉션을 반환한다. → null에대한 보장을 해준다.</li></ul><h4 id="단건-조회">단건 조회</h4><ul><li>결과 없음: null 반환</li><li>결과가 2건 이상 : <code>javax.persistence.NonUniqueResultException</code> 예외 발생</li></ul><h4 id="참고-단건-조회결과가-없을때-jpa와-data-jpa의-차이">참고 단건 조회결과가 없을때 JPA와 data JPA의 차이</h4><blockquote><p>Spring Data JPA는 내부에서 JPQL의 <code>Query.getSingleResult()</code> 메서드를 호출한다.<br>조회 결과가 없으면 <code>javax.persistence.NoResultException</code> 예외가 하지만<br>스프링 데이터는 JPA는 예외를 무시하고 대신 null을 반환한다.</p></blockquote></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/programming/2022/03/29/%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-annotation-processor/" class="nav-link">어노테이션 프로세서 - Annotation Processor</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/programming/2022/03/29/%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98%EC%9D%98-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95/" class="nav-link">클래스 기반의 프록시 생성 방법</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>