<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>값 타입 컬렉션</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">값 타입 컬렉션</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="값-타입-컬렉션">값 타입 컬렉션</h1><p>: 값 타입을 하나 이상 저장할 때 사용한다.</p><ul><li><code>@ElementCollection</code>, <code>@CollectionTable</code> 사용한다.</li><li>DB는 컬렉션같은 테이블을 저장할 수 없다.</li><li>컬렉션을 저장하기 위한 별도의 테이블이 필요하다.</li></ul><p><img width="400px" src="/assets/images/posts/back-end/value-type-collection.png"></p><pre><code class="language-java">@Entity
@Getter @Setter
public class Member{

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @Embedded
    private Address homeAddress;

    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns = @JoinColumn(name = "MEMBER_ID"))
    private Set&lt;String&gt; favoriteFoods = HashSet&lt;&gt;();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns = @JoinColumn(name = "MEMBER_ID"))
    private List&lt;Address&gt; addressHistory = HashList&lt;&gt;();
}
</code></pre><h2 id="값-컬렉션-사용">값 컬렉션 사용</h2><p>참고: 값 타입 컬렉션은 영속성 전의(Cascade) + 고아객체 제거 기능이 필수로 들어가 있다.</p><h3 id="값-타입-저장-예제">값 타입 저장 예제</h3><pre><code class="language-java">Member m = new Member();
m.setUsername("member1");
m.setAddress(new Address("city1", "street1", "100000"))

m.getFavoriteFoods().add("치킨");
m.getFavoriteFoods().add("피자");
m.getFavoriteFoods().add("족발");

m.getAddressHistory().add(new Address("old1", "street1", "10000"))
m.getAddressHistory().add(new Address("old2", "street2", "10000"))

em.persist(m);

</code></pre><ul><li>컬렉션은 다른 테이블이여도 라이프 사이클이 같다. → 같이 저장됬다.</li><li>위 예제의 값타입의 라이프 사이클은 Member에 의존한다.</li></ul><h3 id="값-타입-조회-예제">값 타입 조회 예제</h3><pre><code class="language-java">Member m = new Member();
m.setUsername("member1");
m.setAddress(new Address("city1", "street1", "100000"))

m.getFavoriteFoods().add("치킨");
m.getFavoriteFoods().add("피자");
m.getFavoriteFoods().add("족발");

m.getAddressHistory().add(new Address("old1", "street1", "10000"))
m.getAddressHistory().add(new Address("old2", "street2", "10000"))

em.persist(m);

em.flush();  em.clear();

Member findM = em.find(Member.class, m.getId()); // 기본타입은 지연로딩이 된다. 

List&lt;Address&gt; addressHistory = findM.getAddresHistory(); // 이때 addressHistory 를 쿼리를 날려 불러온다. 

Set&lt;String&gt; favoriteFoodss = findM.getFavoriteFood(); //이떄 favoriteFood를 불러온다.
</code></pre><ul><li>값 타입 컬렉션들은 기본적으로 지연로딩이 된다.</li></ul><h3 id="값-타입-수정-예제">값 타입 수정 예제</h3><pre><code class="language-java">Member m = new Member();
m.setUsername("member1");
m.setAddress(new Address("city1", "street1", "100000"))

m.getFavoriteFoods().add("치킨");
m.getFavoriteFoods().add("피자");
m.getFavoriteFoods().add("족발");

m.getAddressHistory().add(new Address("old1", "street1", "10000"))
m.getAddressHistory().add(new Address("old2", "street2", "10000"))

em.persist(m);

em.flush();  em.clear();

Member findM = em.find(Member.class, m.getId());
// homeCity를 newCity로 바꾸고 싶으면
// findM.getHomeAddress().setCity("newCity"); // 다음과 같이 바꾸면 부작용이 일어날 수 있다.
Address a =  findM.getHomeAddress();
findM.setMemberAddress(new Address("newCity", a.getStreet, a.getZipcode)); //완전히 새로운 객체로 교체를 해야한다.

// 치킨을 한식으로 바꾸기
findM.getFavoritFoods().remove("치킨");
findM.getFavoritFoods().add("한식"); // 컬렉션의 값만 변경해도 업데이트 쿼리가 날라간다.

// address 바꾸기
findM.getAddressHistory().remove(new Address("old1", "street", "10000")); // Address 에equals로 값을 비교하여 지운다. Address에 equals를 오버라이드 해야한다.
findM.getAddressHistory().add(new Address("newCity1", "street", "10000"));  // addressHistory의 모든값이 제거되고 다시insert가 된다.
</code></pre><ul><li>값 타입은 불변해야 하기 떄문에 통제로 교체를 해야한다.</li></ul><h3 id="값-타입-컬렉션-제약사항">값 타입 컬렉션 제약사항</h3><ul><li>값 타입은 식별자가 없다.</li><li>값을 변경하면 추적이 어렵다.</li><li>값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 관련된 모든 데이터를 삭제하고,<br>값 타입 컬렉션에 있는 현재값을 모두 다시 저장한다.</li><li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 된다. <strong>null 입력x, 중복 저장x</strong></li></ul><h2 id="값-타입-컬렉션-대안">값 타입 컬렉션 대안</h2><ul><li>실무에서는 상황에 따라 <strong>값 타입 컬렉션 대신 일대다 관계를 고려한다.</strong></li><li>일대다 관계를 위한 엔티티를 만들고, 여기에서 값타입을 사용한다.</li><li>영속성 전이(<code>Cascade</code>) + 고아 제거를 사용해서 값 타입 컬렉션 처럼 사용한다.</li><li>ex. <code>AddressEntity</code></li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/%EA%B0%92-%ED%83%80%EC%9E%85-%EB%A7%A4%ED%95%91%EC%8B%A4%EC%8A%B5/" class="nav-link">값 타입 매핑(실습)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/%EA%B0%92-%ED%83%80%EC%9E%85/" class="nav-link">값 타입</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>