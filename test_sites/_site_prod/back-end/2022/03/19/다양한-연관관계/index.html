<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>다양한 연관관계</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">다양한 연관관계</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","TIL"]' date="March 19, 2022" reading-time="5" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="다양한-연관관계">다양한 연관관계</h1><h3 id="연관관계-매핑시-고려사항">연관관계 매핑시 고려사항</h3><ul><li>다중성</li><li>단방향, 양방향</li><li>연관관계의 주인(<code>mappedBy</code>)</li></ul><h3 id="다중성">다중성</h3><ul><li>다대일: <code>@ManyToOne</code></li><li>일대다: <code>@OneTomany</code></li><li>일대일: <code>@OneToOn</code></li><li>다대다: <code>@ManyToMany</code><blockquote><p>실무에서 쓰지마라</p></blockquote></li></ul><h3 id="객체와-테이블의-차이">객체와 테이블의 차이</h3><h4 id="테이블">테이블</h4><ul><li>외래키 하나로 양쪽 조인 가능</li><li>방향이라는 개념이 없다.</li></ul><h4 id="객체">객체</h4><ul><li>참조용 필드가 있는 쪽으로만 참조할 수 있다.</li><li>한쪽만 참조하면 단방향이다.</li><li>양쪽이 서로 참조하면 양방향 → 사실 단방향이 두 개가 있는것<blockquote><p>이것을 이해해야 연관관계의 주인에 대해 이해할 수 있다.</p></blockquote></li></ul><h3 id="연관관계의-주인">연관관계의 주인</h3><p>: FK를 관리하는 참조</p><ul><li>객체 양방향 관계는 참조가 두 군데 있어 둘 중 태이블의 기본키를 관리할 곳을 지정해야 한다.</li><li><strong>주인의 반대편</strong><br>외래키에 영향을 주지 않고, 단순 조회만 가능하다.</li></ul><h2 id="다대일n--1">다대일(N : 1)</h2><h3 id="1-다대일-단방향">1. 다대일 단방향</h3><p>&lt;img width=450px src=./img/many-to-one-single.png&gt;</p><pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 

    @Column(name = "USERNAME") private String name; private int age;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team; 
    // etc...
}

@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    private String name;
}
</code></pre><ul><li><p><code>RDB</code>에서 <code>1 : N</code> 이라면<code>N</code>쪽에 외래키를 두어야 한다.</p></li><li>외래키가 있는곳을 기준으로 연관된 참조를 하면 된다.</li><li>가장 많이 사용한다.</li></ul><h3 id="2-다대일n--1-양방향">2. 다대일(N : 1) 양방향</h3><p>&lt;img width=450px src=./img/many-to-one-multi.png&gt;</p><pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 

    @Column(name = "USERNAME") 
    private String name; 
    private int age;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team; 
    // etc...
}

@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    private String name;

    @MappedBy("team")
    private List&lt;Member&gt; members = new ArrayList&lt;&gt;();
}
</code></pre><ul><li><p><strong>FK 있는 쪽이 연관관계의 주인</strong> → 여기 예제에서는 <code>Member</code>에 있다.</p></li><li><p>양쪽을 서로 참조하도록 개발하는 것</p></li></ul><h2 id="일대다1--n">일대다(1 : N)</h2><h3 id="1-일대다-단방향">1. 일대다 단방향</h3><blockquote><p>실무에서 거의 사용하지 않는다.<br>다음과 같이 모델링하는 것은 권장하지 않는다.</p></blockquote><p>일대다 단방향 매핑보다 <strong>다대일(N : 1) 양방향 매핑을 사용하자!!</strong></p><p><img width="450px" src="/assets/images/posts/back-end/one-to-many-single.png"></p><pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 
    @Column(name = "USERNAME") 
    private String name; 
    private int age;

    //etc/..
}

@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany
    @JoinColumen(name = "TEAM_ID")
    private List&lt;member&gt; member = new ArrayList&lt;&gt;();

}
</code></pre><ul><li><p><code>Team</code>에 외래키가 있으면 <code>Team</code>에 중복이 일어난다 → 사실상 <code>Team</code>이 <code>다(N)</code>가 된다.</p></li><li><code>insert</code>를 하면 <code>update</code>쿼리가 한 번 더 나간다. →</li><li>실무에서는 테이블이 한개가 아니라 수십 개를 사용한다.<br>→ “난 분명 <code>Team</code>을 건들었는데 <code>Member</code>에 <code>update</code>쿼리가 나가네?” 라는 상황이 일어난다.</li></ul><h4 id="일대다-단방향-정리">일대다 단방향 정리</h4><ul><li><p>일대다 단방향은 일대다(1:N)에서 <strong>일(1)이 연관관계의 주인</strong>이다.</p></li><li><strong>다(N) 쪽에 외래키가 있다.</strong></li><li>엔티티가 관리하는 외래키가 다른 테이블에 있다.</li><li>객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조</li><li><code>@JoinColumn</code>을 꼭 사용해야 한다.<br>그렇지 않으면 조인 테이블 방식을 사용한다.</li></ul><h3 id="2-일대다1--n-양방향---비-권장">2. 일대다(1 : N) 양방향 - 비 권장</h3><blockquote><p>이 방법은 야매다 사용하지마라 - 김영한</p></blockquote><p><img width="450px" src="/assets/images/posts/back-end/one-to-many-multi.png"></p><pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 
    @Column(name = "USERNAME") 
    private String name; 
    private int age;

    @ManyToOne
    //강재로 읽기 전용으로 만들어버린다.
    @JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
    private Team team; 

    //etc/..
}

@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany
    @JoinColumen(name = "TEAM_ID")
    private List&lt;member&gt; member = new ArrayList&lt;&gt;();

}
</code></pre><ul><li><p>이런 매핑은 공식적으로 존재하지 않는다.<br><code>@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)</code></p></li><li><strong>읽기 전용 필드</strong>를 사용해서 양방향처럼 사용하는 방법</li><li><strong>결론 : 다대일 양방향을 사용하자</strong></li></ul><h2 id="일대일-관계1--1">일대일 관계(1 : 1)</h2><h3 id="1-일대일-단방향">1. 일대일 단방향</h3><p>&lt;img width=450px src=./img/one-to-one-single.png&gt;</p><pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 
    @Column(name = "USERNAME") 
    private String name; 
    
    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    Locker locker;

    //etc/..
}

@Entity
public class Locker{

    @Id @GeneratedValue
    private Long id;
    private String name;
    @OneToOne(mappedBy="locker")
    private Member member;
}
</code></pre><ul><li><p>외래키를 선택할 수 있다.</p></li><li>외래키에 DB 유니크(<code>UNIQUE</code>) 제약조건 추가</li><li>다대일(<code>@ManyToOne</code>) 단방향 매핑과 유사하다.</li></ul><h3 id="2-일대일-양방향">2. 일대일 양방향</h3><p>&lt;img width=450px src=./img/one-to-one-single.png&gt;</p><ul><li>다대일 양방향 매핑 처럼 <strong>외래 키가 있는 곳이 연관관계의 주인이다.</strong></li><li>반대편 <code>mappedBy</code> 적용</li></ul><h3 id="3-대상-테이블에-fk-단방향">3. 대상 테이블에 FK 단방향</h3><p>&lt;img width=450px src=./img/one-to-one-table-fk.png&gt;</p><ul><li><strong>단방향 관계를 JPA에서 지원하지 않는다.</strong></li><li>양방향 관계는 지원한다.</li></ul><h3 id="4-대상-테이블에-fk-양방향">4. 대상 테이블에 FK 양방향</h3><p>&lt;img width=450px src=./img/one-to-one-multi-fk.png&gt;</p><ul><li><p>무조건 즉시 로딩된다. (<code>EAGAR</code>)</p></li><li><p><code>Member</code>를 조회하면 <code>Locker</code>가 있는지 없는지 확인해야 하므로<br>즉시 로딩을 할 수밖에 없다. (반대도 마찬가지)</p></li></ul><h3 id="5-일대일-정리">5. 일대일 정리</h3><p><strong>주 테이블 와래키</strong></p><ul><li><p>주 객체가 대상 객체의 참조를 가지는것 처럼,<br>주 테이블에 외래 키를 두고 대상 테이블을 찾는다.</p></li><li>객체지향 개발자 선호</li><li>JPA 매핑 편리</li><li>장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능</li><li>단점: 값이 없으면 외래 키에 null 허용</li></ul><p><strong>대상 테이블에 외래키</strong></p><ul><li><p>대상 테이블에 외래키가 존재</p></li><li>전통적인 DB 개발자 선호</li><li>장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지한다.</li><li>단점: 프록시(Proxy) 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩(EAGER)된다.</li></ul><h2 id="다대다n--n-관계---비-권장">다대다(N : N) 관계 - 비 권장</h2><blockquote><p>실무에서 쓰면 안 된다. 매핑이 있지만… 알고 안 써야지 모르면 쓰고 싶어 진다.</p></blockquote><p>&lt;img width=450px src=./img/many-to-many.png&gt;</p><ul><li><p>관계형 DB는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.</p></li><li><p>연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 한다. → 야매로 가능하다.</p></li></ul><h3 id="객체는-컬렉션을-사용하여-객체-2개로-다대가-관계가-가능하다">객체는 컬렉션을 사용하여 객체 2개로 다대가 관계가 가능하다.</h3><p>&lt;img width=450px src=./img/obejct-many-to-many.png&gt;</p><ul><li><code>@ManyToMany</code></li><li><code>@JoinTable</code>로 연결 테이블을 지정한다</li><li>다대다 매핑: 단방향, 양방향 가능</li></ul><h3 id="다대다의-한계">다대다의 한계</h3><ul><li><strong>편리해 보이지만 실무에서 사용할 수 없다.</strong></li><li>연결 테이블이 단순히 연결만 하고 끝나지 않음</li><li>주문 시간, 수량 같은 데이터가 들어올 수 있다.<br>&lt;img width=450px; src=./img/meny-to-meny-product.png&gt;</li></ul><h3 id="다대다-한계-극복">다대다 한계 극복</h3><ul><li><strong>연결 테이블용 Entity를 추가한다. (연결 테이블은 엔티티로 승격)</strong></li><li><p><code>@ManyToMany</code> → <code>@OneToMany</code>, <code>@ManyToOne</code><br>&lt;img width=450px src=./img/many-to-many-limit-solve.png&gt;</p></li><li><code>ORDER</code>에 기본키는 관련 없는 값을 사용해야 한다.</li><li><code>GeneratValue</code>를 이용한다. → 확장성이 높아진다.</li></ul><h3 id="다대다-결론">다대다 결론</h3><p>다대다 쓰지 마라 일대다 혹은 대다일 을 사용해라.</p><h2 id="anotation-정리">anotation 정리</h2><h3 id="joincolumn---주요-속성"><code>@JoinColumn</code> - 주요 속성</h3><p>: 외래키를 매핑할때 사용한다. |속성|설명|기본값| |–|–|–| |<code>name</code>|매핑할 FK 이름|필드명 + _ + 참조하는 테 이블의 기본 키 컬럼명| |<code>referencedColumnName</code>|외래 키가 참조하는 대상 테이블의 컬럼명|참조하는 테이블의 기본 키 컬럼명| |<code>foreignKey(DDL)</code>|외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.|| <code>unique</code>, <code>nullable</code>, <code>insertable</code>, <code>updatable</code>, <code>columnDefinition</code>, <code>table</code>,|<code>@Column</code>의 속성과 같다.</p><h3 id="manytoone---주요-속성"><code>@ManyToOne</code> - 주요 속성</h3><p>: 다대일 관계 매핑 |속성|설명|기본값| |–|–|–| |<code>optional</code>|false로 설정하면 연관된 엔티티가 항상 있어야 한다.|TRUE| |<code>fetch</code>|글로벌 페치 전략을 설정한다.| <code>@ManyToOne=FetchType.EAGER</code>, <code>@OneToMany=FetchType.LAZY</code>| |<code>cascade</code>|영속성 전이 기능을 사용한다.|| |<code>targetEntity</code>|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 <strong>거의 사용하지 않는다.</strong> 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다.||</p><h3 id="onetomany---주요-속성"><code>@OneToMany</code> - 주요 속성</h3><p>: 일대다 관계 매핑 |속성|설명|기본값| |–|–|–| |<code>optional</code>|false로 설정하면 연관된 엔티티가 항상 있어야 한다.|TRUE| |<code>fetch</code>|글로벌 페치 전략을 설정한다.| <code>@ManyToOne=FetchType.EAGER</code>, <code>@OneToMany=FetchType.LAZY</code>| |<code>cascade</code>|영속성 전이 기능을 사용한다.|| |<code>targetEntity</code>|연관된 엔티티의 타입 정보를 설정한다. 이 기능은 <strong>거의 사용하지 않는다.</strong> 컬렉션을 사용해도 제네릭으로 타 입 정보를 알 수 있다.||</p></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91%EC%8B%A4%EC%A0%84/" class="nav-link">다양한 연관관계 매핑(실전)</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%84%A4%EA%B3%84/" class="nav-link">데이터 중심 설계</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>