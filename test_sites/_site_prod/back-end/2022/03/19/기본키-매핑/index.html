<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>기본키 매핑</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">기본키 매핑</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="기본키-매핑">기본키 매핑</h1><h2 id="기본키-매핑-방법">기본키 매핑 방법</h2><h3 id="1-직접-할당">1. 직접 할당</h3><p><strong>@Id</strong> 만 사용한다.</p><h3 id="2-자동-생성">2. 자동 생성</h3><p><code>@Id</code> 와 <code>@GeneratedValue</code>를 사용한다.</p><ul><li><a href="#IDENTITY-전략"><code>IDENTITY</code></a> : DB에 위임, MYSQL</li><li><a href="#SEQUENCE-@SequenceGenerator"><code>SEQUENCE</code></a> : DB 시퀀스 오브젝트 사용, ORACLE<ul><li><code>@SequenceGenerator</code> 필요</li></ul></li><li><a href="#TABLE-전략"><code>TABLE</code></a>: 키 생성용 테이블 사용, 모든 DB에서 사용 가능하다<ul><li><code>@TableGenerator</code> 필요</li></ul></li><li><code>AUTO</code>: 방언에 따라 자동 지정, 기본값</li></ul><h2 id="기본키-자동-생성-전략">기본키 자동 생성 전략</h2><h3 id="identity-전략">IDENTITY 전략</h3><p>: 기본 키 생성을 DB에 위임한다.</p><ul><li>MySQL, PostagreSQL, SQL Server, H2DB 에서 사용<blockquote><p>MySQL은 AUTO_INCREMENT</p></blockquote></li><li>AUTO_INCREMENT는 DB <code>INSERT</code> SQL을 실행한 이후 ID값을 알 수 있다.</li><li><code>em.persis()</code> 시점에 즉시 <code>INSERT</code> SQL 실행하고 DB에서 식별자 조회한다.<blockquote><p>즉, <code>INSERT</code> SQL을 실행할 때까지 기본키 값을 확인할 수 없다.</p></blockquote></li></ul><h3 id="sequence-sequencegenerator">SEQUENCE <code>@SequenceGenerator</code></h3><p>: DB 시퀀스 오브젝트 사용한다.</p><ul><li>아이디 값을 임의로 넣으면 안 된다.</li><li>영속성 컨텍스트에 값을 저장할 때<code>DB sequence</code>에서 기본키 값을 가져온다.<blockquote><p><code>insert</code> 쿼리는 날아가지 않는다.</p></blockquote></li></ul><p><strong>속성</strong> |속성|설명|기본값| |—|—|—-| |<code>name</code>|식별자 생성기 이름|필수| |<code>sequenceName</code>|DB에 등록되어 있는 시퀀스 이름|<code>hibernate_sequence</code>| |<code>initialValue</code>|DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 떄 처음 1 시작하는 수를 지정한다.|1| |<code>allocationSize</code>|시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용, <strong>DB 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야한다.</strong>)|50| |<code>catalog</code>, <code>schema</code>| <code>DB catalog</code>, <code>schema</code> 이름||</p><p>예시</p><pre><code class="language-java">@Entity
@SequenceGenerator(
    name = "MEMBER_SEQ_GENERATOR",
    sequenceName = "MEMBER_SEQ",
    initialValue = 1, allocationSize = 1)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE,
            generator = "MEMBER_SEQ_GENERTOR")
    privat Long id;
}
</code></pre><h3 id="table-전략">TABLE 전략</h3><p>: 키 생성 전용 테이블을 하나 만들어서 DB 시퀀스를 흉내 내는 전략</p><ul><li>모든 DB에 적용 가능하나 성능이 않좋다.<blockquote><p>그냥 사용잘 안 한다. 알아만 두자</p><pre><code class="language-sql">create table MY_SEQUENCES (
  sequence_name varcar(255) not null,
  next_val bigint,
  primary key ( sequence_name )
)
</code></pre><p>```java @Entity @TableGenerator( name = “MEMBER_SEQ_GENERATOR”, table = “MY_SEQUENCES”, pkColumnValue = “MEMBER_SEQ”, allocationSize = 1) public class Member {</p></blockquote><p>@Id @GeneratedValue(strategy = GenerationType.TABLE, generator = “MEMBER_SEQ_GENERATOR”) private Long id; } ``` <strong>@TalbeGenerator - 속성</strong> |속성|설명|기본값| |—|—|—-| |<code>name</code>|식별자 생성기 이름|필수| |<code>table</code>|키생성 테이블명|<code>hibernate_sequences</code>| |<code>pkColumnNmae</code>|시퀀스 컬럼명|<code>sequence_name</code>| |<code>valueColumnNa</code>|시퀀스 값 컬럼명|<code>next_val</code>| |<code>pkColumnValue</code>|키로 사용할 값 이름|엔티티 이름| |<code>initialValue</code>|초기 값, 마지막으로 생성된 값이 기준이다|0| |<code>allocationSize</code>|시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)|50| |<code>catalog</code>, <code>schema</code>| DB <code>catalog</code>, <code>schema</code> 이름|| |<code>uniqueConstraints</code>(<code>DDL</code>)|유니크 제약 조건을 지정할 수 있다.||</p></li></ul><h3 id="권장하는-식별자-전략">권장하는 식별자 전략</h3><ul><li><strong>기본 키 제약 조건</strong><ul><li><code>null</code>이 아니다.</li><li>유일해야 한다.</li><li>불변해야 한다.(엄청 어렵다)</li></ul></li><li>대체키를 사용한다.(미래까지 이 조건을 만족하는 자연키는 찾기 어렵다)</li><li><strong>권장: Long형(10억이 넘어도 동작) + 대체키 + 키 생성전략</strong></li></ul><p><strong>실무 경험 공유</strong></p><ul><li>주민등록번호를 기본 키로 쓰고 있었다.</li><li>나라에서 “주민등록번호를 보관하면 안 된다”라고 정책이 바뀌었다.</li><li>문제는 기본키 가 아니라 기본키를 사용하는 외래키로 주민번호를 가지고 있을 것이다.</li><li>마이그래이션을 진행할 때 엄청 난리 났다.</li><li>만약 대체키를 사용했으면 주민등록번호 테이블을 지우거나 다른 테이블로 대체했으면 됬었다.</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/%EA%B8%B0%EB%B3%B8%EA%B0%92-%ED%83%80%EC%9E%85/" class="nav-link">기본값 타입</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91%EC%8B%A4%EC%A0%84/" class="nav-link">다양한 연관관계 매핑(실전)</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>