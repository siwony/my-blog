<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JPA(Java Persistence API)</title><link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css"><link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css"><link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css"><link rel="stylesheet" href="/assets/css/style.css"><script type="module" src="https://unpkg.com/ninja-keys?module"></script></head><body><div class="container"><header><h1><a href="/">My Tech Blog</a></h1><nav><ul><li><a href="/">Home</a></li></ul></nav></header><main><article class="post"><header class="post-header"><h1 class="post-title">JPA(Java Persistence API)</h1><post-metadata layout="inline" categories='["back-end"]' tags='["spring","jpa","TIL"]' date="March 19, 2022" reading-time="2" compact="false"></post-metadata><div class="post-author"><span class="author-label">작성자:</span> <span class="author-name">jeongcool</span></div></header><div class="post-content"><h1 id="jpajava-persistence-api">JPA(Java Persistence API)</h1><p>: <strong>데이터를 영속화 하는 API</strong></p><h2 id="jpa사용하기-이전의-문제점">JPA사용하기 이전의 문제점</h2><h3 id="sql를-직접-사용">SQL를 직접 사용</h3><p><strong>SQL 중심적인 개발을 피하기 어렵다</strong></p><ul><li>기존 <code>JDBC</code>만 사용하면 반복적이며 비슷한 <code>SQL</code> 문을 많이 만들어야한다.(ex. CRUD)<blockquote><p>개발자가 SQL 매퍼가 되어버린다.</p></blockquote></li><li>추가적인 요구사항이 들어왔을 때 DB query, 객체 등 의존하는 여러 코드를 수정해야 한다.<blockquote><p>만약 컬럼이 하나 더 추가된다면, 가장 먼저 SQL Query를 수정해야 할것이고,<br>그다음 Entity 그다음 그와 관련된 로직 등… 수정해야 된다.</p></blockquote></li></ul><h3 id="패러다임의-불일치">패러다임의 불일치</h3><blockquote><p>객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 등 시스템의 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.</p><p align="right">- 어느 객체지향 개발자가</p></blockquote><ul><li>객체와 RDB는 다른 데이터구조를 가진다. 즉, 객체로 DB를 조회할 수 없다.</li><li><p>객체지향적 설계를 하게 되면 DB table과 JAVA 객체 간의 매핑하는 소모적인 작업을 지속해야 한다.</p><p>&lt;img width=500px src=./img/jpa-table-object-relation.png&gt;</p><blockquote><p>객체 모델은 외래키가 필요 없고 단지 참조만 있으면 되지만<br>테이블은 참조가 필요 없고 외래 키만 있으면 된다.</p></blockquote></li></ul><h3 id="jpa의-사용이유">JPA의 사용이유</h3><ul><li>SQL 문을 개발자가 만들지 않기 때문에 <strong>객체 중심적인 개발</strong>을 할 수 있다.</li><li>특정 <strong>RDBMS 문법에 종속적이지 않은 개발</strong>이 가능하다.<blockquote><p><strong>JPA는 RDBMS 벤더가 달라도 설정만 해주면 알아서 쿼리가 나간다!</strong></p></blockquote></li><li>영속성 컨택스트는 효율적인 SQL 처리에 크게 기여하여 성능상의 이점</li><li>객체답게 모델링 할수록 SQL과 매핑하는 작업만 늘어나게 되어 SQL에 의존적으로 설계하게 되는 문제를<br>JPA는 객체를 마치 <code>List</code>와 같은 <code>Java Collection</code>에 저장하듯이 DB에 저장하여 문제를 해결한다.</li></ul><h4 id="jpa는-특정-db에-종속적이지-않다">JPA는 특정 DB에 종속적이지 않다.</h4><ul><li>각각의 데이터베이스가 제공하는 SQL 문법과 함수는 조금씩 다르다<blockquote><p>DB의 방언이라고 한다.</p></blockquote></li><li>가변 문자: MySQL은 <code>VARCHAR</code>, Oracle은 <code>VARCHAR2</code></li><li>문자열을 자르는 함수: SQL 표준은 <code>SUBSTRING()</code>, Oracle은 <code>SUBSTR()</code></li><li>페이징: MySQL은 <code>LIMIT</code> , Oracle은 <code>ROWNUM</code></li></ul><h3 id="jpa-구동-방식">JPA 구동 방식</h3><p>&lt;img width=400px src=./img/jpa-work.png&gt;</p><h3 id="jpa의-가장-중요한-2가지">JPA의 가장 중요한 2가지</h3><ul><li>객체와 RDB 매핑(ORM)</li><li>영속성 컨텍스트</li></ul></div><footer class="post-footer"><div class="post-navigation"><div class="nav-previous"><span class="nav-label">이전 글</span> <a href="/back-end/2022/03/19/jpa-auditing/" class="nav-link">JPA Auditing</a></div><div class="nav-next"><span class="nav-label">다음 글</span> <a href="/back-end/2022/03/19/jpql/" class="nav-link">JPQL</a></div></div></footer></article></main></div><script src="/assets/js/prism/prism.min.js"></script><script src="/assets/js/prism/prism-autoloader.min.js"></script><script src="/assets/js/prism/prism-toolbar.min.js"></script><script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script><script src="/assets/js/prism/prism-show-language.min.js"></script><script src="/assets/js/prism/prism-line-numbers.min.js"></script><script>document.addEventListener("DOMContentLoaded",function(){Prism.plugins&&Prism.plugins.autoloader&&(Prism.plugins.autoloader.languages_path="/assets/js/prism/components/",console.log("Prism autoloader configured with local path:",Prism.plugins.autoloader.languages_path)),document.querySelectorAll('pre[class*="language-"]').forEach(function(s){s.classList.add("line-numbers")}),Prism.highlightAll()})</script><script src="/assets/js/command-palette.js"></script><script src="/assets/js/category-sidebar.js"></script><script src="/assets/js/post-metadata.js"></script></body></html>