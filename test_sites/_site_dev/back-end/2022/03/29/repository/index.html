<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Repository</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring","jpa","data-jpa","TIL"]'
          date="March 29, 2022"
          reading-time="4"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="repository">Repository</h1>
<h2 id="spring-data-jpa-사용전">Spring Data JPA 사용전</h2>
<h3 id="예제-코드">예제 코드</h3>
<h4 id="예제-모델">예제 모델</h4>
<p>Member</p>
<pre><code class="language-java">@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {"id", "name"})
public class Team {

    @Id @GeneratedValue
    @Column(name = "team_id")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    private List&lt;Member&gt; members = new ArrayList&lt;&gt;();

    public Team(String name) {
        this.name = name;
    }
}
</code></pre>
<p>Team</p>
<pre><code class="language-java">@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString(of = {"id", "name"})
public class Team {

    @Id @GeneratedValue
    @Column(name = "team_id")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    private List&lt;Member&gt; members = new ArrayList&lt;&gt;();

    public Team(String name) {
        this.name = name;
    }
}
</code></pre>

<h4 id="예제-repository">예제 Repository</h4>
<p>Member Repository</p>
<pre><code class="language-java">@Repository
public class MemberJpaRepository {

    @PersistenceContext // EntityManger 를 injection 해주는 annotation
    private EntityManager em;

    public Member save(Member member){
        em.persist(member);
        return member;
    }

    public long count(){
        return em.createQuery("select count(m) from Member m", Long.class).getSingleResult();
    }

    public Optional&lt;Member&gt; findById(Long id){
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    public Member find(Long id){
        return em.find(Member.class, id);
    }

    public void delete(Member member){
        em.remove(member);
    }

    public List&lt;Member&gt; findAll(){
        return em.createQuery("select m from Member m").getResultList();
    }
}
</code></pre>
<p>TeamRepository</p>
<pre><code class="language-java">@Repository
public class TeamJpaRepository {

    @PersistenceContext 
    private EntityManager em;

    public Team save(Team team){
        em.persist(team);
        return team;
    }

    public void delete(Team team){
        em.remove(team);
    }

    public List&lt;Team&gt; findAll(){
        return em.createQuery("select t from Team t", Team.class).getResultList();
    }

    public Optional&lt;Team&gt; findById(Long id){
        Team team = em.find(Team.class, id);
        return Optional.ofNullable(team);
    }

    public long count(){
        return em.createQuery("select count(t) from Team t", Long.class).getSingleResult();
    }
}
</code></pre>
<h4 id="테스트-코드-작성">테스트 코드 작성</h4>
<pre><code class="language-java">@SpringBootTest
@Transactional
public class MemberJpaRepositoryTest {
    @Autowired
    MemberJpaRepository memberJpaRepository;

    @Test
    public void basicCRUD() {
        Member member1 = new Member("member1");
        Member member2 = new Member("member2");
        memberJpaRepository.save(member1);
        memberJpaRepository.save(member2);

        //단건 조회 검증
        Member findMember1 = memberJpaRepository.findById(member1.getId()).get();
        Member findMember2 = memberJpaRepository.findById(member2.getId()).get();
        assertThat(findMember1).isEqualTo(member1);
        assertThat(findMember2).isEqualTo(member2);

        //리스트 조회 검증
        List&lt;Member&gt; all = memberJpaRepository.findAll();
        assertThat(all.size()).isEqualTo(2);

        //카운트 검증
        long count = memberJpaRepository.count(); assertThat(count).isEqualTo(2);
        //삭제 검증 

        memberJpaRepository.delete(member1); memberJpaRepository.delete(member2);
        long deletedCount = memberJpaRepository.count();
        assertThat(deletedCount).isEqualTo(0);
    }
}
</code></pre>
<blockquote>
  <p>참고. UPDATE는 JPA의 변경 감지(Dirty Checking)을 사용하므로 필요 없다.</p>
  <h3 id="위-코드의-문제점">위 코드의 문제점</h3>
  <ul>
    <li>위에 Member와 Team의 Repository는 서로 관리하는 Entity만 다르지 기능은 똑같다.</li>
    <li>개발자가 CRUD같은 기본 로직을 계속 짜줘야한다. → 매우번거롭다</li>
  </ul>
</blockquote>

<p><strong>하지만 Spring Data JPA는 이 귀찮은 과정을 스킵할 수 있게한다.</strong></p>

<h2 id="spring-data-jpa-적용후">Spring Data JPA 적용후</h2>
<h3 id="공용-인터페이스-설정">공용 인터페이스 설정</h3>
<h4 id="javaconfig-설정--스프링-부트-사용시-생략-가능">JavaConfig 설정- 스프링 부트 사용시 생략 가능</h4>
<pre><code class="language-java">@Configuration
@EnableJpaRepositories(basePackages = "jpabook.jpashop.repository")
public class AppConfig {} 
</code></pre>
<ul>
  <li>스프링부트사용시<code>@SpringBootApplication</code>이 위치를지정(해당 패키지와 하위 패키지 인식)</li>
  <li>만약 패키지의 위치가 달라지면 <code>@EnableJpaRepositories</code>가 필요하다</li>
</ul>

<h4 id="spring-data-jpa가-구현-클래스-대신-생성한다">Spring Data JPA가 구현 클래스 대신 생성한다.</h4>
<p><img width="450px" src="/assets/images/posts/back-end/data-jpa-implements.png" /></p>

<ul>
  <li><code>org.springframework.data.repository.Repository</code>를 구현한 클래스는 스캔 대상이다.
    <ul>
      <li>그리하여 실제로 MemberRepository 인터페이스를 가져와 출력하면<br />
memberRepo.getClass() → class com.sun.proxy.$ProxyXXX 와 같이 프록시 객체가 만들어진다는것을 알 수 있다.</li>
    </ul>
  </li>
  <li><code>@Repository</code> 생략 가능하다</li>
</ul>

<h3 id="공용-인터페이스-적용">공용 인터페이스 적용</h3>
<p>Member Repository</p>
<pre><code class="language-java">@Repository
public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {}
</code></pre>
<p>Team Repository</p>
<pre><code class="language-java">@Repository
public interface TeamRepository extends JpaRepository&lt;Team, Long&gt; {}
</code></pre>
<h4 id="테스트-코드-작성-1">테스트 코드 작성</h4>
<blockquote>
  <p>기존 순수 JPA 기반 테스트에서 사용했던 코드를 그대로 스프링 데이터 JPA 리포지토리 기반 테스트로 변경해도 동일한 방식으로 동작한다
```java
@SpringBootTest
@Transactional
@Rollback(value = false)
class MemberRepositoryTest {</p>
</blockquote>

<pre><code>@Autowired MemberRepository memberRepo;

@Test
public void basicCRUD() {
    Member member1 = new Member("member1");
    Member member2 = new Member("member2");
    memberRepository.save(member1);
    memberRepository.save(member2);

    //단건 조회 검증
    Member findMember1 = memberRepository.findById(member1.getId()).get(); 
    Member findMember2 = memberRepository.findById(member2.getId()).get(); 
    assertThat(findMember1).isEqualTo(member1); 
    assertThat(findMember2).isEqualTo(member2);

    //리스트 조회 검증
    List&lt;Member&gt; all = memberRepository.findAll(); assertThat(all.size()).isEqualTo(2);

    //카운트 검증
    long count = memberRepository.count(); assertThat(count).isEqualTo(2);

    //삭제 검증 
    memberRepository.delete(member1); 
    memberRepository.delete(member2);
    long deletedCount = memberRepository.count();
    assertThat(deletedCount).isEqualTo(0);
  }
</code></pre>

<p>}</p>
<pre><code>- 위와 같이 간단하게 만들 수 있다.
- 우리는 그냥 간단한 CRUD를 저기 만들어 놓은 Repository를 이용하여 만들면 된다.
- Spring Data JPA한테 구현해야 할 코드를 맡기자

### 공통 인터페이스 분석
- JpaRespotiroy 인터페이스: 공통 CRUD 제공
- 제네릭은 &lt;Entity Type, 식별자 타입&gt;으로 설정한다
#### JpaRepository 공통 기능 인터페이스
```java
public interface JpaRepository&lt;T, ID&gt; extends PagingAndSortingRepository&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt;{
    //etc....
}
</code></pre>
<h4 id="jparepository를-사용하는-인터페이스">JpaRepository를 사용하는 인터페이스</h4>
<pre><code class="language-java">public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {}
</code></pre>

<h4 id="공통-인터페이스-구성">공통 인터페이스 구성</h4>
<p><img width="500px" src="/assets/images/posts/back-end/interface-config.png" /></p>

<h4 id="제네릭-타입">제네릭 타입</h4>
<ul>
  <li><code>T</code>: 엔티티</li>
  <li><code>ID</code> : 엔티티의 식별자 타입</li>
  <li><code>S</code> : 엔티티와 그 자식 타입</li>
</ul>

<h4 id="주요-메서드">주요 메서드</h4>
<ul>
  <li><code>save(S)</code> : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.</li>
  <li><code>delete(T)</code> : 엔티티 하나를 삭제한다.
    <blockquote>
      <p>내부에서 <code>EntityManager.remove()</code> 호출</p>
    </blockquote>
  </li>
  <li><code>findById(ID)</code> : 엔티티 하나를 조회한다
    <blockquote>
      <p>내부에서 <code>EntityManager.find()</code> 호출</p>
    </blockquote>
  </li>
  <li><code>getOne(ID)</code> : 엔티티를 프록시로 조회한다.
    <blockquote>
      <p>내부에서 <code>EntityManager.getReference()</code> 호출</p>
    </blockquote>
  </li>
  <li><code>findAll(...)</code> : 모든 엔티티를 조회한다.
    <blockquote>
      <p>정렬(sort), 패이징(Pageable)조건을 파라미터로 제공할 수 있다.</p>
    </blockquote>
  </li>
</ul>

<p>참고: <code>JpaRepository</code> 는 대부분의 공통 메서드를 제공한다.</p>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/03/29/proxy-pattern/" class="nav-link">Proxy Pattern</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/03/29/singleton-pattern/" class="nav-link">Singleton Pattern</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
