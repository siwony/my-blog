<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Servlet</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Servlet</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["java-ee","TIL"]'
          date="March 19, 2022"
          reading-time="4"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="servlet">Servlet</h1>
<p>: Java를 이용하여 웹페이지를 동적으로 생성하는 server side 프로그램이다.</p>
<blockquote>
  <p>웹 프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 규현 규칙을 지킨 자바 프로그래밍 기술</p>
  <ul>
    <li>서블릿은 자바 기반의 CGI 프로그램이며 CGI 규칙에 따라 웹 서버와 데이터를 주고받는다.</li>
    <li>자바를 사용하여 웹을 만들기 위해 필요한 기술이다.</li>
    <li><code>javax.Servlet.http.HttpServlet</code> 클래스를 상속받아 사용한다.</li>
  </ul>
</blockquote>

<h3 id="웹-어플리케이션의-실행-과정">웹 어플리케이션의 실행 과정</h3>
<p><img width="500px" src="/assets/images/posts/back-end/web-application-run-process.png" /></p>

<ol>
  <li>웹 브라우저가 웹 서버에게 요청을 전송한다.</li>
  <li>웹 서버는 클라이언트가 요청한 프로그램을 찾아서 실행한다.</li>
  <li>해당 프로그램은 작업을 수행한 후 그 결과를 웹 서버에게 돌려준다.</li>
  <li>웹 서버는 그 결과를 HTTP 형식에 맞춰 웹 브라우저에게 보낸다.</li>
</ol>

<p>이때 <strong>웹 서버와 프로그램 사이의 데이터를 주고받는 규칙을 CGI(Common Gateway Interface)라고 한다.</strong></p>

<p>웹 서버에 의해 실행되며 CGI 규칙에 따라 웹 서버와 데이터를 주고받도록 작성된 프로그램을 CGI 프로그램이라 한다.</p>

<h3 id="servlet의-특징">Servlet의 특징</h3>
<ul>
  <li>클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트</li>
  <li>Java Threed를 이용하여 동작한다.</li>
  <li>MVC 패턴에서 controller로 이용한다.</li>
  <li>HTTP 프로토콜 서비스를 지원하는 <code>javax.Servlet.http.HttpServlet</code> 클래스를 상속받는다.</li>
  <li>UDP보다 처리 속도가 느리다.</li>
  <li>HTML 변경 시 Servlet을 재 컴파일해야한다.</li>
</ul>

<h3 id="servlet의-장점">Servlet의 장점</h3>
<ul>
  <li>threed를 이용하여 요청을 처리하므로 빠르다.</li>
  <li>플랫폼에 독립적이다. (JAVA의 JVM)</li>
  <li>보안(Servlet Container)</li>
</ul>

<h3 id="servlet동작-과정">Servlet동작 과정</h3>
<p><img width="650px" src="/assets/images/posts/back-end/servlet-process.png" /></p>

<h4 id="1-사용자의-요청">1. 사용자의 요청</h4>
<p>: 사용자가 웹서버에 요청을 전달한다.<br />
   → 만약 Servlet에 대한 요청인 경우 WAS에 요청을 전달한다.</p>

<h4 id="2-web-container에서-request-response객체-생성">2. Web Container에서 request, response객체 생성</h4>
<p>: Web Container는 사용자의 요청에 대한 <code>HttpServletRequest</code> 객체와, <code>HttpServletResponse</code> 객체를 생성한다.</p>

<h4 id="3-사용자-요청처리">3. 사용자 요청처리</h4>
<ol>
  <li>
    <p>Web Container에서 배포서술자(web.xml)를 참조하여 사용자가 요청한 URL이 어떤 Servlet에 mapping되는지 찾는다.</p>
  </li>
  <li>사용자가 요청한 Servlet이 이전에 요청된적 없다면 객체를 생성한후 <code>init()</code> 호출후 메모리에 로드한다.<br />
<strong>if</strong> 이전에 객체를 생성한 적이 있으면 다시 생성하지 않는다.</li>
  <li>Web Container에서 사용자의 요청을 처리할 Threed를 처리한다.</li>
  <li>Threed가 생성된 후 해당 Threed를 통해 Servlet의 <code>service()</code>를 실행한다.</li>
  <li><code>service()</code> 에서 사용자의 요청 HTTP method에 따라 <code>doGet()</code>, <code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>가 호출된다.<br />
→ 앞에서 생성한 <code>HttpServletRequest</code>, <code>HttpServletResponse</code> 객체를 Tomcat에 의해 인수로 전달받는다.</li>
</ol>

<h4 id="4-응답">4. 응답</h4>
<p>: <code>doGet()</code> 또는 <code>doPost()</code> 등. 을 호출되어 사용자 요청에 따른 페이지를 생성한 뒤<br />
그것이 담긴 <code>HttpServletResponse</code>객체를 Web Container에서 HTTP Response로 바꾸어 Web Server에 전송한다.</p>

<h4 id="5-소멸">5. 소멸</h4>
<ol>
  <li><code>HttpServletRequest</code>, <code>HttpServletResponse</code> 객체를 소멸시킨다.</li>
  <li>Threed를 종료시킨다.</li>
</ol>

<h3 id="httpservletrequest">HttpServletRequest</h3>
<blockquote>
  <p>사용자가 요청시 HttpServletResponse와 함께 웹컨테이너에서 자동으로 생성해준다</p>
  <ul>
    <li>사용자의 요청과 관련된 정보(파라미터)와 동작을 가지고 있는 객체</li>
    <li>Servlet의 <code>service()</code> 인자로 넘겨준다.</li>
  </ul>
</blockquote>

<h4 id="주요-기능">주요 기능</h4>
<ul>
  <li>요청 파라미터 조회</li>
  <li>사용자가 전달한 session 정보가 담겨있는 session 객체 조회</li>
  <li>Request scope(범위) 안에 존제하는 component간 공유 데이터 조회</li>
</ul>

<h3 id="httpservletresponse">HttpServletResponse</h3>
<blockquote>
  <p>사용자가 요청시 HttpServletRequest와 함께 웹컨테이너에서 자동으로 생성해준다</p>
  <ul>
    <li>동일 정보와 동작을 가지고있는 객체</li>
    <li>Servlet의 <code>service()</code> 인자로 넘겨준다.</li>
  </ul>
</blockquote>

<h4 id="주요-기능-1">주요 기능</h4>
<ul>
  <li>다른 페이지로 Redircet</li>
  <li>Response Header정보 설정</li>
  <li>쿠키저장</li>
</ul>

<h3 id="life-cycle">Life cycle</h3>
<ol>
  <li>Servlet 객체 생성은 최초 1회 이루어진다.</li>
  <li><code>init()</code> (Servlet 초기화) 또한 최초 1회만 이루어진다.</li>
  <li><code>service()</code> 는 특정 HTTP 요청(GET, POST 등)을 처리하는 메서드 (<code>doGet()</code>, <code>doPost()</code> 등)를 호출한다.</li>
  <li>서버는 <code>destroy()</code>를 호출하여 Servlet을 제거한다.<br />
→ 자원을 해제할때, Servlet이 수정되어 대시 메모리에 로딩해야 하는 경우, 서버가 종료될때</li>
</ol>

<h2 id="servlet-container">Servlet Container</h2>
<p>: 구현되어 있는 Servlet클레스를 규약에 맞게 <strong>Servlet을 관리</strong>해주는것</p>

<p>서버에 만들어진 Servlet이 스스로 작동하는 것이 아니라, Servlet을 관리 해주는 것이 필요한데, 이러한 역할을 하는 것이 바로 Servlet Container 이다.</p>

<p>즉 Servlet을 ‘요구사항 명세서’라고 표현하면, Servlet container는 그 명세서를 보고 개발하는 ‘개발자’ 이다.</p>

<p>클라이언트의 요청(Request)을 받아주고 응답(Response)할 수 있게, 웹서버와 소켓으로 통신한다.</p>

<p>대표적으로 tomcat이 있다.</p>

<p><img width="600px" src="/assets/images/posts/back-end/servlet-container.png" /></p>

<ol>
  <li>일반적으로 사용자는 서버에서 오직 정적인 웹페이지만을 요청할 수 있다.</li>
  <li>만약 사용자가 본인의 입력을 기초로한 웹페이지를 자유롭게 얻고 싶다면 이 방법은 제한적이다.</li>
  <li>Servlet Container는 server side에서 동적으로 웹페이지를 생성하기 위해 Java를 사용한다.</li>
  <li>때문에 웹서버와 서블릿들이 상호작용할 때 서블릿 컨테이너는 필수적이다.</li>
</ol>

<h3 id="servlet-container의-역활">Servlet Container의 역활</h3>
<h4 id="1-웹서버와의-통신-지원">1. 웹서버와의 통신 지원</h4>
<p>Servlet과 Web서버가 쉽게 통신할 수 있게 한다.</p>
<ul>
  <li>일반적으로 소켓을 만들고 listen, accept 등을 해야하지만 Servlet Container는 이러한 기능을 API로 제공한다.</li>
  <li>개발자가 Servlet에 구현해야할 비즈니스 로직에 대해 집중할 수 있도록 도와준다.</li>
</ul>

<h4 id="2-서블릿-생명주기life-cycle-관리">2. 서블릿 생명주기(Life Cycle) 관리</h4>
<p>서블릿의 생명주기를 관리한다.</p>
<ol>
  <li>Servlet 클래스를 로딩하여 인스턴스화</li>
  <li>초기화 메소드를 호출</li>
  <li>요청이 들어오면 적절한 서블릿 메소드를 호출</li>
  <li>Servlet 소멸 시 Garbage Collection 진행</li>
</ol>

<h4 id="3-멀티쓰레드-지원-및-관리">3. 멀티쓰레드 지원 및 관리</h4>
<p>다중 쓰레드를 생성 및 운영을 관리한다.</p>
<ol>
  <li>Servlet Container는 요청이 올 때 마다 새로운 Java threed 하나 생성</li>
  <li>HTTP 서비스 메소드를 실행하고 나면, threed는 자동으로 소멸</li>
  <li>원래는 threed를 관리해야 하지만 서버가 multi threed를 생성 및 운영해준다<br />
→ 안정성에 대해 걱정하지 않아도 된다.</li>
</ol>

<h4 id="4-선언적인-보안-관리">4. 선언적인 보안 관리</h4>
<ul>
  <li>개발자는 보안에 관련된 내용을 Servlet 또는 Java 클래스에 구현해 놓지 않아도된다.</li>
  <li>보안관리는 XML 배포 서술자에 기록하므로 자바 소스코드를 수정하여 다시 컴파일 하지 않아도 보안관리가 가능하다.</li>
</ul>

<h3 id="웹-서버와-servlet-container의-요청을-처리">웹 서버와 Servlet Container의 요청을 처리</h3>
<p><img width="500px" src="/assets/images/posts/back-end/web-server-servlet-container.png" /></p>

<ol>
  <li>웹서버가 HTTP 요청을 받는다</li>
  <li>웹서버는 요청을 Servlet Container로 전달한다.</li>
  <li>Servlet이 Container에 없다면, Servlet을 동적으로 검색하여 컨테이너의 주소 공간에 로드한다.</li>
  <li>컨테이너가 서블릿의 <code>init()</code> 메소드를 호출하면, 서블릿이 초기화된다.<br />
(서블릿이 처음 로드됬을 때 한번만 호출)</li>
  <li>컨테이너가 서블릿의 <code>service()</code> 메소드를 호출하여 HTTP 요청을 처리한다.<br />
(요청의 데이터를 읽고, 응답을 만들어낸다)</li>
  <li>웹서버는 동적으로 생성된 결과를 올바른 위치에 반환한다.</li>
</ol>

<h3 id="이-과정에서-jvm의-역활">이 과정에서 JVM의 역활</h3>
<ul>
  <li>각 요청들을 “분리된 threed” 내부에서 처리한다.<br />
 Servlet을 사용하는것은 JVM이 각 요청을 분리된 자바 threed 내부에서 처리하도록 하는것이다.</li>
  <li>각 서블릿은 HTTP 요청에 응답하는 특정한 요소들이 있는 자바 클래스이다.</li>
  <li>서블릿 컨테이너는 하나의 JVM에서 동작하지만 컨테이너가 여러개의 JVM들을 필요로하는 문제들이 존재하기도 한다.</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/sequelize/" class="nav-link">sequelize</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/cs/2022/03/19/software-development-life-cycle/" class="nav-link">Software Development Life Cycle</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
