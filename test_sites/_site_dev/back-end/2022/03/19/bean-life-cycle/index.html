<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bean Life Cycle</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Bean Life Cycle</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring","TIL"]'
          date="March 19, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="bean-life-cycle">Bean Life Cycle</h1>
<h3 id="bean-life-cycle에-대해-왜-알아야-할까">Bean Life Cycle에 대해 왜 알아야 할까?</h3>
<p><strong>IoC의 이점을 얻으려면 컨테이너로 가는 애플리케이션의 흐름에 대한 부분적인 제어를 포기해야 한다.</strong> == 인스턴스화</p>
<blockquote>
  <p>시작시 로직 설정 등에 특별한 주의가 필요하다.</p>
</blockquote>

<p>Bean의 생성자에 로직을 포함 시키거나 객체의 인스턴스화 후에 메서드를 호출할 수 없다. 왜냐하면 우리는 그 과정에 통제권을 가지고 있지 않기 때문이다.</p>

<h4 id="예시-시작시-로직-실행">예시) 시작시 로직 실행</h4>
<pre><code class="language-java">@Component
public class InvalidInitExampleBean {

    @Autowired
    private Environment env;

    public InvalidInitExampleBean() {
        env.getActiveProfiles();
    }
}
</code></pre>
<ol>
  <li>생성자에서 autowired필드에 접근하려한다.</li>
  <li>생성자가 호출 될 때 Spring Bean은 완전히 초기화 되지 않았다
    <blockquote>
      <p><code>@Autowired</code>는 필드주입을 하므로 생성자에서 호출하면 당연히 DI가 되지 않았다.</p>
    </blockquote>
  </li>
  <li><code>NullPointerException</code>가 발생한다.</li>
</ol>

<p><strong>Spring은 이러한 상황을 관리하는 몇 가지 방법을 제공한다.</strong></p>

<p>이러한 상황들이 발생할 수 있으므로 우리는 Bean에 대한 생명주기를 알아야 할 필요가 있다.</p>

<h2 id="spring-bean-lifecycle">Spring Bean LifeCycle</h2>
<p><img width="600" src="/assets/images/posts/back-end/bean-lifecycle.png" /></p>

<p>기본적인 Spring Bean LifeCycle은 다음과 같다.</p>
<blockquote>
  <p>Spring 컨테이너 생성 → Spring Bean 생성/객체 생성 → 의존관계 주입 → <strong>초기화 콜백</strong><br />
→ Bean 사용 → <strong>소멸 전 콜백</strong> → 스프링 종료</p>
  <ul>
    <li><strong>단, <em>생성자 주입</em> 은 객체가 생성되는 동시에 주입된다.</strong></li>
    <li><strong>초기화 콜백</strong>을 통해 DI가 완료된 상태임을 확인할 수 있다.
이 때 초기화 작업을 진행해야 함을 알 수 있다.</li>
    <li><strong>소멸 콜백</strong>을 통해 Spring이 종료되기 전인 상태를 개발자가 확인할 수 있다.
이 때 종료작업을 안전하게 진행할 수 있다.</li>
  </ul>
</blockquote>

<h3 id="bean-생명주기-콜백-종류-3가지">Bean 생명주기 콜백 종류 3가지</h3>
<ol>
  <li>Spring에서 제공하는 인터페이스 (<code>InitializingBean</code>, <code>DisposableBean</code>)</li>
  <li>설정 정보에서 초기화 메서드, 종료 메서드 지정하는 방법</li>
  <li><code>@PostConstruct</code>, <code>@PreDestory</code> 어노테이션</li>
</ol>

<h4 id="1--spring에서-제공하는-인터페이스">1.  Spring에서 제공하는 인터페이스</h4>
<pre><code class="language-java">@Component
public class ExBean implements InitializingBean, DisposableBean{

    ...

    @Override
    public void afterPropertiesSet throws Exception{
        // 초기화
    }

    @Override
    public void destroy throws Exception{
        // 메모리 반납, 연결 종료와 같은 과정
    }
}
</code></pre>
<p>이 방식의 단점은 다음과 같다.</p>
<ul>
  <li>Spring 전용 인터페이스에 코드가 의존한다.</li>
  <li>메서드를 오버라이드하기 떄문에 메서드명을 변경할 수 없다.</li>
  <li>코드를 커스터마이징할 수 없는 외부 라이브러리에 적용할 수 없다.</li>
</ul>

<h4 id="2-설정-정보에서-초기화-메서드-종료-메서드-지정하는-방법">2. 설정 정보에서 초기화 메서드, 종료 메서드 지정하는 방법</h4>
<pre><code class="language-java">public class ExBean{

    ...

    public void initialize() throws Exception {
        /// 초기화
    }

    public void close() throws Exception {
        // 메모리 반납, 연결 종료와 같은 과정
    }
}

@Configuration
public class LifeCycleConfig{

    @Bean(initMethod = "initialize", destroyMethod = "close")
    public ExBean exBean(){
        ...
    }
}
</code></pre>
<p>이 방식의 장점</p>
<ul>
  <li>메서드 이름을 자유롭게 부여 가능하다.</li>
  <li>Spring 코드에 의존하지 않음</li>
  <li>코드를 커스터마이징 할 수 없는 외부 라이브러리에 적용 가능하다.
    <blockquote>
      <p>설정 정보를 사용하기 때문에 가능하다.</p>
    </blockquote>
  </li>
</ul>

<p>이 방식에 단점</p>
<ul>
  <li>Bean 지정 시 initMethod와 destoryMethod를 직접 지정해야 하는 번거로움이 았다.</li>
</ul>

<p><code>@Bean</code>의 destoryMethod 속성의 특징</p>
<ul>
  <li>라이브러리의 대부분 종료 메서드명이 close 혹은 shutdown</li>
  <li>@Bean의 destoryMethod는 기본값이 inferred (추론)으로 등록한다.
    <blockquote>
      <p>즉, 종료 메서드를 추론하고 자동으로 호출한다.</p>
    </blockquote>
  </li>
  <li><code>inferred</code>기능을 사용하기 싫다면 명시적으로 <code>destoroyMethod=""</code> 와 같이 공백을 지정해줘야 한다.</li>
</ul>

<h4 id="3-postconstruct-predestroy-어노테이션">3. @PostConstruct, @PreDestroy 어노테이션</h4>
<pre><code class="language-java">public class ExBean{
    
    @PostConstruct
    public void initialize() throws Exception {
        // 초기화
    }

    @PreDestory
    public void close() throws Exception {
        // 메모리 반납, 연결 종료와 같은 과정
    }
}

@Configuration
public class LifeCycleConfig{
    
    @Bean
    public ExBean exampleBean(){
        // 생략
    }
}
</code></pre>
<p><strong>JSR-250</strong>에 정의되어 있어 Spring 이외에 다른 프레임워크가 지원할 수 있다.</p>
<ul>
  <li><strong>최신 스프링에서 권장하는 방법</strong>
    <blockquote>
      <p>Java11에서 제거 되어서 사용할 수 없다는 말이 있는데 <code>javax</code>가 아닌 <code>java.xml.ws.annotation</code>가 Deprecated가 된것이므로 상관 없다.</p>
    </blockquote>
  </li>
  <li>컨포넌트 스캔과 잘 어울린다.</li>
</ul>

<p>이 방식의 단점</p>
<ul>
  <li>커스터마이징이 불가능한 외부 라이브러리에서 사용 할 수 없다.</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/cs/2022/03/19/b-tree/" class="nav-link">B-Tree</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/bean/" class="nav-link">Bean</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
