<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Querydsl</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Querydsl</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring","querydsl","TIL"]'
          date="March 19, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="querydsl">Querydsl</h1>
<p>: Querydsl 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있도록 해 주는 프레임워크이다</p>
<ul>
  <li>Querydsl은 타입에 안전한 방식으로 HQL 쿼리를 실행하기 위한 목적으로 만들어졌다.</li>
  <li>Querydsl은 Java code로 query를 만들 수 있다.</li>
</ul>

<h3 id="왜-사용할까">왜 사용할까?</h3>
<ul>
  <li>Spring Boot와 스프링 데이터JPA는 복잡한 쿼리와 동적 쿼리를 하기 힘들다.</li>
  <li>하지만 네이티브 query를 사용하기에는 문자열를 사용해야 되고 문제를 Runtime에 확인할 수 밖에 없다.</li>
</ul>

<h4 id="사용-예시">사용 예시</h4>
<p>불편한 순간이라는 익명 게시판을 모두 select해서 DTO로 반환하는 매서드 이다. (<code>UncomportableDomain</code> → <code>UncomfortableResponseDto</code>)</p>
<pre><code class="language-java">    @Query("SELECT new com.moment.the.uncomfortable.dto.UncomfortableResponseDto(table.uncomfortableIdx, table.content, table.goods, answer)" +
            "FROM UncomfortableDomain table LEFT JOIN table.answerDomain answer " +
            "ORDER BY table.uncomfortableIdx DESC "
    )
    List&lt;UncomfortableResponseDto&gt; uncomfortableViewAll();
</code></pre>
<p>여기에서는 <code>@Query</code>를 통해 JPQL를 직접 문자열로 작성했다. 그래서 다음 문제점들을 가지고 있다.</p>
<ul>
  <li>Compile시점에 해당 Query문에 있는 에러를 찾기 힘들다.</li>
  <li>만약 native query를 사용했다면 runtime일일히 오류를 찾아야 한다.</li>
</ul>

<p>위 매서드를 Querydsl로 바꾸면 다음과 같다.</p>
<pre><code class="language-java">public List&lt;UncomfortableResponseDto&gt; uncomfortableViewAll() {
    return queryFactory
            .from(uncomfortableDomain)
            .select(Projections.constructor(UncomfortableResponseDto.class, // 생성자를 통해 DTO로 select한다.
                uncomfortableDomain.uncomfortableIdx,
                uncomfortableDomain.content,
                uncomfortableDomain.goods
            )
    ).fetch();
}
</code></pre>
<ul>
  <li>Java code로 만들어 IDE의 도움과 컴파일 시점에 오류를 해결할 수 있다.</li>
  <li>반북되는 부분은 따로 메서드를 이용해 재사용이 가능하다!<br />
<strong>재사용 예시</strong>
    <pre><code class="language-java">    JPAQuery&lt;UncomfortableResponseDto&gt; convertToDto(){
      return queryFactory
              .from(uncomfortableDomain)
              .select(Projections.constructor(UncomfortableResponseDto.class, // 생성자를 통해 DTO로 select한다.
                      uncomfortableDomain.uncomfortableIdx,
                      uncomfortableDomain.content,
                      uncomfortableDomain.goods
              ));
  }

  public List&lt;UncomfortableResponseDto&gt; uncomfortableViewAll() {
      return convertToDto.fetch();
  }

</code></pre>
  </li>
</ul>

<h2 id="querydsl-적용방법---springboot-with-gradle">Querydsl 적용방법 - SpringBoot with gradle</h2>
<h3 id="buildgradle">build.gradle</h3>
<p>plugins 부분</p>
<pre><code class="language-groovy">plugins {

    ...
    id 'io.spring.dependency-management' version '1.0.11.RELEASE' // Spring프로젝트의 의존성을 관리한다.

    id "com.ewerk.gradle.plugins.querydsl" version "1.0.10" // querydsl plugin
    id "io.franzbecker.gradle-lombok" version "3.0.0" // Q-Type error 발생 시 추가
}
</code></pre>
<ul>
  <li>Querydsl를 사용하기 위해<code>com.ewerk.gradle.plugins.querydsl</code> plugin를 추가한다.</li>
  <li>만약 Q-Type error 발생 시 <code>io.franzbecker.gradle-lombok</code> plugin를 추가한다.</li>
</ul>

<p>dependencies 부분</p>
<pre><code class="language-groovy">dependencies {
    ...

    implementation 'com.querydsl:querydsl-jpa' // 추가

    ...
}
</code></pre>
<ul>
  <li>Querydsl를 사용하기 위해<code>com.querydsl:querydsl-jpa</code>의존성을 추가한다.</li>
</ul>

<p>Querydsl관련 task작성</p>
<pre><code class="language-groovy">def querydslDir = "$buildDir/generated/querydsl" as String // queryDSL이 생성하는 QClass 경로 설정
querydsl {
    jpa = true
    querydslSourcesDir = querydslDir
}
sourceSets {
    main.java.srcDir querydslDir
}
configurations {
    querydsl.extendsFrom compileClasspath
}
compileQuerydsl {
    options.annotationProcessorPath = configurations.querydsl
}
</code></pre>
<h3 id="q-class-생성하기">Q-class 생성하기</h3>
<p>Q-class란 APT를 이용해 Entity의 정보를 가지고 생성되는 class이다.</p>

<blockquote>
  <p>APT - Annotation Processing Tool<br />
Annotation 이 있는 기존코드를 바탕으로 새로운 코드와 새로운 파일들을 만들 수 있고, 이들을 이용한 클래스에서 compile 하는 기능도 지원해준다.</p>
</blockquote>

<h4 id="1-entity-생성">1. Entity 생성</h4>
<blockquote>
  <p>Q-class를 생성하기 전 그에 필요한 Entity가 있어야 된다.</p>
</blockquote>

<p>예시 Entity</p>
<pre><code class="language-java">@Entity
@Getter @Setter
public class Hello {
    @Id @GeneratedValue
    private Long id;
}
</code></pre>

<h4 id="2-q-class-생성">2. Q-class 생성</h4>
<p><strong>1. Gradle 콘솔 사용방법</strong></p>
<pre><code class="language-sh"># linux, macOS
./gradlew clean compileQuerydsl

# windows
./gradlew.bat clean compileQuerydsl
</code></pre>

<p><strong>2. Gradle IntelliJ 사용법</strong></p>
<ol>
  <li>Gradle → Tasks → build → clean<br />
<img width="400" src="/assets/images/posts/back-end/gradle-clean.png" /></li>
  <li>Gradle → Tasks → other → compileQuerydsl<br />
<img width="400" src="/assets/images/posts/back-end/create-qclass.png" /></li>
</ol>

<p>예시) Q-class는 위 코드 예시의 Entity를 기반으로 만들었다.<br />
<img src="/assets/images/posts/back-end/q-class-generate-ex.png" /></p>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/proxy/" class="nav-link">Proxy</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/querydsl/" class="nav-link">QueryDSL</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
