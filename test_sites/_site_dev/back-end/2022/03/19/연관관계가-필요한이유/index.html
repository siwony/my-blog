<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>연관관계가 필요한이유</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">연관관계가 필요한이유</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring","jpa","TIL"]'
          date="March 19, 2022"
          reading-time="4"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="연관관계가-필요한이유">연관관계가 필요한이유</h1>
<h3 id="객체를-테이블에-맞추어-모델링">객체를 테이블에 맞추어 모델링</h3>
<p><strong>연관관계가 없는 객체</strong></p>

<p>&lt;img width=450px src=./img/non-object-relationship.png&gt;</p>

<h3 id="객체를-테이블에-맞춰-모델링">객체를 테이블에 맞춰 모델링</h3>
<p><strong>참조 대신 외래 키를 그대로 사용</strong></p>
<pre><code class="language-java">@Entity
public class member{

    @Id @GeneraterValue
    private Long id;

    @Column(name = "USERNAME") 
    private String name;

    @Column(name = "TEAM_ID")
    private Long teamId;

}
@Entity
public class Team{
    @Id @GeneratedValue 
    private Long id; 
    private String name;
    //etc.....
}
</code></pre>

<h4 id="외래키-식별자를-그대로-다룬다">외래키 식별자를 그대로 다룬다.</h4>
<pre><code class="language-java">//팀 저장
Team team = new Team();
team.setName("TeamA"); em.persist(team);

//회원 저장
Member member = new Member();
member.setName("member1");
member.setTeamId(team.getId()); 
em.persist(member);
</code></pre>

<h4 id="식별자로-다시-조회하므로-객체지향적인-방법이-아니다">식별자로 다시 조회하므로 객체지향적인 방법이 아니다.</h4>
<pre><code class="language-java">//조회
Member findMember = em.find(Member.class, member.getId());
//연관관계가 없음
Team findTeam = em.find(Team.class, team.getId());
</code></pre>
<h3 id="연관관계가-필요한-이유">연관관계가 필요한 이유</h3>
<ul>
  <li>
    <p>테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다.</p>
  </li>
  <li>객체는 참조를 사용하여 연관된 객체를 찾는다.</li>
  <li>서로 데이터를 저장하는 방식이 다르다.<br />
→ 즉, 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.</li>
</ul>

<h2 id="단방향-연관관계">단방향 연관관계</h2>
<h3 id="객체-지향-모델링">객체 지향 모델링</h3>
<h4 id="orm-mapping">ORM Mapping</h4>
<p>&lt;img width=450px src=./img/object-oriented-modling.png&gt;</p>

<h4 id="객체의-참조와-테이블의-외래-키를-매핑">객체의 참조와 테이블의 외래 키를 매핑</h4>
<pre><code class="language-java">@Entity
public class Member {
    @Id @GeneratedValue
    private Long id; 

    @Column(name = "USERNAME") 
    private String name; 

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team; 
    // etc...
</code></pre>

<h4 id="연관관계-저장-연관관계-저장">연관관계 저장 연관관계 저장</h4>
<pre><code class="language-java">//팀 저장
Team team = new Team();
team.setName("TeamA"); 
em.persist(team);

//회원 저장
Member member = new Member(); 
member.setName("member1");
member.setTeam(team); //단방향 연관관계 설정, 참조 저장 em.persist(member);
</code></pre>

<h4 id="객체-그래프-탐색">객체 그래프 탐색</h4>
<blockquote>
  <p>참조로 연관관계 조회한다.</p>
  <pre><code class="language-java">//조회
Member findMember = em.find(Member.class, member.getId());
//참조를 사용해서 연관관계 조회
Team findTeam = findMember.getTeam();
</code></pre>
  <h4 id="연관관계-수정">연관관계 수정</h4>
  <p>```java</p>
</blockquote>

<p>// 새로운 팀B
Team teamB = new Team(); 
teamB.setName(“TeamB”); 
em.persist(teamB);</p>

<p>// 회원1에 새로운 팀B 설정 member.setTeam(teamB);
member.setTeam(teamB);</p>
<pre><code>## 양방향 연관관계
&lt;img width=450px src=./img/bidirectional-mapping.png&gt;

- 테이블은 외래키만 있으면 서로 관계를 알 수 있다 &amp;rarr; 애초에 양방향이라는 개념이 없다.
- 객체는 각각 참조하는 객체를 세팅해줘야 한다.
### 1. 객체 지향 모델링
#### Team 엔티티에 컬렉션 추가
```java
@Entity
public class Team{
    @Id @GeneratedValue
    private Long id;
    private String name;

    //반대편(MEMBER)에team 변수로 매핑된다. (연관관계의 주인은 반대편(MEMBER.team이다.))
    @OneToMany(mappedBy = "team")
    List&lt;Member&gt; mebmers = new ArrayList&lt;Member&gt;();
}
</code></pre>
<p>#### 반대 방향으로 객체 그래프 탐색</p>
<pre><code class="language-java">//조회
Team findTeam = em.find(Team.class, team.getId());
//역방향 조회
int memberSize = findTeam.getMembers().size();
</code></pre>

<h3 id="2-객체와-테이블이-관계를-맺는-차이">2. 객체와 테이블이 관계를 맺는 차이</h3>
<p>&lt;img width=450 src=./img/difference-of-obejct-and-table.png&gt;</p>

<ul>
  <li><strong>객체는 연관관계가 2개이다.</strong>
    <ul>
      <li>회원 → 팀 연관관계 1개(단방향)</li>
      <li>팀 → 회원 연관관계 1개(단방향)</li>
    </ul>
  </li>
  <li><strong>테이블은 연관관계가 1개이다.</strong>
    <ul>
      <li>회원 ↔ 팀의 연관 관계 1개(양방향)
        <blockquote>
          <p>애초에 Table은 양방향이라는 개념이 존재하지 않는다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-객체의-양방향-관계">3. 객체의 양방향 관계</h3>
<ul>
  <li><strong>객체의 양방향 관계는 사실 서로 다른 방향 관계 2개이다.</strong></li>
  <li>
    <p>객체를 양방향으로 참조하려면 단방향 2개를 만들어야 한다.</p>

    <p><strong>예시</strong></p>
    <ul>
      <li><code>A</code> → <code>B</code> (<code>a.getB()</code>)</li>
      <li><code>B</code> → <code>A</code> (<code>b.getA()</code>)
        <pre><code class="language-java">  class A{
  B b;
  }
  class b{
  A a;
  }
</code></pre>
        <h3 id="4-테이블의-양방향-관계">4. 테이블의 양방향 관계</h3>
      </li>
    </ul>
  </li>
  <li>외래키 하나로 두 테이블의 연관관계 관리</li>
  <li><code>MEMBER.TEAM_ID</code> 기본키 하나로 연관관계를 맻는다 → 양쪽으로 조인할 수 있다.</li>
</ul>

<pre><code class="language-sql">SELECT *
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

SELECT *
FROM TEAM T
JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
</code></pre>

<h3 id="5-연관관계의-주인owner">5. 연관관계의 주인(Owner)</h3>
<blockquote>
  <p>양방향 매핑은 둘 중 하나로 외래키를 관리해야 한다.</p>
</blockquote>

<p><strong>1. 양방향 매핑 규칙</strong></p>
<ul>
  <li>객체의 두 관계 중 하나를 연관관계의 주인으로 지정</li>
  <li><strong>연관관계의 주인만이 외래 키를 관리(등록, 수정)</strong></li>
  <li><strong>주인이 아닌쪽은 읽기만 가능하다.</strong> → 조회만 가능하다.</li>
  <li>주인은 <code>MappedBy</code> 속성 사용 x</li>
</ul>

<dl>
  <dt><strong>2. 주인을 누구로?</strong></dt>
  <dd><strong>외래키가 있는 곳을 주인으로 정한다.</strong>
    <ul>
      <li>여기서는 <code>Member.team</code>이 연관관계의 주인이다.</li>
      <li>주로 N(다) 쪽이 연관관계의 주인이 된다.</li>
      <li>비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안 된다.</li>
    </ul>
  </dd>
</dl>

<p>&lt;img width=450px src=./img/who-is-owner.png&gt;</p>

<h3 id="6-양방향-연관관계에서-많이-하는-실수">6. 양방향 연관관계에서 많이 하는 실수</h3>
<h4 id="연관관계의-주인에-값을-입력하지-않았다--역방향">연관관계의 주인에 값을 입력하지 않았다 → 역방향</h4>
<pre><code class="language-java">Team team = new Team(); 
team.setName("TeamA"); 
em.persist(team);

Member member = new Member();
member.setName("member1")

//역방향(주인이 아닌 방향)만 연관관계 설정 
team.getMembers().add(member);

em.persist(member);
</code></pre>
<p>|ID|USERNAME|TEAM_ID|
|–|——–|——-|
|1| member1 | <strong>null</strong>|</p>

<h4 id="양방향-매핑시-연관관계의-주인의-값을-입력해야-한다">양방향 매핑시 연관관계의 주인의 값을 입력해야 한다.</h4>
<p>→ 순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야 한다.</p>
<ul>
  <li>
    <p>그렇지 않으면 객체지향 스럽지 않다.</p>
  </li>
  <li>
    <p>양쪽에 값이 세팅되어있지 않으면 한 객체에는 값이 존재하지만,<br />
 반대쪽 객체에는 값이 없는 대참사가 일어난다.<br />
  → 나중에 테스트할 때 Empty 나 null 등 이상하게 값을 가져온다.
```java
Team team = new Team(); 
team.setName(“TeamA”); 
em.persist(team);</p>
  </li>
</ul>

<p>Member member = new Member();
member.setName(“member1”);</p>

<p>team.getMembers().add(member); //연관관계의 주인에 값 설정
member.setTeam(team); 
em.persist(member);
```
|ID|USERNAME|TEAM_ID|
|–|——–|——-|
|1| member1 | 2|</p>

<h3 id="7-양방향-연관관계의-주의점">7. 양방향 연관관계의 주의점</h3>
<ul>
  <li><strong>순수 객체 상태를 고려해서 항상 양쪽에 값을 세팅하자.</strong></li>
  <li>연관관계 편의 매서드를 생성하자.(추천)
    <pre><code class="language-java">      public class Member{
          //etc,,,

          public void setTeam(Team team){
              this.team = team;
              test.getMembers().add(this);
          }

          //etc,,,
      }
</code></pre>
    <ul>
      <li><code>setTeam</code> 같은 네이밍보다 <code>changeTeam같은</code> 네이밍을 권장한다.<br />
  → 뭔가 중요한 로직이구나 라는 것을 알아차리기 위해</li>
      <li>한 개만생성하자 → 두객체중 아무곳이나 만들어도 된다.</li>
    </ul>
  </li>
  <li>무한루프를 조심하자.<br />
  ex) <code>toString()</code>, <code>lombok</code>, <code>JSON</code> 생성라이브러리
    <ul>
      <li><code>lombok</code>에서 <code>toString()</code> 생성 쓰지마라</li>
      <li><code>Controller</code>에 절대로 <code>Entity</code>를 반환하지 마라 → <code>DTO</code>로 변환하여 반환한다.</li>
    </ul>
  </li>
</ul>

<h3 id="양방향-연관관계-정리">양방향 연관관계 정리</h3>
<ul>
  <li>
    <p><strong>단방향 매핑만으로 이미 연관관계 매핑은 완료됐다.</strong><br />
  → 기본적으로 단방향 매핑으로 다 끝내자</p>
  </li>
  <li>양방향 매핑은 객체 그래프 탐색 기능이 추가된 것뿐이다.</li>
  <li>JPQL에서 역방향으로 탐색할 일이 많다</li>
  <li>단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 된다 → 테이블은 변화가 없다.</li>
  <li>양방향 연관관계는 그렇게 이득이 되는 것은 없다. → 걱정거리만 늘어난다.</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EC%8B%9C%EC%9E%91/" class="nav-link">연관관계 매핑 시작</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%82%B4%EB%B6%80-%EB%8F%99%EC%9E%91/" class="nav-link">영속성 컨텍스트 - 내부 동작</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
