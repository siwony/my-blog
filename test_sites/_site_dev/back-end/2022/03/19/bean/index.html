<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bean</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Bean</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["back-end"]'
          tags='["spring","TIL"]'
          date="March 19, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="bean">Bean</h1>
<p>: <code>Spring IOC(Inversion Of Control)</code>컨테이너가 관리하는 Java객체이며, Spring Bean Container에 존재하는 객체를 말한다.</p>
<ul>
  <li>Spring IoC(Inversion of Control) 컨테이너에 의해 <strong>인스턴스화</strong>, <strong>관리</strong>, <strong>생성</strong>된다.</li>
  <li>Bean Container는 의존성 주입을 통해 Bean 객체를 사용할 수 있도록 해준다.</li>
</ul>

<h2 id="bean-scope">Bean Scope</h2>
<p>빈이 존재할 수 있는 범위를 의미한다.</p>

<p>&lt;img width=600px src=./img/spring-bean-scope-table.png&gt;</p>

<h3 id="1-singleton">1. Singleton</h3>
<p>Singleton Bean은 Spring Container에서 한 번 생성되고 스프링 컨텍스트가 종료될 때 Distroy된다.</p>

<p>싱글톤은 JVM을 실행하여 클래스 로드를 할 떄 처음 객체가 생성되는 것이 아닌 Spring Container에서 싱글톤으로 관리한다. 즉, 프로그래밍적인 싱글톤이 아니다.</p>

<ul>
  <li>Spring에서 기본이 된다.</li>
  <li>생성된 하나의 인스턴스는 single beans cache에 저장되고, 해당 bean에 대한 요청과 참조가 있으면 캐시된 객체를 반환한다.</li>
  <li>XML 설정<br />
  <code>&lt;bean id="..." class="..." scope="singleton"&gt;&lt;/bean&gt;</code></li>
  <li>annotation 설정<br />
  대상 클래스에 <code>@Scope("singletone")</code>
&lt;img width=650px src=./img/spring-bean-singleton.png&gt;</li>
</ul>

<h3 id="2-prototype">2. Prototype</h3>
<ul>
  <li><code>prototype bean</code>은 모든 요청에서 새로운 객체를 생성하는 것</li>
  <li><strong>스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계주입, 초기화 까지만 처리한다.</strong>
    <blockquote>
      <p><code>@PreDestory</code>와 같은 종료 메서드를 호출하지 않는다. 자원 회수와 같은 처리는 프로토타입Bean을 요청한 클라이언트가 처리해야 한다.</p>
    </blockquote>
  </li>
  <li>XML 설정
    <pre><code class="language-XML">  &lt;bean id="..." class="..." scope="prototype"&gt;&lt;/bean&gt;
</code></pre>
  </li>
  <li>annotation<br />
  대상 클래스에 <code>@Scope("prototype")</code>
&lt;img width=650px src=./img/spring-bean-prototype.png&gt;</li>
</ul>

<h2 id="bean-등록-방법">Bean 등록 방법</h2>
<h3 id="1-xml-spring">1. XML (Spring)</h3>
<p>: <code>applicationContext.xml</code>이라는 파일을 <code>src/main/resources</code> 폴더에 추가시킨 후 bean을 등록한다.</p>
<blockquote>
  <p>Java 코드를 이용한 Context 설정이 나오기 전 사용하던 방법이다.</p>
  <ul>
    <li>class(필수): 정규화된 자바 클래스 이름</li>
    <li>id: bean의 고유 식별자</li>
    <li>scope: 객체의 범위 (sigleton, prototype)</li>
    <li>constructor-arg: 생성 시 생성자에 전달할 인수</li>
    <li>property: 생성 시 bean setter에 전달할 인수</li>
    <li>init method와 destroy method
```XML
<!-- A simple bean definition --></li>
  </ul>
</blockquote>
<bean id="..." class="..."></bean>

<!-- A bean definition with scope-->
<bean id="..." class="..." scope="singleton"></bean>

<!-- A bean definition with property -->
<bean id="..." class="...">
	<property name="message" value="Hello World!" />
</bean>

<!-- A bean definition with initialization method -->
<bean id="..." class="..." init-method="..."></bean>
<pre><code>### 2. Java Configuration 
: `@Configuration`이라는 Annotation을 이용하여 XML 대신 Java로 Bean을 생성할 수 있다.
```java
@Configuration
public class ApplicationConfig {
    @Bean
    public Car car(Engine e) {
    	Car c = new Car();
    	c.setEngine(e);
    	return c;
    }
	
    @Bean
    public Engine engine() {
    	return new Engine();
    }
}
</code></pre>
<ol>
  <li>위 코드처럼 class에 <code>@Configuration</code>을 달고</li>
  <li>Bean으로 사용할 객체를 반환하는 메소드를 만들고</li>
  <li><code>@Bean</code>이라는 어노테이션을 달면 반환된 객체가 Bean Container에 등록된다.</li>
</ol>

<pre><code class="language-java">public class ApplicationContextExam03 {
    public static void main(String[] args) {
	    // 클래스를 매개변수로 넣는다.
	    ApplicationContext ac = new AnnotationConfigApplicationContext(ApplicationConfig.class);
		
	    Car car = ac.getBean(Car.class);
	    car.run();
    }
}
</code></pre>
<h3 id="3-componentscan">3. @ComponentScan</h3>
<p>: Config 클래스에 <code>@Configuration</code>과 <code>@ComponentScan</code>을 같이 등록하면, 패키지 내의 <code>@Bean</code>, <code>@Component</code> , <code>@Controller</code>, <code>@Service</code>, <code>@Repository</code>로 등록된 클래스를 Classpath Scanning 타임에 Bean Container에 등록시켜 준다.</p>

<p><strong>등록방법</strong><br />
<code>@Configuration</code>을 이용하여 Bean 설정 파일(XML 파일을 대체하는)임을 알려주고, <code>@ComponentScan</code>을 이용해 빈으로 등록되기 위한 annotaction이 부여된 클래스들을 자동으로 IoC컨테이너에 등록한다.</p>

<p><code>ApplicationConfig</code></p>
<pre><code class="language-java">@Configuration
@ComponentScan
public class ApplicationConfig {}
</code></pre>
<p><code>Application</code></p>
<pre><code class="language-java">public class Application {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);
    }
}
</code></pre>
<p>Annotaion을 기반으로 Bean들을 등록하기 위해서는 <code>AnnotaionConfigApplicationContext</code>를 이용해야 한다.<br />
그리하여 <code>AnnotationConfigApplicationContext</code>의 매개변수로 Bean설정 클래스인 <code>ApplicationConfig</code>를 넘겨주었다.</p>

<p><strong>범위</strong></p>
<ul>
  <li><code>basePackages</code>의 경우 괄호안에 직접 패키지경로를 직접 적어주어 스캔할 위치를 지정할 수 있다
    <pre><code class="language-java">@Configuration
@ComponentScan(basePackages = "com.mins.spring")
public class ApplicationConfig {}
</code></pre>
    <p>이 경우 <strong>typesafe하지 않아</strong> 조금만 철자가 잘못되더라도 scan을 못하는 오류가 나타날 수 있다.</p>
  </li>
  <li><code>basePackageClasses</code> 의 경우에는 괄호안에 적힌 Class가 위치한 곳에서부터 모든 어노테이션이 부여된 Class를 bean으로 등록해준다.
    <pre><code class="language-java">@Configuration
@ComponentScan(basePackageClasses = Application.class)
public class ApplicationConfig {}
</code></pre>
    <p>class를 통해 기입하기 때문에 훨씬 <strong>Typesafe한 방법이다.</strong></p>
  </li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/bean-life-cycle/" class="nav-link">Bean Life Cycle</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/cs/2022/03/19/btree-b%ED%8A%B8%EB%A6%AC/" class="nav-link">B+Tree - B+트리</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
