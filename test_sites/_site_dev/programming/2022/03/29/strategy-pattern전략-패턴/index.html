<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Pattern(전략 패턴)</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Strategy Pattern(전략 패턴)</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["TIL","coding","development","Design-pattern","java"]'
          date="March 29, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="strategy-pattern전략-패턴">Strategy Pattern(전략 패턴)</h1>
<p>이전글: <a href="template-method-pattern.md">템플릿 메서드 패턴</a></p>

<h4 id="참고자료">참고자료</h4>
<ul>
  <li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8">김영한 인프런 핵심 원리 - 고급편</a></li>
  <li><a href="https://github.com/siwony/spring-core-principle-advanced/tree/main/src/test/java/com/siwony/ifl_spring_advanced/trace/strategy">예제 코드</a></li>
</ul>

<p align="center"><img width="450" src="/assets/images/posts/programming/strategy-pattern.png" /></p>

<p>전략 패턴은 <strong>변하지 않는 부분을 <code>Context</code></strong> 라는 곳에 두고, <strong>변하는 부분을 <code>Strategy</code></strong> 라는 인터페이스를 만들어 해당 인터페이스를 구현하도록 한다.</p>

<blockquote>
  <p>템플릿 메서드 패턴은 상속을 활용해 특정 부분만 변경하도록 한다. 전략패턴은 <strong>위임</strong>을 통해 특정 부분만 변경할 수 있다.</p>
</blockquote>

<p>GOF의 디자인 패턴에서는 전략 패턴의 의도는 다음과 같다.</p>
<blockquote>
  <p>알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자. <br />
전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다.</p>
</blockquote>

<h2 id="예제---비즈니스-로직의-수행-속도를-측정하여-로깅하기">예제 - 비즈니스 로직의 수행 속도를 측정하여 로깅하기</h2>
<blockquote>
  <p>실습환경: SpringBoot + lombok + junit5</p>
  <h3 id="v1---필드에-전략을-저장하는-방식">V1 - 필드에 전략을 저장하는 방식</h3>
  <p>객체의 생성과 동시에 Strategy 조립하기 - 선 조립, 후 실행
```java
@Slf4j
@AllArgsConstructor
public class ContextV1 {</p>
</blockquote>

<pre><code>private Strategy strategy;

public void execute(){
    long startTime = System.currentTimeMillis();
    // 비즈니스 로직 실행
    strategy.call();
    // 비즈니스 로직 종료
    long endTime = System.currentTimeMillis();
    long resultTime = endTime - startTime;
    log.info("resultTime={}", resultTime);
} }
</code></pre>

<p>public interface Strategy {
    void call();
}</p>
<pre><code>- `ContextV1`은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다.
  &gt; 이것을 `컨텍스트 - context`라고 한다.
- `Context`는 내부에 `Strategy strategy`필드를 가지고 있다. 이 필드에 변하는 부분인 `Strategy`의 구현체를 주입하면 된다.
- `execute()`에서 `strategy.call();`를 통해 비즈니스 로직 실행을 `Strategy`에 위임했다.

#### 전략패턴 사용
```java
@Test
void strategy(){
    ContextV1 context1 = new ContextV1(() -&gt; log.info("비즈니스 로직1 실행"));
    context1.execute();

    ContextV1 context2 = new ContextV1(() -&gt; log.info("비즈니스 로직2 실행"));
    context2.execute();
}
</code></pre>
<p>출력 예시</p>
<pre><code class="language-log">17:20:12.049 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV1Test - 비즈니스 로직1 실행
17:20:12.051 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV1 - resultTime=3
17:20:12.052 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV1Test - 비즈니스 로직2 실행
17:20:12.052 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV1 - resultTime=0
</code></pre>
<ul>
  <li>람다를 이용해 <code>ContextV1</code>에 <code>Strategy.call()</code>를 구현했다.</li>
  <li>상속을 사용하지 않고 <code>Strategy</code>인터페이스를 의존하므로 좀 더 유연한 구조로 변경되었다.</li>
</ul>

<h4 id="전략-패턴-실행">전략 패턴 실행</h4>
<p><img width="500" src="/assets/images/posts/programming/strategy-exec.png" /></p>

<h4 id="선-조립-후-실행방식">선 조립, 후 실행방식</h4>
<p>Context의 내부 필드에 Strategy 를 두고 사용하는 방식은</p>
<ul>
  <li><code>Context</code>와 <code>Strategy</code>를 한번 조립하고 나면 이후로는 <code>Context</code>를 실행하기만 하면 된다.</li>
  <li>Spring에서 애플리케이션 로딩 시점에 DI를 통해 필요한 의존관계를 모두 맺어두고 난 다음에 실제 요청을 처리하는 것과 같은 원리이다.</li>
  <li>이 방식의 단점은 <code>Context</code>와 <code>Strategy</code>를 조립한 이후에는 전략을 변경하기 번거롭다.
    <blockquote>
      <p><code>Getter/Setter</code>를 사용해도 되지만 동시성 문제가 있을 수 있다.</p>
    </blockquote>
  </li>
</ul>

<p>이처럼 전략을 변경하기 어려운 방식을 어떻게 해결할 수 있을까?</p>

<h3 id="v2---전략을-실행할-때-직접-파라미터로-전달하는-방식">V2 - 전략을 실행할 때 직접 파라미터로 전달하는 방식</h3>
<p>위의 방식에서 <code>Strategy</code>필드를 제거하고 파라미터로 <code>Strategy</code>를 넘겨주기만 하면된다.</p>
<pre><code class="language-java">@Slf4j
public class ContextV2 {

    public void execute(Strategy strategy){
        long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행
        strategy.call();
        // 비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime={}", resultTime);
    }
}
</code></pre>
<h4 id="테스트-코드">테스트 코드</h4>
<pre><code class="language-java">@Test
void strategy(){
    ContextV2 context1 = new ContextV2();
    context1.execute(() -&gt; log.info("비즈니스 로직1 실행"));

    ContextV2 context2 = new ContextV2();
    context2.execute(() -&gt; log.info("비즈니스 로직2 실행"));
}
</code></pre>
<p>출력 예시</p>
<pre><code class="language-java">17:54:42.737 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV2Test - 비즈니스 로직1 실행
17:54:42.740 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV2 - resultTime=5
17:54:42.742 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.ContextV2Test - 비즈니스 로직2 실행
17:54:42.742 [main] INFO com.siwony.ifl_spring_advanced.trace.strategy.code.ContextV2 - resultTime=0
</code></pre>
<ul>
  <li>Context를 실행할 때 마다 전략을 인수로 전달한다.
    <blockquote>
      <p>이는 장점이자 단점이다.</p>
    </blockquote>
  </li>
  <li>클라이언트는 <code>Context</code>를 실행하는 시점에 원하는 <code>Strategy</code>를 전달할 수 있다. 따라서 이전 방식과 비교해서 원하는 전략을 더욱 유연하게 변경할 수 있다.</li>
</ul>

<h4 id="전략-패턴-실행-1">전략 패턴 실행</h4>
<p><img width="500" src="/assets/images/posts/programming/strategy-exec-param.png" /></p>

<p>다음글: <a href="template-callback-pettern">템플릿 콜백 패턴</a></p>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/29/spring-data-jpa/" class="nav-link">Spring Data JPA</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/03/29/stream/" class="nav-link">Stream</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
