<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>함수형 interface</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">함수형 interface</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["TIL","grammar","coding","development","java","java8"]'
          date="March 29, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="함수형-interface">함수형 interface</h1>
<ul>
  <li><strong>추상 메서드가 1개만 있으면 모두 함수형 <code>interface</code>이다.</strong></li>
  <li>정적(<code>static</code>) 메서드, 디폴트(<code>default</code>) 메서드가 있을 수 있다.</li>
  <li>SAM(Single Abstract Method)</li>
  <li><code>@FunctionalInterface</code> : Java compiler는 이렇게 명시된 함수형 <code>interface</code>에 두 개 이상의 메소드가 선언되면 오류를 발생시킨다.</li>
</ul>

<h3 id="java에서의-함수형-프로그래밍">Java에서의 함수형 프로그래밍</h3>
<ul>
  <li>함수를 interface의 First class obejct로 사용할 수 있다.</li>
  <li>순수함수 (<code>Pure function</code>) : 상태가 없는 함수를 말한다. ex) 객체
    <ul>
      <li>사이드 이팩트를 만들 수 없다. → 함수 밖에 있는 값을 변경하지 못한다.</li>
    </ul>
  </li>
  <li>고차 함수 (<code>Higher-Order Function</code>) : 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수 있다.</li>
  <li>불변성</li>
</ul>

<h3 id="함수형-interface의-선언">함수형 interface의 선언</h3>
<h4 id="예시">예시</h4>
<pre><code class="language-java">@FunctionalInterface // 함수형 인터페이스가 아니라면 compile error가 생긴다.
[public] interface RunSomething{

    void doIt(); // 추상 메서드 1개

    //정적 메서드
    static void printName(){
        System.out.println("siwon");
    }

    // 디폴트 메서드
    default void printAge(){
        System.out.println(18);
    }
}
</code></pre>
<h3 id="함수형-interface의-사용">함수형 interface의 사용</h3>
<h4 id="1-1-익명-클래스">1-1. 익명 클래스</h4>
<pre><code class="language-java">RunSomething r = new RunSomething() {
    @Override
    public void one() {
        System.out.println("siwony");
    }
};

r.one();
</code></pre>
<h4 id="1-2-lambda">1-2. lambda</h4>
<pre><code class="language-java">// 한줄일때
RunSomething r = () -&gt; 실행문
r.doIt();

// 2줄이상일때
RunSomething r = () -&gt; {
    실행문1;
    실행문2;
    ...
}
r.doIt();

//매개변수를 받을 때
RunSomething r = number -&gt; 실행문;
r.doIt();

// 매개변수가 2개 이상일때
RunSomething r = (number, ...) -&gt; 실행문;

// 리턴값이 있을때 ex) 두 정수를 더하는 메서드
RunSomething r = (i, j) -&gt; return i + j;
r.doIt(10, 20);
</code></pre>

<h2 id="자바에서-제공하는-함수형-인터페이스">자바에서 제공하는 함수형 인터페이스</h2>
<blockquote>
  <p>Java에서는 1.8버전부터 기본적으로 자주 사용할만한 함수형 인터페이스를 제공한다.</p>
  <ul>
    <li><a href="https://url.kr/b295ks">java.lang.function 패키지</a> 에 정의 되어있다.</li>
  </ul>
</blockquote>

<h3 id="functiont-r-를-통한-람다표현식의-사용">Function&lt;T, R&gt; 를 통한 람다표현식의 사용</h3>
<ul>
  <li>T 타입을 받아 R 타입을 리턴하는 함수 인터페이스 이다.</li>
  <li><code>apply</code> 함수만 구현하면 된다.</li>
  <li>다음과 같은 함수 조합용 메서드를 제공한다.
    <ul>
      <li><code>compose</code></li>
      <li><code>andThen</code></li>
    </ul>
  </li>
</ul>

<h4 id="람다-표현식을-사용하기-전">람다 표현식을 사용하기 전</h4>
<p>정수 10에 입력받은 숫자를 더하고 싶다면</p>

<ol>
  <li><code>Plus10</code>이라는 클래스에 함수를 만든다. (혹은 그냥 익명함수를 사용할 수 있다.)
    <pre><code class="language-java">public class Plus10 implements Function&lt;Integer, Integer&gt;{
 @Override
 public Integer apply(Integer i){
     return 10 + i;
 }
}
</code></pre>
  </li>
  <li>객체를 생성해서 사용한다.
    <pre><code class="language-java">public class main{
 public static void main(String[] args){
     Plus10 p10 = new Plus10();
     System.out.println(p10.apply(1)); // 11 출력
 }
}
</code></pre>
    <h4 id="람다-표현식의-사용">람다 표현식의 사용</h4>
    <pre><code class="language-java">public class main{
 public static void main(String[] args){
     Function&lt;Integer, Integer&gt; p10 = (i) -&gt; i + 10;
     System.out.println(p10.apply(1)); // 11 출력
 }
}
</code></pre>
  </li>
</ol>

<h3 id="자바에서-제공하는-다양한-함수형-인터페이스">자바에서 제공하는 다양한 함수형 인터페이스</h3>
<h4 id="unaryoperator">UnaryOperator<T></T></h4>
<ul>
  <li><code>Function&lt;T, R&gt;</code>의 특수한 형태로, 입력값 하나를 받아 동일한 타입을 리턴한다.</li>
</ul>

<h4 id="consumer">Consumer<T></T></h4>
<p>: <code>T</code> 타입을 받아 아무값도 리턴하지 않는 함수 인터페이스</p>
<ul>
  <li>함수 조합용 메서드를 제공한다.
    <ul>
      <li><code>andThen</code></li>
    </ul>
  </li>
</ul>

<p>사용예시</p>
<pre><code class="language-java">Consumer&lt;Integer&gt; printT = (i) -&gt; System.out.println(i);
printT.accept(1); // 1출력

//위 코드랑 똑같은 동작을 한다.
Consumer&lt;Integer&gt; printT = System.out::println; 
printT.accept(1); // 1출력
</code></pre>
<h4 id="bifunctiont-u-r">BiFunction&lt;T, U, R&gt;</h4>
<ul>
  <li>두 개의 값(<code>T</code>, <code>U</code>)를 받아 R 타입을 리턴하는 함수 인터페이스
    <ul>
      <li><code>R apply(T t, U u)</code></li>
    </ul>
  </li>
</ul>

<h4 id="binaryoperator">BinaryOperator<T></T></h4>
<p>Function&lt;T, U, R&gt;의 특수한 형태로, 동일한 타입의 일렬값 두개를 받아 리턴하는 함수 인터페이스</p>

<h4 id="supplier">Supplier<T></T></h4>
<ul>
  <li><code>T</code> 타입의 값을 제공하는 함수 인터페이스
    <ul>
      <li><code>T get()</code>;</li>
    </ul>
  </li>
</ul>

<p>사용예시</p>
<pre><code class="language-java">Supplier&lt;Integer&gt; get10 = () -&gt; 10;
System.out.println(get10.get()); // 10 출력
</code></pre>

<h4 id="predicate">Predicate<T></T></h4>
<ul>
  <li><code>T</code> 타입을 받아서 <code>boolea</code>를 반환하는 함수 인터페이스
    <ul>
      <li><code>boolean test(T t)</code></li>
    </ul>
  </li>
  <li>다음과같은 함수 조합용 메서드를 제공한다.
    <ul>
      <li><code>And</code></li>
      <li><code>Or</code></li>
      <li><code>Negate</code></li>
    </ul>
  </li>
</ul>

<p>사용예시</p>
<pre><code class="language-java">Predicate&lt;Integer&gt; isEven = (i) -&gt; i % 2 == 0;
isEven.test(10) // true
</code></pre>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/29/%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%A0%95%EB%A0%AC/" class="nav-link">페이징 & 정렬</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/network/2022/03/30/http-%EB%B2%84%EC%A0%84%EB%B3%84-%EC%B0%A8%EC%9D%B4/" class="nav-link">HTTP 버전별 차이</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
