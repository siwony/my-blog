<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interface</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">Interface</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["programming"]'
          tags='["java","coding","development","TIL"]'
          date="March 29, 2022"
          reading-time="6"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="interface">Interface</h1>
<p>: Java Programing 언어에서 <strong><code>class</code>들이 구현해야 하는 동작을 지정하는데 사용하는 추상 자료형</strong>이다.</p>
<ul>
  <li><code>interface</code>라는 키워드를 사용하여 선언한다.</li>
  <li>메소드 시그니처(<code>Method sigature</code>), 상수 선언
    <blockquote>
      <p><code>static</code> 과 <code>final</code>은 상수를 값을 할당해줘야 한다.</p>
      <h3 id="역할">역할</h3>
      <h4 id="interface의-특징"><code>interface</code>의 특징</h4>
    </blockquote>
  </li>
  <li>인터페이스는 객체를 어떻게 구성해야 하는지 정리한 설계도이다.</li>
  <li>객체의 교환성(다형성)을 높여준다.</li>
  <li><code>interface</code> 변수에 <code>interface</code>가 구현된 서로 다른 구현 객체를 할당해서 사용이 가능하다.</li>
  <li>구현 객체를 직접 몰라도 <code>interface</code>만 알아도 객체 호출이 가능하게 한다.</li>
  <li>객체가 <code>interface</code>를 사용하면, <code>interface</code> 메서드를 반드시 구현해야 하는 제약을 건다.</li>
</ul>

<p>위 특징을 이용해서 얻고자 하는 인터페이스(<code>interface</code>) 역할은 다음과 같다.
<img width="550px" src="/assets/images/posts/programming/interface-responsibility.png" /></p>

<p><strong><code>interface</code>를 이용하여, 개발 코드를 직접 수정하지 않고도, 사용하고 있는 객체만 변경할 수 있도록 하기 위함이다.</strong></p>

<h2 id="interface-사용">interface 사용</h2>
<h3 id="1-interface-선언">1. interface 선언</h3>
<pre><code class="language-java">public interface 인터페이스명 { ... }

// ex.1
public interface User{ ... }
// ex.2
interface User{ ... }
</code></pre>
<ul>
  <li>인터페이스명은 UpperCamelCase로 작성되어야 한다.</li>
  <li><code>interface</code>는 접근지정자 <code>public</code>만 사용할 수 있다.
    <blockquote>
      <p>public을 생략가능하다.</p>
    </blockquote>
  </li>
  <li><code>interface</code>는 객체로 생성할 수 없기 떄문에 생성자를 가질 수 없다.</li>
</ul>

<h2 id="2-interface의-구성요소">2. interface의 구성요소</h2>
<ol>
  <li><a href="#2-1-상수-필드constant-field">상수 필드(Constant Field)</a></li>
  <li><a href="#2-2-추상-메서드abstract-method">추상 메서드(Abstract Method)</a></li>
  <li><a href="#2-3-디폴트-메서드default-method">디폴트 메서드(Default Method)</a></li>
  <li><a href="#2-4-정적-메서드static-method">정적 메서드(Static Method)</a>
    <blockquote>
      <p>대괄호(<code>[]</code>)는 생략 가능한 것을 나타냄</p>
      <h3 id="2-1-상수-필드constant-field">2-1. 상수 필드(Constant Field)</h3>
      <p>```java
public interface User{</p>
    </blockquote>

    <p>[public static final] 필드타입 상수명 = 값;</p>

    <p>//ex
 String FIRST_NAME = “siwon”; //또는
 public static final String FIRST_NAME = “siwon”; // 는 같다.
}
```
       - <code>interface</code>는 객체가 될 수 없기에 런타임에 필드 데이터를 저장할 수 없다.</p>
    <blockquote>
      <p>그래서 <strong>인스턴스 필드(<code>instance field </code>)</strong> / <strong>정적 필드(<code>static field</code>)</strong> 는 선언이 불가능 하다. 
       - 상수 필드는 <code>Compile Time</code>에 선언되고 <code>Run Time</code>에 변경되지 않으므로 인터페이스에 선언이 가능하다.
       - [public static final]는 명시적으로 사용하지 않아도, <code>Compile Time</code>에 자동으로 선언되어 상수로 만든다.
       - 네이밍은 모두 대문자로 구성되고 구분자는 Under Bar(“_”) 로 표현한다.</p>
    </blockquote>
  </li>
</ol>

<h3 id="2-2-추상-메서드abstract-method">2-2. 추상 메서드(Abstract Method)</h3>
<pre><code class="language-java">public interface User{
    [public abstract] 리턴타입 메서드이름(매개변수, ...)

    // 예시
    String sendMoeny(Money money); // 와
    public abstract String sendMoeny(Money money); // 는 같다
}
</code></pre>
<ul>
  <li><code>interface</code> 변수로 호출된 메서드는 최종적으로 구현 객체에서 실행된다.</li>
  <li>추상 메서드는 <strong>리턴 타입</strong> / <strong>매서드 시그니처(Method sigature)</strong> 가 기술되는 클래스 설계 메서드이다.</li>
  <li><code>public abstract</code>은 명시적으로 선언하지 않아도, <code>Compile Time</code>에 자동으로 선언된다.</li>
</ul>

<h3 id="2-3-디폴트-메서드default-method">2-3 디폴트 메서드(Default Method)</h3>
<pre><code class="language-java">public interface User{
    //디폴트 메서드(Default Method)
    /**
    /* @implSpac
    /* 이 구현체는 어떤 행동을 합니다.
    */
    [ public ] default 리턴타입 메서드_이름(매개변수, ...){ ... }

    // 예시
    /**
    /* @implSpac
    /* 이 매서드는 사용자의 상태를 변경합니다.
    */
    public default void setStatus(Status status){
        if(statuc == Status.ACTIVE){
            System.out.println("사용자가 활성화 되었습니다.");
            return;
        }
        System.out.println("사용자가 비활성화 되었습니다");
    }
}
</code></pre>
<ul>
  <li>선언시 <code>default</code> 가 필요하다.</li>
  <li>클래스의 인스턴스 메서드와 동일하다.  → 인스턴스 메서드</li>
  <li>디폴트 메서드는 나중에 인터페이스를 구현한 구현 클래스에 인스턴스 메서드로 추가된다.</li>
  <li>기본 메서드는 구현체가 모르게 추가된 기능으로 그만큼 리스크가 있다.
    <ul>
      <li>구현체에 따라 런타임 에러가 발생할 수 있다. ex. NPE 등…</li>
      <li>반드시 문서화를 하는걸 권장한다. <code>@ImplSpec</code></li>
    </ul>
  </li>
  <li>Object에서 제공하는 메서드는 사용할 수 없다.
    <blockquote>
      <p>hashCode, equals</p>
    </blockquote>
  </li>
</ul>

<h4 id="default-method-override">Default Method Override</h4>
<blockquote>
  <p>재정의(<code>Override</code>)를 통해서 구현 클래스에서 default 메서드를 재구현할 수 있다.
```java
// 예시코드
public class UserImpl implements User{</p>
</blockquote>

<pre><code>@Override
public default void setStatus(Status status){
    if(status == Status.ACTIVE)
        System.out.println("사용자가 활성화 되었습니다.");
    else if(status == Status.AFK)
        System.out.println("사용자가 잠수상태가 되었습니다.");
    else
        System.out.println("사용자가 비활성화 되었습니다");
} } ```
</code></pre>

<h3 id="2-4-정적-메서드static-method">2-4 정적 메서드(Static Method)</h3>
<pre><code class="language-java">public interface User{
    // 정적 메서드(Static Method)
    [ public ] static 리턴타입 메서드이름(매개변수, ...) { ... }
    // 예시
    public static void printFirstName(){
        System.out.println("나의 이름은 " + firstName + "입니다.");
    }
}
</code></pre>
<ul>
  <li>Java8 에서 추가된 <code>interface</code>의 맴버이다.</li>
  <li>키워드로 <code>static</code>을 붙이고 <strong>메소드 시그니처 + 메서드의 Body(몸체)</strong> 가 있어야 한다.</li>
  <li>[ <code>public</code> ]은 명시적으로 사용하지 않아도, <code>Compile Time</code>에 자동으로 선언된다.</li>
</ul>

<h2 id="3-interface-구현">3. interface 구현</h2>
<ul>
  <li>객체는 interface에 있는 추상 메서드를 구현한 실체 메서드를 가지고 있어야한다.</li>
  <li>interface를 구현한 객체를 구현 객체(구현체) 라고 한다.</li>
</ul>

<h4 id="interface-구현-방식">interface 구현 방식</h4>
<ol>
  <li><a href="#3-1-단일-인터페이스-구현-클래스implementclass">단일 인터페이스 구현 클래스(Single Interface Implement Class)</a></li>
  <li><a href="#3-2-다중-인터페이스-구현-클래스multiple-interface-implement-class">다중 인터페이스 구현 클래스(Multiple interface Implement Class)</a></li>
  <li>익명 구현 객체(Anonymous Implement Object)</li>
</ol>

<h4 id="3-1-단일-인터페이스-구현-클래스implementclass">3-1. 단일 인터페이스 구현 클래스(ImplementClass)</h4>
<pre><code class="language-java">public class 구현클래스_이름 implements 인터페이스_이름{
    // 인터페이스의 추상 메서드를 구현한 실체 메서드 선언 부분
}
</code></pre>
<p>예시</p>
<pre><code class="language-java">public interface User{
    public static final String FIRST_NAME = "siwon";
    String sendMony(Money money);
    public default void setStatus(Status status){
        if(status == Status.ACTIVE){
            System.out.println("사용자가 활성화 되었습니다");
            return;
        }
        System.out.println("사용자가 비활성화 되었습니다");
    }
    public static void printFirstName() { 
        System.out.println("나의 이름은 " + firstName + "입니다."); 
    }
}

public class Recipient implements User {

    // 추상 메서드는 다음처럼 실체 메서드를 정의해야한다.
    public String sendMoney(Money money) {
        thirdpartyApi.send(money.getType(), money.getAmount());
        return Status.SUCCESS.name();
    }

    // 디폴트 메서드는 재정의가 가능하다.
    // 재정의 하지 않으면, 인터페이스에 정의된 내용 그대로 사용된다.
    @Override
    public default void setStatus(Status status) {
        if(status == Status.ACTIVE) {
            System.out.println("수취인이 활성화 되었습니다");
            return;
        }
        System.out.println("수취인이 비활성화 되었습니다");
    }
}
</code></pre>
<p>만약 추상 메서드를 구현 클래스에서 실체 메서드를 모두 작성하지 않으면 추상클래스로 선언해야된다.</p>
<pre><code class="language-java">public abstract class Recipient implements User{ ... }
</code></pre>

<h4 id="3-2-다중-인터페이스-구현-클래스multiple-interface-implement-class">3-2 다중 인터페이스 구현 클래스(Multiple Interface Implement Class)</h4>
<pre><code class="language-java">public class 구현클래스_이름 implements 인터페이스_이름1, 인터페이스이름2{
    // 인터페이스의 추상 메서드를 구현한 실체 메서드를 선언하는 부분
}
</code></pre>
<ul>
  <li><code>interface</code>를 구현한 구현 클래스는 다중 인터페이스를 구현 가능합니다.</li>
  <li>다중 <code>interface</code>를 구현한 구현 클래스는 반드시 모든 <code>interface</code>의 추상 메서드를 실체 메서드로 구현해야한다.</li>
  <li>하나라도 추상 메서드가 구현되지 않으면, 구현 클래스는 추상 클래스로 선언되어야 한다.</li>
</ul>

<p><strong>다중 인터페이스의 사용</strong></p>
<pre><code class="language-java">하위인터페이스 = new 구현클래스(); 
상위인터페이스1 = new 구현클래스();
상위인터페이스2 = new 구현클래스();
</code></pre>
<ul>
  <li><code>하위인터페이스</code> 변수는 <code>하위인터페이스</code>, <code>상위인터페이스1</code>, <code>상위인터페이스2</code>의 실체 메서드를 모두 사용할 수 있다.</li>
  <li><code>상위인터페이스1</code> 변수는 <code>상위인터페이스1</code>의 실체 메서드만 사용할 수 있다.</li>
  <li><code>상위인터페이스2</code> 변수는 <code>상위인터페이스2</code>의 실체 메서드만 사용할 수 있다.</li>
</ul>

<h4 id="3-3-다중-인터페이스-구현-클래스multiple-interface-implement-class">3-3. 다중 인터페이스 구현 클래스(Multiple Interface Implement Class)</h4>
<ul>
  <li>구현 클래스를 만들어서 사용하는 것이 일반적이고, 재사용이 가능하기에 편리하다.<br />
하지만 일회성으로 사용하는 구현 클래스는 클래스로 만들어서 선언해서 쓰는 것이 비효율적이다.</li>
  <li>이러한 비효율을 개선하기 위해 만들어졌다. → 주로 임시 작업 스레드를 만들기 위해 많이 활용된다.</li>
  <li>익명 구현 객체의 경우에는 참조할 구현 클래스가 없기 때문에 <code>User interface</code> 이름을 그대로 사용한다.</li>
  <li>다만, 익명 구현 객체의 구현 부에는 <code>interface</code>의 추상 메서드가 아닌 실체 메서드를 선언해야 한다.</li>
</ul>

<pre><code class="language-java">User user = new User(){
    public String sendMoeny(Money money){
        thirdpartyApi.send(money.getType(), money.getAmount());
        return Status.SUCCESS.name();
    }

    @Override
    public default void setStatus(Status status) {
        if(status == Status.ACTIVE) {
            System.out.println("수취인이 활성화 되었습니다");
            return;
        }
        System.out.println("수취인이 비활성화 되었습니다");
    }
}
</code></pre>
<p><strong>익명 구현 객체는 일반 클래스처럼 클래스가 생성된다.</strong></p>
<ul>
  <li>익명 구현 객체가 사용된 자바 파일을 컴파일을 하게 되면 자동으로 익명 구현 객체의 클래스 파일이 생성된다.</li>
  <li><code>[익명 구현 객체가 사용된 자바 파일]$[번호].class</code> 형식으로 생성된다.</li>
</ul>

<h2 id="4-java8-버전과-그-이전-버전의-interface차이">4. Java8 버전과 그 이전 버전의 interface차이</h2>
<h3 id="default-method가-추가되어-일어난-변화">default method가 추가되어 일어난 변화</h3>
<h4 id="1-java8-이전-interface의-문제점">1. Java8 이전 interface의 문제점</h4>
<ul>
  <li>인터페이스가 함수의 구현을 강제한다.</li>
  <li>강제하지 않기 위해 <code>abstrict class - 추상 클래스</code>를 만들어 함수의 몸체를 비우는 식으로 구현할 수 있다.</li>
</ul>

<p>예제코드</p>
<pre><code class="language-java">public interface Foo{
    void A();
    void B();
    void C();
}

public abstract class FooAbstrict implements Foo{
    @Override
    void A(){}
    @Override
    void B(){}
    @Override
    void C(){}
}

public class FooImpl extends FooAbstrict{

    @Override
    void A{
        System.out.println("DO A");
    }
}
</code></pre>
<ol>
  <li><code>Foo</code>라는 interface의 모든 메서드(<code>A</code>, <code>B</code>, <code>C</code>)에 대해 구현을 강제하지 않기 위해 <code>FooAbstrict</code>에서 함수의 몸체를 비워서 구현했다</li>
  <li><code>Foo</code>를 구현할 <code>FooImpl</code>는 <code>FooAbstrict</code> 추상 클래스로 인해 <code>Foo</code> interface의 모든 메서드의 구현하지 않아도 된다.</li>
</ol>

<h4 id="2-java8-버전의-interface">2. Java8 버전의 interface</h4>
<ul>
  <li><code>default method</code>가 생겨 위와 같은 방식이 아닌 interface에서 구현을 강제하지 않을 수 있는 방법을 제공한다.</li>
</ul>

<p>예제코드</p>
<pre><code class="language-java">public interface Foo{
    default void A(){};
    default void B(){};
    default void C(){};
}

public class FooImpl extends Foo{

    @Override
    void A{
        System.out.println("DO A");
    }
}
</code></pre>

<h4 id="3-그래서-어디서-사용했었나요">3. 그래서 어디서 사용했었나요?</h4>
<p>Spring Web MVC의 설정을 제어하는 <code>WebMvcConfigurer</code>를 예로 들 수 있다.</p>

<p>Java 8 이전에는 <code>WebMvcConfigurerAdapter</code>를 상속받아 구현했지만,<br />
 <code>default method</code> 기능이 추가되며 <code>WebMvcConfigurer</code>를 구현하면 된다.</p>
<ul>
  <li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html"><code>WebMvcConfigurer</code> 공식문서</a></li>
  <li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurerAdapter.html"><code>WebMvcConfigurerAdapter</code> 공식문서</a></li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/programming/2022/03/29/google-guava/" class="nav-link">Google Guava</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/programming/2022/03/29/java-beans/" class="nav-link">Java Beans</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
