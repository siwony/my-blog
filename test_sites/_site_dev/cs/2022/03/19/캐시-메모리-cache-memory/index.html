<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>캐시 메모리 - Cache Memory</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">캐시 메모리 - Cache Memory</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["cs"]'
          tags='["Memory","TIL"]'
          date="March 19, 2022"
          reading-time="3"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="캐시-메모리---cache-memory">캐시 메모리 - Cache Memory</h1>
<p>: 속도가 빠른 장치(CPU)와 느린 장치(메모리) 사이에서 병목현상을 줄이기 위한 고속 <code>Buffer Memory</code>이다.</p>
<blockquote>
  <dl>
    <dt><strong>병목현상</strong></dt>
    <dd>어떤 시스템 내 데이터의 집중적인 사용으로 인해  전체 시스템에 절대적 영향을 미치는 부분에 사용빈도가 늘어나 그 부분의 성능이 저하되어 전체 시스템이 마비되는 현상을 의미한다.
      <ul>
        <li>CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤,</li>
        <li>다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.
즉, 캐시는 메모리 접근의 지역성을 이용하는 장치이다.</li>
        <li>캐시 메모리는 비싸므로 용량이 적다
보통 수십 KByte ~ 수백 KByte (나중에 변경 될 수 있음)</li>
      </ul>
    </dd>
  </dl>
</blockquote>

<p><img src="/assets/images/posts/cs/cache.png" /></p>

<blockquote>
  <p>현재 우리가 사용하고 있는 컴퓨터들은 모두 캐시 메모리 2 ~ 3개(L1, L2, L3)를 사용한다.</p>
</blockquote>

<h4 id="듀얼-코어-프로세서의-캐시-메모리">듀얼 코어 프로세서의 캐시 메모리</h4>
<p>: 각 코어마다 독립된 <code>L1</code> 캐시 메모리를 가지고, 두 코어가 공유하는 <code>L2</code> 캐시 메모리가 내장된다.</p>
<ul>
  <li>L1: CPU 내부에 존재</li>
  <li>L2: CPU와 RAM 사이에 존재</li>
  <li>L3: 보통 메인보드에 존재한다고 함</li>
</ul>

<blockquote>
  <p>만약 L1 캐시가 128kb면, 64/64로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고,<br />
나머지 64kb에는 실행 후 명령어를 임시저장한다. (명령어 세트로 구성, I-Cache - D-Cache)</p>
</blockquote>

<h3 id="적중과-실패">적중과 실패</h3>
<p>캐시메모리가 있는 컴퓨터 시스템은 CPU가 메모리에 접근하기 전 먼저 캐시 메모리에서 원하는 데이터의 존재 여부를 확인한다.<br />
이때 <strong>필요한 데이터가 있는 경우를 적중(hit), 없는 경우를 실패(miss)라고 한다.</strong></p>

<ul>
  <li>캐시 적중일 때
    <blockquote>
      <p>캐시 메모리의 데이터를 CPU 레지스터에 복사한다.</p>
    </blockquote>
  </li>
  <li>캐시 실패/메모리 적중일 때
    <blockquote>
      <p>메모리의 데이터를 캐시 메모리에 복사하고, 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사한다.</p>
    </blockquote>
  </li>
  <li>캐시, 메모리 실패일 때
    <blockquote>
      <p>보조 기억장치에서 필요한 데이터를 메모리에 복사한다. <br />
메모리에 복제된 내용을 캐시 메모리에 복제한다. 캐시 메모리의 복제된 데이터를 CPU 레지스터에 복제한다.</p>
      <h4 id="적중률">적중률</h4>
      <p>: 요청한 데이터를 캐시메모리에서 찾을 확률</p>
      <pre><code>       캐시 메모리의 적중 횟수
적중률 = -----------------------
       전체 메모리의 참조 횟수
</code></pre>
    </blockquote>
  </li>
</ul>

<h2 id="캐시-메모리-동작원리---지역성">캐시 메모리 동작원리 - 지역성</h2>
<p>: 데이터 접근이 시간적, 공간적, 순차적으로 가깝게 일어나는 것이다.</p>
<ul>
  <li>캐시가 효율적으로 동작하려면, 캐시의 적중율(Hit-rate)를 극대화 시켜야 한다.
    <blockquote>
      <p>즉 지역성을 가져야 한다.</p>
    </blockquote>
  </li>
  <li>기억장치 내의 정보를 균일하게 Access하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성이다.</li>
  <li>시간 지역성, 공간 지역성이 있다.</li>
</ul>

<h3 id="시간-지역성">시간 지역성</h3>
<p>: 최근 사용되었던 기억 장소들이 집중적으로 액세스되는 경향</p>
<ul>
  <li>for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높다.</li>
  <li>메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우, 상대적으로 작은 크기의 캐시를 사용해도 효율성을 꾀할 수 있다.</li>
</ul>

<h3 id="공간-지역성">공간 지역성</h3>
<p>: 특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향</p>
<ul>
  <li>A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성이 높음
    <blockquote>
      <p>ex. 배열</p>
    </blockquote>
  </li>
</ul>

<h3 id="순차-지역성">순차 지역성</h3>
<p>: 데이터가 순차적으로 액세스되는 경향</p>
<blockquote>
  <p>데이터가 순차적으로 액세스되는 경향이 있다.</p>
  <ul>
    <li>기억장치에 저장된 순서대로 이용될 가능성이 높다.
ex. 배열</li>
  </ul>
</blockquote>

<h2 id="캐시메모리의-구조-및-동작-방식">캐시메모리의 구조 및 동작 방식</h2>
<h3 id="direct-mapped-cache">Direct Mapped Cache</h3>
<p>: DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식이다.<br />
<img width="420" src="/assets/images/posts/cs/direct-mapping.png" /></p>

<blockquote>
  <p>현재 그림에서는 메모리 공간이 32개(00000~11111)이고, 캐시 메모리 공간은 8개(000~111)인 상황</p>
  <ul>
    <li>인덱스 필드: 000를 가르킨다.</li>
    <li>태그 필드: 인덱스 제외한 앞의 나머지(00, 01, 10, 11)를 가르킨다.</li>
    <li>캐시메모리는 <code>인덱스 필드</code> + <code>태그 필드</code> + <code>데이터 필드</code>로 구성된다.</li>
  </ul>
</blockquote>

<h4 id="특징">특징</h4>
<ul>
  <li>위 사진처럼 같은 색깔의 데이터를 동시에 사용해야 할 떄 사용한다.</li>
  <li><code>Conflict Miss</code>가 발생한다.</li>
  <li>간단하고 구현 비용이 낮다.</li>
  <li>적중률이 낮아진다.</li>
</ul>

<h3 id="fully-associative-cache">Fully Associative Cache</h3>
<p>: 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식이다.</p>
<ul>
  <li>저장할 때는 매우 간단하지만, 모든 블럭을 순회해 데이터가 있는지 검사한다.</li>
  <li>CAM(content Addressable memory)라는 특수한 형태의 메모리 구조를 사용한다
    <blockquote>
      <p>가격이 비싸다</p>
    </blockquote>
  </li>
</ul>

<h3 id="set-associative-cache">Set Associative Cache</h3>
<p>: 특정 행을 지정하고, 그 행안의 어떤 열이든 비어있을 때 저장하는 방식이다.</p>
<blockquote>
  <p>Direct + Fully 방식</p>
  <ul>
    <li>Direct에 비해 검색 속도는 느리지만, 저장이 빠르다.</li>
    <li>Fully에 비해 저장이 느린 대신 검색이 빠르다.</li>
  </ul>
</blockquote>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/%EC%A4%80-%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C/" class="nav-link">준 영속 상태</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/%EC%BB%A4%EB%A7%A8%EB%93%9C-%EA%B0%9D%EC%B2%B4-command-object/" class="nav-link">커맨드 객체 - Command Object</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
