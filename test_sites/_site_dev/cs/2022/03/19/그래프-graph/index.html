<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>그래프 - Graph</title>
    
    <!-- Prism.js CSS 먼저 로드 -->
    <link rel="stylesheet" href="/assets/css/prism/prism-material-theme.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-toolbar.min.css">
    <link rel="stylesheet" href="/assets/css/prism/prism-line-numbers.min.css">

    <!-- 사이트 CSS -->
    <link rel="stylesheet" href="/assets/css/style.css">

    <!-- Ninja Keys CSS -->
    <script type="module" src="https://unpkg.com/ninja-keys?module"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1><a href="/">My Tech Blog</a></h1>
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <article class="post">
    <header class="post-header">
        <h1 class="post-title">그래프 - Graph</h1>
        
        <!-- Enhanced metadata using post-metadata component -->
        <post-metadata 
          layout="inline"
          categories='["cs"]'
          tags='["data-structure","non-linear","graph","TIL"]'
          date="March 19, 2022"
          reading-time="2"
          compact="false">
        </post-metadata>
        
        
        <div class="post-author">
          <span class="author-label">작성자:</span>
          <span class="author-name">jeongcool</span>
        </div>
        
    </header>

    <div class="post-content">
        <h1 id="그래프---graph">그래프 - Graph</h1>
<p><code>그래프 - Graph</code>란 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조이다.</p>

<h3 id="용어-정리">용어 정리</h3>
<p><img src="/assets/images/posts/cs/graph-ex.png" /></p>

<h4 id="정점---vertex">정점 - vertex</h4>
<p><code>노드 - node</code>라고하며 데이터가 저장되는 그래프의 기본 원소이다.</p>

<h4 id="간선---edge">간선 - edge</h4>
<p><code>링크 - link</code>라고하며 정점 간의 관계를 나타낸다</p>

<h4 id="인접-정점---adjacent-vertex">인접 정점 - adjacent vertex</h4>
<p>하나의 정점에서 간선에 의해 직접 연결되어 있는 정점을 뜻한다.</p>
<blockquote>
  <p>위 그래프에서 정점 <code>C</code>의 인접 정점은 <code>A</code>, <code>D</code>이다.</p>
</blockquote>

<h4 id="차수---degree">차수 - degree</h4>
<p>정점에 연결된 간선의 수</p>
<blockquote>
  <p>정점 A의 차수는 3이고 모든 정점의 차수를 합하면 8이다.</p>
</blockquote>

<ul>
  <li>무방향 그래프에서 하나의 간선은 두 개의 정점에 인접하기 때문에 간선 수에 2배를 해주면 된다.</li>
  <li>방향 그래프의 경우 외부에서 오는 간선의 수를 <code>진입 차수 - in-degree</code>라고 하며,</li>
  <li>외부로 향하는 간선의 수를 <code>진출 차수 - out-degree</code>라고 한다.</li>
</ul>

<h4 id="경로---path">경로 - path</h4>
<p>간선을 따라갈 수 있는 길을 말하며, 정점을 나열하여 표시한다.</p>

<h4 id="경로의-길이---length">경로의 길이 - length</h4>
<p>경로를 구성하는 데 사용된 간선의 수를 뜻한다.</p>

<h4 id="단순-경로---simple-path">단순 경로 - simple path</h4>
<p>경로 중 반복되는 간선이 없는 경로</p>

<h4 id="사이클---cycle">사이클 - cycle</h4>
<p>시작 정점과 종료 정점이 같은 단순 경로를 뜻한다.</p>

<h3 id="그래프-adt">그래프 ADT</h3>
<h4 id="객체">객체</h4>
<p>정점의 집합과 건선의 집합</p>

<h4 id="연산">연산</h4>
<ul>
  <li><code>create()</code> : 그래프 생성</li>
  <li><code>insertVertex(v)</code> : 그래프에 정점 v 삽입</li>
  <li><code>insertEdge(u, v)</code> : 그래프에 u정점과 v정점을 연결하는 간선 삽입</li>
  <li><code>deleteVertex(v)</code> : 그래프에서 정점 v 삭제 (v에 연결된 모든 간선도 함께 삭제)</li>
  <li><code>deleteEdge(u, v)</code> : 그래프에서 u정점과 v정점을 연결하는 간선 삭제</li>
  <li><code>adjacent(v)</code> : 정점 v에 인접한 모든 정점을 반환</li>
</ul>

<h2 id="구현-방법">구현 방법</h2>
<p><code>인접 행렬</code>, <code>인접 리스트</code> 로 구현할 수 있다.</p>

<h3 id="1-인접-행렬---adjacency-materix">1. 인접 행렬 - Adjacency Materix</h3>
<p><img width="450" src="/assets/images/posts/cs/adjacency-matrix-ex.png" /></p>

<h4 id="장점">장점</h4>
<ul>
  <li>두 점에 대한 연결 정보를 조회할 때 <code>O(1)</code>시간복잡도를 가진다.
    <blockquote>
      <p>2차원 배열 속 모든 정점들의 간선 정보를 담는다.</p>
    </blockquote>
  </li>
  <li>
    <p>정점(i)의 차수를 구할 때는 다음과 같이 인접행렬(M)의 i번째 행의 값을 모두 더하면 되므로 <code>O(n)</code>의 시간복잡도를 가진다.<br />
\(degree(i)= \sum_{k=0}^{n-1} M[i][k]\)</p>
  </li>
  <li>구현이 비교적 간단하다.</li>
</ul>

<h4 id="단점">단점</h4>
<ul>
  <li><strong>모든 간선의 수를 알아내려면</strong> 모든 정점에 대해 간선 정보를 대입해야 하므로 <code>O(n²)</code>의 시간복잡도를 가진다.</li>
  <li>무조건 2차원 배열이 필요하여 필요 이상의 공간이 낭비된다.</li>
</ul>

<h3 id="2-인접-리스트">2. 인접 리스트</h3>
<p><img width="450" src="/assets/images/posts/cs/adjacency-list.png" /></p>

<h4 id="장점-1">장점</h4>
<ul>
  <li>정점들의 <strong>연결 정보를 탐색할 때 <code>O(n)</code>의 시간복잡도를 가진다.</strong> <code>n = 간선의 갯수</code></li>
  <li>필요한 만큼의 공간만 사용하기 때문에 공간의 낭비가 적다.</li>
</ul>

<h4 id="단점-1">단점</h4>
<ul>
  <li>
    <p><strong>두 정점을 연결하는 간선을 조회</strong>하거나 <strong>정점의 차수를 알기</strong> 위해서는 정점의 인접 리스트를 탐색해야 하므로 정점의 차수만큼의 시간이 필요하다. <code>O(degree(v))</code> <code>v = 정점</code></p>
  </li>
  <li>
    <p>구현이 비교적 어렵다.</p>
  </li>
</ul>

<h3 id="3-인접-행렬-vs-인접-리스트">3. 인접 행렬 vs 인접 리스트</h3>
<p><img width="700" src="/assets/images/posts/cs/matrix-vs-list.png" /></p>

<ul>
  <li>정점의 개수에 비해 간선의 개수가 매우 적은 <strong>희소 그래프에서는 인접 리스트</strong>가 유리할 수 있다.</li>
  <li>모든 정점간에 간선이 존재하는 <strong>완전그래프 에서는 인접 행렬</strong>이 유리할 수 있다.</li>
</ul>

<p>다음글 <a href="../tree/tree.md">트리 - tree</a></p>

<h2 id="reference">Reference</h2>
<ul>
  <li>https://suyeon96.tistory.com/32#—%–%EA%B-%B-%EB%-E%–%ED%–%–%–%EC%-A%A-%EC%–%B-</li>
  <li>https://coding-factory.tistory.com/610</li>
</ul>

    </div>
    
    <footer class="post-footer">
        <div class="post-navigation">
            
            <div class="nav-previous">
                <span class="nav-label">이전 글</span>
                <a href="/back-end/2022/03/19/%EA%B3%A0%EC%95%84-%EA%B0%9D%EC%B2%B4orpan/" class="nav-link">고아 객체(ORPAN)</a>
            </div>
            
            
            
            <div class="nav-next">
                <span class="nav-label">다음 글</span>
                <a href="/back-end/2022/03/19/%EA%B8%B0%EB%B3%B8%EA%B0%92-%ED%83%80%EC%9E%85/" class="nav-link">기본값 타입</a>
            </div>
            
        </div>
    </footer>
</article>

        </main>
    </div>

    <!-- Prism.js JavaScript 로드 (순서 중요!) -->
    <script src="/assets/js/prism/prism.min.js"></script>
    <script src="/assets/js/prism/prism-autoloader.min.js"></script>
    <script src="/assets/js/prism/prism-toolbar.min.js"></script>
    <script src="/assets/js/prism/prism-copy-to-clipboard.min.js"></script>
    <script src="/assets/js/prism/prism-show-language.min.js"></script>
    <script src="/assets/js/prism/prism-line-numbers.min.js"></script>

    <!-- Prism.js 초기화 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // autoloader 경로 설정 (로컬 컴포넌트 사용)
            if (Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path = '/assets/js/prism/components/';
                console.log('Prism autoloader configured with local path:', Prism.plugins.autoloader.languages_path);
            }
            
            // 모든 pre 태그에 toolbar와 line-numbers 클래스 추가
            document.querySelectorAll('pre[class*="language-"]').forEach(function(pre) {
                pre.classList.add('line-numbers');
            });
            
            // Prism 하이라이팅 재실행
            Prism.highlightAll();
        });
    </script>
    
    <!-- Command Palette (Ninja Keys) -->
    <script src="/assets/js/command-palette.js"></script>
    
    <!-- Category Sidebar Web Component -->
    <script src="/assets/js/category-sidebar.js"></script>
    
    <!-- Post Metadata Web Component -->
    <script src="/assets/js/post-metadata.js"></script>
</body>
</html>
